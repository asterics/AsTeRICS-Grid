"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkasterics_grid"] = self["webpackChunkasterics_grid"] || []).push([["vendors-node_modules_matrix-js-sdk_lib_rust-crypto_index_js"],{

/***/ "./node_modules/@matrix-org/matrix-sdk-crypto-wasm/pkg/matrix_sdk_crypto_wasm_bg.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@matrix-org/matrix-sdk-crypto-wasm/pkg/matrix_sdk_crypto_wasm_bg.js ***!
  \******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attachment: () => (/* binding */ Attachment),\n/* harmony export */   BackupDecryptionKey: () => (/* binding */ BackupDecryptionKey),\n/* harmony export */   BackupKeys: () => (/* binding */ BackupKeys),\n/* harmony export */   BackupSecretsBundle: () => (/* binding */ BackupSecretsBundle),\n/* harmony export */   BaseMigrationData: () => (/* binding */ BaseMigrationData),\n/* harmony export */   CancelInfo: () => (/* binding */ CancelInfo),\n/* harmony export */   CheckCode: () => (/* binding */ CheckCode),\n/* harmony export */   CollectStrategy: () => (/* binding */ CollectStrategy),\n/* harmony export */   CrossSigningBootstrapRequests: () => (/* binding */ CrossSigningBootstrapRequests),\n/* harmony export */   CrossSigningKeyExport: () => (/* binding */ CrossSigningKeyExport),\n/* harmony export */   CrossSigningStatus: () => (/* binding */ CrossSigningStatus),\n/* harmony export */   Curve25519PublicKey: () => (/* binding */ Curve25519PublicKey),\n/* harmony export */   DecryptedRoomEvent: () => (/* binding */ DecryptedRoomEvent),\n/* harmony export */   DecryptionErrorCode: () => (/* binding */ DecryptionErrorCode),\n/* harmony export */   DecryptionSettings: () => (/* binding */ DecryptionSettings),\n/* harmony export */   DehydratedDevice: () => (/* binding */ DehydratedDevice),\n/* harmony export */   DehydratedDeviceKey: () => (/* binding */ DehydratedDeviceKey),\n/* harmony export */   DehydratedDevices: () => (/* binding */ DehydratedDevices),\n/* harmony export */   Device: () => (/* binding */ Device),\n/* harmony export */   DeviceId: () => (/* binding */ DeviceId),\n/* harmony export */   DeviceKey: () => (/* binding */ DeviceKey),\n/* harmony export */   DeviceKeyAlgorithm: () => (/* binding */ DeviceKeyAlgorithm),\n/* harmony export */   DeviceKeyAlgorithmName: () => (/* binding */ DeviceKeyAlgorithmName),\n/* harmony export */   DeviceKeyId: () => (/* binding */ DeviceKeyId),\n/* harmony export */   DeviceKeyName: () => (/* binding */ DeviceKeyName),\n/* harmony export */   DeviceLists: () => (/* binding */ DeviceLists),\n/* harmony export */   Ecies: () => (/* binding */ Ecies),\n/* harmony export */   Ed25519PublicKey: () => (/* binding */ Ed25519PublicKey),\n/* harmony export */   Ed25519Signature: () => (/* binding */ Ed25519Signature),\n/* harmony export */   Emoji: () => (/* binding */ Emoji),\n/* harmony export */   EncryptedAttachment: () => (/* binding */ EncryptedAttachment),\n/* harmony export */   EncryptionAlgorithm: () => (/* binding */ EncryptionAlgorithm),\n/* harmony export */   EncryptionInfo: () => (/* binding */ EncryptionInfo),\n/* harmony export */   EncryptionSettings: () => (/* binding */ EncryptionSettings),\n/* harmony export */   EstablishedEcies: () => (/* binding */ EstablishedEcies),\n/* harmony export */   EventId: () => (/* binding */ EventId),\n/* harmony export */   HistoryVisibility: () => (/* binding */ HistoryVisibility),\n/* harmony export */   IdentityKeys: () => (/* binding */ IdentityKeys),\n/* harmony export */   InboundCreationResult: () => (/* binding */ InboundCreationResult),\n/* harmony export */   InboundGroupSession: () => (/* binding */ InboundGroupSession),\n/* harmony export */   KeysBackupRequest: () => (/* binding */ KeysBackupRequest),\n/* harmony export */   KeysClaimRequest: () => (/* binding */ KeysClaimRequest),\n/* harmony export */   KeysQueryRequest: () => (/* binding */ KeysQueryRequest),\n/* harmony export */   KeysUploadRequest: () => (/* binding */ KeysUploadRequest),\n/* harmony export */   LocalTrust: () => (/* binding */ LocalTrust),\n/* harmony export */   LoggerLevel: () => (/* binding */ LoggerLevel),\n/* harmony export */   MaybeSignature: () => (/* binding */ MaybeSignature),\n/* harmony export */   MegolmDecryptionError: () => (/* binding */ MegolmDecryptionError),\n/* harmony export */   MegolmV1BackupKey: () => (/* binding */ MegolmV1BackupKey),\n/* harmony export */   Migration: () => (/* binding */ Migration),\n/* harmony export */   OlmMachine: () => (/* binding */ OlmMachine),\n/* harmony export */   OtherUserIdentity: () => (/* binding */ OtherUserIdentity),\n/* harmony export */   OutboundCreationResult: () => (/* binding */ OutboundCreationResult),\n/* harmony export */   OwnUserIdentity: () => (/* binding */ OwnUserIdentity),\n/* harmony export */   PickledInboundGroupSession: () => (/* binding */ PickledInboundGroupSession),\n/* harmony export */   PickledSession: () => (/* binding */ PickledSession),\n/* harmony export */   PutDehydratedDeviceRequest: () => (/* binding */ PutDehydratedDeviceRequest),\n/* harmony export */   Qr: () => (/* binding */ Qr),\n/* harmony export */   QrCode: () => (/* binding */ QrCode),\n/* harmony export */   QrCodeData: () => (/* binding */ QrCodeData),\n/* harmony export */   QrCodeMode: () => (/* binding */ QrCodeMode),\n/* harmony export */   QrCodeScan: () => (/* binding */ QrCodeScan),\n/* harmony export */   QrState: () => (/* binding */ QrState),\n/* harmony export */   RehydratedDevice: () => (/* binding */ RehydratedDevice),\n/* harmony export */   RequestType: () => (/* binding */ RequestType),\n/* harmony export */   RoomId: () => (/* binding */ RoomId),\n/* harmony export */   RoomKeyCounts: () => (/* binding */ RoomKeyCounts),\n/* harmony export */   RoomKeyImportResult: () => (/* binding */ RoomKeyImportResult),\n/* harmony export */   RoomKeyInfo: () => (/* binding */ RoomKeyInfo),\n/* harmony export */   RoomKeyWithheldInfo: () => (/* binding */ RoomKeyWithheldInfo),\n/* harmony export */   RoomMessageRequest: () => (/* binding */ RoomMessageRequest),\n/* harmony export */   RoomSettings: () => (/* binding */ RoomSettings),\n/* harmony export */   Sas: () => (/* binding */ Sas),\n/* harmony export */   SecretsBundle: () => (/* binding */ SecretsBundle),\n/* harmony export */   ServerName: () => (/* binding */ ServerName),\n/* harmony export */   ShieldColor: () => (/* binding */ ShieldColor),\n/* harmony export */   ShieldState: () => (/* binding */ ShieldState),\n/* harmony export */   ShieldStateCode: () => (/* binding */ ShieldStateCode),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   SignatureState: () => (/* binding */ SignatureState),\n/* harmony export */   SignatureUploadRequest: () => (/* binding */ SignatureUploadRequest),\n/* harmony export */   SignatureVerification: () => (/* binding */ SignatureVerification),\n/* harmony export */   Signatures: () => (/* binding */ Signatures),\n/* harmony export */   StoreHandle: () => (/* binding */ StoreHandle),\n/* harmony export */   ToDeviceRequest: () => (/* binding */ ToDeviceRequest),\n/* harmony export */   Tracing: () => (/* binding */ Tracing),\n/* harmony export */   TrustRequirement: () => (/* binding */ TrustRequirement),\n/* harmony export */   UploadSigningKeysRequest: () => (/* binding */ UploadSigningKeysRequest),\n/* harmony export */   UserDevices: () => (/* binding */ UserDevices),\n/* harmony export */   UserId: () => (/* binding */ UserId),\n/* harmony export */   VerificationMethod: () => (/* binding */ VerificationMethod),\n/* harmony export */   VerificationRequest: () => (/* binding */ VerificationRequest),\n/* harmony export */   VerificationRequestPhase: () => (/* binding */ VerificationRequestPhase),\n/* harmony export */   Versions: () => (/* binding */ Versions),\n/* harmony export */   __wbg_String_8f0eb39a4a4c2f66: () => (/* binding */ __wbg_String_8f0eb39a4a4c2f66),\n/* harmony export */   __wbg_String_eecc4a11987127d6: () => (/* binding */ __wbg_String_eecc4a11987127d6),\n/* harmony export */   __wbg_Window_b0044ac7db258535: () => (/* binding */ __wbg_Window_b0044ac7db258535),\n/* harmony export */   __wbg_WorkerGlobalScope_b74cefefc62a37da: () => (/* binding */ __wbg_WorkerGlobalScope_b74cefefc62a37da),\n/* harmony export */   __wbg_add_0d9e99fb9c2d2cc5: () => (/* binding */ __wbg_add_0d9e99fb9c2d2cc5),\n/* harmony export */   __wbg_add_c836e3d4b14cd062: () => (/* binding */ __wbg_add_c836e3d4b14cd062),\n/* harmony export */   __wbg_at_479807bfddde3a33: () => (/* binding */ __wbg_at_479807bfddde3a33),\n/* harmony export */   __wbg_backupkeys_new: () => (/* binding */ __wbg_backupkeys_new),\n/* harmony export */   __wbg_bound_1918c0826c5b9363: () => (/* binding */ __wbg_bound_1918c0826c5b9363),\n/* harmony export */   __wbg_bound_324dfb8899c9798c: () => (/* binding */ __wbg_bound_324dfb8899c9798c),\n/* harmony export */   __wbg_buffer_61b7ce01341d7f88: () => (/* binding */ __wbg_buffer_61b7ce01341d7f88),\n/* harmony export */   __wbg_call_3b770f0d6eb4720e: () => (/* binding */ __wbg_call_3b770f0d6eb4720e),\n/* harmony export */   __wbg_call_500db948e69c7330: () => (/* binding */ __wbg_call_500db948e69c7330),\n/* harmony export */   __wbg_call_9bd6f269d4835e33: () => (/* binding */ __wbg_call_9bd6f269d4835e33),\n/* harmony export */   __wbg_call_b0d8e36992d9900d: () => (/* binding */ __wbg_call_b0d8e36992d9900d),\n/* harmony export */   __wbg_clearTimeout_5a54f8841c30079a: () => (/* binding */ __wbg_clearTimeout_5a54f8841c30079a),\n/* harmony export */   __wbg_clear_da83758e0bea0eb6: () => (/* binding */ __wbg_clear_da83758e0bea0eb6),\n/* harmony export */   __wbg_close_f6e618ed8b0326a3: () => (/* binding */ __wbg_close_f6e618ed8b0326a3),\n/* harmony export */   __wbg_code_71136b86e2aa7f41: () => (/* binding */ __wbg_code_71136b86e2aa7f41),\n/* harmony export */   __wbg_continue_bd44561c014cacea: () => (/* binding */ __wbg_continue_bd44561c014cacea),\n/* harmony export */   __wbg_count_244aa4118e005b59: () => (/* binding */ __wbg_count_244aa4118e005b59),\n/* harmony export */   __wbg_count_4df50ef6c1ddd770: () => (/* binding */ __wbg_count_4df50ef6c1ddd770),\n/* harmony export */   __wbg_createIndex_14571b3c4eec1628: () => (/* binding */ __wbg_createIndex_14571b3c4eec1628),\n/* harmony export */   __wbg_createIndex_1d4b2bbb6b21b8f8: () => (/* binding */ __wbg_createIndex_1d4b2bbb6b21b8f8),\n/* harmony export */   __wbg_createObjectStore_b6f14aa10f83a300: () => (/* binding */ __wbg_createObjectStore_b6f14aa10f83a300),\n/* harmony export */   __wbg_crosssigningbootstraprequests_new: () => (/* binding */ __wbg_crosssigningbootstraprequests_new),\n/* harmony export */   __wbg_crosssigningkeyexport_new: () => (/* binding */ __wbg_crosssigningkeyexport_new),\n/* harmony export */   __wbg_crosssigningstatus_new: () => (/* binding */ __wbg_crosssigningstatus_new),\n/* harmony export */   __wbg_crypto_ed58b8e10a292839: () => (/* binding */ __wbg_crypto_ed58b8e10a292839),\n/* harmony export */   __wbg_debug_156ca727dbc3150f: () => (/* binding */ __wbg_debug_156ca727dbc3150f),\n/* harmony export */   __wbg_debug_3acd668e6e6c6087: () => (/* binding */ __wbg_debug_3acd668e6e6c6087),\n/* harmony export */   __wbg_decryptedroomevent_new: () => (/* binding */ __wbg_decryptedroomevent_new),\n/* harmony export */   __wbg_dehydrateddevice_new: () => (/* binding */ __wbg_dehydrateddevice_new),\n/* harmony export */   __wbg_dehydrateddevicekey_new: () => (/* binding */ __wbg_dehydrateddevicekey_new),\n/* harmony export */   __wbg_deleteObjectStore_1f50ba0263875deb: () => (/* binding */ __wbg_deleteObjectStore_1f50ba0263875deb),\n/* harmony export */   __wbg_delete_5c33e4966f59624d: () => (/* binding */ __wbg_delete_5c33e4966f59624d),\n/* harmony export */   __wbg_delete_d97b2b4ff716c553: () => (/* binding */ __wbg_delete_d97b2b4ff716c553),\n/* harmony export */   __wbg_device_new: () => (/* binding */ __wbg_device_new),\n/* harmony export */   __wbg_deviceid_new: () => (/* binding */ __wbg_deviceid_new),\n/* harmony export */   __wbg_devicekey_new: () => (/* binding */ __wbg_devicekey_new),\n/* harmony export */   __wbg_devicekeyid_new: () => (/* binding */ __wbg_devicekeyid_new),\n/* harmony export */   __wbg_done_f22c1561fa919baa: () => (/* binding */ __wbg_done_f22c1561fa919baa),\n/* harmony export */   __wbg_emoji_new: () => (/* binding */ __wbg_emoji_new),\n/* harmony export */   __wbg_encryptioninfo_new: () => (/* binding */ __wbg_encryptioninfo_new),\n/* harmony export */   __wbg_entries_4f2bb9b0d701c0f6: () => (/* binding */ __wbg_entries_4f2bb9b0d701c0f6),\n/* harmony export */   __wbg_entries_82bf0e755ef54a5f: () => (/* binding */ __wbg_entries_82bf0e755ef54a5f),\n/* harmony export */   __wbg_error_32fda676ae978f6e: () => (/* binding */ __wbg_error_32fda676ae978f6e),\n/* harmony export */   __wbg_error_7534b8e9a36f1ab4: () => (/* binding */ __wbg_error_7534b8e9a36f1ab4),\n/* harmony export */   __wbg_error_77233c625ed0c533: () => (/* binding */ __wbg_error_77233c625ed0c533),\n/* harmony export */   __wbg_error_fab41a42d22bf2bc: () => (/* binding */ __wbg_error_fab41a42d22bf2bc),\n/* harmony export */   __wbg_from_d68eaa96dba25449: () => (/* binding */ __wbg_from_d68eaa96dba25449),\n/* harmony export */   __wbg_getAllKeys_ad97dc28822a6891: () => (/* binding */ __wbg_getAllKeys_ad97dc28822a6891),\n/* harmony export */   __wbg_getAll_72e2faaa06d1a8cf: () => (/* binding */ __wbg_getAll_72e2faaa06d1a8cf),\n/* harmony export */   __wbg_getAll_8f38031e5969c7f5: () => (/* binding */ __wbg_getAll_8f38031e5969c7f5),\n/* harmony export */   __wbg_getAll_8fa84589faccab36: () => (/* binding */ __wbg_getAll_8fa84589faccab36),\n/* harmony export */   __wbg_getRandomValues_bcb4912f16000dc4: () => (/* binding */ __wbg_getRandomValues_bcb4912f16000dc4),\n/* harmony export */   __wbg_getTime_ab8b72009983c537: () => (/* binding */ __wbg_getTime_ab8b72009983c537),\n/* harmony export */   __wbg_get_6a4f854f5cca7403: () => (/* binding */ __wbg_get_6a4f854f5cca7403),\n/* harmony export */   __wbg_get_7081edc0440983a5: () => (/* binding */ __wbg_get_7081edc0440983a5),\n/* harmony export */   __wbg_get_9aa3dff3f0266054: () => (/* binding */ __wbg_get_9aa3dff3f0266054),\n/* harmony export */   __wbg_get_bbccf8970793c087: () => (/* binding */ __wbg_get_bbccf8970793c087),\n/* harmony export */   __wbg_getwithrefkey_1dc361bd10053bfe: () => (/* binding */ __wbg_getwithrefkey_1dc361bd10053bfe),\n/* harmony export */   __wbg_getwithrefkey_6550b2c093d2eb18: () => (/* binding */ __wbg_getwithrefkey_6550b2c093d2eb18),\n/* harmony export */   __wbg_global_b6f5c73312f62313: () => (/* binding */ __wbg_global_b6f5c73312f62313),\n/* harmony export */   __wbg_inboundgroupsession_new: () => (/* binding */ __wbg_inboundgroupsession_new),\n/* harmony export */   __wbg_index_871d874253bae760: () => (/* binding */ __wbg_index_871d874253bae760),\n/* harmony export */   __wbg_indexedDB_601ec26c63e333de: () => (/* binding */ __wbg_indexedDB_601ec26c63e333de),\n/* harmony export */   __wbg_indexedDB_72e2ca071222fd9e: () => (/* binding */ __wbg_indexedDB_72e2ca071222fd9e),\n/* harmony export */   __wbg_indexedDB_e34a5e9b3d2fcfa1: () => (/* binding */ __wbg_indexedDB_e34a5e9b3d2fcfa1),\n/* harmony export */   __wbg_info_c3044c86ae29faab: () => (/* binding */ __wbg_info_c3044c86ae29faab),\n/* harmony export */   __wbg_info_ed71056bef15b91a: () => (/* binding */ __wbg_info_ed71056bef15b91a),\n/* harmony export */   __wbg_instanceof_ArrayBuffer_670ddde44cdb2602: () => (/* binding */ __wbg_instanceof_ArrayBuffer_670ddde44cdb2602),\n/* harmony export */   __wbg_instanceof_Map_98ecb30afec5acdb: () => (/* binding */ __wbg_instanceof_Map_98ecb30afec5acdb),\n/* harmony export */   __wbg_instanceof_Promise_0aa3a90cfe6672c9: () => (/* binding */ __wbg_instanceof_Promise_0aa3a90cfe6672c9),\n/* harmony export */   __wbg_instanceof_Uint8Array_28af5bc19d6acad8: () => (/* binding */ __wbg_instanceof_Uint8Array_28af5bc19d6acad8),\n/* harmony export */   __wbg_isArray_1ba11a930108ec51: () => (/* binding */ __wbg_isArray_1ba11a930108ec51),\n/* harmony export */   __wbg_isSafeInteger_12f5549b2fca23f4: () => (/* binding */ __wbg_isSafeInteger_12f5549b2fca23f4),\n/* harmony export */   __wbg_item_7156a8ffa4d816bc: () => (/* binding */ __wbg_item_7156a8ffa4d816bc),\n/* harmony export */   __wbg_iterator_23604bb983791576: () => (/* binding */ __wbg_iterator_23604bb983791576),\n/* harmony export */   __wbg_key_87db8226759da642: () => (/* binding */ __wbg_key_87db8226759da642),\n/* harmony export */   __wbg_keysbackuprequest_new: () => (/* binding */ __wbg_keysbackuprequest_new),\n/* harmony export */   __wbg_keysclaimrequest_new: () => (/* binding */ __wbg_keysclaimrequest_new),\n/* harmony export */   __wbg_keysqueryrequest_new: () => (/* binding */ __wbg_keysqueryrequest_new),\n/* harmony export */   __wbg_keysuploadrequest_new: () => (/* binding */ __wbg_keysuploadrequest_new),\n/* harmony export */   __wbg_length_65d1cd11729ced11: () => (/* binding */ __wbg_length_65d1cd11729ced11),\n/* harmony export */   __wbg_length_d65cf0786bfc5739: () => (/* binding */ __wbg_length_d65cf0786bfc5739),\n/* harmony export */   __wbg_length_f4d79409aa324811: () => (/* binding */ __wbg_length_f4d79409aa324811),\n/* harmony export */   __wbg_lowerBound_3aa47caa33c7e1e6: () => (/* binding */ __wbg_lowerBound_3aa47caa33c7e1e6),\n/* harmony export */   __wbg_maybesignature_new: () => (/* binding */ __wbg_maybesignature_new),\n/* harmony export */   __wbg_megolmdecryptionerror_new: () => (/* binding */ __wbg_megolmdecryptionerror_new),\n/* harmony export */   __wbg_message_d19bdb65f0a41cf5: () => (/* binding */ __wbg_message_d19bdb65f0a41cf5),\n/* harmony export */   __wbg_msCrypto_0a36e2ec3a343d26: () => (/* binding */ __wbg_msCrypto_0a36e2ec3a343d26),\n/* harmony export */   __wbg_name_8862cd49ad807c59: () => (/* binding */ __wbg_name_8862cd49ad807c59),\n/* harmony export */   __wbg_new_0f1bd659dcd47068: () => (/* binding */ __wbg_new_0f1bd659dcd47068),\n/* harmony export */   __wbg_new_254fa9eac11932ae: () => (/* binding */ __wbg_new_254fa9eac11932ae),\n/* harmony export */   __wbg_new_3d446df9155128ef: () => (/* binding */ __wbg_new_3d446df9155128ef),\n/* harmony export */   __wbg_new_3ff5b33b1ce712df: () => (/* binding */ __wbg_new_3ff5b33b1ce712df),\n/* harmony export */   __wbg_new_41257536af60ed14: () => (/* binding */ __wbg_new_41257536af60ed14),\n/* harmony export */   __wbg_new_688846f374351c92: () => (/* binding */ __wbg_new_688846f374351c92),\n/* harmony export */   __wbg_new_8a6f238a6ece86ea: () => (/* binding */ __wbg_new_8a6f238a6ece86ea),\n/* harmony export */   __wbg_new_9451f3dcb42e0e37: () => (/* binding */ __wbg_new_9451f3dcb42e0e37),\n/* harmony export */   __wbg_new_bc96c6a1c0786643: () => (/* binding */ __wbg_new_bc96c6a1c0786643),\n/* harmony export */   __wbg_newnoargs_fd9e4bf8be2bc16d: () => (/* binding */ __wbg_newnoargs_fd9e4bf8be2bc16d),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_ba35896968751d91: () => (/* binding */ __wbg_newwithbyteoffsetandlength_ba35896968751d91),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_c0c90653f73c7dfb: () => (/* binding */ __wbg_newwithbyteoffsetandlength_c0c90653f73c7dfb),\n/* harmony export */   __wbg_newwithlength_2aede0ef4e6e97ec: () => (/* binding */ __wbg_newwithlength_2aede0ef4e6e97ec),\n/* harmony export */   __wbg_newwithlength_34ce8f1051e74449: () => (/* binding */ __wbg_newwithlength_34ce8f1051e74449),\n/* harmony export */   __wbg_newwithmessage_80e6436058862fd4: () => (/* binding */ __wbg_newwithmessage_80e6436058862fd4),\n/* harmony export */   __wbg_next_01dd9234a5bf6d05: () => (/* binding */ __wbg_next_01dd9234a5bf6d05),\n/* harmony export */   __wbg_next_137428deb98342b0: () => (/* binding */ __wbg_next_137428deb98342b0),\n/* harmony export */   __wbg_node_02999533c4ea02e3: () => (/* binding */ __wbg_node_02999533c4ea02e3),\n/* harmony export */   __wbg_now_2c95c9de01293173: () => (/* binding */ __wbg_now_2c95c9de01293173),\n/* harmony export */   __wbg_now_64d0bb151e5d3889: () => (/* binding */ __wbg_now_64d0bb151e5d3889),\n/* harmony export */   __wbg_objectStoreNames_cb00c8113b3cf5df: () => (/* binding */ __wbg_objectStoreNames_cb00c8113b3cf5df),\n/* harmony export */   __wbg_objectStore_cdbc73ee600a2cfa: () => (/* binding */ __wbg_objectStore_cdbc73ee600a2cfa),\n/* harmony export */   __wbg_oldVersion_a31d9f8577239dd8: () => (/* binding */ __wbg_oldVersion_a31d9f8577239dd8),\n/* harmony export */   __wbg_olmmachine_new: () => (/* binding */ __wbg_olmmachine_new),\n/* harmony export */   __wbg_openCursor_37e21d9af1a61159: () => (/* binding */ __wbg_openCursor_37e21d9af1a61159),\n/* harmony export */   __wbg_openCursor_da08cc74542711ad: () => (/* binding */ __wbg_openCursor_da08cc74542711ad),\n/* harmony export */   __wbg_openCursor_e7a3f6453a0f6725: () => (/* binding */ __wbg_openCursor_e7a3f6453a0f6725),\n/* harmony export */   __wbg_open_4588c85c0c43671d: () => (/* binding */ __wbg_open_4588c85c0c43671d),\n/* harmony export */   __wbg_open_5c51d4d6d7ab6da6: () => (/* binding */ __wbg_open_5c51d4d6d7ab6da6),\n/* harmony export */   __wbg_otheruseridentity_new: () => (/* binding */ __wbg_otheruseridentity_new),\n/* harmony export */   __wbg_ownuseridentity_new: () => (/* binding */ __wbg_ownuseridentity_new),\n/* harmony export */   __wbg_parse_161c68378e086ae1: () => (/* binding */ __wbg_parse_161c68378e086ae1),\n/* harmony export */   __wbg_performance_7a3ffd0b17f663ad: () => (/* binding */ __wbg_performance_7a3ffd0b17f663ad),\n/* harmony export */   __wbg_pickledinboundgroupsession_unwrap: () => (/* binding */ __wbg_pickledinboundgroupsession_unwrap),\n/* harmony export */   __wbg_pickledsession_unwrap: () => (/* binding */ __wbg_pickledsession_unwrap),\n/* harmony export */   __wbg_process_5c1d670bc53614b8: () => (/* binding */ __wbg_process_5c1d670bc53614b8),\n/* harmony export */   __wbg_push_6edad0df4b546b2c: () => (/* binding */ __wbg_push_6edad0df4b546b2c),\n/* harmony export */   __wbg_put_5393e88dbe742e8f: () => (/* binding */ __wbg_put_5393e88dbe742e8f),\n/* harmony export */   __wbg_putdehydrateddevicerequest_new: () => (/* binding */ __wbg_putdehydrateddevicerequest_new),\n/* harmony export */   __wbg_qr_new: () => (/* binding */ __wbg_qr_new),\n/* harmony export */   __wbg_queueMicrotask_2181040e064c0dc8: () => (/* binding */ __wbg_queueMicrotask_2181040e064c0dc8),\n/* harmony export */   __wbg_queueMicrotask_ef9ac43769cbcc4f: () => (/* binding */ __wbg_queueMicrotask_ef9ac43769cbcc4f),\n/* harmony export */   __wbg_randomFillSync_ab2cfe79ebbf2740: () => (/* binding */ __wbg_randomFillSync_ab2cfe79ebbf2740),\n/* harmony export */   __wbg_readyState_8428fa7c5e093401: () => (/* binding */ __wbg_readyState_8428fa7c5e093401),\n/* harmony export */   __wbg_rehydrateddevice_new: () => (/* binding */ __wbg_rehydrateddevice_new),\n/* harmony export */   __wbg_require_79b1e9274cde3c87: () => (/* binding */ __wbg_require_79b1e9274cde3c87),\n/* harmony export */   __wbg_resolve_0bf7c44d641804f9: () => (/* binding */ __wbg_resolve_0bf7c44d641804f9),\n/* harmony export */   __wbg_result_e6ba6a347dcb7470: () => (/* binding */ __wbg_result_e6ba6a347dcb7470),\n/* harmony export */   __wbg_roomid_unwrap: () => (/* binding */ __wbg_roomid_unwrap),\n/* harmony export */   __wbg_roomkeycounts_new: () => (/* binding */ __wbg_roomkeycounts_new),\n/* harmony export */   __wbg_roomkeyimportresult_new: () => (/* binding */ __wbg_roomkeyimportresult_new),\n/* harmony export */   __wbg_roomkeyinfo_new: () => (/* binding */ __wbg_roomkeyinfo_new),\n/* harmony export */   __wbg_roomkeywithheldinfo_new: () => (/* binding */ __wbg_roomkeywithheldinfo_new),\n/* harmony export */   __wbg_roommessagerequest_new: () => (/* binding */ __wbg_roommessagerequest_new),\n/* harmony export */   __wbg_roomsettings_new: () => (/* binding */ __wbg_roomsettings_new),\n/* harmony export */   __wbg_sas_new: () => (/* binding */ __wbg_sas_new),\n/* harmony export */   __wbg_secretsbundle_new: () => (/* binding */ __wbg_secretsbundle_new),\n/* harmony export */   __wbg_setTimeout_db2dbaeefb6f39c7: () => (/* binding */ __wbg_setTimeout_db2dbaeefb6f39c7),\n/* harmony export */   __wbg_set_1d80752d0d5f0b21: () => (/* binding */ __wbg_set_1d80752d0d5f0b21),\n/* harmony export */   __wbg_set_23d69db4e5c66a6e: () => (/* binding */ __wbg_set_23d69db4e5c66a6e),\n/* harmony export */   __wbg_set_3807d5f0bfc24aa7: () => (/* binding */ __wbg_set_3807d5f0bfc24aa7),\n/* harmony export */   __wbg_set_3f1d0b984ed272ed: () => (/* binding */ __wbg_set_3f1d0b984ed272ed),\n/* harmony export */   __wbg_set_76818dc3c59a63d5: () => (/* binding */ __wbg_set_76818dc3c59a63d5),\n/* harmony export */   __wbg_set_9592f7d5b752cae3: () => (/* binding */ __wbg_set_9592f7d5b752cae3),\n/* harmony export */   __wbg_set_wasm: () => (/* binding */ __wbg_set_wasm),\n/* harmony export */   __wbg_setonabort_ade6cac5c35a572f: () => (/* binding */ __wbg_setonabort_ade6cac5c35a572f),\n/* harmony export */   __wbg_setonblocked_d13048be9383f4dc: () => (/* binding */ __wbg_setonblocked_d13048be9383f4dc),\n/* harmony export */   __wbg_setoncomplete_2747fb71ae0af4a8: () => (/* binding */ __wbg_setoncomplete_2747fb71ae0af4a8),\n/* harmony export */   __wbg_setonerror_72b33e31f9edb045: () => (/* binding */ __wbg_setonerror_72b33e31f9edb045),\n/* harmony export */   __wbg_setonerror_e4beb2652cf66635: () => (/* binding */ __wbg_setonerror_e4beb2652cf66635),\n/* harmony export */   __wbg_setonsuccess_57167b1c2650357c: () => (/* binding */ __wbg_setonsuccess_57167b1c2650357c),\n/* harmony export */   __wbg_setonupgradeneeded_887c7a5fca66011e: () => (/* binding */ __wbg_setonupgradeneeded_887c7a5fca66011e),\n/* harmony export */   __wbg_setonversionchange_a6f60bd1d110795d: () => (/* binding */ __wbg_setonversionchange_a6f60bd1d110795d),\n/* harmony export */   __wbg_setunique_cfc477dc5825e1c4: () => (/* binding */ __wbg_setunique_cfc477dc5825e1c4),\n/* harmony export */   __wbg_signatures_new: () => (/* binding */ __wbg_signatures_new),\n/* harmony export */   __wbg_signatureuploadrequest_new: () => (/* binding */ __wbg_signatureuploadrequest_new),\n/* harmony export */   __wbg_signatureverification_new: () => (/* binding */ __wbg_signatureverification_new),\n/* harmony export */   __wbg_stack_0ed75d68575b0f3c: () => (/* binding */ __wbg_stack_0ed75d68575b0f3c),\n/* harmony export */   __wbg_static_accessor_GLOBAL_0be7472e492ad3e3: () => (/* binding */ __wbg_static_accessor_GLOBAL_0be7472e492ad3e3),\n/* harmony export */   __wbg_static_accessor_GLOBAL_THIS_1a6eb482d12c9bfb: () => (/* binding */ __wbg_static_accessor_GLOBAL_THIS_1a6eb482d12c9bfb),\n/* harmony export */   __wbg_static_accessor_SELF_1dc398a895c82351: () => (/* binding */ __wbg_static_accessor_SELF_1dc398a895c82351),\n/* harmony export */   __wbg_static_accessor_WINDOW_ae1c80c7eea8d64a: () => (/* binding */ __wbg_static_accessor_WINDOW_ae1c80c7eea8d64a),\n/* harmony export */   __wbg_storehandle_new: () => (/* binding */ __wbg_storehandle_new),\n/* harmony export */   __wbg_stringify_f4f701bc34ceda61: () => (/* binding */ __wbg_stringify_f4f701bc34ceda61),\n/* harmony export */   __wbg_subarray_46adeb9b86949d12: () => (/* binding */ __wbg_subarray_46adeb9b86949d12),\n/* harmony export */   __wbg_target_a8fe593e7ee79c21: () => (/* binding */ __wbg_target_a8fe593e7ee79c21),\n/* harmony export */   __wbg_then_0438fad860fe38e1: () => (/* binding */ __wbg_then_0438fad860fe38e1),\n/* harmony export */   __wbg_then_0ffafeddf0e182a4: () => (/* binding */ __wbg_then_0ffafeddf0e182a4),\n/* harmony export */   __wbg_todevicerequest_new: () => (/* binding */ __wbg_todevicerequest_new),\n/* harmony export */   __wbg_transaction_bc71c2aaaf467420: () => (/* binding */ __wbg_transaction_bc71c2aaaf467420),\n/* harmony export */   __wbg_transaction_d2b6d520837fbe7f: () => (/* binding */ __wbg_transaction_d2b6d520837fbe7f),\n/* harmony export */   __wbg_transaction_dbab9cd9ea849958: () => (/* binding */ __wbg_transaction_dbab9cd9ea849958),\n/* harmony export */   __wbg_update_211ddccaf2cec6ee: () => (/* binding */ __wbg_update_211ddccaf2cec6ee),\n/* harmony export */   __wbg_userdevices_new: () => (/* binding */ __wbg_userdevices_new),\n/* harmony export */   __wbg_userid_new: () => (/* binding */ __wbg_userid_new),\n/* harmony export */   __wbg_userid_unwrap: () => (/* binding */ __wbg_userid_unwrap),\n/* harmony export */   __wbg_value_0ad6f37677c8ee74: () => (/* binding */ __wbg_value_0ad6f37677c8ee74),\n/* harmony export */   __wbg_value_4c32fd138a88eee2: () => (/* binding */ __wbg_value_4c32fd138a88eee2),\n/* harmony export */   __wbg_values_7aa03dd078978c86: () => (/* binding */ __wbg_values_7aa03dd078978c86),\n/* harmony export */   __wbg_verificationrequest_new: () => (/* binding */ __wbg_verificationrequest_new),\n/* harmony export */   __wbg_version_2b650c9d4f0a2438: () => (/* binding */ __wbg_version_2b650c9d4f0a2438),\n/* harmony export */   __wbg_versions_c71aa1626a93e0a1: () => (/* binding */ __wbg_versions_c71aa1626a93e0a1),\n/* harmony export */   __wbg_warn_123db6aa8948382e: () => (/* binding */ __wbg_warn_123db6aa8948382e),\n/* harmony export */   __wbg_warn_9d038df1589cb1bd: () => (/* binding */ __wbg_warn_9d038df1589cb1bd),\n/* harmony export */   __wbindgen_as_number: () => (/* binding */ __wbindgen_as_number),\n/* harmony export */   __wbindgen_bigint_from_i64: () => (/* binding */ __wbindgen_bigint_from_i64),\n/* harmony export */   __wbindgen_bigint_from_u64: () => (/* binding */ __wbindgen_bigint_from_u64),\n/* harmony export */   __wbindgen_bigint_get_as_i64: () => (/* binding */ __wbindgen_bigint_get_as_i64),\n/* harmony export */   __wbindgen_boolean_get: () => (/* binding */ __wbindgen_boolean_get),\n/* harmony export */   __wbindgen_cb_drop: () => (/* binding */ __wbindgen_cb_drop),\n/* harmony export */   __wbindgen_closure_wrapper1050: () => (/* binding */ __wbindgen_closure_wrapper1050),\n/* harmony export */   __wbindgen_closure_wrapper2213: () => (/* binding */ __wbindgen_closure_wrapper2213),\n/* harmony export */   __wbindgen_closure_wrapper5386: () => (/* binding */ __wbindgen_closure_wrapper5386),\n/* harmony export */   __wbindgen_closure_wrapper6843: () => (/* binding */ __wbindgen_closure_wrapper6843),\n/* harmony export */   __wbindgen_closure_wrapper6848: () => (/* binding */ __wbindgen_closure_wrapper6848),\n/* harmony export */   __wbindgen_debug_string: () => (/* binding */ __wbindgen_debug_string),\n/* harmony export */   __wbindgen_error_new: () => (/* binding */ __wbindgen_error_new),\n/* harmony export */   __wbindgen_in: () => (/* binding */ __wbindgen_in),\n/* harmony export */   __wbindgen_init_externref_table: () => (/* binding */ __wbindgen_init_externref_table),\n/* harmony export */   __wbindgen_is_array: () => (/* binding */ __wbindgen_is_array),\n/* harmony export */   __wbindgen_is_bigint: () => (/* binding */ __wbindgen_is_bigint),\n/* harmony export */   __wbindgen_is_function: () => (/* binding */ __wbindgen_is_function),\n/* harmony export */   __wbindgen_is_null: () => (/* binding */ __wbindgen_is_null),\n/* harmony export */   __wbindgen_is_object: () => (/* binding */ __wbindgen_is_object),\n/* harmony export */   __wbindgen_is_string: () => (/* binding */ __wbindgen_is_string),\n/* harmony export */   __wbindgen_is_undefined: () => (/* binding */ __wbindgen_is_undefined),\n/* harmony export */   __wbindgen_jsval_eq: () => (/* binding */ __wbindgen_jsval_eq),\n/* harmony export */   __wbindgen_jsval_loose_eq: () => (/* binding */ __wbindgen_jsval_loose_eq),\n/* harmony export */   __wbindgen_memory: () => (/* binding */ __wbindgen_memory),\n/* harmony export */   __wbindgen_number_get: () => (/* binding */ __wbindgen_number_get),\n/* harmony export */   __wbindgen_number_new: () => (/* binding */ __wbindgen_number_new),\n/* harmony export */   __wbindgen_string_get: () => (/* binding */ __wbindgen_string_get),\n/* harmony export */   __wbindgen_string_new: () => (/* binding */ __wbindgen_string_new),\n/* harmony export */   __wbindgen_throw: () => (/* binding */ __wbindgen_throw),\n/* harmony export */   __wbindgen_try_into_number: () => (/* binding */ __wbindgen_try_into_number),\n/* harmony export */   getVersions: () => (/* binding */ getVersions),\n/* harmony export */   start: () => (/* binding */ start)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\nlet wasm;\nfunction __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction addToExternrefTable0(obj) {\n    const idx = wasm.__externref_table_alloc();\n    wasm.__wbindgen_export_4.set(idx, obj);\n    return idx;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        const idx = addToExternrefTable0(e);\n        wasm.__wbindgen_exn_store(idx);\n    }\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nconst CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(state => {\n    wasm.__wbindgen_export_6.get(state.dtor)(state.a, state.b)\n});\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_6.get(state.dtor)(a, state.b);\n                CLOSURE_DTORS.unregister(state);\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n    CLOSURE_DTORS.register(real, state, state);\n    return real;\n}\n\nfunction makeClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        try {\n            return f(state.a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_6.get(state.dtor)(state.a, state.b);\n                state.a = 0;\n                CLOSURE_DTORS.unregister(state);\n            }\n        }\n    };\n    real.original = state;\n    CLOSURE_DTORS.register(real, state, state);\n    return real;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches && builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction takeFromExternrefTable0(idx) {\n    const value = wasm.__wbindgen_export_4.get(idx);\n    wasm.__externref_table_dealloc(idx);\n    return value;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction passArrayJsValueToWasm0(array, malloc) {\n    const ptr = malloc(array.length * 4, 4) >>> 0;\n    const mem = getDataViewMemory0();\n    for (let i = 0; i < array.length; i++) {\n        mem.setUint32(ptr + 4 * i, addToExternrefTable0(array[i]), true);\n    }\n    WASM_VECTOR_LEN = array.length;\n    return ptr;\n}\n\nfunction getArrayJsValueFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    const mem = getDataViewMemory0();\n    const result = [];\n    for (let i = ptr; i < ptr + 4 * len; i += 4) {\n        result.push(wasm.__wbindgen_export_4.get(mem.getUint32(i, true)));\n    }\n    wasm.__externref_drop_slice(ptr, len);\n    return result;\n}\n\nlet cachedUint16ArrayMemory0 = null;\n\nfunction getUint16ArrayMemory0() {\n    if (cachedUint16ArrayMemory0 === null || cachedUint16ArrayMemory0.byteLength === 0) {\n        cachedUint16ArrayMemory0 = new Uint16Array(wasm.memory.buffer);\n    }\n    return cachedUint16ArrayMemory0;\n}\n\nfunction getArrayU16FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint16ArrayMemory0().subarray(ptr / 2, ptr / 2 + len);\n}\n/**\n * Get the versions of the Rust libraries we are using.\n * @returns {Versions}\n */\nfunction getVersions() {\n    const ret = wasm.getVersions();\n    return Versions.__wrap(ret);\n}\n\n/**\n * Run some stuff when the Wasm module is instantiated.\n *\n * Right now, it does the following:\n *\n * * Redirect Rust panics to JavaScript console.\n */\nfunction start() {\n    wasm.start();\n}\n\nfunction __wbg_adapter_58(arg0, arg1, arg2) {\n    const ret = wasm.closure29_externref_shim_multivalue_shim(arg0, arg1, arg2);\n    if (ret[1]) {\n        throw takeFromExternrefTable0(ret[0]);\n    }\n}\n\nfunction __wbg_adapter_61(arg0, arg1) {\n    wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__heca5c4426cc7e703(arg0, arg1);\n}\n\nfunction __wbg_adapter_64(arg0, arg1, arg2) {\n    wasm.closure735_externref_shim(arg0, arg1, arg2);\n}\n\nfunction __wbg_adapter_67(arg0, arg1, arg2) {\n    wasm.closure415_externref_shim(arg0, arg1, arg2);\n}\n\nfunction __wbg_adapter_70(arg0, arg1) {\n    wasm._dyn_core__ops__function__Fn_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h41d552962a79dfb4(arg0, arg1);\n}\n\nfunction __wbg_adapter_758(arg0, arg1, arg2, arg3) {\n    wasm.closure431_externref_shim(arg0, arg1, arg2, arg3);\n}\n\n/**\n * Decryption error codes\n * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6}\n */\nconst DecryptionErrorCode = Object.freeze({\n    /**\n     * The room key is not known\n     */\n    MissingRoomKey: 0, \"0\": \"MissingRoomKey\",\n    /**\n     * The room key is known but ratcheted\n     */\n    UnknownMessageIndex: 1, \"1\": \"UnknownMessageIndex\",\n    /**\n     * Decryption failed because of a mismatch between the identity keys of the\n     * device we received the room key from and the identity keys recorded in\n     * the plaintext of the room key to-device message.\n     */\n    MismatchedIdentityKeys: 2, \"2\": \"MismatchedIdentityKeys\",\n    /**\n     * We weren't able to link the message back to any known device.\n     */\n    UnknownSenderDevice: 3, \"3\": \"UnknownSenderDevice\",\n    /**\n     * The sender device is not cross-signed.\n     */\n    UnsignedSenderDevice: 4, \"4\": \"UnsignedSenderDevice\",\n    /**\n     * The sender's identity is unverified, but was previously verified.\n     */\n    SenderIdentityVerificationViolation: 5, \"5\": \"SenderIdentityVerificationViolation\",\n    /**\n     * Other failure.\n     */\n    UnableToDecrypt: 6, \"6\": \"UnableToDecrypt\",\n});\n/**\n * The basic key algorithm names in the specification.\n * @enum {0 | 1 | 3}\n */\nconst DeviceKeyAlgorithmName = Object.freeze({\n    /**\n     * The Ed25519 signature algorithm.\n     */\n    Ed25519: 0, \"0\": \"Ed25519\",\n    /**\n     * The Curve25519 ECDH algorithm.\n     */\n    Curve25519: 1, \"1\": \"Curve25519\",\n    /**\n     * An unknown device key algorithm.\n     */\n    Unknown: 3, \"3\": \"Unknown\",\n});\n/**\n * An enum over the different key types a device can have.\n *\n * Currently devices have a curve25519 and ed25519 keypair. The keys\n * transport format is a base64 encoded string, any unknown key type\n * will be left as such a string.\n * @enum {0 | 1 | 2}\n */\nconst DeviceKeyName = Object.freeze({\n    /**\n     * The curve25519 device key.\n     */\n    Curve25519: 0, \"0\": \"Curve25519\",\n    /**\n     * The ed25519 device key.\n     */\n    Ed25519: 1, \"1\": \"Ed25519\",\n    /**\n     * An unknown device key.\n     */\n    Unknown: 2, \"2\": \"Unknown\",\n});\n/**\n * An encryption algorithm to be used to encrypt messages sent to a\n * room.\n * @enum {0 | 1 | 2}\n */\nconst EncryptionAlgorithm = Object.freeze({\n    /**\n     * Olm version 1 using Curve25519, AES-256, and SHA-256.\n     */\n    OlmV1Curve25519AesSha2: 0, \"0\": \"OlmV1Curve25519AesSha2\",\n    /**\n     * Megolm version 1 using AES-256 and SHA-256.\n     */\n    MegolmV1AesSha2: 1, \"1\": \"MegolmV1AesSha2\",\n    /**\n     * Unsupported algorithm.\n     *\n     * Applications should ignore this value if it is received, and should\n     * never set it.\n     */\n    Unknown: 2, \"2\": \"Unknown\",\n});\n/**\n * Who can see a room's history.\n * @enum {0 | 1 | 2 | 3}\n */\nconst HistoryVisibility = Object.freeze({\n    /**\n     * Previous events are accessible to newly joined members from\n     * the point they were invited onwards.\n     *\n     * Events stop being accessible when the member's state changes\n     * to something other than *invite* or *join*.\n     */\n    Invited: 0, \"0\": \"Invited\",\n    /**\n     * Previous events are accessible to newly joined members from\n     * the point they joined the room onwards.\n     *\n     * Events stop being accessible when the member's state changes\n     * to something other than *join*.\n     */\n    Joined: 1, \"1\": \"Joined\",\n    /**\n     * Previous events are always accessible to newly joined members.\n     *\n     * All events in the room are accessible, even those sent when\n     * the member was not a part of the room.\n     */\n    Shared: 2, \"2\": \"Shared\",\n    /**\n     * All events while this is the `HistoryVisibility` value may be\n     * shared by any participating homeserver with anyone, regardless\n     * of whether they have ever joined the room.\n     */\n    WorldReadable: 3, \"3\": \"WorldReadable\",\n});\n/**\n * The local trust state of a device.\n * @enum {0 | 1 | 2 | 3}\n */\nconst LocalTrust = Object.freeze({\n    /**\n     * The device has been verified and is trusted.\n     */\n    Verified: 0, \"0\": \"Verified\",\n    /**\n     * The device been blacklisted from communicating.\n     */\n    BlackListed: 1, \"1\": \"BlackListed\",\n    /**\n     * The trust state of the device is being ignored.\n     */\n    Ignored: 2, \"2\": \"Ignored\",\n    /**\n     * The trust state is unset.\n     */\n    Unset: 3, \"3\": \"Unset\",\n});\n/**\n * Logger level.\n * @enum {0 | 1 | 2 | 3 | 4}\n */\nconst LoggerLevel = Object.freeze({\n    /**\n     * `TRACE` level.\n     *\n     * Designate very low priority, often extremely verbose,\n     * information.\n     */\n    Trace: 0, \"0\": \"Trace\",\n    /**\n     * `DEBUG` level.\n     *\n     * Designate lower priority information.\n     */\n    Debug: 1, \"1\": \"Debug\",\n    /**\n     * `INFO` level.\n     *\n     * Designate useful information.\n     */\n    Info: 2, \"2\": \"Info\",\n    /**\n     * `WARN` level.\n     *\n     * Designate hazardous situations.\n     */\n    Warn: 3, \"3\": \"Warn\",\n    /**\n     * `ERROR` level.\n     *\n     * Designate very serious errors.\n     */\n    Error: 4, \"4\": \"Error\",\n});\n/**\n * The mode of the QR code login.\n *\n * The QR code login mechanism supports both, the new device, as well as the\n * existing device to display the QR code.\n *\n * The different modes have an explicit one-byte identifier which gets added to\n * the QR code data.\n * @enum {0 | 1}\n */\nconst QrCodeMode = Object.freeze({\n    /**\n     * The new device is displaying the QR code.\n     */\n    Login: 0, \"0\": \"Login\",\n    /**\n     * The existing device is displaying the QR code.\n     */\n    Reciprocate: 1, \"1\": \"Reciprocate\",\n});\n/**\n * List of `Qr` states\n * @enum {0 | 1 | 2 | 3 | 4 | 5}\n */\nconst QrState = Object.freeze({\n    /**\n     * We have received the other device's details (from the\n     * `m.key.verification.request` or `m.key.verification.ready`) and\n     * established the shared secret, so can\n     * display the QR code.\n     */\n    Created: 0, \"0\": \"Created\",\n    /**\n     * The other side has scanned our QR code and sent an\n     * `m.key.verification.start` message with `method: m.reciprocate.v1` with\n     * matching shared secret.\n     */\n    Scanned: 1, \"1\": \"Scanned\",\n    /**\n     * Our user has confirmed that the other device scanned successfully. We\n     * have sent an `m.key.verification.done`.\n     */\n    Confirmed: 2, \"2\": \"Confirmed\",\n    /**\n     * We have scanned the other side's QR code and are able to send a\n     * `m.key.verification.start` message with `method: m.reciprocate.v1`.\n     *\n     * Call `Qr::reciprocate` to build the start message.\n     *\n     * Note that, despite the name of this state, we have not necessarily\n     * yet sent the `m.reciprocate.v1` message.\n     */\n    Reciprocated: 3, \"3\": \"Reciprocated\",\n    /**\n     * Verification complete: we have received an `m.key.verification.done`\n     * from the other side.\n     */\n    Done: 4, \"4\": \"Done\",\n    /**\n     * Verification cancelled or failed.\n     */\n    Cancelled: 5, \"5\": \"Cancelled\",\n});\n/**\n * Represent the type of a request.\n * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6}\n */\nconst RequestType = Object.freeze({\n    /**\n     * Represents a `KeysUploadRequest`.\n     */\n    KeysUpload: 0, \"0\": \"KeysUpload\",\n    /**\n     * Represents a `KeysQueryRequest`.\n     */\n    KeysQuery: 1, \"1\": \"KeysQuery\",\n    /**\n     * Represents a `KeysClaimRequest`.\n     */\n    KeysClaim: 2, \"2\": \"KeysClaim\",\n    /**\n     * Represents a `ToDeviceRequest`.\n     */\n    ToDevice: 3, \"3\": \"ToDevice\",\n    /**\n     * Represents a `SignatureUploadRequest`.\n     */\n    SignatureUpload: 4, \"4\": \"SignatureUpload\",\n    /**\n     * Represents a `RoomMessageRequest`.\n     */\n    RoomMessage: 5, \"5\": \"RoomMessage\",\n    /**\n     * Represents a `KeysBackupRequest`.\n     */\n    KeysBackup: 6, \"6\": \"KeysBackup\",\n});\n/**\n * Take a look at [`matrix_sdk_common::deserialized_responses::ShieldState`]\n * for more info.\n * @enum {0 | 1 | 2}\n */\nconst ShieldColor = Object.freeze({\n    /**\n     * Important warning\n     */\n    Red: 0, \"0\": \"Red\",\n    /**\n     * Low warning\n     */\n    Grey: 1, \"1\": \"Grey\",\n    /**\n     * No warning\n     */\n    None: 2, \"2\": \"None\",\n});\n/**\n * A machine-readable representation of the authenticity for a `ShieldState`.\n * @enum {0 | 1 | 2 | 3 | 4 | 5}\n */\nconst ShieldStateCode = Object.freeze({\n    /**\n     * Not enough information available to check the authenticity.\n     */\n    AuthenticityNotGuaranteed: 0, \"0\": \"AuthenticityNotGuaranteed\",\n    /**\n     * The sending device isn't yet known by the Client.\n     */\n    UnknownDevice: 1, \"1\": \"UnknownDevice\",\n    /**\n     * The sending device hasn't been verified by the sender.\n     */\n    UnsignedDevice: 2, \"2\": \"UnsignedDevice\",\n    /**\n     * The sender hasn't been verified by the Client's user.\n     */\n    UnverifiedIdentity: 3, \"3\": \"UnverifiedIdentity\",\n    /**\n     * An unencrypted event in an encrypted room.\n     */\n    SentInClear: 4, \"4\": \"SentInClear\",\n    /**\n     * The sender was previously verified but changed their identity.\n     */\n    VerificationViolation: 5, \"5\": \"VerificationViolation\",\n});\n/**\n * The result of a signature check.\n * @enum {0 | 1 | 2 | 3}\n */\nconst SignatureState = Object.freeze({\n    /**\n     * The signature is missing.\n     */\n    Missing: 0, \"0\": \"Missing\",\n    /**\n     * The signature is invalid.\n     */\n    Invalid: 1, \"1\": \"Invalid\",\n    /**\n     * The signature is valid but the device or user identity that created the\n     * signature is not trusted.\n     */\n    ValidButNotTrusted: 2, \"2\": \"ValidButNotTrusted\",\n    /**\n     * The signature is valid and the device or user identity that created the\n     * signature is trusted.\n     */\n    ValidAndTrusted: 3, \"3\": \"ValidAndTrusted\",\n});\n/**\n * The trust level required to decrypt an event\n * @enum {0 | 1 | 2}\n */\nconst TrustRequirement = Object.freeze({\n    /**\n     * Decrypt events from everyone regardless of trust\n     */\n    Untrusted: 0, \"0\": \"Untrusted\",\n    /**\n     * Only decrypt events from cross-signed or legacy devices\n     */\n    CrossSignedOrLegacy: 1, \"1\": \"CrossSignedOrLegacy\",\n    /**\n     * Only decrypt events from cross-signed devices\n     */\n    CrossSigned: 2, \"2\": \"CrossSigned\",\n});\n/**\n * List of available verification methods.\n * @enum {0 | 1 | 2 | 3}\n */\nconst VerificationMethod = Object.freeze({\n    /**\n     * The `m.sas.v1` verification method.\n     *\n     * SAS means Short Authentication String.\n     */\n    SasV1: 0, \"0\": \"SasV1\",\n    /**\n     * The `m.qr_code.scan.v1` verification method.\n     */\n    QrCodeScanV1: 1, \"1\": \"QrCodeScanV1\",\n    /**\n     * The `m.qr_code.show.v1` verification method.\n     */\n    QrCodeShowV1: 2, \"2\": \"QrCodeShowV1\",\n    /**\n     * The `m.reciprocate.v1` verification method.\n     */\n    ReciprocateV1: 3, \"3\": \"ReciprocateV1\",\n});\n/**\n * List of VerificationRequestState phases\n * @enum {0 | 1 | 2 | 3 | 4 | 5}\n */\nconst VerificationRequestPhase = Object.freeze({\n    /**\n     * The verification request has been newly created by us.\n     */\n    Created: 0, \"0\": \"Created\",\n    /**\n     * The verification request was received from the other party.\n     */\n    Requested: 1, \"1\": \"Requested\",\n    /**\n     * The verification request is ready to start a verification flow.\n     */\n    Ready: 2, \"2\": \"Ready\",\n    /**\n     * The verification request has transitioned into a concrete verification\n     * flow. For example it transitioned into the emoji based SAS\n     * verification.\n     */\n    Transitioned: 3, \"3\": \"Transitioned\",\n    /**\n     * The verification flow that was started with this request has finished.\n     */\n    Done: 4, \"4\": \"Done\",\n    /**\n     * The verification process has been cancelled.\n     */\n    Cancelled: 5, \"5\": \"Cancelled\",\n});\n\nconst __wbindgen_enum_IdbRequestReadyState = [\"pending\", \"done\"];\n\nconst __wbindgen_enum_IdbTransactionMode = [\"readonly\", \"readwrite\", \"versionchange\", \"readwriteflush\", \"cleanup\"];\n\nconst AttachmentFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_attachment_free(ptr >>> 0, 1));\n/**\n * A type to encrypt and to decrypt anything that can fit in an\n * `Uint8Array`, usually big buffer.\n */\nclass Attachment {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AttachmentFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_attachment_free(ptr, 0);\n    }\n    /**\n     * Encrypt the content of the `Uint8Array`.\n     *\n     * It produces an `EncryptedAttachment`, which can be used to\n     * retrieve the media encryption information, or the encrypted\n     * data.\n     * @param {Uint8Array} array\n     * @returns {EncryptedAttachment}\n     */\n    static encrypt(array) {\n        const ptr0 = passArray8ToWasm0(array, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.attachment_encrypt(ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return EncryptedAttachment.__wrap(ret[0]);\n    }\n    /**\n     * Decrypt an `EncryptedAttachment`.\n     *\n     * The encrypted attachment can be created manually, or from the\n     * `encrypt` method.\n     *\n     * **Warning**: The encrypted attachment can be used only\n     * **once**! The encrypted data will still be present, but the\n     * media encryption info (which contain secrets) will be\n     * destroyed. It is still possible to get a JSON-encoded backup\n     * by calling `EncryptedAttachment.mediaEncryptionInfo`.\n     * @param {EncryptedAttachment} attachment\n     * @returns {Uint8Array}\n     */\n    static decrypt(attachment) {\n        _assertClass(attachment, EncryptedAttachment);\n        const ret = wasm.attachment_decrypt(attachment.__wbg_ptr);\n        if (ret[3]) {\n            throw takeFromExternrefTable0(ret[2]);\n        }\n        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        return v1;\n    }\n}\n\nconst BackupDecryptionKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_backupdecryptionkey_free(ptr >>> 0, 1));\n/**\n * The private part of the backup key, the one used for recovery.\n */\nclass BackupDecryptionKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BackupDecryptionKey.prototype);\n        obj.__wbg_ptr = ptr;\n        BackupDecryptionKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BackupDecryptionKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_backupdecryptionkey_free(ptr, 0);\n    }\n    /**\n     * Create a new random [`BackupDecryptionKey`].\n     * @returns {BackupDecryptionKey}\n     */\n    static createRandomKey() {\n        const ret = wasm.backupdecryptionkey_createRandomKey();\n        return BackupDecryptionKey.__wrap(ret);\n    }\n    /**\n     * Try to create a [`BackupDecryptionKey`] from a base 64 encoded string.\n     * @param {string} key\n     * @returns {BackupDecryptionKey}\n     */\n    static fromBase64(key) {\n        const ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.backupdecryptionkey_fromBase64(ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return BackupDecryptionKey.__wrap(ret[0]);\n    }\n    /**\n     * Convert the backup decryption key to a base 64 encoded string.\n     * @returns {string}\n     */\n    toBase64() {\n        const ret = wasm.backupdecryptionkey_toBase64(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the public part of the backup key.\n     * @returns {MegolmV1BackupKey}\n     */\n    get megolmV1PublicKey() {\n        const ret = wasm.backupdecryptionkey_megolmV1PublicKey(this.__wbg_ptr);\n        return MegolmV1BackupKey.__wrap(ret);\n    }\n    /**\n     * Try to decrypt a message that was encrypted using the public part of the\n     * backup key.\n     * @param {string} ephemeral_key\n     * @param {string} mac\n     * @param {string} ciphertext\n     * @returns {string}\n     */\n    decryptV1(ephemeral_key, mac, ciphertext) {\n        let deferred5_0;\n        let deferred5_1;\n        try {\n            const ptr0 = passStringToWasm0(ephemeral_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(mac, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            const ptr2 = passStringToWasm0(ciphertext, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len2 = WASM_VECTOR_LEN;\n            const ret = wasm.backupdecryptionkey_decryptV1(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);\n            var ptr4 = ret[0];\n            var len4 = ret[1];\n            if (ret[3]) {\n                ptr4 = 0; len4 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred5_0 = ptr4;\n            deferred5_1 = len4;\n            return getStringFromWasm0(ptr4, len4);\n        } finally {\n            wasm.__wbindgen_free(deferred5_0, deferred5_1, 1);\n        }\n    }\n}\n\nconst BackupKeysFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_backupkeys_free(ptr >>> 0, 1));\n/**\n * Stored versions of the backup keys.\n */\nclass BackupKeys {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BackupKeys.prototype);\n        obj.__wbg_ptr = ptr;\n        BackupKeysFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BackupKeysFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_backupkeys_free(ptr, 0);\n    }\n    /**\n     * The key used to decrypt backed up room keys\n     * @returns {BackupDecryptionKey | undefined}\n     */\n    get decryptionKey() {\n        const ret = wasm.__wbg_get_backupkeys_decryptionKey(this.__wbg_ptr);\n        return ret === 0 ? undefined : BackupDecryptionKey.__wrap(ret);\n    }\n    /**\n     * The key used to decrypt backed up room keys\n     * @param {BackupDecryptionKey | undefined} [arg0]\n     */\n    set decryptionKey(arg0) {\n        let ptr0 = 0;\n        if (!isLikeNone(arg0)) {\n            _assertClass(arg0, BackupDecryptionKey);\n            ptr0 = arg0.__destroy_into_raw();\n        }\n        wasm.__wbg_set_backupkeys_decryptionKey(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * The version that we are using for backups.\n     * @returns {string | undefined}\n     */\n    get backupVersion() {\n        const ret = wasm.__wbg_get_backupkeys_backupVersion(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * The version that we are using for backups.\n     * @param {string | undefined} [arg0]\n     */\n    set backupVersion(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_backupkeys_backupVersion(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The key used to decrypt backed up room keys, encoded as base64\n     *\n     * @deprecated Use `BackupKeys.decryptionKey.toBase64()`\n     * @returns {string | undefined}\n     */\n    get decryptionKeyBase64() {\n        const ret = wasm.backupkeys_decryptionKeyBase64(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst BackupSecretsBundleFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_backupsecretsbundle_free(ptr >>> 0, 1));\n/**\n * The backup-specific parts of a secrets bundle.\n */\nclass BackupSecretsBundle {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BackupSecretsBundle.prototype);\n        obj.__wbg_ptr = ptr;\n        BackupSecretsBundleFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BackupSecretsBundleFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_backupsecretsbundle_free(ptr, 0);\n    }\n    /**\n     * The backup decryption key, encoded as unpadded base64.\n     * @returns {string}\n     */\n    get key() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.__wbg_get_backupsecretsbundle_key(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The backup decryption key, encoded as unpadded base64.\n     * @param {string} arg0\n     */\n    set key(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_backupsecretsbundle_key(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The backup version which this backup decryption key is used with.\n     * @returns {string}\n     */\n    get backup_version() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.__wbg_get_backupsecretsbundle_backup_version(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The backup version which this backup decryption key is used with.\n     * @param {string} arg0\n     */\n    set backup_version(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_backupsecretsbundle_backup_version(this.__wbg_ptr, ptr0, len0);\n    }\n}\n\nconst BaseMigrationDataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_basemigrationdata_free(ptr >>> 0, 1));\n/**\n * The base dataset that is important to migrate to the Rust SDK.\n *\n * Can be imported into the rust store with {@link #migrateBaseData}.\n */\nclass BaseMigrationData {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BaseMigrationDataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_basemigrationdata_free(ptr, 0);\n    }\n    /**\n     * The user id of the account owner.\n     * @returns {UserId | undefined}\n     */\n    get userId() {\n        const ret = wasm.__wbg_get_basemigrationdata_userId(this.__wbg_ptr);\n        return ret === 0 ? undefined : UserId.__wrap(ret);\n    }\n    /**\n     * The user id of the account owner.\n     * @param {UserId | undefined} [arg0]\n     */\n    set userId(arg0) {\n        let ptr0 = 0;\n        if (!isLikeNone(arg0)) {\n            _assertClass(arg0, UserId);\n            ptr0 = arg0.__destroy_into_raw();\n        }\n        wasm.__wbg_set_basemigrationdata_userId(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * The device ID of the account owner.\n     * @returns {DeviceId | undefined}\n     */\n    get deviceId() {\n        const ret = wasm.__wbg_get_basemigrationdata_deviceId(this.__wbg_ptr);\n        return ret === 0 ? undefined : DeviceId.__wrap(ret);\n    }\n    /**\n     * The device ID of the account owner.\n     * @param {DeviceId | undefined} [arg0]\n     */\n    set deviceId(arg0) {\n        let ptr0 = 0;\n        if (!isLikeNone(arg0)) {\n            _assertClass(arg0, DeviceId);\n            ptr0 = arg0.__destroy_into_raw();\n        }\n        wasm.__wbg_set_basemigrationdata_deviceId(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * The pickle string holding the Olm Account, as returned by\n     * `olm_pickle_account` in libolm.\n     * @returns {string}\n     */\n    get pickledAccount() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.__wbg_get_basemigrationdata_pickledAccount(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The pickle string holding the Olm Account, as returned by\n     * `olm_pickle_account` in libolm.\n     * @param {string} arg0\n     */\n    set pickledAccount(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_backupsecretsbundle_key(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The backup version that is currently active.\n     * @returns {string | undefined}\n     */\n    get backupVersion() {\n        const ret = wasm.__wbg_get_basemigrationdata_backupVersion(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * The backup version that is currently active.\n     * @param {string | undefined} [arg0]\n     */\n    set backupVersion(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_basemigrationdata_backupVersion(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The backup recovery key, as a base64-encoded string.\n     * @returns {string | undefined}\n     */\n    get backupRecoveryKey() {\n        const ret = wasm.__wbg_get_basemigrationdata_backupRecoveryKey(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * The backup recovery key, as a base64-encoded string.\n     * @param {string | undefined} [arg0]\n     */\n    set backupRecoveryKey(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_basemigrationdata_backupRecoveryKey(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The private, base64-encoded, master cross-signing key.\n     * @returns {string | undefined}\n     */\n    get privateCrossSigningMasterKey() {\n        const ret = wasm.__wbg_get_basemigrationdata_privateCrossSigningMasterKey(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * The private, base64-encoded, master cross-signing key.\n     * @param {string | undefined} [arg0]\n     */\n    set privateCrossSigningMasterKey(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_basemigrationdata_privateCrossSigningMasterKey(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The private, base64-encoded, self-signing key.\n     * @returns {string | undefined}\n     */\n    get privateCrossSigningSelfSigningKey() {\n        const ret = wasm.__wbg_get_basemigrationdata_privateCrossSigningSelfSigningKey(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * The private, base64-encoded, self-signing key.\n     * @param {string | undefined} [arg0]\n     */\n    set privateCrossSigningSelfSigningKey(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_basemigrationdata_privateCrossSigningSelfSigningKey(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The private, base64-encoded, user-signing key.\n     * @returns {string | undefined}\n     */\n    get privateCrossSigningUserSigningKey() {\n        const ret = wasm.__wbg_get_basemigrationdata_privateCrossSigningUserSigningKey(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * The private, base64-encoded, user-signing key.\n     * @param {string | undefined} [arg0]\n     */\n    set privateCrossSigningUserSigningKey(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_basemigrationdata_privateCrossSigningUserSigningKey(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Create a new `BaseMigrationData` with default values.\n     */\n    constructor() {\n        const ret = wasm.basemigrationdata_new();\n        this.__wbg_ptr = ret >>> 0;\n        BaseMigrationDataFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\n\nconst CancelInfoFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_cancelinfo_free(ptr >>> 0, 1));\n/**\n * Information about the cancellation of a verification request or\n * verification flow.\n */\nclass CancelInfo {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(CancelInfo.prototype);\n        obj.__wbg_ptr = ptr;\n        CancelInfoFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        CancelInfoFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cancelinfo_free(ptr, 0);\n    }\n    /**\n     * Get the human readable reason of the cancellation.\n     * @returns {string}\n     */\n    reason() {\n        const ret = wasm.cancelinfo_reason(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the `code` (e.g. `m.user`) that was used to cancel the\n     * verification.\n     * @returns {string}\n     */\n    cancelCode() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.cancelinfo_cancelCode(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Was the verification cancelled by us?\n     * @returns {boolean}\n     */\n    cancelledbyUs() {\n        const ret = wasm.cancelinfo_cancelledbyUs(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst CheckCodeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_checkcode_free(ptr >>> 0, 1));\n/**\n * A check code that can be used to confirm that two [`EstablishedEcies`]\n * objects share the same secret. This is supposed to be shared out-of-band to\n * protect against active Man-in-the-middle (MITM) attacks.\n *\n * Since the initiator device can always tell whether a MITM attack is in\n * progress after channel establishment, this code technically carries only a\n * single bit of information, representing whether the initiator has determined\n * that the channel is \"secure\" or \"not secure\".\n *\n * However, given this will need to be interactively confirmed by the user,\n * there is risk that the user would confirm the dialogue without paying\n * attention to its content. By expanding this single bit into a deterministic\n * two-digit check code, the user is forced to pay more attention by having to\n * enter it instead of just clicking through a dialogue.\n */\nclass CheckCode {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(CheckCode.prototype);\n        obj.__wbg_ptr = ptr;\n        CheckCodeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        CheckCodeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_checkcode_free(ptr, 0);\n    }\n    /**\n     * Convert the check code to an array of two bytes.\n     *\n     * The bytes can be converted to a more user-friendly representation. The\n     * [`CheckCode::to_digit`] converts the bytes to a two-digit number.\n     * @returns {Uint8Array}\n     */\n    as_bytes() {\n        const ret = wasm.checkcode_as_bytes(this.__wbg_ptr);\n        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        return v1;\n    }\n    /**\n     * Convert the check code to two base-10 numbers.\n     *\n     * The number should be displayed with a leading 0 in case the first digit\n     * is a 0.\n     * @returns {number}\n     */\n    to_digit() {\n        const ret = wasm.checkcode_to_digit(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst CollectStrategyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_collectstrategy_free(ptr >>> 0, 1));\n/**\n * Strategy to collect the devices that should receive room keys for the\n * current discussion.\n */\nclass CollectStrategy {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(CollectStrategy.prototype);\n        obj.__wbg_ptr = ptr;\n        CollectStrategyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        CollectStrategyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_collectstrategy_free(ptr, 0);\n    }\n    /**\n     * Tests for equality between two [`CollectStrategy`]s.\n     * @param {CollectStrategy} other\n     * @returns {boolean}\n     */\n    eq(other) {\n        _assertClass(other, CollectStrategy);\n        const ret = wasm.collectstrategy_eq(this.__wbg_ptr, other.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Device based sharing strategy.\n     *\n     * If `only_allow_trusted_devices` is `true`, devices that are not trusted\n     * will be excluded from the conversation. A device is trusted if any of\n     * the following is true:\n     *     - It was manually marked as trusted.\n     *     - It was marked as verified via interactive verification.\n     *     - It is signed by its owner identity, and this identity has been\n     *       trusted via interactive verification.\n     *     - It is the current own device of the user.\n     *\n     * If `error_on_verified_user` is `true`, and a verified user has an\n     * unsigned device, key sharing will fail with an error.\n     *\n     * If `error_on_verified_user` is `true`, and a verified user has replaced\n     * their identity, key sharing will fail with an error.\n     *\n     * Otherwise, keys are shared with unsigned devices as normal.\n     *\n     * Once the problematic devices are blacklisted or whitelisted the\n     * caller can retry to share a second time.\n     * @param {boolean} only_allow_trusted_devices\n     * @param {boolean} error_on_verified_user_problem\n     * @returns {CollectStrategy}\n     */\n    static deviceBasedStrategy(only_allow_trusted_devices, error_on_verified_user_problem) {\n        const ret = wasm.collectstrategy_deviceBasedStrategy(only_allow_trusted_devices, error_on_verified_user_problem);\n        return CollectStrategy.__wrap(ret);\n    }\n    /**\n     * Share based on identity. Only distribute to devices signed by their\n     * owner. If a user has no published identity he will not receive\n     * any room keys.\n     * @returns {CollectStrategy}\n     */\n    static identityBasedStrategy() {\n        const ret = wasm.collectstrategy_identityBasedStrategy();\n        return CollectStrategy.__wrap(ret);\n    }\n}\n\nconst CrossSigningBootstrapRequestsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_crosssigningbootstraprequests_free(ptr >>> 0, 1));\n/**\n * A set of requests to be executed when bootstrapping cross-signing using\n * {@link OlmMachine.bootstrapCrossSigning}.\n */\nclass CrossSigningBootstrapRequests {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(CrossSigningBootstrapRequests.prototype);\n        obj.__wbg_ptr = ptr;\n        CrossSigningBootstrapRequestsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        CrossSigningBootstrapRequestsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_crosssigningbootstraprequests_free(ptr, 0);\n    }\n    /**\n     * An optional request to upload a device key.\n     *\n     * This will either be `undefined`, or an \"outgoing request\" as returned by\n     * {@link OlmMachine.outgoingRequests}.\n     *\n     * If it is defined, the request should be sent first, and the result sent\n     * back with {@link OlmMachine.markRequestAsSent}.\n     * @returns {any}\n     */\n    get uploadKeysRequest() {\n        const ret = wasm.__wbg_get_crosssigningbootstraprequests_uploadKeysRequest(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Request to upload the cross-signing keys.\n     *\n     * Should be sent second.\n     * @returns {UploadSigningKeysRequest}\n     */\n    get uploadSigningKeysRequest() {\n        const ret = wasm.__wbg_get_crosssigningbootstraprequests_uploadSigningKeysRequest(this.__wbg_ptr);\n        return UploadSigningKeysRequest.__wrap(ret);\n    }\n    /**\n     * Request to upload key signatures, including those for the cross-signing\n     * keys, and maybe some for the optional uploaded key too.\n     *\n     * Should be sent last.\n     * @returns {SignatureUploadRequest}\n     */\n    get uploadSignaturesRequest() {\n        const ret = wasm.__wbg_get_crosssigningbootstraprequests_uploadSignaturesRequest(this.__wbg_ptr);\n        return SignatureUploadRequest.__wrap(ret);\n    }\n}\n\nconst CrossSigningKeyExportFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_crosssigningkeyexport_free(ptr >>> 0, 1));\n/**\n * A struct containing private cross signing keys that can be backed\n * up or uploaded to the secret store.\n */\nclass CrossSigningKeyExport {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(CrossSigningKeyExport.prototype);\n        obj.__wbg_ptr = ptr;\n        CrossSigningKeyExportFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        CrossSigningKeyExportFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_crosssigningkeyexport_free(ptr, 0);\n    }\n    /**\n     * The seed of the master key encoded as unpadded base64.\n     * @returns {string | undefined}\n     */\n    get masterKey() {\n        const ret = wasm.crosssigningkeyexport_masterKey(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * The seed of the self signing key encoded as unpadded base64.\n     * @returns {string | undefined}\n     */\n    get self_signing_key() {\n        const ret = wasm.crosssigningkeyexport_self_signing_key(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * The seed of the user signing key encoded as unpadded base64.\n     * @returns {string | undefined}\n     */\n    get userSigningKey() {\n        const ret = wasm.crosssigningkeyexport_userSigningKey(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n}\n\nconst CrossSigningStatusFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_crosssigningstatus_free(ptr >>> 0, 1));\n/**\n * Struct representing the state of our private cross signing keys,\n * it shows which private cross signing keys we have locally stored.\n */\nclass CrossSigningStatus {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(CrossSigningStatus.prototype);\n        obj.__wbg_ptr = ptr;\n        CrossSigningStatusFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        CrossSigningStatusFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_crosssigningstatus_free(ptr, 0);\n    }\n    /**\n     * Do we have the master key?\n     * @returns {boolean}\n     */\n    get hasMaster() {\n        const ret = wasm.crosssigningstatus_hasMaster(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Do we have the self signing key? This one is necessary to sign\n     * our own devices.\n     * @returns {boolean}\n     */\n    get hasSelfSigning() {\n        const ret = wasm.crosssigningstatus_hasSelfSigning(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Do we have the user signing key? This one is necessary to sign\n     * other users.\n     * @returns {boolean}\n     */\n    get hasUserSigning() {\n        const ret = wasm.crosssigningstatus_hasUserSigning(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst Curve25519PublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_curve25519publickey_free(ptr >>> 0, 1));\n/**\n * A Curve25519 public key.\n */\nclass Curve25519PublicKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Curve25519PublicKey.prototype);\n        obj.__wbg_ptr = ptr;\n        Curve25519PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Curve25519PublicKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_curve25519publickey_free(ptr, 0);\n    }\n    /**\n     * Create a new [`Curve25519PublicKey`] from a base64 encoded string.\n     * @param {string} key\n     */\n    constructor(key) {\n        const ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.curve25519publickey_new(ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        Curve25519PublicKeyFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * The number of bytes a Curve25519 public key has.\n     * @returns {number}\n     */\n    get length() {\n        const ret = wasm.curve25519publickey_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Serialize an Curve25519 public key to an unpadded base64\n     * representation.\n     * @returns {string}\n     */\n    toBase64() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.curve25519publickey_toBase64(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst DecryptedRoomEventFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_decryptedroomevent_free(ptr >>> 0, 1));\n/**\n * A decrypted room event.\n */\nclass DecryptedRoomEvent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DecryptedRoomEvent.prototype);\n        obj.__wbg_ptr = ptr;\n        DecryptedRoomEventFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        DecryptedRoomEventFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_decryptedroomevent_free(ptr, 0);\n    }\n    /**\n     * The JSON-encoded decrypted event.\n     * @returns {string}\n     */\n    get event() {\n        const ret = wasm.__wbg_get_decryptedroomevent_event(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The user ID of the event sender, note this is untrusted data\n     * unless the `verification_state` is as well trusted.\n     * @returns {UserId | undefined}\n     */\n    get sender() {\n        const ret = wasm.decryptedroomevent_sender(this.__wbg_ptr);\n        return ret === 0 ? undefined : UserId.__wrap(ret);\n    }\n    /**\n     * The device ID of the device that sent us the event, note this\n     * is untrusted data unless `verification_state` is as well\n     * trusted.\n     * @returns {DeviceId | undefined}\n     */\n    get senderDevice() {\n        const ret = wasm.decryptedroomevent_senderDevice(this.__wbg_ptr);\n        return ret === 0 ? undefined : DeviceId.__wrap(ret);\n    }\n    /**\n     * The Curve25519 key of the device that created the megolm\n     * decryption key originally.\n     * @returns {string | undefined}\n     */\n    get senderCurve25519Key() {\n        const ret = wasm.decryptedroomevent_senderCurve25519Key(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The signing Ed25519 key that have created the megolm key that\n     * was used to decrypt this session.\n     * @returns {string | undefined}\n     */\n    get senderClaimedEd25519Key() {\n        const ret = wasm.decryptedroomevent_senderClaimedEd25519Key(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Returns an empty array\n     *\n     * Previously, this returned the chain of Curve25519 keys through which\n     * this session was forwarded, via `m.forwarded_room_key` events.\n     * However, that is not cryptographically reliable, and clients should not\n     * be using it.\n     *\n     * @see https://github.com/matrix-org/matrix-spec/issues/1089\n     * @returns {Array<any>}\n     */\n    get forwardingCurve25519KeyChain() {\n        const ret = wasm.decryptedroomevent_forwardingCurve25519KeyChain(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The verification state of the device that sent us the event.\n     * Note this is the state of the device at the time of\n     * decryption. It may change in the future if a device gets\n     * verified or deleted.\n     * @param {boolean} strict\n     * @returns {ShieldState | undefined}\n     */\n    shieldState(strict) {\n        const ret = wasm.decryptedroomevent_shieldState(this.__wbg_ptr, strict);\n        return ret === 0 ? undefined : ShieldState.__wrap(ret);\n    }\n}\n\nconst DecryptionSettingsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_decryptionsettings_free(ptr >>> 0, 1));\n/**\n * Settings for decrypting messages\n */\nclass DecryptionSettings {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        DecryptionSettingsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_decryptionsettings_free(ptr, 0);\n    }\n    /**\n     * The trust level required to decrypt the event\n     * @returns {TrustRequirement}\n     */\n    get sender_device_trust_requirement() {\n        const ret = wasm.__wbg_get_decryptionsettings_sender_device_trust_requirement(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The trust level required to decrypt the event\n     * @param {TrustRequirement} arg0\n     */\n    set sender_device_trust_requirement(arg0) {\n        wasm.__wbg_set_decryptionsettings_sender_device_trust_requirement(this.__wbg_ptr, arg0);\n    }\n    /**\n     * Create a new `DecryptionSettings` with the given trust requirement.\n     * @param {TrustRequirement} sender_device_trust_requirement\n     */\n    constructor(sender_device_trust_requirement) {\n        const ret = wasm.decryptionsettings_new(sender_device_trust_requirement);\n        this.__wbg_ptr = ret >>> 0;\n        DecryptionSettingsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\n\nconst DehydratedDeviceFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_dehydrateddevice_free(ptr >>> 0, 1));\n/**\n * A dehydrated device that can be uploaded to the server\n */\nclass DehydratedDevice {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DehydratedDevice.prototype);\n        obj.__wbg_ptr = ptr;\n        DehydratedDeviceFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        DehydratedDeviceFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_dehydrateddevice_free(ptr, 0);\n    }\n    /**\n     * Create the request to upload the dehydrated device\n     * @param {string} initial_device_display_name\n     * @param {DehydratedDeviceKey} dehydrated_device_key\n     * @returns {Promise<PutDehydratedDeviceRequest>}\n     */\n    keysForUpload(initial_device_display_name, dehydrated_device_key) {\n        _assertClass(dehydrated_device_key, DehydratedDeviceKey);\n        const ret = wasm.dehydrateddevice_keysForUpload(this.__wbg_ptr, initial_device_display_name, dehydrated_device_key.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst DehydratedDeviceKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_dehydrateddevicekey_free(ptr >>> 0, 1));\n/**\n * Dehydrated device key\n */\nclass DehydratedDeviceKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DehydratedDeviceKey.prototype);\n        obj.__wbg_ptr = ptr;\n        DehydratedDeviceKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        DehydratedDeviceKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_dehydrateddevicekey_free(ptr, 0);\n    }\n    /**\n     * Generates a new random dehydrated device key.\n     * @returns {DehydratedDeviceKey}\n     */\n    static createRandomKey() {\n        const ret = wasm.dehydrateddevicekey_createRandomKey();\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return DehydratedDeviceKey.__wrap(ret[0]);\n    }\n    /**\n     * Generates a dehydrated device key from a given array.\n     * @param {Uint8Array} array\n     * @returns {DehydratedDeviceKey}\n     */\n    static createKeyFromArray(array) {\n        const ret = wasm.dehydrateddevicekey_createKeyFromArray(array);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return DehydratedDeviceKey.__wrap(ret[0]);\n    }\n    /**\n     * Convert the dehydrated device key to a base64-encoded string.\n     * @returns {string}\n     */\n    toBase64() {\n        const ret = wasm.dehydrateddevicekey_toBase64(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst DehydratedDevicesFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_dehydrateddevices_free(ptr >>> 0, 1));\n/**\n * Struct collecting methods to create and rehydrate dehydrated devices.\n */\nclass DehydratedDevices {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DehydratedDevices.prototype);\n        obj.__wbg_ptr = ptr;\n        DehydratedDevicesFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        DehydratedDevicesFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_dehydrateddevices_free(ptr, 0);\n    }\n    /**\n     * Create a new {@link DehydratedDevice} which can be uploaded to the\n     * server.\n     * @returns {Promise<DehydratedDevice>}\n     */\n    create() {\n        const ret = wasm.dehydrateddevices_create(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Rehydrate a dehydrated device.\n     * @param {DehydratedDeviceKey} dehydrated_device_key\n     * @param {DeviceId} device_id\n     * @param {string} device_data\n     * @returns {Promise<RehydratedDevice>}\n     */\n    rehydrate(dehydrated_device_key, device_id, device_data) {\n        _assertClass(dehydrated_device_key, DehydratedDeviceKey);\n        _assertClass(device_id, DeviceId);\n        const ptr0 = passStringToWasm0(device_data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.dehydrateddevices_rehydrate(this.__wbg_ptr, dehydrated_device_key.__wbg_ptr, device_id.__wbg_ptr, ptr0, len0);\n        return ret;\n    }\n    /**\n     * Get the cached dehydrated device key if any.\n     *\n     * `None` if the key was not previously cached (via\n     * {@link DehydratedDevices.saveDehydratedDeviceKey}).\n     * @returns {Promise<DehydratedDeviceKey | undefined>}\n     */\n    getDehydratedDeviceKey() {\n        const ret = wasm.dehydrateddevices_getDehydratedDeviceKey(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Store the dehydrated device key in the crypto store.\n     * @param {DehydratedDeviceKey} dehydrated_device_key\n     * @returns {Promise<void>}\n     */\n    saveDehydratedDeviceKey(dehydrated_device_key) {\n        _assertClass(dehydrated_device_key, DehydratedDeviceKey);\n        const ret = wasm.dehydrateddevices_saveDehydratedDeviceKey(this.__wbg_ptr, dehydrated_device_key.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Clear the dehydrated device key saved in the crypto store.\n     * @returns {Promise<void>}\n     */\n    deleteDehydratedDeviceKey() {\n        const ret = wasm.dehydrateddevices_deleteDehydratedDeviceKey(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst DeviceFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_device_free(ptr >>> 0, 1));\n/**\n * A device represents a E2EE capable client of an user.\n */\nclass Device {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Device.prototype);\n        obj.__wbg_ptr = ptr;\n        DeviceFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        DeviceFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_device_free(ptr, 0);\n    }\n    /**\n     * Request an interactive verification with this device.\n     *\n     * Returns a 2-element array `[VerificationRequest, ToDeviceRequest]`.\n     * @param {any[] | undefined} [methods]\n     * @returns {Array<any>}\n     */\n    requestVerification(methods) {\n        var ptr0 = isLikeNone(methods) ? 0 : passArrayJsValueToWasm0(methods, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.device_requestVerification(this.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Encrypt a to-device message to be sent to this device, using Olm\n     * encryption.\n     *\n     * Prior to calling this method you must ensure that an Olm session is\n     * available for the target device. This can be done by calling\n     * {@link OlmMachine.getMissingSessions}.\n     *\n     * The caller is responsible for sending the encrypted\n     * event to the target device. If multiple messages are\n     * encrypted for the same device using this method they should be sent in\n     * the same order as they are encrypted.\n     *\n     * # Returns\n     *\n     * Returns a promise for a JSON string containing the `content` of an\n     * encrypted event, which be used to create the payload for a\n     * `/sendToDevice` API.\n     * @param {string} event_type\n     * @param {any} content\n     * @returns {Promise<string>}\n     */\n    encryptToDeviceEvent(event_type, content) {\n        const ptr0 = passStringToWasm0(event_type, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.device_encryptToDeviceEvent(this.__wbg_ptr, ptr0, len0, content);\n        return ret;\n    }\n    /**\n     * Is this device considered to be verified.\n     *\n     * This method returns true if either the `is_locally_trusted`\n     * method returns `true` or if the `is_cross_signing_trusted`\n     * method returns `true`.\n     * @returns {boolean}\n     */\n    isVerified() {\n        const ret = wasm.device_isVerified(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Is this device considered to be verified using cross signing.\n     * @returns {boolean}\n     */\n    isCrossSigningTrusted() {\n        const ret = wasm.device_isCrossSigningTrusted(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Is this device cross-signed by its owner?\n     * @returns {boolean}\n     */\n    isCrossSignedByOwner() {\n        const ret = wasm.device_isCrossSignedByOwner(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Set the local trust state of the device to the given state.\n     *\n     * This wont affect any cross signing trust state, this only\n     * sets a flag marking to have the given trust state.\n     *\n     * `trust_state` represents the new trust state that should be\n     * set for the device.\n     * @param {LocalTrust} local_state\n     * @returns {Promise<any>}\n     */\n    setLocalTrust(local_state) {\n        const ret = wasm.device_setLocalTrust(this.__wbg_ptr, local_state);\n        return ret;\n    }\n    /**\n     * The user ID of the device owner.\n     * @returns {UserId}\n     */\n    get userId() {\n        const ret = wasm.device_userId(this.__wbg_ptr);\n        return UserId.__wrap(ret);\n    }\n    /**\n     * The unique ID of the device.\n     * @returns {DeviceId}\n     */\n    get deviceId() {\n        const ret = wasm.device_deviceId(this.__wbg_ptr);\n        return DeviceId.__wrap(ret);\n    }\n    /**\n     * Get the human readable name of the device.\n     * @returns {string | undefined}\n     */\n    get displayName() {\n        const ret = wasm.device_displayName(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * Get the key of the given key algorithm belonging to this device.\n     * @param {DeviceKeyAlgorithmName} algorithm\n     * @returns {DeviceKey | undefined}\n     */\n    getKey(algorithm) {\n        const ret = wasm.device_getKey(this.__wbg_ptr, algorithm);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return ret[0] === 0 ? undefined : DeviceKey.__wrap(ret[0]);\n    }\n    /**\n     * Get the Curve25519 key of the given device.\n     * @returns {Curve25519PublicKey | undefined}\n     */\n    get curve25519Key() {\n        const ret = wasm.device_curve25519Key(this.__wbg_ptr);\n        return ret === 0 ? undefined : Curve25519PublicKey.__wrap(ret);\n    }\n    /**\n     * Get the Ed25519 key of the given device.\n     * @returns {Ed25519PublicKey | undefined}\n     */\n    get ed25519Key() {\n        const ret = wasm.device_ed25519Key(this.__wbg_ptr);\n        return ret === 0 ? undefined : Ed25519PublicKey.__wrap(ret);\n    }\n    /**\n     * Get a map containing all the device keys.\n     * @returns {Map<any, any>}\n     */\n    get keys() {\n        const ret = wasm.device_keys(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the list of algorithms this device supports.\n     *\n     * Returns `Array<EncryptionAlgorithm>`.\n     * @returns {Array<any>}\n     */\n    get algorithms() {\n        const ret = wasm.device_algorithms(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get a map containing all the device signatures.\n     * @returns {Signatures}\n     */\n    get signatures() {\n        const ret = wasm.device_signatures(this.__wbg_ptr);\n        return Signatures.__wrap(ret);\n    }\n    /**\n     * Get the trust state of the device.\n     * @returns {LocalTrust}\n     */\n    get localTrustState() {\n        const ret = wasm.device_localTrustState(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Is the device locally marked as trusted?\n     * @returns {boolean}\n     */\n    isLocallyTrusted() {\n        const ret = wasm.device_isLocallyTrusted(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Is the device locally marked as blacklisted?\n     *\n     * Blacklisted devices wont receive any group sessions.\n     * @returns {boolean}\n     */\n    isBlacklisted() {\n        const ret = wasm.device_isBlacklisted(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Is the device deleted?\n     * @returns {boolean}\n     */\n    isDeleted() {\n        const ret = wasm.device_isDeleted(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Timestamp representing the first time this device has been seen (in\n     * milliseconds).\n     * @returns {bigint}\n     */\n    firstTimeSeen() {\n        const ret = wasm.device_firstTimeSeen(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * Mark this device as verified.\n     * Works only if the device is owned by the current user.\n     *\n     * Returns a signature upload request that needs to be sent out.\n     * @returns {Promise<any>}\n     */\n    verify() {\n        const ret = wasm.device_verify(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Whether or not the device is a dehydrated device.\n     * @returns {boolean}\n     */\n    get isDehydrated() {\n        const ret = wasm.device_isDehydrated(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst DeviceIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_deviceid_free(ptr >>> 0, 1));\n/**\n * A Matrix key ID.\n *\n * Device identifiers in Matrix are completely opaque character\n * sequences. This type is provided simply for its semantic value.\n */\nclass DeviceId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DeviceId.prototype);\n        obj.__wbg_ptr = ptr;\n        DeviceIdFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        DeviceIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_deviceid_free(ptr, 0);\n    }\n    /**\n     * Create a new `DeviceId`.\n     * @param {string} id\n     */\n    constructor(id) {\n        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.deviceid_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        DeviceIdFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Return the device ID as a string.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.deviceid_toString(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst DeviceKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_devicekey_free(ptr >>> 0, 1));\n/**\n * An enum over the different key types a device can have.\n *\n * Currently devices have a curve25519 and ed25519 keypair. The keys\n * transport format is a base64 encoded string, any unknown key type\n * will be left as such a string.\n */\nclass DeviceKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DeviceKey.prototype);\n        obj.__wbg_ptr = ptr;\n        DeviceKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        DeviceKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_devicekey_free(ptr, 0);\n    }\n    /**\n     * Get the name of the device key.\n     * @returns {DeviceKeyName}\n     */\n    get name() {\n        const ret = wasm.devicekey_name(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the value associated to the `Curve25519` device key name.\n     * @returns {Curve25519PublicKey | undefined}\n     */\n    get curve25519() {\n        const ret = wasm.devicekey_curve25519(this.__wbg_ptr);\n        return ret === 0 ? undefined : Curve25519PublicKey.__wrap(ret);\n    }\n    /**\n     * Get the value associated to the `Ed25519` device key name.\n     * @returns {Ed25519PublicKey | undefined}\n     */\n    get ed25519() {\n        const ret = wasm.devicekey_ed25519(this.__wbg_ptr);\n        return ret === 0 ? undefined : Ed25519PublicKey.__wrap(ret);\n    }\n    /**\n     * Get the value associated to the `Unknown` device key name.\n     * @returns {string | undefined}\n     */\n    get unknown() {\n        const ret = wasm.devicekey_unknown(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * Convert the `DeviceKey` into a base64 encoded string.\n     * @returns {string}\n     */\n    toBase64() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.devicekey_toBase64(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst DeviceKeyAlgorithmFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_devicekeyalgorithm_free(ptr >>> 0, 1));\n/**\n * The basic key algorithms in the specification.\n */\nclass DeviceKeyAlgorithm {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DeviceKeyAlgorithm.prototype);\n        obj.__wbg_ptr = ptr;\n        DeviceKeyAlgorithmFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        DeviceKeyAlgorithmFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_devicekeyalgorithm_free(ptr, 0);\n    }\n    /**\n     * Read the device key algorithm's name. If the name is\n     * `Unknown`, one may be interested by the `to_string` method to\n     * read the original name.\n     * @returns {DeviceKeyAlgorithmName}\n     */\n    get name() {\n        const ret = wasm.devicekeyalgorithm_name(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Return the device key algorithm as a string.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.devicekeyalgorithm_toString(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst DeviceKeyIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_devicekeyid_free(ptr >>> 0, 1));\n/**\n * A Matrix device key ID.\n *\n * A key algorithm and a device ID, combined with a :.\n */\nclass DeviceKeyId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(DeviceKeyId.prototype);\n        obj.__wbg_ptr = ptr;\n        DeviceKeyIdFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        DeviceKeyIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_devicekeyid_free(ptr, 0);\n    }\n    /**\n     * Parse/validate and create a new `DeviceKeyId`.\n     * @param {string} id\n     */\n    constructor(id) {\n        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.devicekeyid_new(ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        DeviceKeyIdFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Returns key algorithm of the device key ID.\n     * @returns {DeviceKeyAlgorithm}\n     */\n    get algorithm() {\n        const ret = wasm.devicekeyid_algorithm(this.__wbg_ptr);\n        return DeviceKeyAlgorithm.__wrap(ret);\n    }\n    /**\n     * Returns device ID of the device key ID.\n     * @returns {DeviceId}\n     */\n    get deviceId() {\n        const ret = wasm.devicekeyid_deviceId(this.__wbg_ptr);\n        return DeviceId.__wrap(ret);\n    }\n    /**\n     * Return the device key ID as a string.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.devicekeyid_toString(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst DeviceListsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_devicelists_free(ptr >>> 0, 1));\n/**\n * Information on E2E device updates.\n */\nclass DeviceLists {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        DeviceListsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_devicelists_free(ptr, 0);\n    }\n    /**\n     * Create an empty `DeviceLists`.\n     *\n     * `changed` and `left` must be an array of `UserId`.\n     *\n     * Items inside `changed` and `left` will be invalidated by this method. Be\n     * careful not to use the `UserId`s after this method has been called.\n     * @param {(UserId)[] | undefined} [changed]\n     * @param {(UserId)[] | undefined} [left]\n     */\n    constructor(changed, left) {\n        var ptr0 = isLikeNone(changed) ? 0 : passArrayJsValueToWasm0(changed, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(left) ? 0 : passArrayJsValueToWasm0(left, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        const ret = wasm.devicelists_new(ptr0, len0, ptr1, len1);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        DeviceListsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Returns true if there are no device list updates.\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.devicelists_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * List of users who have updated their device identity keys or\n     * who now share an encrypted room with the client since the\n     * previous sync\n     * @returns {(UserId)[]}\n     */\n    get changed() {\n        const ret = wasm.devicelists_changed(this.__wbg_ptr);\n        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n        return v1;\n    }\n    /**\n     * List of users who no longer share encrypted rooms since the\n     * previous sync response.\n     * @returns {(UserId)[]}\n     */\n    get left() {\n        const ret = wasm.devicelists_left(this.__wbg_ptr);\n        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n        return v1;\n    }\n}\n\nconst EciesFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_ecies_free(ptr >>> 0, 1));\n/**\n * An unestablished ECIES session.\n */\nclass Ecies {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        EciesFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ecies_free(ptr, 0);\n    }\n    /**\n     * Create a new, random, unestablished ECIES session.\n     *\n     * This method will use the\n     * [`MATRIX_QR_CODE_LOGIN`](https://github.com/matrix-org/matrix-spec-proposals/pull/4108)\n     * info for domain separation when creating the session.\n     */\n    constructor() {\n        const ret = wasm.ecies_new();\n        this.__wbg_ptr = ret >>> 0;\n        EciesFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get our [`Curve25519PublicKey`].\n     *\n     * This public key needs to be sent to the other side to be able to\n     * establish an ECIES channel.\n     * @returns {Curve25519PublicKey}\n     */\n    public_key() {\n        const ret = wasm.ecies_public_key(this.__wbg_ptr);\n        return Curve25519PublicKey.__wrap(ret);\n    }\n    /**\n     * Create a [`EstablishedEcies`] from an initial message encrypted by the\n     * other side.\n     * @param {string} initial_message\n     * @returns {InboundCreationResult}\n     */\n    establish_inbound_channel(initial_message) {\n        const ptr0 = passStringToWasm0(initial_message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.ecies_establish_inbound_channel(this.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return InboundCreationResult.__wrap(ret[0]);\n    }\n    /**\n     * Create an [`EstablishedEcies`] session using the other side's Curve25519\n     * public key and an initial plaintext.\n     *\n     * After the channel has been established, we can encrypt messages to send\n     * to the other side. The other side uses the initial message to\n     * establishes the same channel on its side.\n     * @param {Curve25519PublicKey} public_key\n     * @param {string} initial_message\n     * @returns {OutboundCreationResult}\n     */\n    establish_outbound_channel(public_key, initial_message) {\n        _assertClass(public_key, Curve25519PublicKey);\n        const ptr0 = passStringToWasm0(initial_message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.ecies_establish_outbound_channel(this.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return OutboundCreationResult.__wrap(ret[0]);\n    }\n}\n\nconst Ed25519PublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_ed25519publickey_free(ptr >>> 0, 1));\n/**\n * An Ed25519 public key, used to verify digital signatures.\n */\nclass Ed25519PublicKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Ed25519PublicKey.prototype);\n        obj.__wbg_ptr = ptr;\n        Ed25519PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Ed25519PublicKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519publickey_free(ptr, 0);\n    }\n    /**\n     * The number of bytes an Ed25519 public key has.\n     * @returns {number}\n     */\n    get length() {\n        const ret = wasm.ed25519publickey_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Serialize an Ed25519 public key to an unpadded base64\n     * representation.\n     * @returns {string}\n     */\n    toBase64() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.ed25519publickey_toBase64(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst Ed25519SignatureFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_ed25519signature_free(ptr >>> 0, 1));\n/**\n * An Ed25519 digital signature, can be used to verify the\n * authenticity of a message.\n */\nclass Ed25519Signature {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Ed25519Signature.prototype);\n        obj.__wbg_ptr = ptr;\n        Ed25519SignatureFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Ed25519SignatureFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519signature_free(ptr, 0);\n    }\n    /**\n     * Try to create an Ed25519 signature from an unpadded base64\n     * representation.\n     * @param {string} signature\n     */\n    constructor(signature) {\n        const ptr0 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.ed25519signature_new(ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        Ed25519SignatureFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Serialize a Ed25519 signature to an unpadded base64\n     * representation.\n     * @returns {string}\n     */\n    toBase64() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.ed25519signature_toBase64(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst EmojiFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_emoji_free(ptr >>> 0, 1));\n/**\n * An emoji that is used for interactive verification using a short\n * auth string.\n *\n * This will contain a single emoji and description from the list of\n * emojis from [the specification].\n *\n * [the specification]: https://spec.matrix.org/unstable/client-server-api/#sas-method-emoji\n */\nclass Emoji {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Emoji.prototype);\n        obj.__wbg_ptr = ptr;\n        EmojiFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        EmojiFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_emoji_free(ptr, 0);\n    }\n    /**\n     * The emoji symbol that represents a part of the short auth\n     * string, for example: \n     * @returns {string}\n     */\n    get symbol() {\n        const ret = wasm.emoji_symbol(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The description of the emoji, for example Dog.\n     * @returns {string}\n     */\n    get description() {\n        const ret = wasm.emoji_description(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst EncryptedAttachmentFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_encryptedattachment_free(ptr >>> 0, 1));\n/**\n * An encrypted attachment, usually created from `Attachment.encrypt`.\n */\nclass EncryptedAttachment {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(EncryptedAttachment.prototype);\n        obj.__wbg_ptr = ptr;\n        EncryptedAttachmentFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        EncryptedAttachmentFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_encryptedattachment_free(ptr, 0);\n    }\n    /**\n     * Create a new encrypted attachment manually.\n     *\n     * It needs encrypted data, stored in an `Uint8Array`, and a\n     * [media encryption\n     * information](https://docs.rs/matrix-sdk-crypto/latest/matrix_sdk_crypto/struct.MediaEncryptionInfo.html),\n     * as a JSON-encoded string.\n     *\n     * The media encryption information aren't stored as a string:\n     * they are parsed, validated and fully deserialized.\n     *\n     * See [the specification to learn\n     * more](https://spec.matrix.org/unstable/client-server-api/#extensions-to-mroommessage-msgtypes).\n     * @param {Uint8Array} encrypted_data\n     * @param {string} media_encryption_info\n     */\n    constructor(encrypted_data, media_encryption_info) {\n        const ptr0 = passArray8ToWasm0(encrypted_data, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(media_encryption_info, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.encryptedattachment_new(ptr0, len0, ptr1, len1);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        EncryptedAttachmentFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * The actual encrypted data.\n     *\n     * **Warning**: It returns a **copy** of the entire encrypted\n     * data; be nice with your memory.\n     * @returns {Uint8Array}\n     */\n    get encryptedData() {\n        const ret = wasm.encryptedattachment_encryptedData(this.__wbg_ptr);\n        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        return v1;\n    }\n    /**\n     * Return the media encryption info as a JSON-encoded string. The\n     * structure is fully valid.\n     *\n     * If the media encryption info have been consumed already, it\n     * will return `null`.\n     * @returns {string | undefined}\n     */\n    get mediaEncryptionInfo() {\n        const ret = wasm.encryptedattachment_mediaEncryptionInfo(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * Check whether the media encryption info has been consumed by\n     * `Attachment.decrypt` already.\n     * @returns {boolean}\n     */\n    get hasMediaEncryptionInfoBeenConsumed() {\n        const ret = wasm.encryptedattachment_hasMediaEncryptionInfoBeenConsumed(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst EncryptionInfoFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_encryptioninfo_free(ptr >>> 0, 1));\n/**\n * Struct containing information on how an event was decrypted.\n */\nclass EncryptionInfo {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(EncryptionInfo.prototype);\n        obj.__wbg_ptr = ptr;\n        EncryptionInfoFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        EncryptionInfoFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_encryptioninfo_free(ptr, 0);\n    }\n    /**\n     * The user ID of the event sender. Note this is untrusted data\n     * unless `verification_state` is also trusted.\n     * @returns {UserId}\n     */\n    get sender() {\n        const ret = wasm.encryptioninfo_sender(this.__wbg_ptr);\n        return UserId.__wrap(ret);\n    }\n    /**\n     * The device ID of the device that sent us the event. Note this\n     * is untrusted data unless `verification_state` is also\n     * trusted.\n     * @returns {DeviceId | undefined}\n     */\n    get senderDevice() {\n        const ret = wasm.encryptioninfo_senderDevice(this.__wbg_ptr);\n        return ret === 0 ? undefined : DeviceId.__wrap(ret);\n    }\n    /**\n     * The Curve25519 key of the device that created the megolm\n     * decryption key originally.\n     * @returns {string | undefined}\n     */\n    get senderCurve25519Key() {\n        const ret = wasm.encryptioninfo_senderCurve25519Key(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The signing Ed25519 key that created the megolm key that\n     * was used to decrypt this session.\n     * @returns {string | undefined}\n     */\n    get senderClaimedEd25519Key() {\n        const ret = wasm.encryptioninfo_senderClaimedEd25519Key(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The verification state of the device that sent us the event.\n     * Note this is the state of the device at the time of\n     * decryption. It may change in the future if a device gets\n     * verified or deleted.\n     *\n     * # Arguments\n     *\n     * * `strict` - whether to enable \"strict mode\" verification. In non-strict\n     *   mode, unverified users are given no shield, and keys that have been\n     *   forwarded or restored from an insecure backup are given a grey shield\n     *   (both get a red shield in strict mode).\n     * @param {boolean} strict\n     * @returns {ShieldState}\n     */\n    shieldState(strict) {\n        const ret = wasm.encryptioninfo_shieldState(this.__wbg_ptr, strict);\n        return ShieldState.__wrap(ret);\n    }\n}\n\nconst EncryptionSettingsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_encryptionsettings_free(ptr >>> 0, 1));\n/**\n * Settings for an encrypted room.\n *\n * This determines the algorithm and rotation periods of a group\n * session.\n */\nclass EncryptionSettings {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        EncryptionSettingsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_encryptionsettings_free(ptr, 0);\n    }\n    /**\n     * The encryption algorithm that should be used in the room.\n     * @returns {EncryptionAlgorithm}\n     */\n    get algorithm() {\n        const ret = wasm.__wbg_get_encryptionsettings_algorithm(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The encryption algorithm that should be used in the room.\n     * @param {EncryptionAlgorithm} arg0\n     */\n    set algorithm(arg0) {\n        wasm.__wbg_set_encryptionsettings_algorithm(this.__wbg_ptr, arg0);\n    }\n    /**\n     * How long the session should be used before changing it,\n     * expressed in microseconds.\n     * @returns {bigint}\n     */\n    get rotationPeriod() {\n        const ret = wasm.__wbg_get_encryptionsettings_rotationPeriod(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * How long the session should be used before changing it,\n     * expressed in microseconds.\n     * @param {bigint} arg0\n     */\n    set rotationPeriod(arg0) {\n        wasm.__wbg_set_encryptionsettings_rotationPeriod(this.__wbg_ptr, arg0);\n    }\n    /**\n     * How many messages should be sent before changing the session.\n     * @returns {bigint}\n     */\n    get rotationPeriodMessages() {\n        const ret = wasm.__wbg_get_encryptionsettings_rotationPeriodMessages(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * How many messages should be sent before changing the session.\n     * @param {bigint} arg0\n     */\n    set rotationPeriodMessages(arg0) {\n        wasm.__wbg_set_encryptionsettings_rotationPeriodMessages(this.__wbg_ptr, arg0);\n    }\n    /**\n     * The history visibility of the room when the session was\n     * created.\n     * @returns {HistoryVisibility}\n     */\n    get historyVisibility() {\n        const ret = wasm.__wbg_get_encryptionsettings_historyVisibility(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The history visibility of the room when the session was\n     * created.\n     * @param {HistoryVisibility} arg0\n     */\n    set historyVisibility(arg0) {\n        wasm.__wbg_set_encryptionsettings_historyVisibility(this.__wbg_ptr, arg0);\n    }\n    /**\n     * Should untrusted devices receive the room key, or should they be\n     * excluded from the conversation.\n     * @returns {CollectStrategy}\n     */\n    get sharingStrategy() {\n        const ret = wasm.__wbg_get_encryptionsettings_sharingStrategy(this.__wbg_ptr);\n        return CollectStrategy.__wrap(ret);\n    }\n    /**\n     * Should untrusted devices receive the room key, or should they be\n     * excluded from the conversation.\n     * @param {CollectStrategy} arg0\n     */\n    set sharingStrategy(arg0) {\n        _assertClass(arg0, CollectStrategy);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_encryptionsettings_sharingStrategy(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * Create a new `EncryptionSettings` with default values.\n     */\n    constructor() {\n        const ret = wasm.encryptionsettings_new();\n        this.__wbg_ptr = ret >>> 0;\n        EncryptionSettingsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\n\nconst EstablishedEciesFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_establishedecies_free(ptr >>> 0, 1));\n/**\n * An established ECIES session.\n *\n * This session can be used to encrypt and decrypt messages between the two\n * sides of the channel.\n */\nclass EstablishedEcies {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(EstablishedEcies.prototype);\n        obj.__wbg_ptr = ptr;\n        EstablishedEciesFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        EstablishedEciesFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_establishedecies_free(ptr, 0);\n    }\n    /**\n     * Get our [`Curve25519PublicKey`].\n     *\n     * This public key needs to be sent to the other side so that it can\n     * complete the ECIES channel establishment.\n     * @returns {Curve25519PublicKey}\n     */\n    public_key() {\n        const ret = wasm.establishedecies_public_key(this.__wbg_ptr);\n        return Curve25519PublicKey.__wrap(ret);\n    }\n    /**\n     * Encrypt the given plaintext using this [`EstablishedEcies`] session.\n     * @param {string} message\n     * @returns {string}\n     */\n    encrypt(message) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const ptr0 = passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ret = wasm.establishedecies_encrypt(this.__wbg_ptr, ptr0, len0);\n            deferred2_0 = ret[0];\n            deferred2_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * Decrypt the given message using this [`EstablishedEcies`] session.\n     * @param {string} message\n     * @returns {string}\n     */\n    decrypt(message) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const ptr0 = passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ret = wasm.establishedecies_decrypt(this.__wbg_ptr, ptr0, len0);\n            var ptr2 = ret[0];\n            var len2 = ret[1];\n            if (ret[3]) {\n                ptr2 = 0; len2 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n     * Get the [`CheckCode`] which uniquely identifies this\n     * [`EstablishedEcies`] session.\n     *\n     * This check code can be used to verify and confirm that both sides of the\n     * session are indeed using the same shared secret.\n     * @returns {CheckCode}\n     */\n    check_code() {\n        const ret = wasm.establishedecies_check_code(this.__wbg_ptr);\n        return CheckCode.__wrap(ret);\n    }\n}\n\nconst EventIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_eventid_free(ptr >>> 0, 1));\n/**\n * A Matrix [event ID].\n *\n * An `EventId` is generated randomly or converted from a string\n * slice, and can be converted back into a string as needed.\n *\n * [event ID]: https://spec.matrix.org/v1.2/appendices/#room-ids-and-event-ids\n */\nclass EventId {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        EventIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_eventid_free(ptr, 0);\n    }\n    /**\n     * Parse/validate and create a new `EventId`.\n     * @param {string} id\n     */\n    constructor(id) {\n        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.eventid_new(ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        EventIdFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Returns the event's localpart.\n     * @returns {string}\n     */\n    get localpart() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.eventid_localpart(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the server name of the event ID.\n     * @returns {ServerName | undefined}\n     */\n    get serverName() {\n        const ret = wasm.eventid_serverName(this.__wbg_ptr);\n        return ret === 0 ? undefined : ServerName.__wrap(ret);\n    }\n    /**\n     * Return the event ID as a string.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.eventid_toString(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst IdentityKeysFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_identitykeys_free(ptr >>> 0, 1));\n/**\n * Struct holding the two public identity keys of an account.\n */\nclass IdentityKeys {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(IdentityKeys.prototype);\n        obj.__wbg_ptr = ptr;\n        IdentityKeysFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        IdentityKeysFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_identitykeys_free(ptr, 0);\n    }\n    /**\n     * The Ed25519 public key, used for signing.\n     * @returns {Ed25519PublicKey}\n     */\n    get ed25519() {\n        const ret = wasm.__wbg_get_identitykeys_ed25519(this.__wbg_ptr);\n        return Ed25519PublicKey.__wrap(ret);\n    }\n    /**\n     * The Ed25519 public key, used for signing.\n     * @param {Ed25519PublicKey} arg0\n     */\n    set ed25519(arg0) {\n        _assertClass(arg0, Ed25519PublicKey);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_identitykeys_ed25519(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * The Curve25519 public key, used for establish shared secrets.\n     * @returns {Curve25519PublicKey}\n     */\n    get curve25519() {\n        const ret = wasm.__wbg_get_identitykeys_curve25519(this.__wbg_ptr);\n        return Curve25519PublicKey.__wrap(ret);\n    }\n    /**\n     * The Curve25519 public key, used for establish shared secrets.\n     * @param {Curve25519PublicKey} arg0\n     */\n    set curve25519(arg0) {\n        _assertClass(arg0, Curve25519PublicKey);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_identitykeys_curve25519(this.__wbg_ptr, ptr0);\n    }\n}\n\nconst InboundCreationResultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_inboundcreationresult_free(ptr >>> 0, 1));\n/**\n * The result of an inbound ECIES channel establishment.\n */\nclass InboundCreationResult {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InboundCreationResult.prototype);\n        obj.__wbg_ptr = ptr;\n        InboundCreationResultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        InboundCreationResultFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inboundcreationresult_free(ptr, 0);\n    }\n    /**\n     * The established ECIES channel.\n     * @returns {EstablishedEcies}\n     */\n    get channel() {\n        const ret = wasm.__wbg_get_inboundcreationresult_channel(this.__wbg_ptr);\n        return EstablishedEcies.__wrap(ret);\n    }\n    /**\n     * The established ECIES channel.\n     * @param {EstablishedEcies} arg0\n     */\n    set channel(arg0) {\n        _assertClass(arg0, EstablishedEcies);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_inboundcreationresult_channel(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * The plaintext of the initial message.\n     * @returns {string}\n     */\n    get message() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.__wbg_get_inboundcreationresult_message(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The plaintext of the initial message.\n     * @param {string} arg0\n     */\n    set message(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_backupsecretsbundle_key(this.__wbg_ptr, ptr0, len0);\n    }\n}\n\nconst InboundGroupSessionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_inboundgroupsession_free(ptr >>> 0, 1));\n/**\n * Inbound group session.\n *\n * Inbound group sessions are used to exchange room messages between a group of\n * participants. Inbound group sessions are used to decrypt the room messages.\n */\nclass InboundGroupSession {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InboundGroupSession.prototype);\n        obj.__wbg_ptr = ptr;\n        InboundGroupSessionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        InboundGroupSessionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inboundgroupsession_free(ptr, 0);\n    }\n    /**\n     * The room where this session is used in.\n     * @returns {RoomId}\n     */\n    get roomId() {\n        const ret = wasm.inboundgroupsession_roomId(this.__wbg_ptr);\n        return RoomId.__wrap(ret);\n    }\n    /**\n     * The Curve25519 key of the sender of this session, as a\n     * [Curve25519PublicKey].\n     * @returns {Curve25519PublicKey}\n     */\n    get senderKey() {\n        const ret = wasm.inboundgroupsession_senderKey(this.__wbg_ptr);\n        return Curve25519PublicKey.__wrap(ret);\n    }\n    /**\n     * Returns the unique identifier for this session.\n     * @returns {string}\n     */\n    get sessionId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.inboundgroupsession_sessionId(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Has the session been imported from a file or server-side backup? As\n     * opposed to being directly received as an `m.room_key` event.\n     * @returns {boolean}\n     */\n    hasBeenImported() {\n        const ret = wasm.inboundgroupsession_hasBeenImported(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst KeysBackupRequestFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_keysbackuprequest_free(ptr >>> 0, 1));\n/**\n * A request that will back up a batch of room keys to the server\n * ([specification]).\n *\n * [specification]: https://spec.matrix.org/unstable/client-server-api/#put_matrixclientv3room_keyskeys\n */\nclass KeysBackupRequest {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(KeysBackupRequest.prototype);\n        obj.__wbg_ptr = ptr;\n        KeysBackupRequestFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        KeysBackupRequestFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_keysbackuprequest_free(ptr, 0);\n    }\n    /**\n     * The request ID.\n     * @returns {string}\n     */\n    get id() {\n        const ret = wasm.__wbg_get_keysbackuprequest_id(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * A JSON-encoded string containing the rest of the payload: `rooms`.\n     *\n     * It represents the body of the HTTP request.\n     * @returns {string}\n     */\n    get body() {\n        const ret = wasm.__wbg_get_keysbackuprequest_body(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The backup version that these room keys should be part of.\n     * @returns {string}\n     */\n    get version() {\n        const ret = wasm.__wbg_get_keysbackuprequest_version(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Create a new `KeysBackupRequest`.\n     * @param {string} id\n     * @param {string} body\n     * @param {string} version\n     */\n    constructor(id, body, version) {\n        const ret = wasm.keysbackuprequest_new(id, body, version);\n        this.__wbg_ptr = ret >>> 0;\n        KeysBackupRequestFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get its request type.\n     * @returns {RequestType}\n     */\n    get type() {\n        const ret = wasm.keysbackuprequest_type(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst KeysClaimRequestFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_keysclaimrequest_free(ptr >>> 0, 1));\n/**\n * Data for a request to the `/keys/claim` API endpoint\n * ([specification]).\n *\n * Claims one-time keys that can be used to establish 1-to-1 E2EE\n * sessions.\n *\n * [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keysclaim\n */\nclass KeysClaimRequest {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(KeysClaimRequest.prototype);\n        obj.__wbg_ptr = ptr;\n        KeysClaimRequestFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        KeysClaimRequestFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_keysclaimrequest_free(ptr, 0);\n    }\n    /**\n     * The request ID.\n     * @returns {string}\n     */\n    get id() {\n        const ret = wasm.__wbg_get_keysclaimrequest_id(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * A JSON-encoded string containing the rest of the payload: `timeout`,\n     * `one_time_keys`.\n     *\n     * It represents the body of the HTTP request.\n     * @returns {string}\n     */\n    get body() {\n        const ret = wasm.__wbg_get_keysclaimrequest_body(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Create a new `KeysClaimRequest`.\n     * @param {string} id\n     * @param {string} body\n     */\n    constructor(id, body) {\n        const ret = wasm.keysclaimrequest_new(id, body);\n        this.__wbg_ptr = ret >>> 0;\n        KeysClaimRequestFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get its request type.\n     * @returns {RequestType}\n     */\n    get type() {\n        const ret = wasm.keysclaimrequest_type(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst KeysQueryRequestFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_keysqueryrequest_free(ptr >>> 0, 1));\n/**\n * Data for a request to the `/keys/query` API endpoint\n * ([specification]).\n *\n * Returns the current devices and identity keys for the given users.\n *\n * [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keysquery\n */\nclass KeysQueryRequest {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(KeysQueryRequest.prototype);\n        obj.__wbg_ptr = ptr;\n        KeysQueryRequestFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        KeysQueryRequestFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_keysqueryrequest_free(ptr, 0);\n    }\n    /**\n     * The request ID.\n     * @returns {string}\n     */\n    get id() {\n        const ret = wasm.__wbg_get_keysqueryrequest_id(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * A JSON-encoded string containing the rest of the payload: `timeout`,\n     * `device_keys`, `token`.\n     *\n     * It represents the body of the HTTP request.\n     * @returns {string}\n     */\n    get body() {\n        const ret = wasm.__wbg_get_keysqueryrequest_body(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Create a new `KeysQueryRequest`.\n     * @param {string} id\n     * @param {string} body\n     */\n    constructor(id, body) {\n        const ret = wasm.keysqueryrequest_new(id, body);\n        this.__wbg_ptr = ret >>> 0;\n        KeysQueryRequestFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get its request type.\n     * @returns {RequestType}\n     */\n    get type() {\n        const ret = wasm.keysqueryrequest_type(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst KeysUploadRequestFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_keysuploadrequest_free(ptr >>> 0, 1));\n/**\n * Outgoing Requests *\n * Data for a request to the `/keys/upload` API endpoint\n * ([specification]).\n *\n * Publishes end-to-end encryption keys for the device.\n *\n * [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keysupload\n */\nclass KeysUploadRequest {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(KeysUploadRequest.prototype);\n        obj.__wbg_ptr = ptr;\n        KeysUploadRequestFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        KeysUploadRequestFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_keysuploadrequest_free(ptr, 0);\n    }\n    /**\n     * The request ID.\n     * @returns {string}\n     */\n    get id() {\n        const ret = wasm.__wbg_get_keysuploadrequest_id(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * A JSON-encoded string containing the rest of the payload: `device_keys`,\n     * `one_time_keys`, `fallback_keys`.\n     *\n     * It represents the body of the HTTP request.\n     * @returns {string}\n     */\n    get body() {\n        const ret = wasm.__wbg_get_keysuploadrequest_body(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Create a new `KeysUploadRequest`.\n     * @param {string} id\n     * @param {string} body\n     */\n    constructor(id, body) {\n        const ret = wasm.keysuploadrequest_new(id, body);\n        this.__wbg_ptr = ret >>> 0;\n        KeysUploadRequestFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get its request type.\n     * @returns {RequestType}\n     */\n    get type() {\n        const ret = wasm.keysuploadrequest_type(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst MaybeSignatureFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_maybesignature_free(ptr >>> 0, 1));\n/**\n * Represents a signature that is either valid _or_ that could not be\n * decoded.\n */\nclass MaybeSignature {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MaybeSignature.prototype);\n        obj.__wbg_ptr = ptr;\n        MaybeSignatureFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        MaybeSignatureFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_maybesignature_free(ptr, 0);\n    }\n    /**\n     * Check whether the signature has been successfully decoded.\n     * @returns {boolean}\n     */\n    isValid() {\n        const ret = wasm.maybesignature_isValid(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Check whether the signature could not be successfully decoded.\n     * @returns {boolean}\n     */\n    isInvalid() {\n        const ret = wasm.maybesignature_isInvalid(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * The signature, if successfully decoded.\n     * @returns {Signature | undefined}\n     */\n    get signature() {\n        const ret = wasm.maybesignature_signature(this.__wbg_ptr);\n        return ret === 0 ? undefined : Signature.__wrap(ret);\n    }\n    /**\n     * The base64 encoded string that is claimed to contain a\n     * signature but could not be decoded, if any.\n     * @returns {string | undefined}\n     */\n    get invalidSignatureSource() {\n        const ret = wasm.maybesignature_invalidSignatureSource(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n}\n\nconst MegolmDecryptionErrorFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_megolmdecryptionerror_free(ptr >>> 0, 1));\n/**\n * Js Decryption error with code.\n */\nclass MegolmDecryptionError {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MegolmDecryptionError.prototype);\n        obj.__wbg_ptr = ptr;\n        MegolmDecryptionErrorFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        MegolmDecryptionErrorFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_megolmdecryptionerror_free(ptr, 0);\n    }\n    /**\n     * Description code for the error. See `DecryptionErrorCode`\n     * @returns {DecryptionErrorCode}\n     */\n    get code() {\n        const ret = wasm.__wbg_get_megolmdecryptionerror_code(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * detailed description\n     * @returns {string}\n     */\n    get description() {\n        const ret = wasm.__wbg_get_megolmdecryptionerror_description(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Withheld code if any. Only for `UnknownMessageIndex` error code\n     * @returns {string | undefined}\n     */\n    get maybe_withheld() {\n        const ret = wasm.__wbg_get_megolmdecryptionerror_maybe_withheld(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst MegolmV1BackupKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_megolmv1backupkey_free(ptr >>> 0, 1));\n/**\n * The public part of the backup key.\n */\nclass MegolmV1BackupKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MegolmV1BackupKey.prototype);\n        obj.__wbg_ptr = ptr;\n        MegolmV1BackupKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        MegolmV1BackupKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_megolmv1backupkey_free(ptr, 0);\n    }\n    /**\n     * The actual base64 encoded public key.\n     * @returns {string}\n     */\n    get publicKeyBase64() {\n        const ret = wasm.megolmv1backupkey_publicKeyBase64(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the full name of the backup algorithm this backup key supports.\n     * @returns {string}\n     */\n    get algorithm() {\n        const ret = wasm.megolmv1backupkey_algorithm(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst MigrationFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_migration_free(ptr >>> 0, 1));\n/**\n * Migration routines\n *\n * The public methods are exposed as static methods on this class, for\n * namespacing and to enable easier mocking in unit tests.\n */\nclass Migration {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        MigrationFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_migration_free(ptr, 0);\n    }\n    /**\n     * Import the base dataset from a libolm-based setup to a vodozemac-based\n     * setup stored in IndexedDB.\n     *\n     * Populates the user credentials, Olm account, backup data, etc. This is\n     * the first step in the migration process. Once this base data is\n     * imported, further data can be imported with {@link\n     * #migrateOlmSessions}, {@link #migrateMegolmSessions}, and TODO room settings.\n     *\n     * # Arguments\n     *\n     * * `data` - The data to be migrated\n     * * `pickle_key` - The libolm pickle key that was used to pickle the olm\n     *   account objects.\n     * * `store_handle` - A connection to the CryptoStore which will be used to\n     *   store the vodozemac data.\n     * @param {BaseMigrationData} data\n     * @param {Uint8Array} pickle_key\n     * @param {StoreHandle} store_handle\n     * @returns {Promise<any>}\n     */\n    static migrateBaseData(data, pickle_key, store_handle) {\n        _assertClass(data, BaseMigrationData);\n        _assertClass(store_handle, StoreHandle);\n        const ret = wasm.migration_migrateBaseData(data.__wbg_ptr, pickle_key, store_handle.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Migrate Olm sessions of a libolm-based setup to a vodozemac-based setup\n     * stored in an indexedDB crypto store.\n     *\n     * Before this method can be used, {@link #migrateBaseData} must be used to\n     * import the base data into the crypto store.\n     *\n     * This method should be called a number of times, with separate batches of\n     * `sessions`. If a progress display is given, it can be updated after\n     * each batch is successfully imported.\n     *\n     * # Arguments\n     *\n     * * `sessions` - An `Array` of {@link PickledSession}s to import. Items\n     *   inside `sessions` will be invalidated by this method.\n     * * `pickle_key` - The libolm pickle key that was used to pickle the olm\n     *   session objects.\n     * * `store_handle` - A connection to the CryptoStore which will be used to\n     *   store the vodozemac data.\n     * @param {(PickledSession)[]} sessions\n     * @param {Uint8Array} pickle_key\n     * @param {StoreHandle} store_handle\n     * @returns {Promise<any>}\n     */\n    static migrateOlmSessions(sessions, pickle_key, store_handle) {\n        const ptr0 = passArrayJsValueToWasm0(sessions, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(store_handle, StoreHandle);\n        const ret = wasm.migration_migrateOlmSessions(ptr0, len0, pickle_key, store_handle.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Migrate Megolm sessions of a libolm-based setup to a vodozemac-based\n     * setup stored in an indexedDB crypto store.\n     *\n     * Before this method can be used, {@link #migrateBaseData} must be used to\n     * import the base data into the crypto store.\n     *\n     * This method should be called a number of times, with separate batches of\n     * `sessions`. If a progress display is given, it can be updated after\n     * each batch is successfully imported.\n     *\n     * # Arguments\n     *\n     * * `sessions` - An `Array` of {@link PickledInboundGroupSession}s to\n     *   import. Items inside `sessions` will be invalidated by this method.\n     * * `pickle_key` - The libolm pickle key that was used to pickle the\n     *   megolm session objects.\n     * * `store_handle` - A connection to the CryptoStore which will be used to\n     *   store the vodozemac data.\n     * @param {(PickledInboundGroupSession)[]} sessions\n     * @param {Uint8Array} pickle_key\n     * @param {StoreHandle} store_handle\n     * @returns {Promise<any>}\n     */\n    static migrateMegolmSessions(sessions, pickle_key, store_handle) {\n        const ptr0 = passArrayJsValueToWasm0(sessions, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(store_handle, StoreHandle);\n        const ret = wasm.migration_migrateMegolmSessions(ptr0, len0, pickle_key, store_handle.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst OlmMachineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_olmmachine_free(ptr >>> 0, 1));\n/**\n * State machine implementation of the Olm/Megolm encryption protocol\n * used for Matrix end to end encryption.\n */\nclass OlmMachine {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OlmMachine.prototype);\n        obj.__wbg_ptr = ptr;\n        OlmMachineFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OlmMachineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_olmmachine_free(ptr, 0);\n    }\n    /**\n     * Constructor will always fail. To create a new `OlmMachine`, please use\n     * the `initialize` method.\n     *\n     * Why this pattern? `initialize` returns a `Promise`. Returning a\n     */\n    constructor() {\n        const ret = wasm.olmmachine_new();\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        OlmMachineFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a new `OlmMachine`.\n     *\n     * The created machine will keep the encryption keys either in a IndexedDB\n     * based store, or in a memory store and once the objects is dropped,\n     * the keys will be lost.\n     *\n     * # Arguments\n     *\n     * * `user_id` - represents the unique ID of the user that owns this\n     * machine.\n     *\n     * * `device_id` - represents the unique ID of the device\n     * that owns this machine.\n     *\n     * * `store_name` - The name that should be used to open the IndexedDB\n     *   based database. If this isn't provided, a memory-only store will be\n     *   used. *Note* the memory-only store will lose your E2EE keys when the\n     *   `OlmMachine` gets dropped.\n     *\n     * * `store_passphrase` - The passphrase that should be used to encrypt the\n     *   IndexedDB-based store.\n     * @param {UserId} user_id\n     * @param {DeviceId} device_id\n     * @param {string | undefined} [store_name]\n     * @param {string | undefined} [store_passphrase]\n     * @returns {Promise<any>}\n     */\n    static initialize(user_id, device_id, store_name, store_passphrase) {\n        _assertClass(user_id, UserId);\n        _assertClass(device_id, DeviceId);\n        var ptr0 = isLikeNone(store_name) ? 0 : passStringToWasm0(store_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(store_passphrase) ? 0 : passStringToWasm0(store_passphrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_initialize(user_id.__wbg_ptr, device_id.__wbg_ptr, ptr0, len0, ptr1, len1);\n        return ret;\n    }\n    /**\n     * Create a new `OlmMachine` backed by an existing store.\n     *\n     * # Arguments\n     *\n     * * `user_id` - represents the unique ID of the user that owns this\n     * machine.\n     *\n     * * `device_id` - represents the unique ID of the device\n     * that owns this machine.\n     *\n     * * `store_handle` - the connection to the crypto store to be used for\n     *   this machine.\n     * @param {UserId} user_id\n     * @param {DeviceId} device_id\n     * @param {StoreHandle} store_handle\n     * @returns {Promise<any>}\n     */\n    static initFromStore(user_id, device_id, store_handle) {\n        _assertClass(user_id, UserId);\n        _assertClass(device_id, DeviceId);\n        _assertClass(store_handle, StoreHandle);\n        const ret = wasm.olmmachine_initFromStore(user_id.__wbg_ptr, device_id.__wbg_ptr, store_handle.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The unique user ID that owns this `OlmMachine` instance.\n     * @returns {UserId}\n     */\n    get userId() {\n        const ret = wasm.olmmachine_userId(this.__wbg_ptr);\n        return UserId.__wrap(ret);\n    }\n    /**\n     * The unique device ID that identifies this `OlmMachine`.\n     * @returns {DeviceId}\n     */\n    get deviceId() {\n        const ret = wasm.olmmachine_deviceId(this.__wbg_ptr);\n        return DeviceId.__wrap(ret);\n    }\n    /**\n     * The time, in milliseconds since the unix epoch, at which the `Account`\n     * backing this `OlmMachine` was created.\n     *\n     * An `Account` is created when an `OlmMachine` is first instantiated\n     * against a given `Store`, at which point it creates identity keys etc.\n     * This method returns the timestamp, according to the local clock, at\n     * which that happened.\n     * @returns {number}\n     */\n    get deviceCreationTimeMs() {\n        const ret = wasm.olmmachine_deviceCreationTimeMs(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the public parts of our Olm identity keys.\n     * @returns {IdentityKeys}\n     */\n    get identityKeys() {\n        const ret = wasm.olmmachine_identityKeys(this.__wbg_ptr);\n        return IdentityKeys.__wrap(ret);\n    }\n    /**\n     * Get the display name of our own device.\n     * @returns {Promise<any>}\n     */\n    get displayName() {\n        const ret = wasm.olmmachine_displayName(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Whether automatic transmission of room key requests is enabled.\n     *\n     * Room key requests allow the device to request room keys that it might\n     * have missed in the original share using `m.room_key_request`\n     * events.\n     * @returns {boolean}\n     */\n    get roomKeyRequestsEnabled() {\n        const ret = wasm.olmmachine_roomKeyRequestsEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Enable or disable automatic transmission of room key requests.\n     * @param {boolean} enabled\n     */\n    set roomKeyRequestsEnabled(enabled) {\n        wasm.olmmachine_set_roomKeyRequestsEnabled(this.__wbg_ptr, enabled);\n    }\n    /**\n     * Whether room key forwarding is enabled.\n     *\n     * If room key forwarding is enabled, we will automatically reply to\n     * incoming `m.room_key_request` messages from verified devices by\n     * forwarding the requested key (if we have it).\n     * @returns {boolean}\n     */\n    get roomKeyForwardingEnabled() {\n        const ret = wasm.olmmachine_roomKeyForwardingEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Enable or disable room key forwarding.\n     * @param {boolean} enabled\n     */\n    set roomKeyForwardingEnabled(enabled) {\n        wasm.olmmachine_set_roomKeyForwardingEnabled(this.__wbg_ptr, enabled);\n    }\n    /**\n     * Get the list of users whose devices we are currently tracking.\n     *\n     * A user can be marked for tracking using the\n     * [`update_tracked_users`](#method.update_tracked_users) method.\n     *\n     * Returns a `Set<UserId>`.\n     * @returns {Promise<any>}\n     */\n    trackedUsers() {\n        const ret = wasm.olmmachine_trackedUsers(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Update the list of tracked users.\n     *\n     * The OlmMachine maintains a list of users whose devices we are keeping\n     * track of: these are known as \"tracked users\". These must be users\n     * that we share a room with, so that the server sends us updates for\n     * their device lists.\n     *\n     * # Arguments\n     *\n     * * `users` - An array of user ids that should be added to the list of\n     *   tracked users\n     *\n     * Any users that hadn't been seen before will be flagged for a key query\n     * immediately, and whenever `receive_sync_changes` receives a\n     * \"changed\" notification for that user in the future.\n     *\n     * Users that were already in the list are unaffected.\n     *\n     * Items inside `users` will be invalidated by this method. Be careful not\n     * to use the `UserId`s after this method has been called.\n     * @param {(UserId)[]} users\n     * @returns {Promise<any>}\n     */\n    updateTrackedUsers(users) {\n        const ptr0 = passArrayJsValueToWasm0(users, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_updateTrackedUsers(this.__wbg_ptr, ptr0, len0);\n        return ret;\n    }\n    /**\n     * Mark all tracked users as dirty.\n     *\n     * All users *whose device lists we are tracking* are flagged as needing a\n     * key query. Users whose devices we are not tracking are ignored.\n     * @returns {Promise<void>}\n     */\n    markAllTrackedUsersAsDirty() {\n        const ret = wasm.olmmachine_markAllTrackedUsersAsDirty(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Handle to-device events and one-time key counts from a sync\n     * response.\n     *\n     * This will decrypt and handle to-device events returning the\n     * decrypted versions of them.\n     *\n     * To decrypt an event from the room timeline call\n     * `decrypt_room_event`.\n     *\n     * # Arguments\n     *\n     * * `to_device_events`: the JSON-encoded to-device evens from the `/sync`\n     *   response\n     * * `changed_devices`: the mapping of changed and left devices, from the\n     *   `/sync` response\n     * * `one_time_keys_counts`: The number of one-time keys on the server,\n     *   from the `/sync` response. A `Map` from string (encryption algorithm)\n     *   to number (number of keys).\n     * * `unused_fallback_keys`: Optionally, a `Set` of unused fallback keys on\n     *   the server, from the `/sync` response. If this is set, it is used to\n     *   determine if new fallback keys should be uploaded.\n     *\n     * # Returns\n     *\n     * A list of JSON strings, containing the decrypted to-device events.\n     * @param {string} to_device_events\n     * @param {DeviceLists} changed_devices\n     * @param {Map<any, any>} one_time_keys_counts\n     * @param {Set<any> | undefined} [unused_fallback_keys]\n     * @returns {Promise<any>}\n     */\n    receiveSyncChanges(to_device_events, changed_devices, one_time_keys_counts, unused_fallback_keys) {\n        const ptr0 = passStringToWasm0(to_device_events, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(changed_devices, DeviceLists);\n        const ret = wasm.olmmachine_receiveSyncChanges(this.__wbg_ptr, ptr0, len0, changed_devices.__wbg_ptr, one_time_keys_counts, isLikeNone(unused_fallback_keys) ? 0 : addToExternrefTable0(unused_fallback_keys));\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Get the outgoing requests that need to be sent out.\n     *\n     * This returns a list of values, each of which can be any of:\n     *   * {@link KeysUploadRequest},\n     *   * {@link KeysQueryRequest},\n     *   * {@link KeysClaimRequest},\n     *   * {@link ToDeviceRequest},\n     *   * {@link SignatureUploadRequest},\n     *   * {@link RoomMessageRequest}, or\n     *   * {@link KeysBackupRequest}.\n     *\n     * Those requests need to be sent out to the server and the\n     * responses need to be passed back to the state machine\n     * using {@link OlmMachine.markRequestAsSent}.\n     * @returns {Promise<any>}\n     */\n    outgoingRequests() {\n        const ret = wasm.olmmachine_outgoingRequests(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Mark the request with the given request ID as sent (see\n     * `outgoing_requests`).\n     *\n     * Arguments are:\n     *\n     * * `request_id` represents the unique ID of the request that was sent\n     *   out. This is needed to couple the response with the now sent out\n     *   request.\n     * * `response_type` represents the type of the request that was sent out.\n     * * `response` represents the response that was received from the server\n     *   after the outgoing request was sent out.\n     * @param {string} request_id\n     * @param {RequestType} request_type\n     * @param {string} response\n     * @returns {Promise<any>}\n     */\n    markRequestAsSent(request_id, request_type, response) {\n        const ptr0 = passStringToWasm0(request_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(response, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_markRequestAsSent(this.__wbg_ptr, ptr0, len0, request_type, ptr1, len1);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Encrypt a room message for the given room.\n     *\n     * **Note**: A room key needs to be shared with the group of users that are\n     * members in the given room. If this is not done this method will panic.\n     *\n     * The usual flow to encrypt an event using this state machine is as\n     * follows:\n     *\n     * 1. Get the one-time key claim request to establish 1:1 Olm sessions for\n     *    the room members of the room we wish to participate in. This is done\n     *    using the [`get_missing_sessions()`](Self::get_missing_sessions)\n     *    method. This method call should be locked per call.\n     *\n     * 2. Share a room key with all the room members using the\n     *    [`share_room_key()`](Self::share_room_key). This method call should\n     *    be locked per room.\n     *\n     * 3. Encrypt the event using this method.\n     *\n     * 4. Send the encrypted event to the server.\n     *\n     * After the room key is shared steps 1 and 2 will become noops, unless\n     * there's some changes in the room membership or in the list of devices a\n     * member has.\n     *\n     *\n     * `room_id` is the ID of the room for which the message should\n     * be encrypted. `event_type` is the type of the event. `content`\n     * is the plaintext content of the message that should be\n     * encrypted.\n     *\n     * # Panics\n     *\n     * Panics if a group session for the given room wasn't shared\n     * beforehand.\n     * @param {RoomId} room_id\n     * @param {string} event_type\n     * @param {string} content\n     * @returns {Promise<any>}\n     */\n    encryptRoomEvent(room_id, event_type, content) {\n        _assertClass(room_id, RoomId);\n        const ptr0 = passStringToWasm0(event_type, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(content, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_encryptRoomEvent(this.__wbg_ptr, room_id.__wbg_ptr, ptr0, len0, ptr1, len1);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Decrypt an event from a room timeline.\n     *\n     * # Arguments\n     *\n     * * `event`, the event that should be decrypted.\n     * * `room_id`, the ID of the room where the event was sent to.\n     *\n     * # Returns\n     *\n     * A `Promise` which resolves to a {@link DecryptedRoomEvent} instance, or\n     * rejects with a {@link MegolmDecryptionError} instance.\n     * @param {string} event\n     * @param {RoomId} room_id\n     * @param {DecryptionSettings} decryption_settings\n     * @returns {Promise<any>}\n     */\n    decryptRoomEvent(event, room_id, decryption_settings) {\n        const ptr0 = passStringToWasm0(event, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(room_id, RoomId);\n        _assertClass(decryption_settings, DecryptionSettings);\n        const ret = wasm.olmmachine_decryptRoomEvent(this.__wbg_ptr, ptr0, len0, room_id.__wbg_ptr, decryption_settings.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Get encryption info for a decrypted timeline event.\n     *\n     * This recalculates the `EncryptionInfo` data that is returned by\n     * `decryptRoomEvent`, based on the current\n     * verification status of the sender, etc.\n     *\n     * Returns an error for an unencrypted event.\n     *\n     * # Arguments\n     *\n     * * `event` - The event to get information for.\n     * * `room_id` - The ID of the room where the event was sent to.\n     *\n     * # Returns\n     *\n     * {@link EncryptionInfo}\n     * @param {string} event\n     * @param {RoomId} room_id\n     * @returns {Promise<any>}\n     */\n    getRoomEventEncryptionInfo(event, room_id) {\n        const ptr0 = passStringToWasm0(event, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(room_id, RoomId);\n        const ret = wasm.olmmachine_getRoomEventEncryptionInfo(this.__wbg_ptr, ptr0, len0, room_id.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Get the status of the private cross signing keys.\n     *\n     * This can be used to check which private cross signing keys we\n     * have stored locally.\n     * @returns {Promise<any>}\n     */\n    crossSigningStatus() {\n        const ret = wasm.olmmachine_crossSigningStatus(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Export all the secrets we have in the store into a {@link\n     * SecretsBundle}.\n     *\n     * This method will export all the private cross-signing keys and, if\n     * available, the private part of a backup key and its accompanying\n     * version.\n     *\n     * The method will fail if we don't have all three private cross-signing\n     * keys available.\n     *\n     * **Warning**: Only export this and share it with a trusted recipient,\n     * i.e. if an existing device is sharing this with a new device.\n     * @returns {Promise<SecretsBundle>}\n     */\n    exportSecretsBundle() {\n        const ret = wasm.olmmachine_exportSecretsBundle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Import and persists secrets from a {@link SecretsBundle}.\n     *\n     * This method will import all the private cross-signing keys and, if\n     * available, the private part of a backup key and its accompanying\n     * version into the store.\n     *\n     * **Warning**: Only import this from a trusted source, i.e. if an existing\n     * device is sharing this with a new device. The imported cross-signing\n     * keys will create a {@link OwnUserIdentity} and mark it as verified.\n     *\n     * The backup key will be persisted in the store and can be enabled using\n     * the {@link BackupMachine}.\n     *\n     * The provided `SecretsBundle` is freed by this method; be careful not to\n     * use it once this method has been called.\n     * @param {SecretsBundle} bundle\n     * @returns {Promise<void>}\n     */\n    importSecretsBundle(bundle) {\n        _assertClass(bundle, SecretsBundle);\n        var ptr0 = bundle.__destroy_into_raw();\n        const ret = wasm.olmmachine_importSecretsBundle(this.__wbg_ptr, ptr0);\n        return ret;\n    }\n    /**\n     * Export all the private cross signing keys we have.\n     *\n     * The export will contain the seeds for the ed25519 keys as\n     * unpadded base64 encoded strings.\n     *\n     * Returns `null` if we dont have any private cross signing keys;\n     * otherwise returns a `CrossSigningKeyExport`.\n     * @returns {Promise<any>}\n     */\n    exportCrossSigningKeys() {\n        const ret = wasm.olmmachine_exportCrossSigningKeys(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Import our private cross signing keys.\n     *\n     * The keys should be provided as unpadded-base64-encoded strings.\n     *\n     * Returns a `CrossSigningStatus`.\n     * @param {string | undefined} [master_key]\n     * @param {string | undefined} [self_signing_key]\n     * @param {string | undefined} [user_signing_key]\n     * @returns {Promise<any>}\n     */\n    importCrossSigningKeys(master_key, self_signing_key, user_signing_key) {\n        var ptr0 = isLikeNone(master_key) ? 0 : passStringToWasm0(master_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(self_signing_key) ? 0 : passStringToWasm0(self_signing_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(user_signing_key) ? 0 : passStringToWasm0(user_signing_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_importCrossSigningKeys(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        return ret;\n    }\n    /**\n     * Create a new cross signing identity and get the upload request\n     * to push the new public keys to the server.\n     *\n     * Warning: This will delete any existing cross signing keys that\n     * might exist on the server and thus will reset the trust\n     * between all the devices.\n     *\n     * Uploading these keys will require user interactive auth.\n     *\n     * # Arguments\n     *\n     * * `reset`, whether the method should create a new identity or use the\n     *   existing one during the request. If set to true, the request will\n     *   attempt to upload a new identity. If set to false, the request will\n     *   attempt to upload the existing identity. Since the uploading process\n     *   requires user interactive authentication, which involves sending out\n     *   the same request multiple times, setting this argument to false\n     *   enables you to reuse the same request.\n     *\n     * Returns a {@link CrossSigningBootstrapRequests}.\n     * @param {boolean} reset\n     * @returns {Promise<any>}\n     */\n    bootstrapCrossSigning(reset) {\n        const ret = wasm.olmmachine_bootstrapCrossSigning(this.__wbg_ptr, reset);\n        return ret;\n    }\n    /**\n     * Get the cross signing user identity of a user.\n     *\n     * Returns a promise for an {@link identities.OwnUserIdentity}, a\n     * {@link identities.OtherUserIdentity}, or `undefined`.\n     * @param {UserId} user_id\n     * @returns {Promise<any>}\n     */\n    getIdentity(user_id) {\n        _assertClass(user_id, UserId);\n        const ret = wasm.olmmachine_getIdentity(this.__wbg_ptr, user_id.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Sign the given message using our device key and if available\n     * cross-signing master key.\n     * @param {string} message\n     * @returns {Promise<any>}\n     */\n    sign(message) {\n        const ptr0 = passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_sign(this.__wbg_ptr, ptr0, len0);\n        return ret;\n    }\n    /**\n     * Invalidate the currently active outbound group session for the\n     * given room.\n     *\n     * Returns true if a session was invalidated, false if there was\n     * no session to invalidate.\n     * @param {RoomId} room_id\n     * @returns {Promise<any>}\n     */\n    invalidateGroupSession(room_id) {\n        _assertClass(room_id, RoomId);\n        const ret = wasm.olmmachine_invalidateGroupSession(this.__wbg_ptr, room_id.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get to-device requests to share a room key with users in a room.\n     *\n     * `room_id` is the room ID. `users` is an array of `UserId`\n     * objects. `encryption_settings` are an `EncryptionSettings`\n     * object.\n     *\n     * Note: Care should be taken that only one such request at a\n     * time is in flight for the same room, e.g. using a lock.\n     *\n     * Returns an array of `ToDeviceRequest`s.\n     *\n     * Items inside `users` will be invalidated by this method. Be careful not\n     * to use the `UserId`s after this method has been called.\n     * @param {RoomId} room_id\n     * @param {(UserId)[]} users\n     * @param {EncryptionSettings} encryption_settings\n     * @returns {Promise<any>}\n     */\n    shareRoomKey(room_id, users, encryption_settings) {\n        _assertClass(room_id, RoomId);\n        const ptr0 = passArrayJsValueToWasm0(users, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(encryption_settings, EncryptionSettings);\n        const ret = wasm.olmmachine_shareRoomKey(this.__wbg_ptr, room_id.__wbg_ptr, ptr0, len0, encryption_settings.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Generate an \"out-of-band\" key query request for the given set of users.\n     *\n     * This can be useful if we need the results from `getIdentity` or\n     * `getUserDevices` to be as up-to-date as possible.\n     *\n     * Returns a `KeysQueryRequest` object. The response of the request should\n     * be passed to the `OlmMachine` with the `mark_request_as_sent`.\n     *\n     * Items inside `users` will be invalidated by this method. Be careful not\n     * to use the `UserId`s after this method has been called.\n     * @param {(UserId)[]} users\n     * @returns {KeysQueryRequest}\n     */\n    queryKeysForUsers(users) {\n        const ptr0 = passArrayJsValueToWasm0(users, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_queryKeysForUsers(this.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return KeysQueryRequest.__wrap(ret[0]);\n    }\n    /**\n     * Get the a key claiming request for the user/device pairs that\n     * we are missing Olm sessions for.\n     *\n     * Returns `null` if no key claiming request needs to be sent\n     * out, otherwise it returns a `KeysClaimRequest` object.\n     *\n     * Sessions need to be established between devices so group\n     * sessions for a room can be shared with them.\n     *\n     * This should be called every time a group session needs to be\n     * shared as well as between sync calls. After a sync some\n     * devices may request room keys without us having a valid Olm\n     * session with them, making it impossible to server the room key\n     * request, thus its necessary to check for missing sessions\n     * between sync as well.\n     *\n     * Note: Care should be taken that only one such request at a\n     * time is in flight, e.g. using a lock.\n     *\n     * The response of a successful key claiming requests needs to be\n     * passed to the `OlmMachine` with the `mark_request_as_sent`.\n     *\n     * `users` represents the list of users that we should check if\n     * we lack a session with one of their devices. This can be an\n     * empty iterator when calling this method between sync requests.\n     *\n     * Items inside `users` will be invalidated by this method. Be careful not\n     * to use the `UserId`s after this method has been called.\n     * @param {(UserId)[]} users\n     * @returns {Promise<any>}\n     */\n    getMissingSessions(users) {\n        const ptr0 = passArrayJsValueToWasm0(users, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_getMissingSessions(this.__wbg_ptr, ptr0, len0);\n        return ret;\n    }\n    /**\n     * Get a map holding all the devices of a user.\n     *\n     * ### Parameters\n     *\n     * * `user_id` - The unique ID of the user that the device belongs to.\n     *\n     * * `timeout_secs` - The amount of time we should wait for a `/keys/query`\n     *   response before returning if the user's device list has been marked as\n     *   stale. **Note**, this assumes that the requests from {@link\n     *   OlmMachine.outgoingRequests} are being processed and sent out.\n     *\n     *   If unset, we will return immediately even if the device list is stale.\n     *\n     * ### Returns\n     *\n     * A {@link UserDevices} object.\n     * @param {UserId} user_id\n     * @param {number | undefined} [timeout_secs]\n     * @returns {Promise<any>}\n     */\n    getUserDevices(user_id, timeout_secs) {\n        _assertClass(user_id, UserId);\n        const ret = wasm.olmmachine_getUserDevices(this.__wbg_ptr, user_id.__wbg_ptr, !isLikeNone(timeout_secs), isLikeNone(timeout_secs) ? 0 : timeout_secs);\n        return ret;\n    }\n    /**\n     * Get a specific device of a user.\n     *\n     * ### Parameters\n     *\n     * * `user_id` - The unique ID of the user that the device belongs to.\n     *\n     * * `device_id` - The unique ID of the device.\n     *\n     * * `timeout_secs` - The amount of time we should wait for a `/keys/query`\n     *   response before returning if the user's device list has been marked as\n     *   stale. **Note**, this assumes that the requests from {@link\n     *   OlmMachine.outgoingRequests} are being processed and sent out.\n     *\n     *   If unset, we will return immediately even if the device list is stale.\n     *\n     * ### Returns\n     *\n     * If the device is known, a {@link Device}. Otherwise, `undefined`.\n     * @param {UserId} user_id\n     * @param {DeviceId} device_id\n     * @param {number | undefined} [timeout_secs]\n     * @returns {Promise<any>}\n     */\n    getDevice(user_id, device_id, timeout_secs) {\n        _assertClass(user_id, UserId);\n        _assertClass(device_id, DeviceId);\n        const ret = wasm.olmmachine_getDevice(this.__wbg_ptr, user_id.__wbg_ptr, device_id.__wbg_ptr, !isLikeNone(timeout_secs), isLikeNone(timeout_secs) ? 0 : timeout_secs);\n        return ret;\n    }\n    /**\n     * Get a verification object for the given user ID with the given\n     * flow ID (a to-device request ID if the verification has been\n     * requested by a to-device request, or a room event ID if the\n     * verification has been requested by a room event).\n     *\n     * It returns a `Verification` object, which is either a `Sas`\n     * or `Qr` object.\n     * @param {UserId} user_id\n     * @param {string} flow_id\n     * @returns {any}\n     */\n    getVerification(user_id, flow_id) {\n        _assertClass(user_id, UserId);\n        const ptr0 = passStringToWasm0(flow_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_getVerification(this.__wbg_ptr, user_id.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Get a verification request object with the given flow ID.\n     * @param {UserId} user_id\n     * @param {string} flow_id\n     * @returns {VerificationRequest | undefined}\n     */\n    getVerificationRequest(user_id, flow_id) {\n        _assertClass(user_id, UserId);\n        const ptr0 = passStringToWasm0(flow_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_getVerificationRequest(this.__wbg_ptr, user_id.__wbg_ptr, ptr0, len0);\n        return ret === 0 ? undefined : VerificationRequest.__wrap(ret);\n    }\n    /**\n     * Get all the verification requests of a given user.\n     * @param {UserId} user_id\n     * @returns {Array<any>}\n     */\n    getVerificationRequests(user_id) {\n        _assertClass(user_id, UserId);\n        const ret = wasm.olmmachine_getVerificationRequests(this.__wbg_ptr, user_id.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Receive a verification event.\n     *\n     * This method can be used to pass verification events that are happening\n     * in rooms to the `OlmMachine`. The event should be in the decrypted form.\n     * @param {string} event\n     * @param {RoomId} room_id\n     * @returns {Promise<any>}\n     */\n    receiveVerificationEvent(event, room_id) {\n        const ptr0 = passStringToWasm0(event, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(room_id, RoomId);\n        const ret = wasm.olmmachine_receiveVerificationEvent(this.__wbg_ptr, ptr0, len0, room_id.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Export the keys that match the given predicate.\n     *\n     * `predicate` is a closure that will be called for every known\n     * `InboundGroupSession`, which represents a room key. If the closure\n     * returns `true`, the `InboundGroupSession` will be included in the\n     * export; otherwise it won't.\n     *\n     * Returns a Promise containing a Result containing a String which is a\n     * JSON-encoded array of ExportedRoomKey objects.\n     * @param {Function} predicate\n     * @returns {Promise<any>}\n     */\n    exportRoomKeys(predicate) {\n        const ret = wasm.olmmachine_exportRoomKeys(this.__wbg_ptr, predicate);\n        return ret;\n    }\n    /**\n     * Import the given room keys into our store.\n     *\n     * Mostly, a deprecated alias for `importExportedRoomKeys`, though the\n     * return type is different.\n     *\n     * Returns a String containing a JSON-encoded object, holding three\n     * properties:\n     *  * `total_count` (the total number of keys found in the export data).\n     *  * `imported_count` (the number of keys that were imported).\n     *  * `keys` (the keys that were imported; a map from room id to a map of\n     *    the sender key to a list of session ids).\n     *\n     * @deprecated Use `importExportedRoomKeys` or `importBackedUpRoomKeys`.\n     * @param {string} exported_room_keys\n     * @param {Function} progress_listener\n     * @returns {Promise<any>}\n     */\n    importRoomKeys(exported_room_keys, progress_listener) {\n        const ptr0 = passStringToWasm0(exported_room_keys, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_importRoomKeys(this.__wbg_ptr, ptr0, len0, progress_listener);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Import the given room keys into our store.\n     *\n     * `exported_keys` is a JSON-encoded list of previously exported keys that\n     * should be imported into our store. If we already have a better\n     * version of a key, the key will _not_ be imported.\n     *\n     * `progress_listener` is a closure that takes 2 `BigInt` arguments:\n     * `progress` and `total`, and returns nothing.\n     *\n     * Returns a {@link RoomKeyImportResult}.\n     * @param {string} exported_room_keys\n     * @param {Function} progress_listener\n     * @returns {Promise<any>}\n     */\n    importExportedRoomKeys(exported_room_keys, progress_listener) {\n        const ptr0 = passStringToWasm0(exported_room_keys, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_importExportedRoomKeys(this.__wbg_ptr, ptr0, len0, progress_listener);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Import the given room keys into our store.\n     *\n     * # Arguments\n     *\n     * * `backed_up_room_keys`: keys that were retrieved from backup and that\n     *   should be added to our store (provided they are better than our\n     *   current versions of those keys). Specifically, it should be a Map from\n     *   {@link RoomId}, to a Map from session ID to a (decrypted) session data\n     *   structure.\n     *\n     * * `progress_listener`: an optional callback that takes 3 arguments:\n     *   `progress` (the number of keys that have successfully been imported),\n     *   `total` (the total number of keys), and `failures` (the number of keys\n     *   that failed to import), and returns nothing.\n     *\n     * # Returns\n     *\n     * A {@link RoomKeyImportResult}.\n     * @param {Map<any, any>} backed_up_room_keys\n     * @param {Function | undefined} progress_listener\n     * @param {string} backup_version\n     * @returns {Promise<any>}\n     */\n    importBackedUpRoomKeys(backed_up_room_keys, progress_listener, backup_version) {\n        const ptr0 = passStringToWasm0(backup_version, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_importBackedUpRoomKeys(this.__wbg_ptr, backed_up_room_keys, isLikeNone(progress_listener) ? 0 : addToExternrefTable0(progress_listener), ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Store the backup decryption key in the crypto store.\n     *\n     * This is useful if the client wants to support gossiping of the backup\n     * key.\n     *\n     * Returns `Promise<void>`.\n     * @param {BackupDecryptionKey} decryption_key\n     * @param {string} version\n     * @returns {Promise<any>}\n     */\n    saveBackupDecryptionKey(decryption_key, version) {\n        _assertClass(decryption_key, BackupDecryptionKey);\n        const ptr0 = passStringToWasm0(version, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_saveBackupDecryptionKey(this.__wbg_ptr, decryption_key.__wbg_ptr, ptr0, len0);\n        return ret;\n    }\n    /**\n     * Get the backup keys we have saved in our store.\n     * Returns a `Promise` for {@link BackupKeys}.\n     * @returns {Promise<any>}\n     */\n    getBackupKeys() {\n        const ret = wasm.olmmachine_getBackupKeys(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Check if the given backup has been verified by us or by another of our\n     * devices that we trust.\n     *\n     * The `backup_info` should be a Javascript object with the following\n     * format:\n     *\n     * ```json\n     * {\n     *     \"algorithm\": \"m.megolm_backup.v1.curve25519-aes-sha2\",\n     *     \"auth_data\": {\n     *         \"public_key\":\"XjhWTCjW7l59pbfx9tlCBQolfnIQWARoKOzjTOPSlWM\",\n     *         \"signatures\": {}\n     *     }\n     * }\n     * ```\n     *\n     * Returns a {@link SignatureVerification} object.\n     * @param {any} backup_info\n     * @returns {Promise<any>}\n     */\n    verifyBackup(backup_info) {\n        const ret = wasm.olmmachine_verifyBackup(this.__wbg_ptr, backup_info);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Activate the given backup key to be used with the given backup version.\n     *\n     * **Warning**: The caller needs to make sure that the given `BackupKey` is\n     * trusted, otherwise we might be encrypting room keys that a malicious\n     * party could decrypt.\n     *\n     * The {@link #verifyBackup} method can be used to do so.\n     *\n     * Returns `Promise<void>`.\n     * @param {string} public_key_base_64\n     * @param {string} version\n     * @returns {Promise<any>}\n     */\n    enableBackupV1(public_key_base_64, version) {\n        const ptr0 = passStringToWasm0(public_key_base_64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(version, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_enableBackupV1(this.__wbg_ptr, ptr0, len0, ptr1, len1);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Are we able to encrypt room keys.\n     *\n     * This returns true if we have an active `BackupKey` and backup version\n     * registered with the state machine.\n     *\n     * Returns `Promise<bool>`.\n     * @returns {Promise<any>}\n     */\n    isBackupEnabled() {\n        const ret = wasm.olmmachine_isBackupEnabled(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Disable and reset our backup state.\n     *\n     * This will remove any pending backup request, remove the backup key and\n     * reset the backup state of each room key we have.\n     *\n     * Returns `Promise<void>`.\n     * @returns {Promise<any>}\n     */\n    disableBackup() {\n        const ret = wasm.olmmachine_disableBackup(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Encrypt a batch of room keys and return a request that needs to be sent\n     * out to backup the room keys.\n     *\n     * Returns an optional {@link KeysBackupRequest}.\n     * @returns {Promise<any>}\n     */\n    backupRoomKeys() {\n        const ret = wasm.olmmachine_backupRoomKeys(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the number of backed up room keys and the total number of room keys.\n     * Returns a {@link RoomKeyCounts}.\n     * @returns {Promise<any>}\n     */\n    roomKeyCounts() {\n        const ret = wasm.olmmachine_roomKeyCounts(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Encrypt the list of exported room keys using the given passphrase.\n     *\n     * `exported_room_keys` is a list of sessions that should be encrypted\n     * (it's generally returned by `export_room_keys`). `passphrase` is the\n     * passphrase that will be used to encrypt the exported room keys. And\n     * `rounds` is the number of rounds that should be used for the key\n     * derivation when the passphrase gets turned into an AES key. More rounds\n     * are increasingly computationnally intensive and as such help against\n     * brute-force attacks. Should be at least `10_000`, while values in the\n     * `100_000` ranges should be preferred.\n     * @param {string} exported_room_keys\n     * @param {string} passphrase\n     * @param {number} rounds\n     * @returns {string}\n     */\n    static encryptExportedRoomKeys(exported_room_keys, passphrase, rounds) {\n        let deferred4_0;\n        let deferred4_1;\n        try {\n            const ptr0 = passStringToWasm0(exported_room_keys, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(passphrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            const ret = wasm.olmmachine_encryptExportedRoomKeys(ptr0, len0, ptr1, len1, rounds);\n            var ptr3 = ret[0];\n            var len3 = ret[1];\n            if (ret[3]) {\n                ptr3 = 0; len3 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred4_0 = ptr3;\n            deferred4_1 = len3;\n            return getStringFromWasm0(ptr3, len3);\n        } finally {\n            wasm.__wbindgen_free(deferred4_0, deferred4_1, 1);\n        }\n    }\n    /**\n     * Try to decrypt a reader into a list of exported room keys.\n     *\n     * `encrypted_exported_room_keys` is the result from\n     * `encrypt_exported_room_keys`. `passphrase` is the passphrase that was\n     * used when calling `encrypt_exported_room_keys`.\n     * @param {string} encrypted_exported_room_keys\n     * @param {string} passphrase\n     * @returns {string}\n     */\n    static decryptExportedRoomKeys(encrypted_exported_room_keys, passphrase) {\n        let deferred4_0;\n        let deferred4_1;\n        try {\n            const ptr0 = passStringToWasm0(encrypted_exported_room_keys, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(passphrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            const ret = wasm.olmmachine_decryptExportedRoomKeys(ptr0, len0, ptr1, len1);\n            var ptr3 = ret[0];\n            var len3 = ret[1];\n            if (ret[3]) {\n                ptr3 = 0; len3 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred4_0 = ptr3;\n            deferred4_1 = len3;\n            return getStringFromWasm0(ptr3, len3);\n        } finally {\n            wasm.__wbindgen_free(deferred4_0, deferred4_1, 1);\n        }\n    }\n    /**\n     * Register a callback which will be called whenever there is an update to\n     * a room key.\n     *\n     * `callback` should be a function that takes a single argument (an array\n     * of {@link RoomKeyInfo}) and returns a Promise.\n     * @param {Function} callback\n     * @returns {Promise<void>}\n     */\n    registerRoomKeyUpdatedCallback(callback) {\n        const ret = wasm.olmmachine_registerRoomKeyUpdatedCallback(this.__wbg_ptr, callback);\n        return ret;\n    }\n    /**\n     * Register a callback which will be called whenever we receive a\n     * notification that some room keys have been withheld.\n     *\n     * `callback` should be a function that takes a single argument (an array\n     * of {@link RoomKeyWithheldInfo}) and returns a Promise.\n     * @param {Function} callback\n     * @returns {Promise<void>}\n     */\n    registerRoomKeysWithheldCallback(callback) {\n        const ret = wasm.olmmachine_registerRoomKeysWithheldCallback(this.__wbg_ptr, callback);\n        return ret;\n    }\n    /**\n     * Register a callback which will be called whenever there is an update to\n     * a user identity.\n     *\n     * `callback` should be a function that takes a single argument (a {@link\n     * UserId}) and returns a Promise.\n     * @param {Function} callback\n     * @returns {Promise<void>}\n     */\n    registerUserIdentityUpdatedCallback(callback) {\n        const ret = wasm.olmmachine_registerUserIdentityUpdatedCallback(this.__wbg_ptr, callback);\n        return ret;\n    }\n    /**\n     * Register a callback which will be called whenever there is an update to\n     * a device.\n     *\n     * `callback` should be a function that takes a single argument (an array\n     * of user IDs as strings) and returns a Promise.\n     * @param {Function} callback\n     * @returns {Promise<void>}\n     */\n    registerDevicesUpdatedCallback(callback) {\n        const ret = wasm.olmmachine_registerDevicesUpdatedCallback(this.__wbg_ptr, callback);\n        return ret;\n    }\n    /**\n     * Register a callback which will be called whenever a secret\n     * (`m.secret.send`) is received.\n     *\n     * The only secret this will currently broadcast is the\n     * `m.megolm_backup.v1` (the cross signing secrets are handled internally).\n     *\n     * To request a secret from other devices, a client sends an\n     * `m.secret.request` device event with `action` set to `request` and\n     * `name` set to the identifier of the secret. A device that wishes to\n     * share the secret will reply with an `m.secret.send` event, encrypted\n     * using olm.\n     *\n     * The secrets are guaranteed to have been received over a 1-to-1 encrypted\n     * to_device message from a one of the user's own verified devices.\n     *\n     * See https://matrix-org.github.io/matrix-rust-sdk/matrix_sdk_crypto/store/struct.Store.html#method.secrets_stream for more information.\n     *\n     * `callback` should be a function that takes 2 arguments: the secret name\n     * (string) and value (string).\n     *\n     * **Note**: if the secret is valid and handled on the javascript side, the\n     * secret inbox should be cleared by calling\n     * `delete_secrets_from_inbox`.\n     * @param {Function} callback\n     * @returns {Promise<void>}\n     */\n    registerReceiveSecretCallback(callback) {\n        const ret = wasm.olmmachine_registerReceiveSecretCallback(this.__wbg_ptr, callback);\n        return ret;\n    }\n    /**\n     * Get all the secrets with the given secret_name we have currently\n     * stored.\n     * The only secret this will currently return is the\n     * `m.megolm_backup.v1` secret.\n     *\n     * Usually you would just register a callback with\n     * [`register_receive_secret_callback`], but if the client is shut down\n     * before handling them, this method can be used to retrieve them.\n     * This method should therefore be called at client startup to retrieve any\n     * secrets received during the previous session.\n     *\n     * The secrets are guaranteed to have been received over a 1-to-1 encrypted\n     * to_device message from one of the user's own verified devices.\n     *\n     * Returns a `Promise` for a `Set` of `String` corresponding to the secret\n     * values.\n     *\n     * If the secret is valid and handled, the secret inbox should be cleared\n     * by calling `delete_secrets_from_inbox`.\n     * @param {string} secret_name\n     * @returns {Promise<Promise<any>>}\n     */\n    getSecretsFromInbox(secret_name) {\n        const ptr0 = passStringToWasm0(secret_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_getSecretsFromInbox(this.__wbg_ptr, ptr0, len0);\n        return ret;\n    }\n    /**\n     * Delete all secrets with the given secret name from the inbox.\n     *\n     * Should be called after handling the secrets with\n     * `get_secrets_from_inbox`.\n     *\n     * # Arguments\n     *\n     * * `secret_name` - The name of the secret to delete.\n     * @param {string} secret_name\n     * @returns {Promise<Promise<any>>}\n     */\n    deleteSecretsFromInbox(secret_name) {\n        const ptr0 = passStringToWasm0(secret_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.olmmachine_deleteSecretsFromInbox(this.__wbg_ptr, ptr0, len0);\n        return ret;\n    }\n    /**\n     * Request missing local secrets from our other trusted devices.\n     *\n     * \"Local secrets\" refers to secrets which can be shared between trusted\n     * devices, such as private cross-signing keys, and the megolm backup\n     * decryption key.\n     *\n     * This method will cause the sdk to generated outgoing secret requests\n     * (`m.secret.request`) to get the missing secrets. These requests will\n     * then be returned by a future call to {@link\n     * OlmMachine#outgoing_requests}.\n     *\n     * # Returns\n     *\n     * A `Promise` for a `bool` result, which will be true if  secrets were\n     * missing, and a request was generated.\n     * @returns {Promise<Promise<any>>}\n     */\n    requestMissingSecretsIfNeeded() {\n        const ret = wasm.olmmachine_requestMissingSecretsIfNeeded(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the stored room settings, such as the encryption algorithm or\n     * whether to encrypt only for trusted devices.\n     *\n     * These settings can be modified via {@link #setRoomSettings}.\n     *\n     * # Returns\n     *\n     * `Promise<RoomSettings|undefined>`\n     * @param {RoomId} room_id\n     * @returns {Promise<any>}\n     */\n    getRoomSettings(room_id) {\n        _assertClass(room_id, RoomId);\n        const ret = wasm.olmmachine_getRoomSettings(this.__wbg_ptr, room_id.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Store encryption settings for the given room.\n     *\n     * This method checks if the new settings are \"safe\" -- ie, that they do\n     * not represent a downgrade in encryption security from any previous\n     * settings. Attempts to downgrade security will result in an error.\n     *\n     * If the settings are valid, they will be persisted to the crypto store.\n     * These settings are not used directly by this library, but the saved\n     * settings can be retrieved via {@link #getRoomSettings}.\n     * @param {RoomId} room_id\n     * @param {RoomSettings} room_settings\n     * @returns {Promise<void>}\n     */\n    setRoomSettings(room_id, room_settings) {\n        _assertClass(room_id, RoomId);\n        _assertClass(room_settings, RoomSettings);\n        const ret = wasm.olmmachine_setRoomSettings(this.__wbg_ptr, room_id.__wbg_ptr, room_settings.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Manage dehydrated devices\n     * @returns {DehydratedDevices}\n     */\n    dehydratedDevices() {\n        const ret = wasm.olmmachine_dehydratedDevices(this.__wbg_ptr);\n        return DehydratedDevices.__wrap(ret);\n    }\n    /**\n     * Shut down the `OlmMachine`.\n     *\n     * The `OlmMachine` cannot be used after this method has been called.\n     *\n     * All associated resources will be closed too, like IndexedDB\n     * connections.\n     */\n    close() {\n        const ptr = this.__destroy_into_raw();\n        wasm.olmmachine_close(ptr);\n    }\n}\n\nconst OtherUserIdentityFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_otheruseridentity_free(ptr >>> 0, 1));\n/**\n * Struct representing a cross signing identity of a user.\n *\n * This is the user identity of a user that isn't our own. Other users will\n * only contain a master key and a self signing key, meaning that only device\n * signatures can be checked with this identity.\n *\n * This struct wraps a read-only version of the struct and allows verifications\n * to be requested to verify our own device with the user identity.\n */\nclass OtherUserIdentity {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OtherUserIdentity.prototype);\n        obj.__wbg_ptr = ptr;\n        OtherUserIdentityFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OtherUserIdentityFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_otheruseridentity_free(ptr, 0);\n    }\n    /**\n     * Is this user identity verified?\n     * @returns {boolean}\n     */\n    isVerified() {\n        const ret = wasm.otheruseridentity_isVerified(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Manually verify this user.\n     *\n     * This method will attempt to sign the user identity using our private\n     * cross signing key.\n     *\n     * This method fails if we don't have the private part of our user-signing\n     * key.\n     *\n     * Returns a request that needs to be sent out for the user to be marked as\n     * verified.\n     * @returns {Promise<any>}\n     */\n    verify() {\n        const ret = wasm.otheruseridentity_verify(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Create a `VerificationRequest` object after the verification\n     * request content has been sent out.\n     * @param {RoomId} room_id\n     * @param {EventId} request_event_id\n     * @param {any[] | undefined} [methods]\n     * @returns {VerificationRequest}\n     */\n    requestVerification(room_id, request_event_id, methods) {\n        _assertClass(room_id, RoomId);\n        _assertClass(request_event_id, EventId);\n        var ptr0 = isLikeNone(methods) ? 0 : passArrayJsValueToWasm0(methods, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.otheruseridentity_requestVerification(this.__wbg_ptr, room_id.__wbg_ptr, request_event_id.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return VerificationRequest.__wrap(ret[0]);\n    }\n    /**\n     * Send a verification request to the given user.\n     *\n     * The returned content needs to be sent out into a DM room with the given\n     * user.\n     *\n     * After the content has been sent out a VerificationRequest can be started\n     * with the `request_verification` method.\n     * @param {any[] | undefined} [methods]\n     * @returns {string}\n     */\n    verificationRequestContent(methods) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            var ptr0 = isLikeNone(methods) ? 0 : passArrayJsValueToWasm0(methods, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            const ret = wasm.otheruseridentity_verificationRequestContent(this.__wbg_ptr, ptr0, len0);\n            var ptr2 = ret[0];\n            var len2 = ret[1];\n            if (ret[3]) {\n                ptr2 = 0; len2 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n     * Get the master key of the identity.\n     * @returns {string}\n     */\n    get masterKey() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const ret = wasm.otheruseridentity_masterKey(this.__wbg_ptr);\n            var ptr1 = ret[0];\n            var len1 = ret[1];\n            if (ret[3]) {\n                ptr1 = 0; len1 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * Get the self-signing key of the identity.\n     * @returns {string}\n     */\n    get selfSigningKey() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const ret = wasm.otheruseridentity_selfSigningKey(this.__wbg_ptr);\n            var ptr1 = ret[0];\n            var len1 = ret[1];\n            if (ret[3]) {\n                ptr1 = 0; len1 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * Pin the current identity (public part of the master signing key).\n     * @returns {Promise<any>}\n     */\n    pinCurrentMasterKey() {\n        const ret = wasm.otheruseridentity_pinCurrentMasterKey(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Has the identity changed in a way that requires approval from the user?\n     *\n     * A user identity needs approval if it changed after the crypto machine\n     * has already observed (\"pinned\") a different identity for that user,\n     * unless it is an explicitly verified identity (using for example\n     * interactive verification).\n     *\n     * This situation can be resolved by:\n     *\n     * - Verifying the new identity with {@link requestVerification}, or:\n     * - Updating the pin to the new identity with {@link pinCurrentMasterKey}.\n     * @returns {boolean}\n     */\n    identityNeedsUserApproval() {\n        const ret = wasm.otheruseridentity_identityNeedsUserApproval(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * True if we verified this identity (with any own identity, at any\n     * point).\n     *\n     * To set this latch back to false, call {@link withdrawVerification}.\n     * @returns {boolean}\n     */\n    wasPreviouslyVerified() {\n        const ret = wasm.otheruseridentity_wasPreviouslyVerified(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Remove the requirement for this identity to be verified.\n     *\n     * If an identity was previously verified and is not anymore it will be\n     * reported to the user. In order to remove this notice users have to\n     * verify again or to withdraw the verification requirement.\n     * @returns {Promise<any>}\n     */\n    withdrawVerification() {\n        const ret = wasm.otheruseridentity_withdrawVerification(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Was this identity verified since initial observation and is not anymore?\n     *\n     * Such a violation should be reported to the local user by the\n     * application, and resolved by\n     *\n     * - Verifying the new identity with {@link requestVerification}, or:\n     * - Withdrawing the verification requirement with {@link\n     *   withdrawVerification}.\n     * @returns {boolean}\n     */\n    hasVerificationViolation() {\n        const ret = wasm.otheruseridentity_hasVerificationViolation(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst OutboundCreationResultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_outboundcreationresult_free(ptr >>> 0, 1));\n/**\n * The result of an outbound ECIES channel establishment.\n */\nclass OutboundCreationResult {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OutboundCreationResult.prototype);\n        obj.__wbg_ptr = ptr;\n        OutboundCreationResultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OutboundCreationResultFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outboundcreationresult_free(ptr, 0);\n    }\n    /**\n     * The established ECIES channel.\n     * @returns {EstablishedEcies}\n     */\n    get channel() {\n        const ret = wasm.__wbg_get_inboundcreationresult_channel(this.__wbg_ptr);\n        return EstablishedEcies.__wrap(ret);\n    }\n    /**\n     * The established ECIES channel.\n     * @param {EstablishedEcies} arg0\n     */\n    set channel(arg0) {\n        _assertClass(arg0, EstablishedEcies);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_inboundcreationresult_channel(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * The initial encrypted message.\n     * @returns {string}\n     */\n    get initial_message() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.__wbg_get_outboundcreationresult_initial_message(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The initial encrypted message.\n     * @param {string} arg0\n     */\n    set initial_message(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_backupsecretsbundle_key(this.__wbg_ptr, ptr0, len0);\n    }\n}\n\nconst OwnUserIdentityFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_ownuseridentity_free(ptr >>> 0, 1));\n/**\n * Struct representing a cross signing identity of a user.\n *\n * This is the user identity of a user that is our own.\n */\nclass OwnUserIdentity {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OwnUserIdentity.prototype);\n        obj.__wbg_ptr = ptr;\n        OwnUserIdentityFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OwnUserIdentityFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ownuseridentity_free(ptr, 0);\n    }\n    /**\n     * Is this user identity verified?\n     * @returns {boolean}\n     */\n    isVerified() {\n        const ret = wasm.ownuseridentity_isVerified(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Mark our user identity as verified.\n     *\n     * This will mark the identity locally as verified and sign it with our own\n     * device.\n     *\n     * Returns a signature upload request that needs to be sent out.\n     * @returns {Promise<any>}\n     */\n    verify() {\n        const ret = wasm.ownuseridentity_verify(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Send a verification request to our other devices.\n     * @param {any[] | undefined} [methods]\n     * @returns {Promise<any>}\n     */\n    requestVerification(methods) {\n        var ptr0 = isLikeNone(methods) ? 0 : passArrayJsValueToWasm0(methods, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.ownuseridentity_requestVerification(this.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Does our user identity trust our own device, i.e. have we signed our own\n     * device keys with our self-signing key?\n     * @returns {Promise<any>}\n     */\n    trustsOurOwnDevice() {\n        const ret = wasm.ownuseridentity_trustsOurOwnDevice(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the master key of the identity.\n     * @returns {string}\n     */\n    get masterKey() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const ret = wasm.ownuseridentity_masterKey(this.__wbg_ptr);\n            var ptr1 = ret[0];\n            var len1 = ret[1];\n            if (ret[3]) {\n                ptr1 = 0; len1 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * Get the self-signing key of the identity.\n     * @returns {string}\n     */\n    get selfSigningKey() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const ret = wasm.ownuseridentity_selfSigningKey(this.__wbg_ptr);\n            var ptr1 = ret[0];\n            var len1 = ret[1];\n            if (ret[3]) {\n                ptr1 = 0; len1 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * Get the user-signing key of the identity. This is only present for our\n     * own user identity.\n     * @returns {string}\n     */\n    get userSigningKey() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const ret = wasm.ownuseridentity_userSigningKey(this.__wbg_ptr);\n            var ptr1 = ret[0];\n            var len1 = ret[1];\n            if (ret[3]) {\n                ptr1 = 0; len1 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * True if we verified our own identity at some point in the past.\n     *\n     * To reset this latch back to `false`, call {@link withdrawVerification}.\n     * @returns {boolean}\n     */\n    wasPreviouslyVerified() {\n        const ret = wasm.ownuseridentity_wasPreviouslyVerified(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Remove the requirement for this identity to be verified.\n     *\n     * If an identity was previously verified and is not any longer, it will be\n     * reported to the user. In order to remove this notice users have to\n     * verify again or to withdraw the verification requirement.\n     * @returns {Promise<any>}\n     */\n    withdrawVerification() {\n        const ret = wasm.ownuseridentity_withdrawVerification(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Was this identity verified since initial observation and is not anymore?\n     *\n     * Such a violation should be reported to the local user by the\n     * application, and resolved by\n     *\n     * - Verifying the new identity with {@link requestVerification}, or:\n     * - Withdrawing the verification requirement with {@link\n     *   withdrawVerification}.\n     * @returns {boolean}\n     */\n    hasVerificationViolation() {\n        const ret = wasm.ownuseridentity_hasVerificationViolation(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst PickledInboundGroupSessionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_pickledinboundgroupsession_free(ptr >>> 0, 1));\n/**\n * A pickled version of an `InboundGroupSession`.\n *\n * Holds all the information that needs to be stored in a database to restore\n * an InboundGroupSession.\n */\nclass PickledInboundGroupSession {\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof PickledInboundGroupSession)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PickledInboundGroupSessionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pickledinboundgroupsession_free(ptr, 0);\n    }\n    /**\n     * The pickle string holding the Megolm Session, as returned by\n     * `olm_pickle_inbound_group_session` in libolm.\n     * @returns {string}\n     */\n    get pickle() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.__wbg_get_pickledinboundgroupsession_pickle(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The pickle string holding the Megolm Session, as returned by\n     * `olm_pickle_inbound_group_session` in libolm.\n     * @param {string} arg0\n     */\n    set pickle(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_backupsecretsbundle_key(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The public curve25519 key of the account that sent us the session.\n     * @returns {string}\n     */\n    get senderKey() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.__wbg_get_pickledinboundgroupsession_senderKey(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The public curve25519 key of the account that sent us the session.\n     * @param {string} arg0\n     */\n    set senderKey(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_backupsecretsbundle_backup_version(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The public ed25519 key of the account that is believed to have initiated\n     * the session, if known.\n     *\n     * If the session was received directly from the creator via an\n     * Olm-encrypted `m.room_key` event, this value is taken from the `keys`\n     * property of the plaintext payload of that event (see\n     * [`m.olm.v1.curve25519-aes-sha2`]).\n     *\n     * If the session was forwarded to us using an [`m.forwarded_room_key`],\n     * this value is a copy of the `sender_claimed_ed25519_key` from the\n     * content of the event.\n     *\n     * [`m.olm.v1.curve25519-aes-sha2`]: https://spec.matrix.org/v1.9/client-server-api/#molmv1curve25519-aes-sha2\n     * [`m.forwarded_room_key`]: https://spec.matrix.org/v1.9/client-server-api/#mforwarded_room_key\n     * @returns {string | undefined}\n     */\n    get senderSigningKey() {\n        const ret = wasm.__wbg_get_pickledinboundgroupsession_senderSigningKey(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * The public ed25519 key of the account that is believed to have initiated\n     * the session, if known.\n     *\n     * If the session was received directly from the creator via an\n     * Olm-encrypted `m.room_key` event, this value is taken from the `keys`\n     * property of the plaintext payload of that event (see\n     * [`m.olm.v1.curve25519-aes-sha2`]).\n     *\n     * If the session was forwarded to us using an [`m.forwarded_room_key`],\n     * this value is a copy of the `sender_claimed_ed25519_key` from the\n     * content of the event.\n     *\n     * [`m.olm.v1.curve25519-aes-sha2`]: https://spec.matrix.org/v1.9/client-server-api/#molmv1curve25519-aes-sha2\n     * [`m.forwarded_room_key`]: https://spec.matrix.org/v1.9/client-server-api/#mforwarded_room_key\n     * @param {string | undefined} [arg0]\n     */\n    set senderSigningKey(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_basemigrationdata_backupRecoveryKey(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The id of the room that the session is used in.\n     *\n     * Nullable so that a `PickledInboundGroupSession` can be constructed\n     * incrementally. Must be populated!\n     * @returns {RoomId | undefined}\n     */\n    get roomId() {\n        const ret = wasm.__wbg_get_pickledinboundgroupsession_roomId(this.__wbg_ptr);\n        return ret === 0 ? undefined : RoomId.__wrap(ret);\n    }\n    /**\n     * The id of the room that the session is used in.\n     *\n     * Nullable so that a `PickledInboundGroupSession` can be constructed\n     * incrementally. Must be populated!\n     * @param {RoomId | undefined} [arg0]\n     */\n    set roomId(arg0) {\n        let ptr0 = 0;\n        if (!isLikeNone(arg0)) {\n            _assertClass(arg0, RoomId);\n            ptr0 = arg0.__destroy_into_raw();\n        }\n        wasm.__wbg_set_pickledinboundgroupsession_roomId(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * Flag remembering if the session was directly sent to us by the sender\n     * or if it was imported.\n     * @returns {boolean}\n     */\n    get imported() {\n        const ret = wasm.__wbg_get_pickledinboundgroupsession_imported(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Flag remembering if the session was directly sent to us by the sender\n     * or if it was imported.\n     * @param {boolean} arg0\n     */\n    set imported(arg0) {\n        wasm.__wbg_set_pickledinboundgroupsession_imported(this.__wbg_ptr, arg0);\n    }\n    /**\n     * Flag remembering if the session has been backed up.\n     * @returns {boolean}\n     */\n    get backedUp() {\n        const ret = wasm.__wbg_get_pickledinboundgroupsession_backedUp(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Flag remembering if the session has been backed up.\n     * @param {boolean} arg0\n     */\n    set backedUp(arg0) {\n        wasm.__wbg_set_pickledinboundgroupsession_backedUp(this.__wbg_ptr, arg0);\n    }\n    /**\n     * Construct a new `PickledInboundGroupSession`, with default values.\n     */\n    constructor() {\n        const ret = wasm.pickledinboundgroupsession_new();\n        this.__wbg_ptr = ret >>> 0;\n        PickledInboundGroupSessionFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\n\nconst PickledSessionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_pickledsession_free(ptr >>> 0, 1));\n/**\n * A pickled version of a `Session`.\n *\n * Holds all the information that needs to be stored in a database to restore\n * an Olm Session. Can be imported into the rust store with {@link\n * #migrateOlmSessions}.\n */\nclass PickledSession {\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof PickledSession)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PickledSessionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pickledsession_free(ptr, 0);\n    }\n    /**\n     * The pickle string holding the Olm Session, as returned by\n     * `olm_pickle_session` in libolm.\n     * @returns {string}\n     */\n    get pickle() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.__wbg_get_pickledsession_pickle(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The pickle string holding the Olm Session, as returned by\n     * `olm_pickle_session` in libolm.\n     * @param {string} arg0\n     */\n    set pickle(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_backupsecretsbundle_key(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The base64-encoded public curve25519 key of the other user that we share\n     * this session with.\n     * @returns {string}\n     */\n    get senderKey() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.__wbg_get_pickledsession_senderKey(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The base64-encoded public curve25519 key of the other user that we share\n     * this session with.\n     * @param {string} arg0\n     */\n    set senderKey(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_backupsecretsbundle_backup_version(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Was the session created using a fallback key?\n     * @returns {boolean}\n     */\n    get createdUsingFallbackKey() {\n        const ret = wasm.__wbg_get_pickledsession_createdUsingFallbackKey(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Was the session created using a fallback key?\n     * @param {boolean} arg0\n     */\n    set createdUsingFallbackKey(arg0) {\n        wasm.__wbg_set_pickledsession_createdUsingFallbackKey(this.__wbg_ptr, arg0);\n    }\n    /**\n     * When the session was created.\n     * @returns {Date}\n     */\n    get creationTime() {\n        const ret = wasm.__wbg_get_pickledsession_creationTime(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * When the session was created.\n     * @param {Date} arg0\n     */\n    set creationTime(arg0) {\n        wasm.__wbg_set_pickledsession_creationTime(this.__wbg_ptr, arg0);\n    }\n    /**\n     * When the session was last used.\n     * @returns {Date}\n     */\n    get lastUseTime() {\n        const ret = wasm.__wbg_get_pickledsession_lastUseTime(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * When the session was last used.\n     * @param {Date} arg0\n     */\n    set lastUseTime(arg0) {\n        wasm.__wbg_set_pickledsession_lastUseTime(this.__wbg_ptr, arg0);\n    }\n    /**\n     * Construct a new `PickledSession`, with default values.\n     */\n    constructor() {\n        const ret = wasm.pickledsession_new();\n        this.__wbg_ptr = ret >>> 0;\n        PickledSessionFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\n\nconst PutDehydratedDeviceRequestFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_putdehydrateddevicerequest_free(ptr >>> 0, 1));\n/**\n * A request that will upload a dehydrated device to the server.\n */\nclass PutDehydratedDeviceRequest {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PutDehydratedDeviceRequest.prototype);\n        obj.__wbg_ptr = ptr;\n        PutDehydratedDeviceRequestFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PutDehydratedDeviceRequestFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_putdehydrateddevicerequest_free(ptr, 0);\n    }\n    /**\n     * A JSON-encoded string containing the rest of the payload: `rooms`.\n     *\n     * It represents the body of the HTTP request.\n     * @returns {string}\n     */\n    get body() {\n        const ret = wasm.__wbg_get_putdehydrateddevicerequest_body(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Create a new `PutDehydratedDeviceRequest`\n     * @param {string} body\n     */\n    constructor(body) {\n        const ret = wasm.putdehydrateddevicerequest_new(body);\n        this.__wbg_ptr = ret >>> 0;\n        PutDehydratedDeviceRequestFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\n\nconst QrFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_qr_free(ptr >>> 0, 1));\n/**\n * QR code based verification.\n */\nclass Qr {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Qr.prototype);\n        obj.__wbg_ptr = ptr;\n        QrFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        QrFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_qr_free(ptr, 0);\n    }\n    /**\n     * Get the current state of this request.\n     *\n     * Returns a `QrState`.\n     * @returns {QrState}\n     */\n    state() {\n        const ret = wasm.qr_state(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Has the QR verification been scanned by the other side.\n     *\n     * When the verification object is in this state its required\n     * that the user confirms that the other side has scanned the QR\n     * code.\n     * @returns {boolean}\n     */\n    hasBeenScanned() {\n        const ret = wasm.qr_hasBeenScanned(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Has the scanning of the QR code been confirmed by us?\n     * @returns {boolean}\n     */\n    hasBeenConfirmed() {\n        const ret = wasm.qr_hasBeenConfirmed(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get our own user ID.\n     * @returns {UserId}\n     */\n    get userId() {\n        const ret = wasm.qr_userId(this.__wbg_ptr);\n        return UserId.__wrap(ret);\n    }\n    /**\n     * Get the user id of the other user that is participating in\n     * this verification flow.\n     * @returns {UserId}\n     */\n    get otherUserId() {\n        const ret = wasm.qr_otherUserId(this.__wbg_ptr);\n        return UserId.__wrap(ret);\n    }\n    /**\n     * Get the device ID of the other side.\n     * @returns {DeviceId}\n     */\n    get otherDeviceId() {\n        const ret = wasm.qr_otherDeviceId(this.__wbg_ptr);\n        return DeviceId.__wrap(ret);\n    }\n    /**\n     * Did we initiate the verification request?\n     * @returns {boolean}\n     */\n    weStarted() {\n        const ret = wasm.qr_weStarted(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get info about the cancellation if the verification flow has\n     * been cancelled.\n     * @returns {CancelInfo | undefined}\n     */\n    cancelInfo() {\n        const ret = wasm.qr_cancelInfo(this.__wbg_ptr);\n        return ret === 0 ? undefined : CancelInfo.__wrap(ret);\n    }\n    /**\n     * Has the verification flow completed?\n     * @returns {boolean}\n     */\n    isDone() {\n        const ret = wasm.qr_isDone(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Has the verification flow been cancelled?\n     * @returns {boolean}\n     */\n    isCancelled() {\n        const ret = wasm.qr_isCancelled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Is this a verification that is verifying one of our own devices?\n     * @returns {boolean}\n     */\n    isSelfVerification() {\n        const ret = wasm.qr_isSelfVerification(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Have we successfully scanned the QR code and are able to send\n     * a reciprocation event?\n     * @returns {boolean}\n     */\n    reciprocated() {\n        const ret = wasm.qr_reciprocated(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get the unique ID that identifies this QR verification flow,\n     * be either a to-device request ID or a room event ID.\n     * @returns {string}\n     */\n    get flowId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.qr_flowId(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the room id if the verification is happening inside a\n     * room.\n     * @returns {RoomId | undefined}\n     */\n    get roomId() {\n        const ret = wasm.qr_roomId(this.__wbg_ptr);\n        return ret === 0 ? undefined : RoomId.__wrap(ret);\n    }\n    /**\n     * Generate a QR code object that is representing this\n     * verification flow.\n     *\n     * The QrCode can then be rendered as an image or as an unicode\n     * string.\n     *\n     * The `to_bytes` method can be used to instead output the raw\n     * bytes that should be encoded as a QR code.\n     *\n     * Returns a `QrCode`.\n     * @returns {QrCode}\n     */\n    toQrCode() {\n        const ret = wasm.qr_toQrCode(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return QrCode.__wrap(ret[0]);\n    }\n    /**\n     * Generate a the raw bytes that should be encoded as a QR code\n     * is representing this verification flow.\n     *\n     * The `to_qr_code` method can be used to instead output a QrCode\n     * object that can be rendered.\n     * @returns {Uint8ClampedArray}\n     */\n    toBytes() {\n        const ret = wasm.qr_toBytes(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Notify the other side that we have successfully scanned the QR\n     * code and that the QR verification flow can start.\n     *\n     * This will return some OutgoingContent if the object is in the\n     * correct state to start the verification flow, otherwise None.\n     * @returns {any}\n     */\n    reciprocate() {\n        const ret = wasm.qr_reciprocate(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Confirm that the other side has scanned our QR code.\n     *\n     * Returns either an `OutgoingRequest` which should be sent out, or\n     * `undefined` if the verification is already confirmed.\n     * @returns {any}\n     */\n    confirmScanning() {\n        const ret = wasm.qr_confirmScanning(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Cancel the verification flow.\n     *\n     * Returns either an `OutgoingRequest` which should be sent out, or\n     * `undefined` if the verification is already cancelled.\n     * @returns {any}\n     */\n    cancel() {\n        const ret = wasm.qr_cancel(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Cancel the verification.\n     *\n     * This cancels the verification with given code (e.g. `m.user`).\n     *\n     * Returns either an `OutgoingRequest` which should be sent out, or\n     * `undefined` if the verification is already cancelled.\n     * @param {string} code\n     * @returns {any}\n     */\n    cancelWithCode(code) {\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.qr_cancelWithCode(this.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Register a callback which will be called whenever there is an update to\n     * the request\n     *\n     * The `callback` is called with no parameters.\n     * @param {Function} callback\n     */\n    registerChangesCallback(callback) {\n        wasm.qr_registerChangesCallback(this.__wbg_ptr, callback);\n    }\n}\n\nconst QrCodeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_qrcode_free(ptr >>> 0, 1));\n/**\n * A QR code.\n */\nclass QrCode {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(QrCode.prototype);\n        obj.__wbg_ptr = ptr;\n        QrCodeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        QrCodeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_qrcode_free(ptr, 0);\n    }\n    /**\n     * Render the QR code into a `Uint8ClampedArray` where 1 represents a\n     * dark pixel and 0 a white pixel.\n     * @returns {Uint8ClampedArray}\n     */\n    renderIntoBuffer() {\n        const ret = wasm.qrcode_renderIntoBuffer(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n}\n\nconst QrCodeDataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_qrcodedata_free(ptr >>> 0, 1));\n/**\n * Data for the QR code login mechanism.\n *\n * The {@link QrCodeData} can be serialized and encoded as a QR code or it can\n * be decoded from a QR code.\n */\nclass QrCodeData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(QrCodeData.prototype);\n        obj.__wbg_ptr = ptr;\n        QrCodeDataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        QrCodeDataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_qrcodedata_free(ptr, 0);\n    }\n    /**\n     * Create new {@link QrCodeData} from a given public key, a rendezvous URL\n     * and, optionally, a server name for the homeserver.\n     *\n     * If a server name is given, then the {@link QrCodeData} mode will be\n     * {@link QrCodeMode.Reciprocate}, i.e. the QR code will contain data for\n     * the existing device to display the QR code.\n     *\n     * If no server name is given, the {@link QrCodeData} mode will be\n     * {@link QrCodeMode.Login}, i.e. the QR code will contain data for the\n     * new device to display the QR code.\n     * @param {Curve25519PublicKey} public_key\n     * @param {string} rendezvous_url\n     * @param {string | undefined} [server_name]\n     */\n    constructor(public_key, rendezvous_url, server_name) {\n        _assertClass(public_key, Curve25519PublicKey);\n        var ptr0 = public_key.__destroy_into_raw();\n        const ptr1 = passStringToWasm0(rendezvous_url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(server_name) ? 0 : passStringToWasm0(server_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        const ret = wasm.qrcodedata_new(ptr0, ptr1, len1, ptr2, len2);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        QrCodeDataFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Attempt to decode a slice of bytes into a {@link QrCodeData} object.\n     *\n     * The slice of bytes would generally be returned by a QR code decoder.\n     * @param {Uint8Array} bytes\n     * @returns {QrCodeData}\n     */\n    static fromBytes(bytes) {\n        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.qrcodedata_fromBytes(ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return QrCodeData.__wrap(ret[0]);\n    }\n    /**\n     * Encode the {@link QrCodeData} into a list of bytes.\n     *\n     * The list of bytes can be used by a QR code generator to create an image\n     * containing a QR code.\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        const ret = wasm.qrcodedata_toBytes(this.__wbg_ptr);\n        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        return v1;\n    }\n    /**\n     * Attempt to decode a base64 encoded string into a {@link QrCodeData}\n     * object.\n     * @param {string} data\n     * @returns {QrCodeData}\n     */\n    static fromBase64(data) {\n        const ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.qrcodedata_fromBase64(ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return QrCodeData.__wrap(ret[0]);\n    }\n    /**\n     * Encode the {@link QrCodeData} into a string using base64.\n     *\n     * This format can be used for debugging purposes and the\n     * [`QrcodeData::from_base64()`] method can be used to parse the string\n     * again.\n     * @returns {string}\n     */\n    toBase64() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.qrcodedata_toBase64(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the Curve25519 public key embedded in the {@link QrCodeData}.\n     *\n     * This Curve25519 public key should be used to establish an\n     * [ECIES](https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme)\n     * (Elliptic Curve Integrated Encryption Scheme) channel with the other\n     * device.\n     * @returns {Curve25519PublicKey}\n     */\n    get publicKey() {\n        const ret = wasm.qrcodedata_publicKey(this.__wbg_ptr);\n        return Curve25519PublicKey.__wrap(ret);\n    }\n    /**\n     * Get the URL of the rendezvous server which will be used to exchange\n     * messages between the two devices.\n     * @returns {string}\n     */\n    get rendezvousUrl() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.qrcodedata_rendezvousUrl(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the server name of the homeserver which the new device will be\n     * logged in to.\n     *\n     * This will be only available if the existing device has generated the QR\n     * code and the new device is the one scanning the QR code.\n     * @returns {string | undefined}\n     */\n    get serverName() {\n        const ret = wasm.qrcodedata_serverName(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * Get the mode of this {@link QrCodeData} instance.\n     * @returns {QrCodeMode}\n     */\n    get mode() {\n        const ret = wasm.qrcodedata_mode(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst QrCodeScanFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_qrcodescan_free(ptr >>> 0, 1));\n/**\n * A scanned QR code.\n */\nclass QrCodeScan {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(QrCodeScan.prototype);\n        obj.__wbg_ptr = ptr;\n        QrCodeScanFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        QrCodeScanFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_qrcodescan_free(ptr, 0);\n    }\n    /**\n     * Parse the decoded payload of a QR code in byte slice form.\n     *\n     * This method is useful if you would like to do your own custom QR code\n     * decoding.\n     * @param {Uint8ClampedArray} buffer\n     * @returns {QrCodeScan}\n     */\n    static fromBytes(buffer) {\n        const ret = wasm.qrcodescan_fromBytes(buffer);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return QrCodeScan.__wrap(ret[0]);\n    }\n}\n\nconst RehydratedDeviceFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rehydrateddevice_free(ptr >>> 0, 1));\n/**\n * A rehydrated device\n *\n * This device can receive to-device events to get room keys that were send to\n * it.\n */\nclass RehydratedDevice {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RehydratedDevice.prototype);\n        obj.__wbg_ptr = ptr;\n        RehydratedDeviceFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RehydratedDeviceFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rehydrateddevice_free(ptr, 0);\n    }\n    /**\n     * Receive the to-device events that sent to the dehydrated device\n     *\n     * The rehydrated device will decrypt the events and pass the room keys\n     * into the `OlmMachine`.\n     *\n     * `to_device_events` is a JSON-encoded result of the `events` array from\n     * `/dehydrated_device/{device_id}/events`.\n     *\n     * Returns an array of `RoomKeyInfo`, indicating the room keys that were\n     * received.\n     * @param {string} to_device_events\n     * @returns {Promise<Array<any>>}\n     */\n    receiveEvents(to_device_events) {\n        const ptr0 = passStringToWasm0(to_device_events, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rehydrateddevice_receiveEvents(this.__wbg_ptr, ptr0, len0);\n        return ret;\n    }\n}\n\nconst RoomIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_roomid_free(ptr >>> 0, 1));\n/**\n * A Matrix [room ID].\n *\n * [room ID]: https://spec.matrix.org/v1.2/appendices/#room-ids-and-event-ids\n */\nclass RoomId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RoomId.prototype);\n        obj.__wbg_ptr = ptr;\n        RoomIdFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof RoomId)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RoomIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_roomid_free(ptr, 0);\n    }\n    /**\n     * Parse/validate and create a new `RoomId`.\n     * @param {string} id\n     */\n    constructor(id) {\n        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.roomid_new(ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        RoomIdFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Return the room ID as a string.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.roomid_toString(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst RoomKeyCountsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_roomkeycounts_free(ptr >>> 0, 1));\n/**\n * Struct holding the number of room keys we have.\n */\nclass RoomKeyCounts {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RoomKeyCounts.prototype);\n        obj.__wbg_ptr = ptr;\n        RoomKeyCountsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RoomKeyCountsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_roomkeycounts_free(ptr, 0);\n    }\n    /**\n     * The total number of room keys.\n     * @returns {number}\n     */\n    get total() {\n        const ret = wasm.__wbg_get_roomkeycounts_total(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The total number of room keys.\n     * @param {number} arg0\n     */\n    set total(arg0) {\n        wasm.__wbg_set_roomkeycounts_total(this.__wbg_ptr, arg0);\n    }\n    /**\n     * The number of backed up room keys.\n     * @returns {number}\n     */\n    get backedUp() {\n        const ret = wasm.__wbg_get_roomkeycounts_backedUp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The number of backed up room keys.\n     * @param {number} arg0\n     */\n    set backedUp(arg0) {\n        wasm.__wbg_set_roomkeycounts_backedUp(this.__wbg_ptr, arg0);\n    }\n}\n\nconst RoomKeyImportResultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_roomkeyimportresult_free(ptr >>> 0, 1));\n/**\n * The result of a call to {@link OlmMachine.importExportedRoomKeys} or\n * {@link OlmMachine.importBackedUpRoomKeys}.\n */\nclass RoomKeyImportResult {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RoomKeyImportResult.prototype);\n        obj.__wbg_ptr = ptr;\n        RoomKeyImportResultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RoomKeyImportResultFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_roomkeyimportresult_free(ptr, 0);\n    }\n    /**\n     * The number of room keys that were imported.\n     * @returns {number}\n     */\n    get importedCount() {\n        const ret = wasm.__wbg_get_roomkeyimportresult_importedCount(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * The total number of room keys that were found in the export.\n     * @returns {number}\n     */\n    get totalCount() {\n        const ret = wasm.__wbg_get_roomkeyimportresult_totalCount(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * The keys that were imported.\n     *\n     * A Map from room id to a Map of the sender key to a Set of session ids.\n     *\n     * Typescript type: `Map<string, Map<string, Set<string>>`.\n     * @returns {Map<any, any>}\n     */\n    keys() {\n        const ret = wasm.roomkeyimportresult_keys(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RoomKeyInfoFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_roomkeyinfo_free(ptr >>> 0, 1));\n/**\n * Information on a room key that has been received or imported.\n */\nclass RoomKeyInfo {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RoomKeyInfo.prototype);\n        obj.__wbg_ptr = ptr;\n        RoomKeyInfoFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RoomKeyInfoFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_roomkeyinfo_free(ptr, 0);\n    }\n    /**\n     * The {@link EncryptionAlgorithm} that this key is used for. Will be one\n     * of the `m.megolm.*` algorithms.\n     * @returns {EncryptionAlgorithm}\n     */\n    get algorithm() {\n        const ret = wasm.roomkeyinfo_algorithm(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The room where the key is used.\n     * @returns {RoomId}\n     */\n    get roomId() {\n        const ret = wasm.roomkeyinfo_roomId(this.__wbg_ptr);\n        return RoomId.__wrap(ret);\n    }\n    /**\n     * The Curve25519 key of the device which initiated the session originally.\n     * @returns {Curve25519PublicKey}\n     */\n    get senderKey() {\n        const ret = wasm.roomkeyinfo_senderKey(this.__wbg_ptr);\n        return Curve25519PublicKey.__wrap(ret);\n    }\n    /**\n     * The ID of the session that the key is for.\n     * @returns {string}\n     */\n    get sessionId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.roomkeyinfo_sessionId(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst RoomKeyWithheldInfoFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_roomkeywithheldinfo_free(ptr >>> 0, 1));\n/**\n * Information on a received `m.room_key.withheld` event.\n */\nclass RoomKeyWithheldInfo {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RoomKeyWithheldInfo.prototype);\n        obj.__wbg_ptr = ptr;\n        RoomKeyWithheldInfoFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RoomKeyWithheldInfoFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_roomkeywithheldinfo_free(ptr, 0);\n    }\n    /**\n     * The User ID of the user that sent us the `m.room_key.withheld` message.\n     * @returns {UserId}\n     */\n    get sender() {\n        const ret = wasm.roomkeywithheldinfo_sender(this.__wbg_ptr);\n        return UserId.__wrap(ret);\n    }\n    /**\n     * The encryption algorithm of the session that is being withheld.\n     * @returns {EncryptionAlgorithm}\n     */\n    get algorithm() {\n        const ret = wasm.roomkeywithheldinfo_algorithm(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The `code` from the `m.room_key.withheld` message, such as\n     * `m.unverified`.\n     * @returns {string}\n     */\n    get withheldCode() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.roomkeywithheldinfo_withheldCode(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The room ID of the session that is being withheld.\n     * @returns {RoomId}\n     */\n    get roomId() {\n        const ret = wasm.roomkeywithheldinfo_roomId(this.__wbg_ptr);\n        return RoomId.__wrap(ret);\n    }\n    /**\n     * The session ID of the session that is being withheld.\n     * @returns {string}\n     */\n    get sessionId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.roomkeywithheldinfo_sessionId(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst RoomMessageRequestFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_roommessagerequest_free(ptr >>> 0, 1));\n/**\n * A customized owned request type for sending out room messages\n * ([specification]).\n *\n * [specification]: https://spec.matrix.org/unstable/client-server-api/#put_matrixclientv3roomsroomidsendeventtypetxnid\n */\nclass RoomMessageRequest {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RoomMessageRequest.prototype);\n        obj.__wbg_ptr = ptr;\n        RoomMessageRequestFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RoomMessageRequestFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_roommessagerequest_free(ptr, 0);\n    }\n    /**\n     * The request ID.\n     * @returns {string}\n     */\n    get id() {\n        const ret = wasm.__wbg_get_roommessagerequest_id(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * A string representing the room to send the event to.\n     * @returns {string}\n     */\n    get room_id() {\n        const ret = wasm.__wbg_get_roommessagerequest_room_id(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * A string representing the transaction ID for this event.\n     *\n     * Clients should generate an ID unique across requests with the same\n     * access token; it will be used by the server to ensure idempotency of\n     * requests.\n     * @returns {string}\n     */\n    get txn_id() {\n        const ret = wasm.__wbg_get_roommessagerequest_txn_id(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * A string representing the type of event to be sent.\n     * @returns {string}\n     */\n    get event_type() {\n        const ret = wasm.__wbg_get_roommessagerequest_event_type(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * A JSON-encoded string containing the message's content.\n     * @returns {string}\n     */\n    get body() {\n        const ret = wasm.__wbg_get_roommessagerequest_body(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Create a new `RoomMessageRequest`.\n     * @param {string} id\n     * @param {string} room_id\n     * @param {string} txn_id\n     * @param {string} event_type\n     * @param {string} content\n     */\n    constructor(id, room_id, txn_id, event_type, content) {\n        const ret = wasm.roommessagerequest_new(id, room_id, txn_id, event_type, content);\n        this.__wbg_ptr = ret >>> 0;\n        RoomMessageRequestFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get its request type.\n     * @returns {RequestType}\n     */\n    get type() {\n        const ret = wasm.roommessagerequest_type(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RoomSettingsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_roomsettings_free(ptr >>> 0, 1));\n/**\n * Room encryption settings which are modified by state events or user options\n */\nclass RoomSettings {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RoomSettings.prototype);\n        obj.__wbg_ptr = ptr;\n        RoomSettingsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RoomSettingsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_roomsettings_free(ptr, 0);\n    }\n    /**\n     * The encryption algorithm that should be used in the room.\n     *\n     * Should be one of the members of {@link EncryptionAlgorithm}.\n     * @returns {EncryptionAlgorithm}\n     */\n    get algorithm() {\n        const ret = wasm.__wbg_get_roomsettings_algorithm(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The encryption algorithm that should be used in the room.\n     *\n     * Should be one of the members of {@link EncryptionAlgorithm}.\n     * @param {EncryptionAlgorithm} arg0\n     */\n    set algorithm(arg0) {\n        wasm.__wbg_set_roomsettings_algorithm(this.__wbg_ptr, arg0);\n    }\n    /**\n     * Whether untrusted devices should receive room keys. If this is `false`,\n     * they will be excluded from the conversation.\n     * @returns {boolean}\n     */\n    get onlyAllowTrustedDevices() {\n        const ret = wasm.__wbg_get_roomsettings_onlyAllowTrustedDevices(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Whether untrusted devices should receive room keys. If this is `false`,\n     * they will be excluded from the conversation.\n     * @param {boolean} arg0\n     */\n    set onlyAllowTrustedDevices(arg0) {\n        wasm.__wbg_set_roomsettings_onlyAllowTrustedDevices(this.__wbg_ptr, arg0);\n    }\n    /**\n     * The maximum time, in milliseconds, that an encryption session should be\n     * used for, before it is rotated.\n     * @returns {number | undefined}\n     */\n    get sessionRotationPeriodMs() {\n        const ret = wasm.__wbg_get_roomsettings_sessionRotationPeriodMs(this.__wbg_ptr);\n        return ret[0] === 0 ? undefined : ret[1];\n    }\n    /**\n     * The maximum time, in milliseconds, that an encryption session should be\n     * used for, before it is rotated.\n     * @param {number | undefined} [arg0]\n     */\n    set sessionRotationPeriodMs(arg0) {\n        wasm.__wbg_set_roomsettings_sessionRotationPeriodMs(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? 0 : arg0);\n    }\n    /**\n     * The maximum number of messages an encryption session should be used for,\n     * before it is rotated.\n     * @returns {number | undefined}\n     */\n    get sessionRotationPeriodMessages() {\n        const ret = wasm.__wbg_get_roomsettings_sessionRotationPeriodMessages(this.__wbg_ptr);\n        return ret[0] === 0 ? undefined : ret[1];\n    }\n    /**\n     * The maximum number of messages an encryption session should be used for,\n     * before it is rotated.\n     * @param {number | undefined} [arg0]\n     */\n    set sessionRotationPeriodMessages(arg0) {\n        wasm.__wbg_set_roomsettings_sessionRotationPeriodMessages(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? 0 : arg0);\n    }\n    /**\n     * Create a new `RoomSettings` with default values.\n     */\n    constructor() {\n        const ret = wasm.roomsettings_new();\n        this.__wbg_ptr = ret >>> 0;\n        RoomSettingsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\n\nconst SasFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_sas_free(ptr >>> 0, 1));\n/**\n * Short Authentication String (SAS) verification.\n */\nclass Sas {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Sas.prototype);\n        obj.__wbg_ptr = ptr;\n        SasFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SasFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_sas_free(ptr, 0);\n    }\n    /**\n     * Get our own user ID.\n     * @returns {UserId}\n     */\n    get userId() {\n        const ret = wasm.sas_userId(this.__wbg_ptr);\n        return UserId.__wrap(ret);\n    }\n    /**\n     * Get our own device ID.\n     * @returns {DeviceId}\n     */\n    get deviceId() {\n        const ret = wasm.sas_deviceId(this.__wbg_ptr);\n        return DeviceId.__wrap(ret);\n    }\n    /**\n     * Get the user id of the other side.\n     * @returns {UserId}\n     */\n    get otherUserId() {\n        const ret = wasm.sas_otherUserId(this.__wbg_ptr);\n        return UserId.__wrap(ret);\n    }\n    /**\n     * Get the device ID of the other side.\n     * @returns {DeviceId}\n     */\n    get otherDeviceId() {\n        const ret = wasm.sas_otherDeviceId(this.__wbg_ptr);\n        return DeviceId.__wrap(ret);\n    }\n    /**\n     * Get the unique ID that identifies this SAS verification flow,\n     * be either a to-device request ID or a room event ID.\n     * @returns {string}\n     */\n    get flowId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.sas_flowId(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the room ID if the verification is happening inside a\n     * room.\n     * @returns {RoomId | undefined}\n     */\n    get roomId() {\n        const ret = wasm.sas_roomId(this.__wbg_ptr);\n        return ret === 0 ? undefined : RoomId.__wrap(ret);\n    }\n    /**\n     * Does this verification flow support displaying emoji for the\n     * short authentication string?\n     * @returns {boolean}\n     */\n    supportsEmoji() {\n        const ret = wasm.sas_supportsEmoji(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Did this verification flow start from a verification request?\n     * @returns {boolean}\n     */\n    startedFromRequest() {\n        const ret = wasm.sas_startedFromRequest(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Is this a verification that is verifying one of our own\n     * devices?\n     * @returns {boolean}\n     */\n    isSelfVerification() {\n        const ret = wasm.sas_isSelfVerification(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Have we confirmed that the short auth string matches?\n     * @returns {boolean}\n     */\n    haveWeConfirmed() {\n        const ret = wasm.sas_haveWeConfirmed(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Has the verification been accepted by both parties?\n     * @returns {boolean}\n     */\n    hasBeenAccepted() {\n        const ret = wasm.sas_hasBeenAccepted(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get info about the cancellation if the verification flow has\n     * been cancelled.\n     * @returns {CancelInfo | undefined}\n     */\n    cancelInfo() {\n        const ret = wasm.sas_cancelInfo(this.__wbg_ptr);\n        return ret === 0 ? undefined : CancelInfo.__wrap(ret);\n    }\n    /**\n     * True if we initiated the verification flow (ie, we sent the\n     * `m.key.verification.request`).\n     * @returns {boolean}\n     */\n    weStarted() {\n        const ret = wasm.sas_weStarted(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Accept the SAS verification.\n     *\n     * This does nothing (and returns `undefined`) if the verification was\n     * already accepted, otherwise it returns an `OutgoingRequest`\n     * that needs to be sent out.\n     * @returns {any}\n     */\n    accept() {\n        const ret = wasm.sas_accept(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Confirm the SAS verification.\n     *\n     * This confirms that the short auth strings match on both sides.\n     *\n     * Does nothing if were not in a state where we can confirm the\n     * short auth string.\n     *\n     * Returns a `Promise` for an array of `OutgoingRequest`s.\n     * @returns {Promise<any>}\n     */\n    confirm() {\n        const ret = wasm.sas_confirm(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Cancel the verification.\n     *\n     * Returns either an `OutgoingRequest` which should be sent out, or\n     * `undefined` if the verification is already cancelled.\n     * @returns {any}\n     */\n    cancel() {\n        const ret = wasm.sas_cancel(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Cancel the verification.\n     *\n     * This cancels the verification with given code (e.g. `m.user`).\n     *\n     * Returns either an `OutgoingRequest` which should be sent out, or\n     * `undefined` if the verification is already cancelled.\n     * @param {string} code\n     * @returns {any}\n     */\n    cancelWithCode(code) {\n        const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.sas_cancelWithCode(this.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Has the SAS verification flow timed out?\n     * @returns {boolean}\n     */\n    timedOut() {\n        const ret = wasm.sas_timedOut(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Are we in a state where we can show the short auth string?\n     * @returns {boolean}\n     */\n    canBePresented() {\n        const ret = wasm.sas_canBePresented(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Is the SAS flow done?\n     * @returns {boolean}\n     */\n    isDone() {\n        const ret = wasm.sas_isDone(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Is the SAS flow cancelled?\n     * @returns {boolean}\n     */\n    isCancelled() {\n        const ret = wasm.sas_isCancelled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get the emoji version of the short auth string.\n     *\n     * Returns `undefined` if we can't yet present the short auth string,\n     * otherwise an array of seven `Emoji` objects.\n     * @returns {(Emoji)[] | undefined}\n     */\n    emoji() {\n        const ret = wasm.sas_emoji(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n        }\n        return v1;\n    }\n    /**\n     * Get the index of the emoji representing the short auth string\n     *\n     * Returns `undefined` if we cant yet present the short auth\n     * string, otherwise seven `u8` numbers in the range from 0 to 63\n     * inclusive which can be converted to an emoji using [the\n     * relevant specification\n     * entry](https://spec.matrix.org/unstable/client-server-api/#sas-method-emoji).\n     * @returns {Uint8Array | undefined}\n     */\n    emojiIndex() {\n        const ret = wasm.sas_emojiIndex(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * Get the decimal version of the short auth string.\n     *\n     * Returns None if we cant yet present the short auth string,\n     * otherwise a tuple containing three 4-digit integers that\n     * represent the short auth string.\n     * @returns {Uint16Array | undefined}\n     */\n    decimals() {\n        const ret = wasm.sas_decimals(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getArrayU16FromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n        }\n        return v1;\n    }\n    /**\n     * Register a callback which will be called whenever there is an update to\n     * the request.\n     *\n     * The `callback` is called with no parameters.\n     * @param {Function} callback\n     */\n    registerChangesCallback(callback) {\n        wasm.sas_registerChangesCallback(this.__wbg_ptr, callback);\n    }\n}\n\nconst SecretsBundleFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_secretsbundle_free(ptr >>> 0, 1));\n/**\n * Struct containing the bundle of secrets to fully activate a new device for\n * end-to-end encryption.\n */\nclass SecretsBundle {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SecretsBundle.prototype);\n        obj.__wbg_ptr = ptr;\n        SecretsBundleFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SecretsBundleFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secretsbundle_free(ptr, 0);\n    }\n    /**\n     * The seed of the master key encoded as unpadded base64.\n     * @returns {string}\n     */\n    get masterKey() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.secretsbundle_masterKey(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The seed of the self signing key encoded as unpadded base64.\n     * @returns {string}\n     */\n    get selfSigningKey() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.secretsbundle_selfSigningKey(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The seed of the user signing key encoded as unpadded base64.\n     * @returns {string}\n     */\n    get userSigningKey() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.secretsbundle_userSigningKey(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The bundle of the backup decryption key and backup version if any.\n     * @returns {BackupSecretsBundle | undefined}\n     */\n    get backupBundle() {\n        const ret = wasm.secretsbundle_backupBundle(this.__wbg_ptr);\n        return ret === 0 ? undefined : BackupSecretsBundle.__wrap(ret);\n    }\n    /**\n     * Serialize the [`SecretsBundle`] to a JSON object.\n     * @returns {any}\n     */\n    to_json() {\n        const ret = wasm.secretsbundle_to_json(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Deserialize the [`SecretsBundle`] from a JSON object.\n     * @param {any} json\n     * @returns {SecretsBundle}\n     */\n    static from_json(json) {\n        const ret = wasm.secretsbundle_from_json(json);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return SecretsBundle.__wrap(ret[0]);\n    }\n}\n\nconst ServerNameFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_servername_free(ptr >>> 0, 1));\n/**\n * A Matrix-spec compliant [server name].\n *\n * It consists of a host and an optional port (separated by a colon if\n * present).\n *\n * [server name]: https://spec.matrix.org/v1.2/appendices/#server-name\n */\nclass ServerName {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ServerName.prototype);\n        obj.__wbg_ptr = ptr;\n        ServerNameFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ServerNameFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_servername_free(ptr, 0);\n    }\n    /**\n     * Parse/validate and create a new `ServerName`.\n     * @param {string} name\n     */\n    constructor(name) {\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.servername_new(ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        ServerNameFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Returns the host of the server name.\n     *\n     * That is: Return the part of the server before `:<port>` or the\n     * full server name if there is no port.\n     * @returns {string}\n     */\n    get host() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.servername_host(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the port of the server name if any.\n     * @returns {number | undefined}\n     */\n    get port() {\n        const ret = wasm.servername_port(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n     * Returns true if and only if the server name is an IPv4 or IPv6\n     * address.\n     * @returns {boolean}\n     */\n    isIpLiteral() {\n        const ret = wasm.servername_isIpLiteral(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst ShieldStateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_shieldstate_free(ptr >>> 0, 1));\n/**\n * Take a look at [`matrix_sdk_common::deserialized_responses::ShieldState`]\n * for more info.\n */\nclass ShieldState {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ShieldState.prototype);\n        obj.__wbg_ptr = ptr;\n        ShieldStateFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ShieldStateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_shieldstate_free(ptr, 0);\n    }\n    /**\n     * The shield color\n     * @returns {ShieldColor}\n     */\n    get color() {\n        const ret = wasm.__wbg_get_shieldstate_color(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The shield color\n     * @param {ShieldColor} arg0\n     */\n    set color(arg0) {\n        wasm.__wbg_set_shieldstate_color(this.__wbg_ptr, arg0);\n    }\n    /**\n     * A machine-readable representation of the authenticity for a\n     * `ShieldState`.\n     * @returns {ShieldStateCode | undefined}\n     */\n    get code() {\n        const ret = wasm.__wbg_get_shieldstate_code(this.__wbg_ptr);\n        return ret === 6 ? undefined : ret;\n    }\n    /**\n     * A machine-readable representation of the authenticity for a\n     * `ShieldState`.\n     * @param {ShieldStateCode | undefined} [arg0]\n     */\n    set code(arg0) {\n        wasm.__wbg_set_shieldstate_code(this.__wbg_ptr, isLikeNone(arg0) ? 6 : arg0);\n    }\n    /**\n     * Error message that can be displayed as a tooltip\n     * @returns {string | undefined}\n     */\n    get message() {\n        const ret = wasm.shieldstate_message(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n}\n\nconst SignatureFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_signature_free(ptr >>> 0, 1));\n/**\n * Represents a potentially decoded signature (but not a validated\n * one).\n */\nclass Signature {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Signature.prototype);\n        obj.__wbg_ptr = ptr;\n        SignatureFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SignatureFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signature_free(ptr, 0);\n    }\n    /**\n     * Get the Ed25519 signature, if this is one.\n     * @returns {Ed25519Signature | undefined}\n     */\n    get ed25519() {\n        const ret = wasm.signature_ed25519(this.__wbg_ptr);\n        return ret === 0 ? undefined : Ed25519Signature.__wrap(ret);\n    }\n    /**\n     * Convert the signature to a base64 encoded string.\n     * @returns {string}\n     */\n    toBase64() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.signature_toBase64(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst SignatureUploadRequestFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_signatureuploadrequest_free(ptr >>> 0, 1));\n/**\n * Data for a request to the `/keys/signatures/upload` API endpoint\n * ([specification]).\n *\n * Publishes cross-signing signatures for the user.\n *\n * [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keyssignaturesupload\n */\nclass SignatureUploadRequest {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SignatureUploadRequest.prototype);\n        obj.__wbg_ptr = ptr;\n        SignatureUploadRequestFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SignatureUploadRequestFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signatureuploadrequest_free(ptr, 0);\n    }\n    /**\n     * The request ID.\n     * Some signature upload will have to an `id` field, some won't.\n     * They have one when they are created automatically during an interactive\n     * verification, otherwise they don't.\n     * @returns {string | undefined}\n     */\n    get id() {\n        const ret = wasm.__wbg_get_signatureuploadrequest_id(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * A JSON-encoded string containing the payload of the request\n     *\n     * It represents the body of the HTTP request.\n     * @returns {string}\n     */\n    get body() {\n        const ret = wasm.__wbg_get_signatureuploadrequest_body(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Create a new `SignatureUploadRequest`.\n     * @param {string} id\n     * @param {string} signed_keys\n     */\n    constructor(id, signed_keys) {\n        const ret = wasm.signatureuploadrequest_new(id, signed_keys);\n        this.__wbg_ptr = ret >>> 0;\n        SignatureUploadRequestFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get its request type.\n     * @returns {RequestType}\n     */\n    get type() {\n        const ret = wasm.signatureuploadrequest_type(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst SignatureVerificationFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_signatureverification_free(ptr >>> 0, 1));\n/**\n * The result of a signature verification of a signed JSON object.\n */\nclass SignatureVerification {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SignatureVerification.prototype);\n        obj.__wbg_ptr = ptr;\n        SignatureVerificationFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SignatureVerificationFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signatureverification_free(ptr, 0);\n    }\n    /**\n     * Give the backup signature state from the current device.\n     * See SignatureState for values\n     * @returns {SignatureState}\n     */\n    get deviceState() {\n        const ret = wasm.signatureverification_deviceState(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Give the backup signature state from the current user identity.\n     * See SignatureState for values\n     * @returns {SignatureState}\n     */\n    get userState() {\n        const ret = wasm.signatureverification_userState(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Is the result considered to be trusted?\n     *\n     * This tells us if the result has a valid signature from any of the\n     * following:\n     *\n     * * Our own device\n     * * Our own user identity, provided the identity is trusted as well\n     * * Any of our own devices, provided the device is trusted as well\n     * @returns {boolean}\n     */\n    trusted() {\n        const ret = wasm.signatureverification_trusted(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst SignaturesFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_signatures_free(ptr >>> 0, 1));\n/**\n * A collection of `Signature`.\n */\nclass Signatures {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Signatures.prototype);\n        obj.__wbg_ptr = ptr;\n        SignaturesFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SignaturesFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signatures_free(ptr, 0);\n    }\n    /**\n     * Creates a new, empty, signatures collection.\n     */\n    constructor() {\n        const ret = wasm.signatures_new();\n        this.__wbg_ptr = ret >>> 0;\n        SignaturesFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Add the given signature from the given signer and the given key ID to\n     * the collection.\n     * @param {UserId} signer\n     * @param {DeviceKeyId} key_id\n     * @param {Ed25519Signature} signature\n     * @returns {MaybeSignature | undefined}\n     */\n    addSignature(signer, key_id, signature) {\n        _assertClass(signer, UserId);\n        _assertClass(key_id, DeviceKeyId);\n        _assertClass(signature, Ed25519Signature);\n        const ret = wasm.signatures_addSignature(this.__wbg_ptr, signer.__wbg_ptr, key_id.__wbg_ptr, signature.__wbg_ptr);\n        return ret === 0 ? undefined : MaybeSignature.__wrap(ret);\n    }\n    /**\n     * Try to find an Ed25519 signature from the given signer with\n     * the given key ID.\n     * @param {UserId} signer\n     * @param {DeviceKeyId} key_id\n     * @returns {Ed25519Signature | undefined}\n     */\n    getSignature(signer, key_id) {\n        _assertClass(signer, UserId);\n        _assertClass(key_id, DeviceKeyId);\n        const ret = wasm.signatures_getSignature(this.__wbg_ptr, signer.__wbg_ptr, key_id.__wbg_ptr);\n        return ret === 0 ? undefined : Ed25519Signature.__wrap(ret);\n    }\n    /**\n     * Get the map of signatures that belong to the given user.\n     * @param {UserId} signer\n     * @returns {Map<any, any> | undefined}\n     */\n    get(signer) {\n        _assertClass(signer, UserId);\n        const ret = wasm.signatures_get(this.__wbg_ptr, signer.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Remove all the signatures we currently hold.\n     */\n    clear() {\n        wasm.signatures_clear(this.__wbg_ptr);\n    }\n    /**\n     * Do we hold any signatures or is our collection completely\n     * empty.\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.signatures_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * How many signatures do we currently hold.\n     * @returns {number}\n     */\n    get count() {\n        const ret = wasm.signatures_count(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Get the json with all signatures\n     * @returns {string}\n     */\n    asJSON() {\n        const ret = wasm.signatures_asJSON(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n}\n\nconst StoreHandleFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_storehandle_free(ptr >>> 0, 1));\n/**\n * A struct containing an open connection to a CryptoStore.\n *\n * Opening the CryptoStore can take some time, due to the PBKDF calculation\n * involved, so if multiple operations are being done on the same store, it is\n * more efficient to open it once.\n */\nclass StoreHandle {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(StoreHandle.prototype);\n        obj.__wbg_ptr = ptr;\n        StoreHandleFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        StoreHandleFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_storehandle_free(ptr, 0);\n    }\n    /**\n     * Open a crypto store.\n     *\n     * The created store will be based on IndexedDB if a `store_name` is\n     * provided; otherwise it will be based on a memory store and once the\n     * objects is dropped, the keys will be lost.\n     *\n     * # Arguments\n     *\n     * * `store_name` - The name that should be used to open the IndexedDB\n     *   based database. If this isn't provided, a memory-only store will be\n     *   used. *Note* the memory-only store will lose your E2EE keys when the\n     *   `StoreHandle` gets dropped.\n     *\n     * * `store_passphrase` - The passphrase that should be used to encrypt the\n     *   store, for IndexedDB-based stores\n     * @param {string | undefined} [store_name]\n     * @param {string | undefined} [store_passphrase]\n     * @returns {Promise<StoreHandle>}\n     */\n    static open(store_name, store_passphrase) {\n        var ptr0 = isLikeNone(store_name) ? 0 : passStringToWasm0(store_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(store_passphrase) ? 0 : passStringToWasm0(store_passphrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        const ret = wasm.storehandle_open(ptr0, len0, ptr1, len1);\n        return ret;\n    }\n    /**\n     * Open a crypto store based on IndexedDB, using the given key for\n     * encryption.\n     *\n     * # Arguments\n     *\n     * * `store_name` - The name that should be used to open the IndexedDB\n     *   based database.\n     *\n     * * `store_key` - The key that should be used to encrypt the store, for\n     *   IndexedDB-based stores. Must be a 32-byte array.\n     * @param {string} store_name\n     * @param {Uint8Array} store_key\n     * @returns {Promise<StoreHandle>}\n     */\n    static openWithKey(store_name, store_key) {\n        const ptr0 = passStringToWasm0(store_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray8ToWasm0(store_key, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.storehandle_openWithKey(ptr0, len0, ptr1, len1);\n        return ret;\n    }\n}\n\nconst ToDeviceRequestFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_todevicerequest_free(ptr >>> 0, 1));\n/**\n * Data for a request to the `/sendToDevice` API endpoint\n * ([specification]).\n *\n * Send an event to a single device or to a group of devices.\n *\n * [specification]: https://spec.matrix.org/unstable/client-server-api/#put_matrixclientv3sendtodeviceeventtypetxnid\n */\nclass ToDeviceRequest {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ToDeviceRequest.prototype);\n        obj.__wbg_ptr = ptr;\n        ToDeviceRequestFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ToDeviceRequestFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_todevicerequest_free(ptr, 0);\n    }\n    /**\n     * The request ID.\n     * For to-device request this would be the same value as `txn_id`. It is\n     * exposed also as `id` so that the js bindings are consistent with the\n     * other request types by using this field to mark as sent.\n     * @returns {string}\n     */\n    get id() {\n        const ret = wasm.__wbg_get_todevicerequest_id(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * A string representing the type of event being sent to each devices.\n     * @returns {string}\n     */\n    get event_type() {\n        const ret = wasm.__wbg_get_todevicerequest_event_type(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * A string representing a request identifier unique to the access token\n     * used to send the request.\n     * @returns {string}\n     */\n    get txn_id() {\n        const ret = wasm.__wbg_get_todevicerequest_txn_id(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * A JSON-encoded string containing the rest of the payload: `messages`.\n     *\n     * It represents the body of the HTTP request.\n     * @returns {string}\n     */\n    get body() {\n        const ret = wasm.__wbg_get_todevicerequest_body(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Create a new `ToDeviceRequest`.\n     * @param {string} id\n     * @param {string} event_type\n     * @param {string} txn_id\n     * @param {string} body\n     */\n    constructor(id, event_type, txn_id, body) {\n        const ret = wasm.todevicerequest_new(id, event_type, txn_id, body);\n        this.__wbg_ptr = ret >>> 0;\n        ToDeviceRequestFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get its request type.\n     * @returns {RequestType}\n     */\n    get type() {\n        const ret = wasm.todevicerequest_type(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst TracingFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_tracing_free(ptr >>> 0, 1));\n/**\n * Type to install and to manipulate the tracing layer.\n */\nclass Tracing {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TracingFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tracing_free(ptr, 0);\n    }\n    /**\n     * Check whether the `tracing` feature has been enabled.\n     *\n     * @deprecated: `tracing` is now always enabled.\n     * @returns {boolean}\n     */\n    static isAvailable() {\n        const ret = wasm.tracing_isAvailable();\n        return ret !== 0;\n    }\n    /**\n     * Install the tracing layer.\n     * @param {LoggerLevel} min_level\n     */\n    constructor(min_level) {\n        const ret = wasm.tracing_new(min_level);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        TracingFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Re-define the minimum logger level.\n     * @param {LoggerLevel} min_level\n     */\n    set minLevel(min_level) {\n        const ret = wasm.tracing_set_minLevel(this.__wbg_ptr, min_level);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * Turn the logger on, i.e. it emits logs again if it was turned\n     * off.\n     */\n    turnOn() {\n        const ret = wasm.tracing_turnOn(this.__wbg_ptr);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * Turn the logger off, i.e. it no longer emits logs.\n     */\n    turnOff() {\n        const ret = wasm.tracing_turnOff(this.__wbg_ptr);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n}\n\nconst UploadSigningKeysRequestFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_uploadsigningkeysrequest_free(ptr >>> 0, 1));\n/**\n * Other Requests *\n * Request that will publish a cross signing identity.\n *\n * This uploads the public cross signing key triplet.\n */\nclass UploadSigningKeysRequest {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(UploadSigningKeysRequest.prototype);\n        obj.__wbg_ptr = ptr;\n        UploadSigningKeysRequestFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        UploadSigningKeysRequestFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_uploadsigningkeysrequest_free(ptr, 0);\n    }\n    /**\n     * A JSON-encoded string containing the rest of the payload: `master_key`,\n     * `self_signing_key`, `user_signing_key`.\n     *\n     * It represents the body of the HTTP request.\n     * @returns {string}\n     */\n    get body() {\n        const ret = wasm.__wbg_get_uploadsigningkeysrequest_body(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Create a new `UploadSigningKeysRequest`.\n     * @param {string} body\n     */\n    constructor(body) {\n        const ret = wasm.uploadsigningkeysrequest_new(body);\n        this.__wbg_ptr = ret >>> 0;\n        UploadSigningKeysRequestFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\n\nconst UserDevicesFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_userdevices_free(ptr >>> 0, 1));\n/**\n * A read only view over all devices belonging to a user.\n */\nclass UserDevices {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(UserDevices.prototype);\n        obj.__wbg_ptr = ptr;\n        UserDevicesFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        UserDevicesFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_userdevices_free(ptr, 0);\n    }\n    /**\n     * Get the specific device with the given device ID.\n     * @param {DeviceId} device_id\n     * @returns {Device | undefined}\n     */\n    get(device_id) {\n        _assertClass(device_id, DeviceId);\n        const ret = wasm.userdevices_get(this.__wbg_ptr, device_id.__wbg_ptr);\n        return ret === 0 ? undefined : Device.__wrap(ret);\n    }\n    /**\n     * Returns true if there is at least one devices of this user\n     * that is considered to be verified, false otherwise.\n     *\n     * This won't consider your own device as verified, as your own\n     * device is always implicitly verified.\n     * @returns {boolean}\n     */\n    isAnyVerified() {\n        const ret = wasm.userdevices_isAnyVerified(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Array over all the device IDs of the user devices.\n     * @returns {Array<any>}\n     */\n    keys() {\n        const ret = wasm.userdevices_keys(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Iterator over all the devices of the user devices.\n     * @returns {Array<any>}\n     */\n    devices() {\n        const ret = wasm.userdevices_devices(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst UserIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_userid_free(ptr >>> 0, 1));\n/**\n * A Matrix [user ID].\n *\n * [user ID]: https://spec.matrix.org/v1.2/appendices/#user-identifiers\n */\nclass UserId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(UserId.prototype);\n        obj.__wbg_ptr = ptr;\n        UserIdFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof UserId)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        UserIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_userid_free(ptr, 0);\n    }\n    /**\n     * Parse/validate and create a new `UserId`.\n     * @param {string} id\n     */\n    constructor(id) {\n        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.userid_new(ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        UserIdFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Returns the user's localpart.\n     * @returns {string}\n     */\n    get localpart() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.userid_localpart(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the server name of the user ID.\n     * @returns {ServerName}\n     */\n    get serverName() {\n        const ret = wasm.userid_serverName(this.__wbg_ptr);\n        return ServerName.__wrap(ret);\n    }\n    /**\n     * Whether this user ID is a historical one.\n     *\n     * A historical user ID is one that doesn't conform to the latest\n     * specification of the user ID grammar but is still accepted\n     * because it was previously allowed.\n     * @returns {boolean}\n     */\n    isHistorical() {\n        const ret = wasm.userid_isHistorical(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Return the user ID as a string.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.userid_toString(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create a clone of this `UserId`.\n     *\n     * This can be useful when passing a `UserId` instance to methods such as\n     * {@link OlmMachine.updateTrackedUsers} which destroy the instance.\n     * @returns {UserId}\n     */\n    clone() {\n        const ret = wasm.userid_clone(this.__wbg_ptr);\n        return UserId.__wrap(ret);\n    }\n}\n\nconst VerificationRequestFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_verificationrequest_free(ptr >>> 0, 1));\n/**\n * An object controlling key verification requests.\n *\n * Interactive verification flows usually start with a verification\n * request, this object lets you send and reply to such a\n * verification request.\n *\n * After the initial handshake the verification flow transitions into\n * one of the verification methods.\n */\nclass VerificationRequest {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VerificationRequest.prototype);\n        obj.__wbg_ptr = ptr;\n        VerificationRequestFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        VerificationRequestFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_verificationrequest_free(ptr, 0);\n    }\n    /**\n     * Create an event content that can be sent as a room event to\n     * request verification from the other side. This should be used\n     * only for verifications of other users and it should be sent to\n     * a room we consider to be a DM with the other user.\n     * @param {UserId} own_user_id\n     * @param {DeviceId} own_device_id\n     * @param {UserId} other_user_id\n     * @param {any[] | undefined} [methods]\n     * @returns {string}\n     */\n    static request(own_user_id, own_device_id, other_user_id, methods) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            _assertClass(own_user_id, UserId);\n            _assertClass(own_device_id, DeviceId);\n            _assertClass(other_user_id, UserId);\n            var ptr0 = isLikeNone(methods) ? 0 : passArrayJsValueToWasm0(methods, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            const ret = wasm.verificationrequest_request(own_user_id.__wbg_ptr, own_device_id.__wbg_ptr, other_user_id.__wbg_ptr, ptr0, len0);\n            var ptr2 = ret[0];\n            var len2 = ret[1];\n            if (ret[3]) {\n                ptr2 = 0; len2 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n     * Our own user id.\n     * @returns {UserId}\n     */\n    get ownUserId() {\n        const ret = wasm.verificationrequest_ownUserId(this.__wbg_ptr);\n        return UserId.__wrap(ret);\n    }\n    /**\n     * The ID of the other user that is participating in this\n     * verification request.\n     * @returns {UserId}\n     */\n    get otherUserId() {\n        const ret = wasm.verificationrequest_otherUserId(this.__wbg_ptr);\n        return UserId.__wrap(ret);\n    }\n    /**\n     * The ID of the other device that is participating in this\n     * verification.\n     * @returns {DeviceId | undefined}\n     */\n    get otherDeviceId() {\n        const ret = wasm.verificationrequest_otherDeviceId(this.__wbg_ptr);\n        return ret === 0 ? undefined : DeviceId.__wrap(ret);\n    }\n    /**\n     * Get the room ID if the verification is happening inside a\n     * room.\n     * @returns {RoomId | undefined}\n     */\n    get roomId() {\n        const ret = wasm.verificationrequest_roomId(this.__wbg_ptr);\n        return ret === 0 ? undefined : RoomId.__wrap(ret);\n    }\n    /**\n     * Get info about the cancellation if the verification request\n     * has been cancelled.\n     * @returns {CancelInfo | undefined}\n     */\n    get cancelInfo() {\n        const ret = wasm.verificationrequest_cancelInfo(this.__wbg_ptr);\n        return ret === 0 ? undefined : CancelInfo.__wrap(ret);\n    }\n    /**\n     * Has the verification request been answered by another device?\n     * @returns {boolean}\n     */\n    isPassive() {\n        const ret = wasm.verificationrequest_isPassive(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Is the verification request ready to start a verification flow?\n     * @returns {boolean}\n     */\n    isReady() {\n        const ret = wasm.verificationrequest_isReady(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Has the verification flow timed out?\n     * @returns {boolean}\n     */\n    timedOut() {\n        const ret = wasm.verificationrequest_timedOut(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * The number of milliseconds remaining before this verification flow times\n     * out.\n     *\n     * Returns zero if the time has already passed.\n     * @returns {number}\n     */\n    timeRemainingMillis() {\n        const ret = wasm.verificationrequest_timeRemainingMillis(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the supported verification methods of the other side.\n     *\n     * Will be present only if the other side requested the\n     * verification or if were in the ready state.\n     *\n     * # Returns\n     *\n     * `undefined` if we do not yet know the supported methods; otherwise, an\n     * array of `VerificationMethod`s.\n     * @returns {any[] | undefined}\n     */\n    get theirSupportedMethods() {\n        const ret = wasm.verificationrequest_theirSupportedMethods(this.__wbg_ptr);\n        if (ret[3]) {\n            throw takeFromExternrefTable0(ret[2]);\n        }\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n        }\n        return v1;\n    }\n    /**\n     * Get our own supported verification methods that we advertised.\n     *\n     * Will be present only we requested the verification or if were\n     * in the ready state.\n     * @returns {any[] | undefined}\n     */\n    get ourSupportedMethods() {\n        const ret = wasm.verificationrequest_ourSupportedMethods(this.__wbg_ptr);\n        if (ret[3]) {\n            throw takeFromExternrefTable0(ret[2]);\n        }\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n        }\n        return v1;\n    }\n    /**\n     * Get the unique ID of this verification request.\n     * @returns {string}\n     */\n    get flowId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.verificationrequest_flowId(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Is this a verification that is verifying one of our own\n     * devices?\n     * @returns {boolean}\n     */\n    isSelfVerification() {\n        const ret = wasm.verificationrequest_isSelfVerification(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Did we initiate the verification request?\n     * @returns {boolean}\n     */\n    weStarted() {\n        const ret = wasm.verificationrequest_weStarted(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Has the verification flow that was started with this request\n     * finished?\n     * @returns {boolean}\n     */\n    isDone() {\n        const ret = wasm.verificationrequest_isDone(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get the current phase of this request.\n     *\n     * Returns a `VerificationRequestPhase`.\n     * @returns {VerificationRequestPhase}\n     */\n    phase() {\n        const ret = wasm.verificationrequest_phase(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * If this request has transitioned into a concrete verification\n     * flow (and not yet been completed or cancelled), returns a `Verification`\n     * object.\n     *\n     * Returns: a `Sas`, a `Qr`, or `undefined`.\n     * @returns {any}\n     */\n    getVerification() {\n        const ret = wasm.verificationrequest_getVerification(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Register a callback which will be called whenever there is an update to\n     * the request.\n     *\n     * The `callback` is called with no parameters.\n     * @param {Function} callback\n     */\n    registerChangesCallback(callback) {\n        wasm.verificationrequest_registerChangesCallback(this.__wbg_ptr, callback);\n    }\n    /**\n     * Has the verification flow that was started with this request\n     * been cancelled?\n     * @returns {boolean}\n     */\n    isCancelled() {\n        const ret = wasm.verificationrequest_isCancelled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Accept the verification request signaling that our client\n     * supports the given verification methods.\n     *\n     * `methods` represents the methods that we should advertise as\n     * supported by us.\n     *\n     * It returns either a `ToDeviceRequest`, a `RoomMessageRequest`\n     * or `undefined`.\n     * @param {any[]} methods\n     * @returns {any}\n     */\n    acceptWithMethods(methods) {\n        const ptr0 = passArrayJsValueToWasm0(methods, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.verificationrequest_acceptWithMethods(this.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Accept the verification request.\n     *\n     * This method will accept the request and signal that it\n     * supports the `m.sas.v1`, the `m.qr_code.show.v1`, and\n     * `m.reciprocate.v1` method.\n     *\n     * `m.qr_code.show.v1` will only be signaled if the `qrcode`\n     * feature is enabled. This feature is disabled by default. If\n     * it's enabled and QR code scanning should be supported or QR\n     * code showing shouldn't be supported the `accept_with_methods`\n     * method should be used instead.\n     *\n     * It returns either a `ToDeviceRequest`, a `RoomMessageRequest`\n     * or `undefined`.\n     * @returns {any}\n     */\n    accept() {\n        const ret = wasm.verificationrequest_accept(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Cancel the verification request.\n     *\n     * It returns either a `ToDeviceRequest`, a `RoomMessageRequest`\n     * or `undefined`.\n     * @returns {any}\n     */\n    cancel() {\n        const ret = wasm.verificationrequest_cancel(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Transition from this verification request into a SAS verification flow.\n     *\n     * Returns `Promise<[Sas, RoomMessageRequest|ToDeviceRequest] | undefined>`\n     * @returns {Promise<any>}\n     */\n    startSas() {\n        const ret = wasm.verificationrequest_startSas(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Generate a QR code that can be used by another client to start\n     * a QR code based verification.\n     *\n     * Returns a `Qr` or `undefined`.\n     * @returns {Promise<any>}\n     */\n    generateQrCode() {\n        const ret = wasm.verificationrequest_generateQrCode(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Start a QR code verification by providing a scanned QR code\n     * for this verification flow.\n     * @param {QrCodeScan} data\n     * @returns {Promise<any>}\n     */\n    scanQrCode(data) {\n        _assertClass(data, QrCodeScan);\n        const ret = wasm.verificationrequest_scanQrCode(this.__wbg_ptr, data.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst VersionsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_versions_free(ptr >>> 0, 1));\n/**\n * Object containing the versions of the Rust libraries we are using.\n */\nclass Versions {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Versions.prototype);\n        obj.__wbg_ptr = ptr;\n        VersionsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        VersionsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_versions_free(ptr, 0);\n    }\n    /**\n     * The version of the vodozemac crate.\n     * @returns {string}\n     */\n    get vodozemac() {\n        const ret = wasm.__wbg_get_versions_vodozemac(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The version of the matrix-sdk-crypto crate.\n     * @returns {string}\n     */\n    get matrix_sdk_crypto() {\n        const ret = wasm.__wbg_get_versions_matrix_sdk_crypto(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The Git commit hash of the crate's source tree at build time.\n     * @returns {string}\n     */\n    get git_sha() {\n        const ret = wasm.__wbg_get_versions_git_sha(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The build-time output of the `git describe` command of the source tree\n     * of crate.\n     * @returns {string}\n     */\n    get git_description() {\n        const ret = wasm.__wbg_get_versions_git_description(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nfunction __wbg_String_8f0eb39a4a4c2f66(arg0, arg1) {\n    const ret = String(arg1);\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n};\n\nfunction __wbg_String_eecc4a11987127d6(arg0, arg1) {\n    const ret = String(arg1);\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n};\n\nfunction __wbg_Window_b0044ac7db258535(arg0) {\n    const ret = arg0.Window;\n    return ret;\n};\n\nfunction __wbg_WorkerGlobalScope_b74cefefc62a37da(arg0) {\n    const ret = arg0.WorkerGlobalScope;\n    return ret;\n};\n\nfunction __wbg_add_0d9e99fb9c2d2cc5(arg0, arg1) {\n    const ret = arg0.add(arg1);\n    return ret;\n};\n\nfunction __wbg_add_c836e3d4b14cd062() { return handleError(function (arg0, arg1, arg2) {\n    const ret = arg0.add(arg1, arg2);\n    return ret;\n}, arguments) };\n\nfunction __wbg_at_479807bfddde3a33(arg0, arg1) {\n    const ret = arg0.at(arg1);\n    return ret;\n};\n\nfunction __wbg_backupkeys_new(arg0) {\n    const ret = BackupKeys.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_bound_1918c0826c5b9363() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = IDBKeyRange.bound(arg0, arg1, arg2 !== 0, arg3 !== 0);\n    return ret;\n}, arguments) };\n\nfunction __wbg_bound_324dfb8899c9798c() { return handleError(function (arg0, arg1) {\n    const ret = IDBKeyRange.bound(arg0, arg1);\n    return ret;\n}, arguments) };\n\nfunction __wbg_buffer_61b7ce01341d7f88(arg0) {\n    const ret = arg0.buffer;\n    return ret;\n};\n\nfunction __wbg_call_3b770f0d6eb4720e() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = arg0.call(arg1, arg2, arg3);\n    return ret;\n}, arguments) };\n\nfunction __wbg_call_500db948e69c7330() { return handleError(function (arg0, arg1, arg2) {\n    const ret = arg0.call(arg1, arg2);\n    return ret;\n}, arguments) };\n\nfunction __wbg_call_9bd6f269d4835e33() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = arg0.call(arg1, arg2, arg3, arg4);\n    return ret;\n}, arguments) };\n\nfunction __wbg_call_b0d8e36992d9900d() { return handleError(function (arg0, arg1) {\n    const ret = arg0.call(arg1);\n    return ret;\n}, arguments) };\n\nfunction __wbg_clearTimeout_5a54f8841c30079a(arg0) {\n    const ret = clearTimeout(arg0);\n    return ret;\n};\n\nfunction __wbg_clear_da83758e0bea0eb6() { return handleError(function (arg0) {\n    const ret = arg0.clear();\n    return ret;\n}, arguments) };\n\nfunction __wbg_close_f6e618ed8b0326a3(arg0) {\n    arg0.close();\n};\n\nfunction __wbg_code_71136b86e2aa7f41(arg0) {\n    const ret = arg0.code;\n    return ret;\n};\n\nfunction __wbg_continue_bd44561c014cacea() { return handleError(function (arg0) {\n    arg0.continue();\n}, arguments) };\n\nfunction __wbg_count_244aa4118e005b59() { return handleError(function (arg0) {\n    const ret = arg0.count();\n    return ret;\n}, arguments) };\n\nfunction __wbg_count_4df50ef6c1ddd770() { return handleError(function (arg0) {\n    const ret = arg0.count();\n    return ret;\n}, arguments) };\n\nfunction __wbg_createIndex_14571b3c4eec1628() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = arg0.createIndex(getStringFromWasm0(arg1, arg2), arg3);\n    return ret;\n}, arguments) };\n\nfunction __wbg_createIndex_1d4b2bbb6b21b8f8() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = arg0.createIndex(getStringFromWasm0(arg1, arg2), arg3, arg4);\n    return ret;\n}, arguments) };\n\nfunction __wbg_createObjectStore_b6f14aa10f83a300() { return handleError(function (arg0, arg1, arg2) {\n    const ret = arg0.createObjectStore(getStringFromWasm0(arg1, arg2));\n    return ret;\n}, arguments) };\n\nfunction __wbg_crosssigningbootstraprequests_new(arg0) {\n    const ret = CrossSigningBootstrapRequests.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_crosssigningkeyexport_new(arg0) {\n    const ret = CrossSigningKeyExport.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_crosssigningstatus_new(arg0) {\n    const ret = CrossSigningStatus.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_crypto_ed58b8e10a292839(arg0) {\n    const ret = arg0.crypto;\n    return ret;\n};\n\nfunction __wbg_debug_156ca727dbc3150f(arg0) {\n    console.debug(arg0);\n};\n\nfunction __wbg_debug_3acd668e6e6c6087(arg0, arg1) {\n    arg0.debug(arg1);\n};\n\nfunction __wbg_decryptedroomevent_new(arg0) {\n    const ret = DecryptedRoomEvent.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_dehydrateddevice_new(arg0) {\n    const ret = DehydratedDevice.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_dehydrateddevicekey_new(arg0) {\n    const ret = DehydratedDeviceKey.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_deleteObjectStore_1f50ba0263875deb() { return handleError(function (arg0, arg1, arg2) {\n    arg0.deleteObjectStore(getStringFromWasm0(arg1, arg2));\n}, arguments) };\n\nfunction __wbg_delete_5c33e4966f59624d() { return handleError(function (arg0, arg1) {\n    const ret = arg0.delete(arg1);\n    return ret;\n}, arguments) };\n\nfunction __wbg_delete_d97b2b4ff716c553() { return handleError(function (arg0) {\n    const ret = arg0.delete();\n    return ret;\n}, arguments) };\n\nfunction __wbg_device_new(arg0) {\n    const ret = Device.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_deviceid_new(arg0) {\n    const ret = DeviceId.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_devicekey_new(arg0) {\n    const ret = DeviceKey.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_devicekeyid_new(arg0) {\n    const ret = DeviceKeyId.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_done_f22c1561fa919baa(arg0) {\n    const ret = arg0.done;\n    return ret;\n};\n\nfunction __wbg_emoji_new(arg0) {\n    const ret = Emoji.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_encryptioninfo_new(arg0) {\n    const ret = EncryptionInfo.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_entries_4f2bb9b0d701c0f6(arg0) {\n    const ret = Object.entries(arg0);\n    return ret;\n};\n\nfunction __wbg_entries_82bf0e755ef54a5f(arg0) {\n    const ret = arg0.entries();\n    return ret;\n};\n\nfunction __wbg_error_32fda676ae978f6e(arg0, arg1) {\n    arg0.error(arg1);\n};\n\nfunction __wbg_error_7534b8e9a36f1ab4(arg0, arg1) {\n    let deferred0_0;\n    let deferred0_1;\n    try {\n        deferred0_0 = arg0;\n        deferred0_1 = arg1;\n        console.error(getStringFromWasm0(arg0, arg1));\n    } finally {\n        wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n    }\n};\n\nfunction __wbg_error_77233c625ed0c533() { return handleError(function (arg0) {\n    const ret = arg0.error;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n}, arguments) };\n\nfunction __wbg_error_fab41a42d22bf2bc(arg0) {\n    console.error(arg0);\n};\n\nfunction __wbg_from_d68eaa96dba25449(arg0) {\n    const ret = Array.from(arg0);\n    return ret;\n};\n\nfunction __wbg_getAllKeys_ad97dc28822a6891() { return handleError(function (arg0) {\n    const ret = arg0.getAllKeys();\n    return ret;\n}, arguments) };\n\nfunction __wbg_getAll_72e2faaa06d1a8cf() { return handleError(function (arg0) {\n    const ret = arg0.getAll();\n    return ret;\n}, arguments) };\n\nfunction __wbg_getAll_8f38031e5969c7f5() { return handleError(function (arg0, arg1) {\n    const ret = arg0.getAll(arg1);\n    return ret;\n}, arguments) };\n\nfunction __wbg_getAll_8fa84589faccab36() { return handleError(function (arg0, arg1, arg2) {\n    const ret = arg0.getAll(arg1, arg2 >>> 0);\n    return ret;\n}, arguments) };\n\nfunction __wbg_getRandomValues_bcb4912f16000dc4() { return handleError(function (arg0, arg1) {\n    arg0.getRandomValues(arg1);\n}, arguments) };\n\nfunction __wbg_getTime_ab8b72009983c537(arg0) {\n    const ret = arg0.getTime();\n    return ret;\n};\n\nfunction __wbg_get_6a4f854f5cca7403() { return handleError(function (arg0, arg1) {\n    const ret = arg0.get(arg1);\n    return ret;\n}, arguments) };\n\nfunction __wbg_get_7081edc0440983a5() { return handleError(function (arg0, arg1) {\n    const ret = arg0.get(arg1);\n    return ret;\n}, arguments) };\n\nfunction __wbg_get_9aa3dff3f0266054(arg0, arg1) {\n    const ret = arg0[arg1 >>> 0];\n    return ret;\n};\n\nfunction __wbg_get_bbccf8970793c087() { return handleError(function (arg0, arg1) {\n    const ret = Reflect.get(arg0, arg1);\n    return ret;\n}, arguments) };\n\nfunction __wbg_getwithrefkey_1dc361bd10053bfe(arg0, arg1) {\n    const ret = arg0[arg1];\n    return ret;\n};\n\nfunction __wbg_getwithrefkey_6550b2c093d2eb18(arg0, arg1) {\n    const ret = arg0[arg1];\n    return ret;\n};\n\nfunction __wbg_global_b6f5c73312f62313(arg0) {\n    const ret = arg0.global;\n    return ret;\n};\n\nfunction __wbg_inboundgroupsession_new(arg0) {\n    const ret = InboundGroupSession.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_index_871d874253bae760() { return handleError(function (arg0, arg1, arg2) {\n    const ret = arg0.index(getStringFromWasm0(arg1, arg2));\n    return ret;\n}, arguments) };\n\nfunction __wbg_indexedDB_601ec26c63e333de() { return handleError(function (arg0) {\n    const ret = arg0.indexedDB;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n}, arguments) };\n\nfunction __wbg_indexedDB_72e2ca071222fd9e() { return handleError(function (arg0) {\n    const ret = arg0.indexedDB;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n}, arguments) };\n\nfunction __wbg_indexedDB_e34a5e9b3d2fcfa1() { return handleError(function (arg0) {\n    const ret = arg0.indexedDB;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n}, arguments) };\n\nfunction __wbg_info_c3044c86ae29faab(arg0) {\n    console.info(arg0);\n};\n\nfunction __wbg_info_ed71056bef15b91a(arg0, arg1) {\n    arg0.info(arg1);\n};\n\nfunction __wbg_instanceof_ArrayBuffer_670ddde44cdb2602(arg0) {\n    let result;\n    try {\n        result = arg0 instanceof ArrayBuffer;\n    } catch (_) {\n        result = false;\n    }\n    const ret = result;\n    return ret;\n};\n\nfunction __wbg_instanceof_Map_98ecb30afec5acdb(arg0) {\n    let result;\n    try {\n        result = arg0 instanceof Map;\n    } catch (_) {\n        result = false;\n    }\n    const ret = result;\n    return ret;\n};\n\nfunction __wbg_instanceof_Promise_0aa3a90cfe6672c9(arg0) {\n    let result;\n    try {\n        result = arg0 instanceof Promise;\n    } catch (_) {\n        result = false;\n    }\n    const ret = result;\n    return ret;\n};\n\nfunction __wbg_instanceof_Uint8Array_28af5bc19d6acad8(arg0) {\n    let result;\n    try {\n        result = arg0 instanceof Uint8Array;\n    } catch (_) {\n        result = false;\n    }\n    const ret = result;\n    return ret;\n};\n\nfunction __wbg_isArray_1ba11a930108ec51(arg0) {\n    const ret = Array.isArray(arg0);\n    return ret;\n};\n\nfunction __wbg_isSafeInteger_12f5549b2fca23f4(arg0) {\n    const ret = Number.isSafeInteger(arg0);\n    return ret;\n};\n\nfunction __wbg_item_7156a8ffa4d816bc(arg0, arg1, arg2) {\n    const ret = arg1.item(arg2 >>> 0);\n    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len1 = WASM_VECTOR_LEN;\n    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n};\n\nfunction __wbg_iterator_23604bb983791576() {\n    const ret = Symbol.iterator;\n    return ret;\n};\n\nfunction __wbg_key_87db8226759da642() { return handleError(function (arg0) {\n    const ret = arg0.key;\n    return ret;\n}, arguments) };\n\nfunction __wbg_keysbackuprequest_new(arg0) {\n    const ret = KeysBackupRequest.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_keysclaimrequest_new(arg0) {\n    const ret = KeysClaimRequest.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_keysqueryrequest_new(arg0) {\n    const ret = KeysQueryRequest.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_keysuploadrequest_new(arg0) {\n    const ret = KeysUploadRequest.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_length_65d1cd11729ced11(arg0) {\n    const ret = arg0.length;\n    return ret;\n};\n\nfunction __wbg_length_d65cf0786bfc5739(arg0) {\n    const ret = arg0.length;\n    return ret;\n};\n\nfunction __wbg_length_f4d79409aa324811(arg0) {\n    const ret = arg0.length;\n    return ret;\n};\n\nfunction __wbg_lowerBound_3aa47caa33c7e1e6() { return handleError(function (arg0, arg1) {\n    const ret = IDBKeyRange.lowerBound(arg0, arg1 !== 0);\n    return ret;\n}, arguments) };\n\nfunction __wbg_maybesignature_new(arg0) {\n    const ret = MaybeSignature.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_megolmdecryptionerror_new(arg0) {\n    const ret = MegolmDecryptionError.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_message_d19bdb65f0a41cf5(arg0, arg1) {\n    const ret = arg1.message;\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n};\n\nfunction __wbg_msCrypto_0a36e2ec3a343d26(arg0) {\n    const ret = arg0.msCrypto;\n    return ret;\n};\n\nfunction __wbg_name_8862cd49ad807c59(arg0, arg1) {\n    const ret = arg1.name;\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n};\n\nfunction __wbg_new_0f1bd659dcd47068(arg0) {\n    const ret = new Set(arg0);\n    return ret;\n};\n\nfunction __wbg_new_254fa9eac11932ae() {\n    const ret = new Array();\n    return ret;\n};\n\nfunction __wbg_new_3d446df9155128ef(arg0, arg1) {\n    try {\n        var state0 = {a: arg0, b: arg1};\n        var cb0 = (arg0, arg1) => {\n            const a = state0.a;\n            state0.a = 0;\n            try {\n                return __wbg_adapter_758(a, state0.b, arg0, arg1);\n            } finally {\n                state0.a = a;\n            }\n        };\n        const ret = new Promise(cb0);\n        return ret;\n    } finally {\n        state0.a = state0.b = 0;\n    }\n};\n\nfunction __wbg_new_3ff5b33b1ce712df(arg0) {\n    const ret = new Uint8Array(arg0);\n    return ret;\n};\n\nfunction __wbg_new_41257536af60ed14(arg0) {\n    const ret = new Date(arg0);\n    return ret;\n};\n\nfunction __wbg_new_688846f374351c92() {\n    const ret = new Object();\n    return ret;\n};\n\nfunction __wbg_new_8a6f238a6ece86ea() {\n    const ret = new Error();\n    return ret;\n};\n\nfunction __wbg_new_9451f3dcb42e0e37(arg0) {\n    const ret = new Uint8ClampedArray(arg0);\n    return ret;\n};\n\nfunction __wbg_new_bc96c6a1c0786643() {\n    const ret = new Map();\n    return ret;\n};\n\nfunction __wbg_newnoargs_fd9e4bf8be2bc16d(arg0, arg1) {\n    const ret = new Function(getStringFromWasm0(arg0, arg1));\n    return ret;\n};\n\nfunction __wbg_newwithbyteoffsetandlength_ba35896968751d91(arg0, arg1, arg2) {\n    const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);\n    return ret;\n};\n\nfunction __wbg_newwithbyteoffsetandlength_c0c90653f73c7dfb(arg0, arg1, arg2) {\n    const ret = new Uint8ClampedArray(arg0, arg1 >>> 0, arg2 >>> 0);\n    return ret;\n};\n\nfunction __wbg_newwithlength_2aede0ef4e6e97ec(arg0) {\n    const ret = new Uint8ClampedArray(arg0 >>> 0);\n    return ret;\n};\n\nfunction __wbg_newwithlength_34ce8f1051e74449(arg0) {\n    const ret = new Uint8Array(arg0 >>> 0);\n    return ret;\n};\n\nfunction __wbg_newwithmessage_80e6436058862fd4() { return handleError(function (arg0, arg1) {\n    const ret = new DOMException(getStringFromWasm0(arg0, arg1));\n    return ret;\n}, arguments) };\n\nfunction __wbg_next_01dd9234a5bf6d05() { return handleError(function (arg0) {\n    const ret = arg0.next();\n    return ret;\n}, arguments) };\n\nfunction __wbg_next_137428deb98342b0(arg0) {\n    const ret = arg0.next;\n    return ret;\n};\n\nfunction __wbg_node_02999533c4ea02e3(arg0) {\n    const ret = arg0.node;\n    return ret;\n};\n\nfunction __wbg_now_2c95c9de01293173(arg0) {\n    const ret = arg0.now();\n    return ret;\n};\n\nfunction __wbg_now_64d0bb151e5d3889() {\n    const ret = Date.now();\n    return ret;\n};\n\nfunction __wbg_objectStoreNames_cb00c8113b3cf5df(arg0) {\n    const ret = arg0.objectStoreNames;\n    return ret;\n};\n\nfunction __wbg_objectStore_cdbc73ee600a2cfa() { return handleError(function (arg0, arg1, arg2) {\n    const ret = arg0.objectStore(getStringFromWasm0(arg1, arg2));\n    return ret;\n}, arguments) };\n\nfunction __wbg_oldVersion_a31d9f8577239dd8(arg0) {\n    const ret = arg0.oldVersion;\n    return ret;\n};\n\nfunction __wbg_olmmachine_new(arg0) {\n    const ret = OlmMachine.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_openCursor_37e21d9af1a61159() { return handleError(function (arg0) {\n    const ret = arg0.openCursor();\n    return ret;\n}, arguments) };\n\nfunction __wbg_openCursor_da08cc74542711ad() { return handleError(function (arg0, arg1) {\n    const ret = arg0.openCursor(arg1);\n    return ret;\n}, arguments) };\n\nfunction __wbg_openCursor_e7a3f6453a0f6725() { return handleError(function (arg0) {\n    const ret = arg0.openCursor();\n    return ret;\n}, arguments) };\n\nfunction __wbg_open_4588c85c0c43671d() { return handleError(function (arg0, arg1, arg2) {\n    const ret = arg0.open(getStringFromWasm0(arg1, arg2));\n    return ret;\n}, arguments) };\n\nfunction __wbg_open_5c51d4d6d7ab6da6() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = arg0.open(getStringFromWasm0(arg1, arg2), arg3 >>> 0);\n    return ret;\n}, arguments) };\n\nfunction __wbg_otheruseridentity_new(arg0) {\n    const ret = OtherUserIdentity.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_ownuseridentity_new(arg0) {\n    const ret = OwnUserIdentity.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_parse_161c68378e086ae1() { return handleError(function (arg0, arg1) {\n    const ret = JSON.parse(getStringFromWasm0(arg0, arg1));\n    return ret;\n}, arguments) };\n\nfunction __wbg_performance_7a3ffd0b17f663ad(arg0) {\n    const ret = arg0.performance;\n    return ret;\n};\n\nfunction __wbg_pickledinboundgroupsession_unwrap(arg0) {\n    const ret = PickledInboundGroupSession.__unwrap(arg0);\n    return ret;\n};\n\nfunction __wbg_pickledsession_unwrap(arg0) {\n    const ret = PickledSession.__unwrap(arg0);\n    return ret;\n};\n\nfunction __wbg_process_5c1d670bc53614b8(arg0) {\n    const ret = arg0.process;\n    return ret;\n};\n\nfunction __wbg_push_6edad0df4b546b2c(arg0, arg1) {\n    const ret = arg0.push(arg1);\n    return ret;\n};\n\nfunction __wbg_put_5393e88dbe742e8f() { return handleError(function (arg0, arg1, arg2) {\n    const ret = arg0.put(arg1, arg2);\n    return ret;\n}, arguments) };\n\nfunction __wbg_putdehydrateddevicerequest_new(arg0) {\n    const ret = PutDehydratedDeviceRequest.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_qr_new(arg0) {\n    const ret = Qr.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_queueMicrotask_2181040e064c0dc8(arg0) {\n    queueMicrotask(arg0);\n};\n\nfunction __wbg_queueMicrotask_ef9ac43769cbcc4f(arg0) {\n    const ret = arg0.queueMicrotask;\n    return ret;\n};\n\nfunction __wbg_randomFillSync_ab2cfe79ebbf2740() { return handleError(function (arg0, arg1) {\n    arg0.randomFillSync(arg1);\n}, arguments) };\n\nfunction __wbg_readyState_8428fa7c5e093401(arg0) {\n    const ret = arg0.readyState;\n    return (__wbindgen_enum_IdbRequestReadyState.indexOf(ret) + 1 || 3) - 1;\n};\n\nfunction __wbg_rehydrateddevice_new(arg0) {\n    const ret = RehydratedDevice.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_require_79b1e9274cde3c87() { return handleError(function () {\n    const ret = module.require;\n    return ret;\n}, arguments) };\n\nfunction __wbg_resolve_0bf7c44d641804f9(arg0) {\n    const ret = Promise.resolve(arg0);\n    return ret;\n};\n\nfunction __wbg_result_e6ba6a347dcb7470() { return handleError(function (arg0) {\n    const ret = arg0.result;\n    return ret;\n}, arguments) };\n\nfunction __wbg_roomid_unwrap(arg0) {\n    const ret = RoomId.__unwrap(arg0);\n    return ret;\n};\n\nfunction __wbg_roomkeycounts_new(arg0) {\n    const ret = RoomKeyCounts.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_roomkeyimportresult_new(arg0) {\n    const ret = RoomKeyImportResult.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_roomkeyinfo_new(arg0) {\n    const ret = RoomKeyInfo.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_roomkeywithheldinfo_new(arg0) {\n    const ret = RoomKeyWithheldInfo.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_roommessagerequest_new(arg0) {\n    const ret = RoomMessageRequest.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_roomsettings_new(arg0) {\n    const ret = RoomSettings.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_sas_new(arg0) {\n    const ret = Sas.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_secretsbundle_new(arg0) {\n    const ret = SecretsBundle.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_setTimeout_db2dbaeefb6f39c7() { return handleError(function (arg0, arg1) {\n    const ret = setTimeout(arg0, arg1);\n    return ret;\n}, arguments) };\n\nfunction __wbg_set_1d80752d0d5f0b21(arg0, arg1, arg2) {\n    arg0[arg1 >>> 0] = arg2;\n};\n\nfunction __wbg_set_23d69db4e5c66a6e(arg0, arg1, arg2) {\n    arg0.set(arg1, arg2 >>> 0);\n};\n\nfunction __wbg_set_3807d5f0bfc24aa7(arg0, arg1, arg2) {\n    arg0[arg1] = arg2;\n};\n\nfunction __wbg_set_3f1d0b984ed272ed(arg0, arg1, arg2) {\n    arg0[arg1] = arg2;\n};\n\nfunction __wbg_set_76818dc3c59a63d5(arg0, arg1, arg2) {\n    const ret = arg0.set(arg1, arg2);\n    return ret;\n};\n\nfunction __wbg_set_9592f7d5b752cae3(arg0, arg1, arg2) {\n    arg0.set(arg1, arg2 >>> 0);\n};\n\nfunction __wbg_setonabort_ade6cac5c35a572f(arg0, arg1) {\n    arg0.onabort = arg1;\n};\n\nfunction __wbg_setonblocked_d13048be9383f4dc(arg0, arg1) {\n    arg0.onblocked = arg1;\n};\n\nfunction __wbg_setoncomplete_2747fb71ae0af4a8(arg0, arg1) {\n    arg0.oncomplete = arg1;\n};\n\nfunction __wbg_setonerror_72b33e31f9edb045(arg0, arg1) {\n    arg0.onerror = arg1;\n};\n\nfunction __wbg_setonerror_e4beb2652cf66635(arg0, arg1) {\n    arg0.onerror = arg1;\n};\n\nfunction __wbg_setonsuccess_57167b1c2650357c(arg0, arg1) {\n    arg0.onsuccess = arg1;\n};\n\nfunction __wbg_setonupgradeneeded_887c7a5fca66011e(arg0, arg1) {\n    arg0.onupgradeneeded = arg1;\n};\n\nfunction __wbg_setonversionchange_a6f60bd1d110795d(arg0, arg1) {\n    arg0.onversionchange = arg1;\n};\n\nfunction __wbg_setunique_cfc477dc5825e1c4(arg0, arg1) {\n    arg0.unique = arg1 !== 0;\n};\n\nfunction __wbg_signatures_new(arg0) {\n    const ret = Signatures.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_signatureuploadrequest_new(arg0) {\n    const ret = SignatureUploadRequest.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_signatureverification_new(arg0) {\n    const ret = SignatureVerification.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_stack_0ed75d68575b0f3c(arg0, arg1) {\n    const ret = arg1.stack;\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n};\n\nfunction __wbg_static_accessor_GLOBAL_0be7472e492ad3e3() {\n    const ret = typeof __webpack_require__.g === 'undefined' ? null : __webpack_require__.g;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n};\n\nfunction __wbg_static_accessor_GLOBAL_THIS_1a6eb482d12c9bfb() {\n    const ret = typeof globalThis === 'undefined' ? null : globalThis;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n};\n\nfunction __wbg_static_accessor_SELF_1dc398a895c82351() {\n    const ret = typeof self === 'undefined' ? null : self;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n};\n\nfunction __wbg_static_accessor_WINDOW_ae1c80c7eea8d64a() {\n    const ret = typeof window === 'undefined' ? null : window;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n};\n\nfunction __wbg_storehandle_new(arg0) {\n    const ret = StoreHandle.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_stringify_f4f701bc34ceda61() { return handleError(function (arg0) {\n    const ret = JSON.stringify(arg0);\n    return ret;\n}, arguments) };\n\nfunction __wbg_subarray_46adeb9b86949d12(arg0, arg1, arg2) {\n    const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n    return ret;\n};\n\nfunction __wbg_target_a8fe593e7ee79c21(arg0) {\n    const ret = arg0.target;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n};\n\nfunction __wbg_then_0438fad860fe38e1(arg0, arg1) {\n    const ret = arg0.then(arg1);\n    return ret;\n};\n\nfunction __wbg_then_0ffafeddf0e182a4(arg0, arg1, arg2) {\n    const ret = arg0.then(arg1, arg2);\n    return ret;\n};\n\nfunction __wbg_todevicerequest_new(arg0) {\n    const ret = ToDeviceRequest.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_transaction_bc71c2aaaf467420() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = arg0.transaction(getStringFromWasm0(arg1, arg2), __wbindgen_enum_IdbTransactionMode[arg3]);\n    return ret;\n}, arguments) };\n\nfunction __wbg_transaction_d2b6d520837fbe7f(arg0) {\n    const ret = arg0.transaction;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n};\n\nfunction __wbg_transaction_dbab9cd9ea849958() { return handleError(function (arg0, arg1, arg2) {\n    const ret = arg0.transaction(arg1, __wbindgen_enum_IdbTransactionMode[arg2]);\n    return ret;\n}, arguments) };\n\nfunction __wbg_update_211ddccaf2cec6ee() { return handleError(function (arg0, arg1) {\n    const ret = arg0.update(arg1);\n    return ret;\n}, arguments) };\n\nfunction __wbg_userdevices_new(arg0) {\n    const ret = UserDevices.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_userid_new(arg0) {\n    const ret = UserId.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_userid_unwrap(arg0) {\n    const ret = UserId.__unwrap(arg0);\n    return ret;\n};\n\nfunction __wbg_value_0ad6f37677c8ee74() { return handleError(function (arg0) {\n    const ret = arg0.value;\n    return ret;\n}, arguments) };\n\nfunction __wbg_value_4c32fd138a88eee2(arg0) {\n    const ret = arg0.value;\n    return ret;\n};\n\nfunction __wbg_values_7aa03dd078978c86(arg0) {\n    const ret = arg0.values();\n    return ret;\n};\n\nfunction __wbg_verificationrequest_new(arg0) {\n    const ret = VerificationRequest.__wrap(arg0);\n    return ret;\n};\n\nfunction __wbg_version_2b650c9d4f0a2438(arg0) {\n    const ret = arg0.version;\n    return ret;\n};\n\nfunction __wbg_versions_c71aa1626a93e0a1(arg0) {\n    const ret = arg0.versions;\n    return ret;\n};\n\nfunction __wbg_warn_123db6aa8948382e(arg0) {\n    console.warn(arg0);\n};\n\nfunction __wbg_warn_9d038df1589cb1bd(arg0, arg1) {\n    arg0.warn(arg1);\n};\n\nfunction __wbindgen_as_number(arg0) {\n    const ret = +arg0;\n    return ret;\n};\n\nfunction __wbindgen_bigint_from_i64(arg0) {\n    const ret = arg0;\n    return ret;\n};\n\nfunction __wbindgen_bigint_from_u64(arg0) {\n    const ret = BigInt.asUintN(64, arg0);\n    return ret;\n};\n\nfunction __wbindgen_bigint_get_as_i64(arg0, arg1) {\n    const v = arg1;\n    const ret = typeof(v) === 'bigint' ? v : undefined;\n    getDataViewMemory0().setBigInt64(arg0 + 8 * 1, isLikeNone(ret) ? BigInt(0) : ret, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n};\n\nfunction __wbindgen_boolean_get(arg0) {\n    const v = arg0;\n    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nfunction __wbindgen_cb_drop(arg0) {\n    const obj = arg0.original;\n    if (obj.cnt-- == 1) {\n        obj.a = 0;\n        return true;\n    }\n    const ret = false;\n    return ret;\n};\n\nfunction __wbindgen_closure_wrapper1050(arg0, arg1, arg2) {\n    const ret = makeMutClosure(arg0, arg1, 30, __wbg_adapter_58);\n    return ret;\n};\n\nfunction __wbindgen_closure_wrapper2213(arg0, arg1, arg2) {\n    const ret = makeMutClosure(arg0, arg1, 410, __wbg_adapter_61);\n    return ret;\n};\n\nfunction __wbindgen_closure_wrapper5386(arg0, arg1, arg2) {\n    const ret = makeMutClosure(arg0, arg1, 410, __wbg_adapter_64);\n    return ret;\n};\n\nfunction __wbindgen_closure_wrapper6843(arg0, arg1, arg2) {\n    const ret = makeClosure(arg0, arg1, 416, __wbg_adapter_67);\n    return ret;\n};\n\nfunction __wbindgen_closure_wrapper6848(arg0, arg1, arg2) {\n    const ret = makeClosure(arg0, arg1, 416, __wbg_adapter_70);\n    return ret;\n};\n\nfunction __wbindgen_debug_string(arg0, arg1) {\n    const ret = debugString(arg1);\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n};\n\nfunction __wbindgen_error_new(arg0, arg1) {\n    const ret = new Error(getStringFromWasm0(arg0, arg1));\n    return ret;\n};\n\nfunction __wbindgen_in(arg0, arg1) {\n    const ret = arg0 in arg1;\n    return ret;\n};\n\nfunction __wbindgen_init_externref_table() {\n    const table = wasm.__wbindgen_export_4;\n    const offset = table.grow(4);\n    table.set(0, undefined);\n    table.set(offset + 0, undefined);\n    table.set(offset + 1, null);\n    table.set(offset + 2, true);\n    table.set(offset + 3, false);\n    ;\n};\n\nfunction __wbindgen_is_array(arg0) {\n    const ret = Array.isArray(arg0);\n    return ret;\n};\n\nfunction __wbindgen_is_bigint(arg0) {\n    const ret = typeof(arg0) === 'bigint';\n    return ret;\n};\n\nfunction __wbindgen_is_function(arg0) {\n    const ret = typeof(arg0) === 'function';\n    return ret;\n};\n\nfunction __wbindgen_is_null(arg0) {\n    const ret = arg0 === null;\n    return ret;\n};\n\nfunction __wbindgen_is_object(arg0) {\n    const val = arg0;\n    const ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nfunction __wbindgen_is_string(arg0) {\n    const ret = typeof(arg0) === 'string';\n    return ret;\n};\n\nfunction __wbindgen_is_undefined(arg0) {\n    const ret = arg0 === undefined;\n    return ret;\n};\n\nfunction __wbindgen_jsval_eq(arg0, arg1) {\n    const ret = arg0 === arg1;\n    return ret;\n};\n\nfunction __wbindgen_jsval_loose_eq(arg0, arg1) {\n    const ret = arg0 == arg1;\n    return ret;\n};\n\nfunction __wbindgen_memory() {\n    const ret = wasm.memory;\n    return ret;\n};\n\nfunction __wbindgen_number_get(arg0, arg1) {\n    const obj = arg1;\n    const ret = typeof(obj) === 'number' ? obj : undefined;\n    getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n};\n\nfunction __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return ret;\n};\n\nfunction __wbindgen_string_get(arg0, arg1) {\n    const obj = arg1;\n    const ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len1 = WASM_VECTOR_LEN;\n    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n};\n\nfunction __wbindgen_string_new(arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return ret;\n};\n\nfunction __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nfunction __wbindgen_try_into_number(arg0) {\n    let result;\n    try { result = +arg0 } catch (e) { result = e }\n    const ret = result;\n    return ret;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hdHJpeC1vcmcvbWF0cml4LXNkay1jcnlwdG8td2FzbS9wa2cvbWF0cml4X3Nka19jcnlwdG9fd2FzbV9iZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDTztBQUNQO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0QsOEJBQThCOztBQUVsRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTLElBQUksWUFBWSxJQUFJLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7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Q0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELDJCQUEyQixHQUFHLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxZQUFZO0FBQzNCLGVBQWUsYUFBYTtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsWUFBWTtBQUMzQixlQUFlLGFBQWE7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DLGVBQWUsWUFBWTtBQUMzQixlQUFlLGFBQWE7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQSw0QkFBNEIseUNBQXlDO0FBQ3JFLElBQUksd0NBQXdDO0FBQzVDO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMEJBQTBCO0FBQ2xFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBCQUEwQjtBQUNsRSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUNBQXFDO0FBQzdDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsbUJBQW1CO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTyx3Q0FBd0M7QUFDL0M7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU8sMENBQTBDO0FBQ2pEO0FBQ0E7QUFDQSxDQUFDOztBQUVNLDBDQUEwQztBQUNqRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTs7QUFFTyx5Q0FBeUM7QUFDaEQ7QUFDQTtBQUNBLENBQUM7O0FBRU0seUNBQXlDO0FBQ2hEO0FBQ0E7QUFDQSxDQUFDOztBQUVNLHlDQUF5QztBQUNoRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSx5Q0FBeUM7QUFDaEQ7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7O0FBRU8sMENBQTBDO0FBQ2pEO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTyw2Q0FBNkM7QUFDcEQ7QUFDQSxDQUFDOztBQUVNLDBDQUEwQztBQUNqRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSwwQ0FBMEM7QUFDakQ7QUFDQTtBQUNBLENBQUM7O0FBRU0sZ0RBQWdEO0FBQ3ZEO0FBQ0E7QUFDQSxDQUFDOztBQUVNLGdEQUFnRDtBQUN2RDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSxzREFBc0Q7QUFDN0Q7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTyxzREFBc0Q7QUFDN0Q7QUFDQSxDQUFDOztBQUVNLDJDQUEyQztBQUNsRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSwyQ0FBMkM7QUFDbEQ7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFTywwQ0FBMEM7QUFDakQ7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPLCtDQUErQztBQUN0RDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSwyQ0FBMkM7QUFDbEQ7QUFDQTtBQUNBLENBQUM7O0FBRU0sMkNBQTJDO0FBQ2xEO0FBQ0E7QUFDQSxDQUFDOztBQUVNLDJDQUEyQztBQUNsRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSxvREFBb0Q7QUFDM0Q7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBOztBQUVPLHdDQUF3QztBQUMvQztBQUNBO0FBQ0EsQ0FBQzs7QUFFTSx3Q0FBd0M7QUFDL0M7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7O0FBRU8sd0NBQXdDO0FBQy9DO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPLDBDQUEwQztBQUNqRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSw4Q0FBOEM7QUFDckQ7QUFDQTtBQUNBLENBQUM7O0FBRU0sOENBQThDO0FBQ3JEO0FBQ0E7QUFDQSxDQUFDOztBQUVNLDhDQUE4QztBQUNyRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU8sd0NBQXdDO0FBQy9DO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPLCtDQUErQztBQUN0RDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU8sbURBQW1EO0FBQzFEO0FBQ0E7QUFDQSxDQUFDOztBQUVNLHlDQUF5QztBQUNoRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTyxnREFBZ0Q7QUFDdkQ7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU8sK0NBQStDO0FBQ3REO0FBQ0E7QUFDQSxDQUFDOztBQUVNLCtDQUErQztBQUN0RDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSwrQ0FBK0M7QUFDdEQ7QUFDQTtBQUNBLENBQUM7O0FBRU0seUNBQXlDO0FBQ2hEO0FBQ0E7QUFDQSxDQUFDOztBQUVNLHlDQUF5QztBQUNoRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTywwQ0FBMEM7QUFDakQ7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU8sd0NBQXdDO0FBQy9DO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTyxtREFBbUQ7QUFDMUQ7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPLDRDQUE0QztBQUNuRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTs7QUFFTywyQ0FBMkM7QUFDbEQ7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU8sK0NBQStDO0FBQ3REO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCx1QkFBdUIscUJBQU0sMEJBQTBCLHFCQUFNO0FBQzdEO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU8sOENBQThDO0FBQ3JEO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPLGdEQUFnRDtBQUN2RDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTs7QUFFTyxnREFBZ0Q7QUFDdkQ7QUFDQTtBQUNBLENBQUM7O0FBRU0sMkNBQTJDO0FBQ2xEO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPLDBDQUEwQztBQUNqRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0EsVUFBVSxpQkFBaUIsWUFBWTtBQUN2QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc3Rlcmljcy1ncmlkLy4vbm9kZV9tb2R1bGVzL0BtYXRyaXgtb3JnL21hdHJpeC1zZGstY3J5cHRvLXdhc20vcGtnL21hdHJpeF9zZGtfY3J5cHRvX3dhc21fYmcuanM/NGZlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgd2FzbTtcbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19zZXRfd2FzbSh2YWwpIHtcbiAgICB3YXNtID0gdmFsO1xufVxuXG5cbmxldCBXQVNNX1ZFQ1RPUl9MRU4gPSAwO1xuXG5sZXQgY2FjaGVkVWludDhBcnJheU1lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRVaW50OEFycmF5TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkVWludDhBcnJheU1lbW9yeTAgPT09IG51bGwgfHwgY2FjaGVkVWludDhBcnJheU1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRVaW50OEFycmF5TWVtb3J5MCA9IG5ldyBVaW50OEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRVaW50OEFycmF5TWVtb3J5MDtcbn1cblxuY29uc3QgbFRleHRFbmNvZGVyID0gdHlwZW9mIFRleHRFbmNvZGVyID09PSAndW5kZWZpbmVkJyA/ICgwLCBtb2R1bGUucmVxdWlyZSkoJ3V0aWwnKS5UZXh0RW5jb2RlciA6IFRleHRFbmNvZGVyO1xuXG5sZXQgY2FjaGVkVGV4dEVuY29kZXIgPSBuZXcgbFRleHRFbmNvZGVyKCd1dGYtOCcpO1xuXG5jb25zdCBlbmNvZGVTdHJpbmcgPSAodHlwZW9mIGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZUludG8gPT09ICdmdW5jdGlvbidcbiAgICA/IGZ1bmN0aW9uIChhcmcsIHZpZXcpIHtcbiAgICByZXR1cm4gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byhhcmcsIHZpZXcpO1xufVxuICAgIDogZnVuY3Rpb24gKGFyZywgdmlldykge1xuICAgIGNvbnN0IGJ1ZiA9IGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZShhcmcpO1xuICAgIHZpZXcuc2V0KGJ1Zik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVhZDogYXJnLmxlbmd0aCxcbiAgICAgICAgd3JpdHRlbjogYnVmLmxlbmd0aFxuICAgIH07XG59KTtcblxuZnVuY3Rpb24gcGFzc1N0cmluZ1RvV2FzbTAoYXJnLCBtYWxsb2MsIHJlYWxsb2MpIHtcblxuICAgIGlmIChyZWFsbG9jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgICAgIGNvbnN0IHB0ciA9IG1hbGxvYyhidWYubGVuZ3RoLCAxKSA+Pj4gMDtcbiAgICAgICAgZ2V0VWludDhBcnJheU1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGJ1Zi5sZW5ndGgpLnNldChidWYpO1xuICAgICAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBidWYubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGxldCBsZW4gPSBhcmcubGVuZ3RoO1xuICAgIGxldCBwdHIgPSBtYWxsb2MobGVuLCAxKSA+Pj4gMDtcblxuICAgIGNvbnN0IG1lbSA9IGdldFVpbnQ4QXJyYXlNZW1vcnkwKCk7XG5cbiAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgIGZvciAoOyBvZmZzZXQgPCBsZW47IG9mZnNldCsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhcmcuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICBpZiAoY29kZSA+IDB4N0YpIGJyZWFrO1xuICAgICAgICBtZW1bcHRyICsgb2Zmc2V0XSA9IGNvZGU7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCAhPT0gbGVuKSB7XG4gICAgICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZShvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHB0ciA9IHJlYWxsb2MocHRyLCBsZW4sIGxlbiA9IG9mZnNldCArIGFyZy5sZW5ndGggKiAzLCAxKSA+Pj4gMDtcbiAgICAgICAgY29uc3QgdmlldyA9IGdldFVpbnQ4QXJyYXlNZW1vcnkwKCkuc3ViYXJyYXkocHRyICsgb2Zmc2V0LCBwdHIgKyBsZW4pO1xuICAgICAgICBjb25zdCByZXQgPSBlbmNvZGVTdHJpbmcoYXJnLCB2aWV3KTtcblxuICAgICAgICBvZmZzZXQgKz0gcmV0LndyaXR0ZW47XG4gICAgICAgIHB0ciA9IHJlYWxsb2MocHRyLCBsZW4sIG9mZnNldCwgMSkgPj4+IDA7XG4gICAgfVxuXG4gICAgV0FTTV9WRUNUT1JfTEVOID0gb2Zmc2V0O1xuICAgIHJldHVybiBwdHI7XG59XG5cbmxldCBjYWNoZWREYXRhVmlld01lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXREYXRhVmlld01lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZERhdGFWaWV3TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWREYXRhVmlld01lbW9yeTAuYnVmZmVyLmRldGFjaGVkID09PSB0cnVlIHx8IChjYWNoZWREYXRhVmlld01lbW9yeTAuYnVmZmVyLmRldGFjaGVkID09PSB1bmRlZmluZWQgJiYgY2FjaGVkRGF0YVZpZXdNZW1vcnkwLmJ1ZmZlciAhPT0gd2FzbS5tZW1vcnkuYnVmZmVyKSkge1xuICAgICAgICBjYWNoZWREYXRhVmlld01lbW9yeTAgPSBuZXcgRGF0YVZpZXcod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZERhdGFWaWV3TWVtb3J5MDtcbn1cblxuZnVuY3Rpb24gYWRkVG9FeHRlcm5yZWZUYWJsZTAob2JqKSB7XG4gICAgY29uc3QgaWR4ID0gd2FzbS5fX2V4dGVybnJlZl90YWJsZV9hbGxvYygpO1xuICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfNC5zZXQoaWR4LCBvYmopO1xuICAgIHJldHVybiBpZHg7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGYsIGFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGFkZFRvRXh0ZXJucmVmVGFibGUwKGUpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhuX3N0b3JlKGlkeCk7XG4gICAgfVxufVxuXG5jb25zdCBsVGV4dERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnID8gKDAsIG1vZHVsZS5yZXF1aXJlKSgndXRpbCcpLlRleHREZWNvZGVyIDogVGV4dERlY29kZXI7XG5cbmxldCBjYWNoZWRUZXh0RGVjb2RlciA9IG5ldyBsVGV4dERlY29kZXIoJ3V0Zi04JywgeyBpZ25vcmVCT006IHRydWUsIGZhdGFsOiB0cnVlIH0pO1xuXG5jYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoKTtcblxuZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcHRyID0gcHRyID4+PiAwO1xuICAgIHJldHVybiBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoZ2V0VWludDhBcnJheU1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGxlbikpO1xufVxuXG5mdW5jdGlvbiBpc0xpa2VOb25lKHgpIHtcbiAgICByZXR1cm4geCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGw7XG59XG5cbmNvbnN0IENMT1NVUkVfRFRPUlMgPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoc3RhdGUgPT4ge1xuICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfNi5nZXQoc3RhdGUuZHRvcikoc3RhdGUuYSwgc3RhdGUuYilcbn0pO1xuXG5mdW5jdGlvbiBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCBkdG9yLCBmKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7IGE6IGFyZzAsIGI6IGFyZzEsIGNudDogMSwgZHRvciB9O1xuICAgIGNvbnN0IHJlYWwgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAvLyBGaXJzdCB1cCB3aXRoIGEgY2xvc3VyZSB3ZSBpbmNyZW1lbnQgdGhlIGludGVybmFsIHJlZmVyZW5jZVxuICAgICAgICAvLyBjb3VudC4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIFJ1c3QgY2xvc3VyZSBlbnZpcm9ubWVudCB3b24ndFxuICAgICAgICAvLyBiZSBkZWFsbG9jYXRlZCB3aGlsZSB3ZSdyZSBpbnZva2luZyBpdC5cbiAgICAgICAgc3RhdGUuY250Kys7XG4gICAgICAgIGNvbnN0IGEgPSBzdGF0ZS5hO1xuICAgICAgICBzdGF0ZS5hID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmKGEsIHN0YXRlLmIsIC4uLmFyZ3MpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKC0tc3RhdGUuY250ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF82LmdldChzdGF0ZS5kdG9yKShhLCBzdGF0ZS5iKTtcbiAgICAgICAgICAgICAgICBDTE9TVVJFX0RUT1JTLnVucmVnaXN0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVhbC5vcmlnaW5hbCA9IHN0YXRlO1xuICAgIENMT1NVUkVfRFRPUlMucmVnaXN0ZXIocmVhbCwgc3RhdGUsIHN0YXRlKTtcbiAgICByZXR1cm4gcmVhbDtcbn1cblxuZnVuY3Rpb24gbWFrZUNsb3N1cmUoYXJnMCwgYXJnMSwgZHRvciwgZikge1xuICAgIGNvbnN0IHN0YXRlID0geyBhOiBhcmcwLCBiOiBhcmcxLCBjbnQ6IDEsIGR0b3IgfTtcbiAgICBjb25zdCByZWFsID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgLy8gRmlyc3QgdXAgd2l0aCBhIGNsb3N1cmUgd2UgaW5jcmVtZW50IHRoZSBpbnRlcm5hbCByZWZlcmVuY2VcbiAgICAgICAgLy8gY291bnQuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBSdXN0IGNsb3N1cmUgZW52aXJvbm1lbnQgd29uJ3RcbiAgICAgICAgLy8gYmUgZGVhbGxvY2F0ZWQgd2hpbGUgd2UncmUgaW52b2tpbmcgaXQuXG4gICAgICAgIHN0YXRlLmNudCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGYoc3RhdGUuYSwgc3RhdGUuYiwgLi4uYXJncyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoLS1zdGF0ZS5jbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzYuZ2V0KHN0YXRlLmR0b3IpKHN0YXRlLmEsIHN0YXRlLmIpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmEgPSAwO1xuICAgICAgICAgICAgICAgIENMT1NVUkVfRFRPUlMudW5yZWdpc3RlcihzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJlYWwub3JpZ2luYWwgPSBzdGF0ZTtcbiAgICBDTE9TVVJFX0RUT1JTLnJlZ2lzdGVyKHJlYWwsIHN0YXRlLCBzdGF0ZSk7XG4gICAgcmV0dXJuIHJlYWw7XG59XG5cbmZ1bmN0aW9uIGRlYnVnU3RyaW5nKHZhbCkge1xuICAgIC8vIHByaW1pdGl2ZSB0eXBlc1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsO1xuICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAgYCR7dmFsfWA7XG4gICAgfVxuICAgIGlmICh0eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBgXCIke3ZhbH1cImA7XG4gICAgfVxuICAgIGlmICh0eXBlID09ICdzeW1ib2wnKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsLmRlc2NyaXB0aW9uO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdTeW1ib2wnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBTeW1ib2woJHtkZXNjcmlwdGlvbn0pYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWwubmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnICYmIG5hbWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGBGdW5jdGlvbigke25hbWV9KWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Z1bmN0aW9uJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBvYmplY3RzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSB2YWwubGVuZ3RoO1xuICAgICAgICBsZXQgZGVidWcgPSAnWyc7XG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZWJ1ZyArPSBkZWJ1Z1N0cmluZyh2YWxbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVidWcgKz0gJywgJyArIGRlYnVnU3RyaW5nKHZhbFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcgKz0gJ10nO1xuICAgICAgICByZXR1cm4gZGVidWc7XG4gICAgfVxuICAgIC8vIFRlc3QgZm9yIGJ1aWx0LWluXG4gICAgY29uc3QgYnVpbHRJbk1hdGNoZXMgPSAvXFxbb2JqZWN0IChbXlxcXV0rKVxcXS8uZXhlYyh0b1N0cmluZy5jYWxsKHZhbCkpO1xuICAgIGxldCBjbGFzc05hbWU7XG4gICAgaWYgKGJ1aWx0SW5NYXRjaGVzICYmIGJ1aWx0SW5NYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gYnVpbHRJbk1hdGNoZXNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFpbGVkIHRvIG1hdGNoIHRoZSBzdGFuZGFyZCAnW29iamVjdCBDbGFzc05hbWVdJ1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpO1xuICAgIH1cbiAgICBpZiAoY2xhc3NOYW1lID09ICdPYmplY3QnKSB7XG4gICAgICAgIC8vIHdlJ3JlIGEgdXNlciBkZWZpbmVkIGNsYXNzIG9yIE9iamVjdFxuICAgICAgICAvLyBKU09OLnN0cmluZ2lmeSBhdm9pZHMgcHJvYmxlbXMgd2l0aCBjeWNsZXMsIGFuZCBpcyBnZW5lcmFsbHkgbXVjaFxuICAgICAgICAvLyBlYXNpZXIgdGhhbiBsb29waW5nIHRocm91Z2ggb3duUHJvcGVydGllcyBvZiBgdmFsYC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAnT2JqZWN0KCcgKyBKU09OLnN0cmluZ2lmeSh2YWwpICsgJyknO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gJ09iamVjdCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXJyb3JzXG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBgJHt2YWwubmFtZX06ICR7dmFsLm1lc3NhZ2V9XFxuJHt2YWwuc3RhY2t9YDtcbiAgICB9XG4gICAgLy8gVE9ETyB3ZSBjb3VsZCB0ZXN0IGZvciBtb3JlIHRoaW5ncyBoZXJlLCBsaWtlIGBTZXRgcyBhbmQgYE1hcGBzLlxuICAgIHJldHVybiBjbGFzc05hbWU7XG59XG5cbmZ1bmN0aW9uIHBhc3NBcnJheThUb1dhc20wKGFyZywgbWFsbG9jKSB7XG4gICAgY29uc3QgcHRyID0gbWFsbG9jKGFyZy5sZW5ndGggKiAxLCAxKSA+Pj4gMDtcbiAgICBnZXRVaW50OEFycmF5TWVtb3J5MCgpLnNldChhcmcsIHB0ciAvIDEpO1xuICAgIFdBU01fVkVDVE9SX0xFTiA9IGFyZy5sZW5ndGg7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxuZnVuY3Rpb24gdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAoaWR4KSB7XG4gICAgY29uc3QgdmFsdWUgPSB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQuZ2V0KGlkeCk7XG4gICAgd2FzbS5fX2V4dGVybnJlZl90YWJsZV9kZWFsbG9jKGlkeCk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0Q2xhc3MoaW5zdGFuY2UsIGtsYXNzKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBrbGFzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBpbnN0YW5jZSBvZiAke2tsYXNzLm5hbWV9YCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRBcnJheVU4RnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcHRyID0gcHRyID4+PiAwO1xuICAgIHJldHVybiBnZXRVaW50OEFycmF5TWVtb3J5MCgpLnN1YmFycmF5KHB0ciAvIDEsIHB0ciAvIDEgKyBsZW4pO1xufVxuXG5mdW5jdGlvbiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhcnJheSwgbWFsbG9jKSB7XG4gICAgY29uc3QgcHRyID0gbWFsbG9jKGFycmF5Lmxlbmd0aCAqIDQsIDQpID4+PiAwO1xuICAgIGNvbnN0IG1lbSA9IGdldERhdGFWaWV3TWVtb3J5MCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWVtLnNldFVpbnQzMihwdHIgKyA0ICogaSwgYWRkVG9FeHRlcm5yZWZUYWJsZTAoYXJyYXlbaV0pLCB0cnVlKTtcbiAgICB9XG4gICAgV0FTTV9WRUNUT1JfTEVOID0gYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBwdHI7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICBjb25zdCBtZW0gPSBnZXREYXRhVmlld01lbW9yeTAoKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gcHRyOyBpIDwgcHRyICsgNCAqIGxlbjsgaSArPSA0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHdhc20uX193YmluZGdlbl9leHBvcnRfNC5nZXQobWVtLmdldFVpbnQzMihpLCB0cnVlKSkpO1xuICAgIH1cbiAgICB3YXNtLl9fZXh0ZXJucmVmX2Ryb3Bfc2xpY2UocHRyLCBsZW4pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmxldCBjYWNoZWRVaW50MTZBcnJheU1lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRVaW50MTZBcnJheU1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZFVpbnQxNkFycmF5TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWRVaW50MTZBcnJheU1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRVaW50MTZBcnJheU1lbW9yeTAgPSBuZXcgVWludDE2QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFVpbnQxNkFycmF5TWVtb3J5MDtcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlVMTZGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgcmV0dXJuIGdldFVpbnQxNkFycmF5TWVtb3J5MCgpLnN1YmFycmF5KHB0ciAvIDIsIHB0ciAvIDIgKyBsZW4pO1xufVxuLyoqXG4gKiBHZXQgdGhlIHZlcnNpb25zIG9mIHRoZSBSdXN0IGxpYnJhcmllcyB3ZSBhcmUgdXNpbmcuXG4gKiBAcmV0dXJucyB7VmVyc2lvbnN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJzaW9ucygpIHtcbiAgICBjb25zdCByZXQgPSB3YXNtLmdldFZlcnNpb25zKCk7XG4gICAgcmV0dXJuIFZlcnNpb25zLl9fd3JhcChyZXQpO1xufVxuXG4vKipcbiAqIFJ1biBzb21lIHN0dWZmIHdoZW4gdGhlIFdhc20gbW9kdWxlIGlzIGluc3RhbnRpYXRlZC5cbiAqXG4gKiBSaWdodCBub3csIGl0IGRvZXMgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAqIFJlZGlyZWN0IFJ1c3QgcGFuaWNzIHRvIEphdmFTY3JpcHQgY29uc29sZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIHdhc20uc3RhcnQoKTtcbn1cblxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl81OChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgY29uc3QgcmV0ID0gd2FzbS5jbG9zdXJlMjlfZXh0ZXJucmVmX3NoaW1fbXVsdGl2YWx1ZV9zaGltKGFyZzAsIGFyZzEsIGFyZzIpO1xuICAgIGlmIChyZXRbMV0pIHtcbiAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzBdKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfNjEoYXJnMCwgYXJnMSkge1xuICAgIHdhc20uX2R5bl9jb3JlX19vcHNfX2Z1bmN0aW9uX19Gbk11dF9fX19fT3V0cHV0X19fUl9hc193YXNtX2JpbmRnZW5fX2Nsb3N1cmVfX1dhc21DbG9zdXJlX19fZGVzY3JpYmVfX2ludm9rZV9faGVjYTVjNDQyNmNjN2U3MDMoYXJnMCwgYXJnMSk7XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfNjQoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIHdhc20uY2xvc3VyZTczNV9leHRlcm5yZWZfc2hpbShhcmcwLCBhcmcxLCBhcmcyKTtcbn1cblxuZnVuY3Rpb24gX193YmdfYWRhcHRlcl82NyhhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgd2FzbS5jbG9zdXJlNDE1X2V4dGVybnJlZl9zaGltKGFyZzAsIGFyZzEsIGFyZzIpO1xufVxuXG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzcwKGFyZzAsIGFyZzEpIHtcbiAgICB3YXNtLl9keW5fY29yZV9fb3BzX19mdW5jdGlvbl9fRm5fX19fX091dHB1dF9fX1JfYXNfd2FzbV9iaW5kZ2VuX19jbG9zdXJlX19XYXNtQ2xvc3VyZV9fX2Rlc2NyaWJlX19pbnZva2VfX2g0MWQ1NTI5NjJhNzlkZmI0KGFyZzAsIGFyZzEpO1xufVxuXG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzc1OChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgd2FzbS5jbG9zdXJlNDMxX2V4dGVybnJlZl9zaGltKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xufVxuXG4vKipcbiAqIERlY3J5cHRpb24gZXJyb3IgY29kZXNcbiAqIEBlbnVtIHswIHwgMSB8IDIgfCAzIHwgNCB8IDUgfCA2fVxuICovXG5leHBvcnQgY29uc3QgRGVjcnlwdGlvbkVycm9yQ29kZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIC8qKlxuICAgICAqIFRoZSByb29tIGtleSBpcyBub3Qga25vd25cbiAgICAgKi9cbiAgICBNaXNzaW5nUm9vbUtleTogMCwgXCIwXCI6IFwiTWlzc2luZ1Jvb21LZXlcIixcbiAgICAvKipcbiAgICAgKiBUaGUgcm9vbSBrZXkgaXMga25vd24gYnV0IHJhdGNoZXRlZFxuICAgICAqL1xuICAgIFVua25vd25NZXNzYWdlSW5kZXg6IDEsIFwiMVwiOiBcIlVua25vd25NZXNzYWdlSW5kZXhcIixcbiAgICAvKipcbiAgICAgKiBEZWNyeXB0aW9uIGZhaWxlZCBiZWNhdXNlIG9mIGEgbWlzbWF0Y2ggYmV0d2VlbiB0aGUgaWRlbnRpdHkga2V5cyBvZiB0aGVcbiAgICAgKiBkZXZpY2Ugd2UgcmVjZWl2ZWQgdGhlIHJvb20ga2V5IGZyb20gYW5kIHRoZSBpZGVudGl0eSBrZXlzIHJlY29yZGVkIGluXG4gICAgICogdGhlIHBsYWludGV4dCBvZiB0aGUgcm9vbSBrZXkgdG8tZGV2aWNlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWlzbWF0Y2hlZElkZW50aXR5S2V5czogMiwgXCIyXCI6IFwiTWlzbWF0Y2hlZElkZW50aXR5S2V5c1wiLFxuICAgIC8qKlxuICAgICAqIFdlIHdlcmVuJ3QgYWJsZSB0byBsaW5rIHRoZSBtZXNzYWdlIGJhY2sgdG8gYW55IGtub3duIGRldmljZS5cbiAgICAgKi9cbiAgICBVbmtub3duU2VuZGVyRGV2aWNlOiAzLCBcIjNcIjogXCJVbmtub3duU2VuZGVyRGV2aWNlXCIsXG4gICAgLyoqXG4gICAgICogVGhlIHNlbmRlciBkZXZpY2UgaXMgbm90IGNyb3NzLXNpZ25lZC5cbiAgICAgKi9cbiAgICBVbnNpZ25lZFNlbmRlckRldmljZTogNCwgXCI0XCI6IFwiVW5zaWduZWRTZW5kZXJEZXZpY2VcIixcbiAgICAvKipcbiAgICAgKiBUaGUgc2VuZGVyJ3MgaWRlbnRpdHkgaXMgdW52ZXJpZmllZCwgYnV0IHdhcyBwcmV2aW91c2x5IHZlcmlmaWVkLlxuICAgICAqL1xuICAgIFNlbmRlcklkZW50aXR5VmVyaWZpY2F0aW9uVmlvbGF0aW9uOiA1LCBcIjVcIjogXCJTZW5kZXJJZGVudGl0eVZlcmlmaWNhdGlvblZpb2xhdGlvblwiLFxuICAgIC8qKlxuICAgICAqIE90aGVyIGZhaWx1cmUuXG4gICAgICovXG4gICAgVW5hYmxlVG9EZWNyeXB0OiA2LCBcIjZcIjogXCJVbmFibGVUb0RlY3J5cHRcIixcbn0pO1xuLyoqXG4gKiBUaGUgYmFzaWMga2V5IGFsZ29yaXRobSBuYW1lcyBpbiB0aGUgc3BlY2lmaWNhdGlvbi5cbiAqIEBlbnVtIHswIHwgMSB8IDN9XG4gKi9cbmV4cG9ydCBjb25zdCBEZXZpY2VLZXlBbGdvcml0aG1OYW1lID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLyoqXG4gICAgICogVGhlIEVkMjU1MTkgc2lnbmF0dXJlIGFsZ29yaXRobS5cbiAgICAgKi9cbiAgICBFZDI1NTE5OiAwLCBcIjBcIjogXCJFZDI1NTE5XCIsXG4gICAgLyoqXG4gICAgICogVGhlIEN1cnZlMjU1MTkgRUNESCBhbGdvcml0aG0uXG4gICAgICovXG4gICAgQ3VydmUyNTUxOTogMSwgXCIxXCI6IFwiQ3VydmUyNTUxOVwiLFxuICAgIC8qKlxuICAgICAqIEFuIHVua25vd24gZGV2aWNlIGtleSBhbGdvcml0aG0uXG4gICAgICovXG4gICAgVW5rbm93bjogMywgXCIzXCI6IFwiVW5rbm93blwiLFxufSk7XG4vKipcbiAqIEFuIGVudW0gb3ZlciB0aGUgZGlmZmVyZW50IGtleSB0eXBlcyBhIGRldmljZSBjYW4gaGF2ZS5cbiAqXG4gKiBDdXJyZW50bHkgZGV2aWNlcyBoYXZlIGEgY3VydmUyNTUxOSBhbmQgZWQyNTUxOSBrZXlwYWlyLiBUaGUga2V5c1xuICogdHJhbnNwb3J0IGZvcm1hdCBpcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZywgYW55IHVua25vd24ga2V5IHR5cGVcbiAqIHdpbGwgYmUgbGVmdCBhcyBzdWNoIGEgc3RyaW5nLlxuICogQGVudW0gezAgfCAxIHwgMn1cbiAqL1xuZXhwb3J0IGNvbnN0IERldmljZUtleU5hbWUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VydmUyNTUxOSBkZXZpY2Uga2V5LlxuICAgICAqL1xuICAgIEN1cnZlMjU1MTk6IDAsIFwiMFwiOiBcIkN1cnZlMjU1MTlcIixcbiAgICAvKipcbiAgICAgKiBUaGUgZWQyNTUxOSBkZXZpY2Uga2V5LlxuICAgICAqL1xuICAgIEVkMjU1MTk6IDEsIFwiMVwiOiBcIkVkMjU1MTlcIixcbiAgICAvKipcbiAgICAgKiBBbiB1bmtub3duIGRldmljZSBrZXkuXG4gICAgICovXG4gICAgVW5rbm93bjogMiwgXCIyXCI6IFwiVW5rbm93blwiLFxufSk7XG4vKipcbiAqIEFuIGVuY3J5cHRpb24gYWxnb3JpdGhtIHRvIGJlIHVzZWQgdG8gZW5jcnlwdCBtZXNzYWdlcyBzZW50IHRvIGFcbiAqIHJvb20uXG4gKiBAZW51bSB7MCB8IDEgfCAyfVxuICovXG5leHBvcnQgY29uc3QgRW5jcnlwdGlvbkFsZ29yaXRobSA9IE9iamVjdC5mcmVlemUoe1xuICAgIC8qKlxuICAgICAqIE9sbSB2ZXJzaW9uIDEgdXNpbmcgQ3VydmUyNTUxOSwgQUVTLTI1NiwgYW5kIFNIQS0yNTYuXG4gICAgICovXG4gICAgT2xtVjFDdXJ2ZTI1NTE5QWVzU2hhMjogMCwgXCIwXCI6IFwiT2xtVjFDdXJ2ZTI1NTE5QWVzU2hhMlwiLFxuICAgIC8qKlxuICAgICAqIE1lZ29sbSB2ZXJzaW9uIDEgdXNpbmcgQUVTLTI1NiBhbmQgU0hBLTI1Ni5cbiAgICAgKi9cbiAgICBNZWdvbG1WMUFlc1NoYTI6IDEsIFwiMVwiOiBcIk1lZ29sbVYxQWVzU2hhMlwiLFxuICAgIC8qKlxuICAgICAqIFVuc3VwcG9ydGVkIGFsZ29yaXRobS5cbiAgICAgKlxuICAgICAqIEFwcGxpY2F0aW9ucyBzaG91bGQgaWdub3JlIHRoaXMgdmFsdWUgaWYgaXQgaXMgcmVjZWl2ZWQsIGFuZCBzaG91bGRcbiAgICAgKiBuZXZlciBzZXQgaXQuXG4gICAgICovXG4gICAgVW5rbm93bjogMiwgXCIyXCI6IFwiVW5rbm93blwiLFxufSk7XG4vKipcbiAqIFdobyBjYW4gc2VlIGEgcm9vbSdzIGhpc3RvcnkuXG4gKiBAZW51bSB7MCB8IDEgfCAyIHwgM31cbiAqL1xuZXhwb3J0IGNvbnN0IEhpc3RvcnlWaXNpYmlsaXR5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLyoqXG4gICAgICogUHJldmlvdXMgZXZlbnRzIGFyZSBhY2Nlc3NpYmxlIHRvIG5ld2x5IGpvaW5lZCBtZW1iZXJzIGZyb21cbiAgICAgKiB0aGUgcG9pbnQgdGhleSB3ZXJlIGludml0ZWQgb253YXJkcy5cbiAgICAgKlxuICAgICAqIEV2ZW50cyBzdG9wIGJlaW5nIGFjY2Vzc2libGUgd2hlbiB0aGUgbWVtYmVyJ3Mgc3RhdGUgY2hhbmdlc1xuICAgICAqIHRvIHNvbWV0aGluZyBvdGhlciB0aGFuICppbnZpdGUqIG9yICpqb2luKi5cbiAgICAgKi9cbiAgICBJbnZpdGVkOiAwLCBcIjBcIjogXCJJbnZpdGVkXCIsXG4gICAgLyoqXG4gICAgICogUHJldmlvdXMgZXZlbnRzIGFyZSBhY2Nlc3NpYmxlIHRvIG5ld2x5IGpvaW5lZCBtZW1iZXJzIGZyb21cbiAgICAgKiB0aGUgcG9pbnQgdGhleSBqb2luZWQgdGhlIHJvb20gb253YXJkcy5cbiAgICAgKlxuICAgICAqIEV2ZW50cyBzdG9wIGJlaW5nIGFjY2Vzc2libGUgd2hlbiB0aGUgbWVtYmVyJ3Mgc3RhdGUgY2hhbmdlc1xuICAgICAqIHRvIHNvbWV0aGluZyBvdGhlciB0aGFuICpqb2luKi5cbiAgICAgKi9cbiAgICBKb2luZWQ6IDEsIFwiMVwiOiBcIkpvaW5lZFwiLFxuICAgIC8qKlxuICAgICAqIFByZXZpb3VzIGV2ZW50cyBhcmUgYWx3YXlzIGFjY2Vzc2libGUgdG8gbmV3bHkgam9pbmVkIG1lbWJlcnMuXG4gICAgICpcbiAgICAgKiBBbGwgZXZlbnRzIGluIHRoZSByb29tIGFyZSBhY2Nlc3NpYmxlLCBldmVuIHRob3NlIHNlbnQgd2hlblxuICAgICAqIHRoZSBtZW1iZXIgd2FzIG5vdCBhIHBhcnQgb2YgdGhlIHJvb20uXG4gICAgICovXG4gICAgU2hhcmVkOiAyLCBcIjJcIjogXCJTaGFyZWRcIixcbiAgICAvKipcbiAgICAgKiBBbGwgZXZlbnRzIHdoaWxlIHRoaXMgaXMgdGhlIGBIaXN0b3J5VmlzaWJpbGl0eWAgdmFsdWUgbWF5IGJlXG4gICAgICogc2hhcmVkIGJ5IGFueSBwYXJ0aWNpcGF0aW5nIGhvbWVzZXJ2ZXIgd2l0aCBhbnlvbmUsIHJlZ2FyZGxlc3NcbiAgICAgKiBvZiB3aGV0aGVyIHRoZXkgaGF2ZSBldmVyIGpvaW5lZCB0aGUgcm9vbS5cbiAgICAgKi9cbiAgICBXb3JsZFJlYWRhYmxlOiAzLCBcIjNcIjogXCJXb3JsZFJlYWRhYmxlXCIsXG59KTtcbi8qKlxuICogVGhlIGxvY2FsIHRydXN0IHN0YXRlIG9mIGEgZGV2aWNlLlxuICogQGVudW0gezAgfCAxIHwgMiB8IDN9XG4gKi9cbmV4cG9ydCBjb25zdCBMb2NhbFRydXN0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLyoqXG4gICAgICogVGhlIGRldmljZSBoYXMgYmVlbiB2ZXJpZmllZCBhbmQgaXMgdHJ1c3RlZC5cbiAgICAgKi9cbiAgICBWZXJpZmllZDogMCwgXCIwXCI6IFwiVmVyaWZpZWRcIixcbiAgICAvKipcbiAgICAgKiBUaGUgZGV2aWNlIGJlZW4gYmxhY2tsaXN0ZWQgZnJvbSBjb21tdW5pY2F0aW5nLlxuICAgICAqL1xuICAgIEJsYWNrTGlzdGVkOiAxLCBcIjFcIjogXCJCbGFja0xpc3RlZFwiLFxuICAgIC8qKlxuICAgICAqIFRoZSB0cnVzdCBzdGF0ZSBvZiB0aGUgZGV2aWNlIGlzIGJlaW5nIGlnbm9yZWQuXG4gICAgICovXG4gICAgSWdub3JlZDogMiwgXCIyXCI6IFwiSWdub3JlZFwiLFxuICAgIC8qKlxuICAgICAqIFRoZSB0cnVzdCBzdGF0ZSBpcyB1bnNldC5cbiAgICAgKi9cbiAgICBVbnNldDogMywgXCIzXCI6IFwiVW5zZXRcIixcbn0pO1xuLyoqXG4gKiBMb2dnZXIgbGV2ZWwuXG4gKiBAZW51bSB7MCB8IDEgfCAyIHwgMyB8IDR9XG4gKi9cbmV4cG9ydCBjb25zdCBMb2dnZXJMZXZlbCA9IE9iamVjdC5mcmVlemUoe1xuICAgIC8qKlxuICAgICAqIGBUUkFDRWAgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBEZXNpZ25hdGUgdmVyeSBsb3cgcHJpb3JpdHksIG9mdGVuIGV4dHJlbWVseSB2ZXJib3NlLFxuICAgICAqIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIFRyYWNlOiAwLCBcIjBcIjogXCJUcmFjZVwiLFxuICAgIC8qKlxuICAgICAqIGBERUJVR2AgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBEZXNpZ25hdGUgbG93ZXIgcHJpb3JpdHkgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgRGVidWc6IDEsIFwiMVwiOiBcIkRlYnVnXCIsXG4gICAgLyoqXG4gICAgICogYElORk9gIGxldmVsLlxuICAgICAqXG4gICAgICogRGVzaWduYXRlIHVzZWZ1bCBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBJbmZvOiAyLCBcIjJcIjogXCJJbmZvXCIsXG4gICAgLyoqXG4gICAgICogYFdBUk5gIGxldmVsLlxuICAgICAqXG4gICAgICogRGVzaWduYXRlIGhhemFyZG91cyBzaXR1YXRpb25zLlxuICAgICAqL1xuICAgIFdhcm46IDMsIFwiM1wiOiBcIldhcm5cIixcbiAgICAvKipcbiAgICAgKiBgRVJST1JgIGxldmVsLlxuICAgICAqXG4gICAgICogRGVzaWduYXRlIHZlcnkgc2VyaW91cyBlcnJvcnMuXG4gICAgICovXG4gICAgRXJyb3I6IDQsIFwiNFwiOiBcIkVycm9yXCIsXG59KTtcbi8qKlxuICogVGhlIG1vZGUgb2YgdGhlIFFSIGNvZGUgbG9naW4uXG4gKlxuICogVGhlIFFSIGNvZGUgbG9naW4gbWVjaGFuaXNtIHN1cHBvcnRzIGJvdGgsIHRoZSBuZXcgZGV2aWNlLCBhcyB3ZWxsIGFzIHRoZVxuICogZXhpc3RpbmcgZGV2aWNlIHRvIGRpc3BsYXkgdGhlIFFSIGNvZGUuXG4gKlxuICogVGhlIGRpZmZlcmVudCBtb2RlcyBoYXZlIGFuIGV4cGxpY2l0IG9uZS1ieXRlIGlkZW50aWZpZXIgd2hpY2ggZ2V0cyBhZGRlZCB0b1xuICogdGhlIFFSIGNvZGUgZGF0YS5cbiAqIEBlbnVtIHswIHwgMX1cbiAqL1xuZXhwb3J0IGNvbnN0IFFyQ29kZU1vZGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmV3IGRldmljZSBpcyBkaXNwbGF5aW5nIHRoZSBRUiBjb2RlLlxuICAgICAqL1xuICAgIExvZ2luOiAwLCBcIjBcIjogXCJMb2dpblwiLFxuICAgIC8qKlxuICAgICAqIFRoZSBleGlzdGluZyBkZXZpY2UgaXMgZGlzcGxheWluZyB0aGUgUVIgY29kZS5cbiAgICAgKi9cbiAgICBSZWNpcHJvY2F0ZTogMSwgXCIxXCI6IFwiUmVjaXByb2NhdGVcIixcbn0pO1xuLyoqXG4gKiBMaXN0IG9mIGBRcmAgc3RhdGVzXG4gKiBAZW51bSB7MCB8IDEgfCAyIHwgMyB8IDQgfCA1fVxuICovXG5leHBvcnQgY29uc3QgUXJTdGF0ZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIC8qKlxuICAgICAqIFdlIGhhdmUgcmVjZWl2ZWQgdGhlIG90aGVyIGRldmljZSdzIGRldGFpbHMgKGZyb20gdGhlXG4gICAgICogYG0ua2V5LnZlcmlmaWNhdGlvbi5yZXF1ZXN0YCBvciBgbS5rZXkudmVyaWZpY2F0aW9uLnJlYWR5YCkgYW5kXG4gICAgICogZXN0YWJsaXNoZWQgdGhlIHNoYXJlZCBzZWNyZXQsIHNvIGNhblxuICAgICAqIGRpc3BsYXkgdGhlIFFSIGNvZGUuXG4gICAgICovXG4gICAgQ3JlYXRlZDogMCwgXCIwXCI6IFwiQ3JlYXRlZFwiLFxuICAgIC8qKlxuICAgICAqIFRoZSBvdGhlciBzaWRlIGhhcyBzY2FubmVkIG91ciBRUiBjb2RlIGFuZCBzZW50IGFuXG4gICAgICogYG0ua2V5LnZlcmlmaWNhdGlvbi5zdGFydGAgbWVzc2FnZSB3aXRoIGBtZXRob2Q6IG0ucmVjaXByb2NhdGUudjFgIHdpdGhcbiAgICAgKiBtYXRjaGluZyBzaGFyZWQgc2VjcmV0LlxuICAgICAqL1xuICAgIFNjYW5uZWQ6IDEsIFwiMVwiOiBcIlNjYW5uZWRcIixcbiAgICAvKipcbiAgICAgKiBPdXIgdXNlciBoYXMgY29uZmlybWVkIHRoYXQgdGhlIG90aGVyIGRldmljZSBzY2FubmVkIHN1Y2Nlc3NmdWxseS4gV2VcbiAgICAgKiBoYXZlIHNlbnQgYW4gYG0ua2V5LnZlcmlmaWNhdGlvbi5kb25lYC5cbiAgICAgKi9cbiAgICBDb25maXJtZWQ6IDIsIFwiMlwiOiBcIkNvbmZpcm1lZFwiLFxuICAgIC8qKlxuICAgICAqIFdlIGhhdmUgc2Nhbm5lZCB0aGUgb3RoZXIgc2lkZSdzIFFSIGNvZGUgYW5kIGFyZSBhYmxlIHRvIHNlbmQgYVxuICAgICAqIGBtLmtleS52ZXJpZmljYXRpb24uc3RhcnRgIG1lc3NhZ2Ugd2l0aCBgbWV0aG9kOiBtLnJlY2lwcm9jYXRlLnYxYC5cbiAgICAgKlxuICAgICAqIENhbGwgYFFyOjpyZWNpcHJvY2F0ZWAgdG8gYnVpbGQgdGhlIHN0YXJ0IG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQsIGRlc3BpdGUgdGhlIG5hbWUgb2YgdGhpcyBzdGF0ZSwgd2UgaGF2ZSBub3QgbmVjZXNzYXJpbHlcbiAgICAgKiB5ZXQgc2VudCB0aGUgYG0ucmVjaXByb2NhdGUudjFgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgUmVjaXByb2NhdGVkOiAzLCBcIjNcIjogXCJSZWNpcHJvY2F0ZWRcIixcbiAgICAvKipcbiAgICAgKiBWZXJpZmljYXRpb24gY29tcGxldGU6IHdlIGhhdmUgcmVjZWl2ZWQgYW4gYG0ua2V5LnZlcmlmaWNhdGlvbi5kb25lYFxuICAgICAqIGZyb20gdGhlIG90aGVyIHNpZGUuXG4gICAgICovXG4gICAgRG9uZTogNCwgXCI0XCI6IFwiRG9uZVwiLFxuICAgIC8qKlxuICAgICAqIFZlcmlmaWNhdGlvbiBjYW5jZWxsZWQgb3IgZmFpbGVkLlxuICAgICAqL1xuICAgIENhbmNlbGxlZDogNSwgXCI1XCI6IFwiQ2FuY2VsbGVkXCIsXG59KTtcbi8qKlxuICogUmVwcmVzZW50IHRoZSB0eXBlIG9mIGEgcmVxdWVzdC5cbiAqIEBlbnVtIHswIHwgMSB8IDIgfCAzIHwgNCB8IDUgfCA2fVxuICovXG5leHBvcnQgY29uc3QgUmVxdWVzdFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgYEtleXNVcGxvYWRSZXF1ZXN0YC5cbiAgICAgKi9cbiAgICBLZXlzVXBsb2FkOiAwLCBcIjBcIjogXCJLZXlzVXBsb2FkXCIsXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGBLZXlzUXVlcnlSZXF1ZXN0YC5cbiAgICAgKi9cbiAgICBLZXlzUXVlcnk6IDEsIFwiMVwiOiBcIktleXNRdWVyeVwiLFxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBgS2V5c0NsYWltUmVxdWVzdGAuXG4gICAgICovXG4gICAgS2V5c0NsYWltOiAyLCBcIjJcIjogXCJLZXlzQ2xhaW1cIixcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgYFRvRGV2aWNlUmVxdWVzdGAuXG4gICAgICovXG4gICAgVG9EZXZpY2U6IDMsIFwiM1wiOiBcIlRvRGV2aWNlXCIsXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGBTaWduYXR1cmVVcGxvYWRSZXF1ZXN0YC5cbiAgICAgKi9cbiAgICBTaWduYXR1cmVVcGxvYWQ6IDQsIFwiNFwiOiBcIlNpZ25hdHVyZVVwbG9hZFwiLFxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBgUm9vbU1lc3NhZ2VSZXF1ZXN0YC5cbiAgICAgKi9cbiAgICBSb29tTWVzc2FnZTogNSwgXCI1XCI6IFwiUm9vbU1lc3NhZ2VcIixcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgYEtleXNCYWNrdXBSZXF1ZXN0YC5cbiAgICAgKi9cbiAgICBLZXlzQmFja3VwOiA2LCBcIjZcIjogXCJLZXlzQmFja3VwXCIsXG59KTtcbi8qKlxuICogVGFrZSBhIGxvb2sgYXQgW2BtYXRyaXhfc2RrX2NvbW1vbjo6ZGVzZXJpYWxpemVkX3Jlc3BvbnNlczo6U2hpZWxkU3RhdGVgXVxuICogZm9yIG1vcmUgaW5mby5cbiAqIEBlbnVtIHswIHwgMSB8IDJ9XG4gKi9cbmV4cG9ydCBjb25zdCBTaGllbGRDb2xvciA9IE9iamVjdC5mcmVlemUoe1xuICAgIC8qKlxuICAgICAqIEltcG9ydGFudCB3YXJuaW5nXG4gICAgICovXG4gICAgUmVkOiAwLCBcIjBcIjogXCJSZWRcIixcbiAgICAvKipcbiAgICAgKiBMb3cgd2FybmluZ1xuICAgICAqL1xuICAgIEdyZXk6IDEsIFwiMVwiOiBcIkdyZXlcIixcbiAgICAvKipcbiAgICAgKiBObyB3YXJuaW5nXG4gICAgICovXG4gICAgTm9uZTogMiwgXCIyXCI6IFwiTm9uZVwiLFxufSk7XG4vKipcbiAqIEEgbWFjaGluZS1yZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgYXV0aGVudGljaXR5IGZvciBhIGBTaGllbGRTdGF0ZWAuXG4gKiBAZW51bSB7MCB8IDEgfCAyIHwgMyB8IDQgfCA1fVxuICovXG5leHBvcnQgY29uc3QgU2hpZWxkU3RhdGVDb2RlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLyoqXG4gICAgICogTm90IGVub3VnaCBpbmZvcm1hdGlvbiBhdmFpbGFibGUgdG8gY2hlY2sgdGhlIGF1dGhlbnRpY2l0eS5cbiAgICAgKi9cbiAgICBBdXRoZW50aWNpdHlOb3RHdWFyYW50ZWVkOiAwLCBcIjBcIjogXCJBdXRoZW50aWNpdHlOb3RHdWFyYW50ZWVkXCIsXG4gICAgLyoqXG4gICAgICogVGhlIHNlbmRpbmcgZGV2aWNlIGlzbid0IHlldCBrbm93biBieSB0aGUgQ2xpZW50LlxuICAgICAqL1xuICAgIFVua25vd25EZXZpY2U6IDEsIFwiMVwiOiBcIlVua25vd25EZXZpY2VcIixcbiAgICAvKipcbiAgICAgKiBUaGUgc2VuZGluZyBkZXZpY2UgaGFzbid0IGJlZW4gdmVyaWZpZWQgYnkgdGhlIHNlbmRlci5cbiAgICAgKi9cbiAgICBVbnNpZ25lZERldmljZTogMiwgXCIyXCI6IFwiVW5zaWduZWREZXZpY2VcIixcbiAgICAvKipcbiAgICAgKiBUaGUgc2VuZGVyIGhhc24ndCBiZWVuIHZlcmlmaWVkIGJ5IHRoZSBDbGllbnQncyB1c2VyLlxuICAgICAqL1xuICAgIFVudmVyaWZpZWRJZGVudGl0eTogMywgXCIzXCI6IFwiVW52ZXJpZmllZElkZW50aXR5XCIsXG4gICAgLyoqXG4gICAgICogQW4gdW5lbmNyeXB0ZWQgZXZlbnQgaW4gYW4gZW5jcnlwdGVkIHJvb20uXG4gICAgICovXG4gICAgU2VudEluQ2xlYXI6IDQsIFwiNFwiOiBcIlNlbnRJbkNsZWFyXCIsXG4gICAgLyoqXG4gICAgICogVGhlIHNlbmRlciB3YXMgcHJldmlvdXNseSB2ZXJpZmllZCBidXQgY2hhbmdlZCB0aGVpciBpZGVudGl0eS5cbiAgICAgKi9cbiAgICBWZXJpZmljYXRpb25WaW9sYXRpb246IDUsIFwiNVwiOiBcIlZlcmlmaWNhdGlvblZpb2xhdGlvblwiLFxufSk7XG4vKipcbiAqIFRoZSByZXN1bHQgb2YgYSBzaWduYXR1cmUgY2hlY2suXG4gKiBAZW51bSB7MCB8IDEgfCAyIHwgM31cbiAqL1xuZXhwb3J0IGNvbnN0IFNpZ25hdHVyZVN0YXRlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLyoqXG4gICAgICogVGhlIHNpZ25hdHVyZSBpcyBtaXNzaW5nLlxuICAgICAqL1xuICAgIE1pc3Npbmc6IDAsIFwiMFwiOiBcIk1pc3NpbmdcIixcbiAgICAvKipcbiAgICAgKiBUaGUgc2lnbmF0dXJlIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgSW52YWxpZDogMSwgXCIxXCI6IFwiSW52YWxpZFwiLFxuICAgIC8qKlxuICAgICAqIFRoZSBzaWduYXR1cmUgaXMgdmFsaWQgYnV0IHRoZSBkZXZpY2Ugb3IgdXNlciBpZGVudGl0eSB0aGF0IGNyZWF0ZWQgdGhlXG4gICAgICogc2lnbmF0dXJlIGlzIG5vdCB0cnVzdGVkLlxuICAgICAqL1xuICAgIFZhbGlkQnV0Tm90VHJ1c3RlZDogMiwgXCIyXCI6IFwiVmFsaWRCdXROb3RUcnVzdGVkXCIsXG4gICAgLyoqXG4gICAgICogVGhlIHNpZ25hdHVyZSBpcyB2YWxpZCBhbmQgdGhlIGRldmljZSBvciB1c2VyIGlkZW50aXR5IHRoYXQgY3JlYXRlZCB0aGVcbiAgICAgKiBzaWduYXR1cmUgaXMgdHJ1c3RlZC5cbiAgICAgKi9cbiAgICBWYWxpZEFuZFRydXN0ZWQ6IDMsIFwiM1wiOiBcIlZhbGlkQW5kVHJ1c3RlZFwiLFxufSk7XG4vKipcbiAqIFRoZSB0cnVzdCBsZXZlbCByZXF1aXJlZCB0byBkZWNyeXB0IGFuIGV2ZW50XG4gKiBAZW51bSB7MCB8IDEgfCAyfVxuICovXG5leHBvcnQgY29uc3QgVHJ1c3RSZXF1aXJlbWVudCA9IE9iamVjdC5mcmVlemUoe1xuICAgIC8qKlxuICAgICAqIERlY3J5cHQgZXZlbnRzIGZyb20gZXZlcnlvbmUgcmVnYXJkbGVzcyBvZiB0cnVzdFxuICAgICAqL1xuICAgIFVudHJ1c3RlZDogMCwgXCIwXCI6IFwiVW50cnVzdGVkXCIsXG4gICAgLyoqXG4gICAgICogT25seSBkZWNyeXB0IGV2ZW50cyBmcm9tIGNyb3NzLXNpZ25lZCBvciBsZWdhY3kgZGV2aWNlc1xuICAgICAqL1xuICAgIENyb3NzU2lnbmVkT3JMZWdhY3k6IDEsIFwiMVwiOiBcIkNyb3NzU2lnbmVkT3JMZWdhY3lcIixcbiAgICAvKipcbiAgICAgKiBPbmx5IGRlY3J5cHQgZXZlbnRzIGZyb20gY3Jvc3Mtc2lnbmVkIGRldmljZXNcbiAgICAgKi9cbiAgICBDcm9zc1NpZ25lZDogMiwgXCIyXCI6IFwiQ3Jvc3NTaWduZWRcIixcbn0pO1xuLyoqXG4gKiBMaXN0IG9mIGF2YWlsYWJsZSB2ZXJpZmljYXRpb24gbWV0aG9kcy5cbiAqIEBlbnVtIHswIHwgMSB8IDIgfCAzfVxuICovXG5leHBvcnQgY29uc3QgVmVyaWZpY2F0aW9uTWV0aG9kID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLyoqXG4gICAgICogVGhlIGBtLnNhcy52MWAgdmVyaWZpY2F0aW9uIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFNBUyBtZWFucyBTaG9ydCBBdXRoZW50aWNhdGlvbiBTdHJpbmcuXG4gICAgICovXG4gICAgU2FzVjE6IDAsIFwiMFwiOiBcIlNhc1YxXCIsXG4gICAgLyoqXG4gICAgICogVGhlIGBtLnFyX2NvZGUuc2Nhbi52MWAgdmVyaWZpY2F0aW9uIG1ldGhvZC5cbiAgICAgKi9cbiAgICBRckNvZGVTY2FuVjE6IDEsIFwiMVwiOiBcIlFyQ29kZVNjYW5WMVwiLFxuICAgIC8qKlxuICAgICAqIFRoZSBgbS5xcl9jb2RlLnNob3cudjFgIHZlcmlmaWNhdGlvbiBtZXRob2QuXG4gICAgICovXG4gICAgUXJDb2RlU2hvd1YxOiAyLCBcIjJcIjogXCJRckNvZGVTaG93VjFcIixcbiAgICAvKipcbiAgICAgKiBUaGUgYG0ucmVjaXByb2NhdGUudjFgIHZlcmlmaWNhdGlvbiBtZXRob2QuXG4gICAgICovXG4gICAgUmVjaXByb2NhdGVWMTogMywgXCIzXCI6IFwiUmVjaXByb2NhdGVWMVwiLFxufSk7XG4vKipcbiAqIExpc3Qgb2YgVmVyaWZpY2F0aW9uUmVxdWVzdFN0YXRlIHBoYXNlc1xuICogQGVudW0gezAgfCAxIHwgMiB8IDMgfCA0IHwgNX1cbiAqL1xuZXhwb3J0IGNvbnN0IFZlcmlmaWNhdGlvblJlcXVlc3RQaGFzZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJpZmljYXRpb24gcmVxdWVzdCBoYXMgYmVlbiBuZXdseSBjcmVhdGVkIGJ5IHVzLlxuICAgICAqL1xuICAgIENyZWF0ZWQ6IDAsIFwiMFwiOiBcIkNyZWF0ZWRcIixcbiAgICAvKipcbiAgICAgKiBUaGUgdmVyaWZpY2F0aW9uIHJlcXVlc3Qgd2FzIHJlY2VpdmVkIGZyb20gdGhlIG90aGVyIHBhcnR5LlxuICAgICAqL1xuICAgIFJlcXVlc3RlZDogMSwgXCIxXCI6IFwiUmVxdWVzdGVkXCIsXG4gICAgLyoqXG4gICAgICogVGhlIHZlcmlmaWNhdGlvbiByZXF1ZXN0IGlzIHJlYWR5IHRvIHN0YXJ0IGEgdmVyaWZpY2F0aW9uIGZsb3cuXG4gICAgICovXG4gICAgUmVhZHk6IDIsIFwiMlwiOiBcIlJlYWR5XCIsXG4gICAgLyoqXG4gICAgICogVGhlIHZlcmlmaWNhdGlvbiByZXF1ZXN0IGhhcyB0cmFuc2l0aW9uZWQgaW50byBhIGNvbmNyZXRlIHZlcmlmaWNhdGlvblxuICAgICAqIGZsb3cuIEZvciBleGFtcGxlIGl0IHRyYW5zaXRpb25lZCBpbnRvIHRoZSBlbW9qaSBiYXNlZCBTQVNcbiAgICAgKiB2ZXJpZmljYXRpb24uXG4gICAgICovXG4gICAgVHJhbnNpdGlvbmVkOiAzLCBcIjNcIjogXCJUcmFuc2l0aW9uZWRcIixcbiAgICAvKipcbiAgICAgKiBUaGUgdmVyaWZpY2F0aW9uIGZsb3cgdGhhdCB3YXMgc3RhcnRlZCB3aXRoIHRoaXMgcmVxdWVzdCBoYXMgZmluaXNoZWQuXG4gICAgICovXG4gICAgRG9uZTogNCwgXCI0XCI6IFwiRG9uZVwiLFxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJpZmljYXRpb24gcHJvY2VzcyBoYXMgYmVlbiBjYW5jZWxsZWQuXG4gICAgICovXG4gICAgQ2FuY2VsbGVkOiA1LCBcIjVcIjogXCJDYW5jZWxsZWRcIixcbn0pO1xuXG5jb25zdCBfX3diaW5kZ2VuX2VudW1fSWRiUmVxdWVzdFJlYWR5U3RhdGUgPSBbXCJwZW5kaW5nXCIsIFwiZG9uZVwiXTtcblxuY29uc3QgX193YmluZGdlbl9lbnVtX0lkYlRyYW5zYWN0aW9uTW9kZSA9IFtcInJlYWRvbmx5XCIsIFwicmVhZHdyaXRlXCIsIFwidmVyc2lvbmNoYW5nZVwiLCBcInJlYWR3cml0ZWZsdXNoXCIsIFwiY2xlYW51cFwiXTtcblxuY29uc3QgQXR0YWNobWVudEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hdHRhY2htZW50X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEEgdHlwZSB0byBlbmNyeXB0IGFuZCB0byBkZWNyeXB0IGFueXRoaW5nIHRoYXQgY2FuIGZpdCBpbiBhblxuICogYFVpbnQ4QXJyYXlgLCB1c3VhbGx5IGJpZyBidWZmZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBBdHRhY2htZW50IHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQXR0YWNobWVudEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYXR0YWNobWVudF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgdGhlIGNvbnRlbnQgb2YgdGhlIGBVaW50OEFycmF5YC5cbiAgICAgKlxuICAgICAqIEl0IHByb2R1Y2VzIGFuIGBFbmNyeXB0ZWRBdHRhY2htZW50YCwgd2hpY2ggY2FuIGJlIHVzZWQgdG9cbiAgICAgKiByZXRyaWV2ZSB0aGUgbWVkaWEgZW5jcnlwdGlvbiBpbmZvcm1hdGlvbiwgb3IgdGhlIGVuY3J5cHRlZFxuICAgICAqIGRhdGEuXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnJheVxuICAgICAqIEByZXR1cm5zIHtFbmNyeXB0ZWRBdHRhY2htZW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBlbmNyeXB0KGFycmF5KSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChhcnJheSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYXR0YWNobWVudF9lbmNyeXB0KHB0cjAsIGxlbjApO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFbmNyeXB0ZWRBdHRhY2htZW50Ll9fd3JhcChyZXRbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0IGFuIGBFbmNyeXB0ZWRBdHRhY2htZW50YC5cbiAgICAgKlxuICAgICAqIFRoZSBlbmNyeXB0ZWQgYXR0YWNobWVudCBjYW4gYmUgY3JlYXRlZCBtYW51YWxseSwgb3IgZnJvbSB0aGVcbiAgICAgKiBgZW5jcnlwdGAgbWV0aG9kLlxuICAgICAqXG4gICAgICogKipXYXJuaW5nKio6IFRoZSBlbmNyeXB0ZWQgYXR0YWNobWVudCBjYW4gYmUgdXNlZCBvbmx5XG4gICAgICogKipvbmNlKiohIFRoZSBlbmNyeXB0ZWQgZGF0YSB3aWxsIHN0aWxsIGJlIHByZXNlbnQsIGJ1dCB0aGVcbiAgICAgKiBtZWRpYSBlbmNyeXB0aW9uIGluZm8gKHdoaWNoIGNvbnRhaW4gc2VjcmV0cykgd2lsbCBiZVxuICAgICAqIGRlc3Ryb3llZC4gSXQgaXMgc3RpbGwgcG9zc2libGUgdG8gZ2V0IGEgSlNPTi1lbmNvZGVkIGJhY2t1cFxuICAgICAqIGJ5IGNhbGxpbmcgYEVuY3J5cHRlZEF0dGFjaG1lbnQubWVkaWFFbmNyeXB0aW9uSW5mb2AuXG4gICAgICogQHBhcmFtIHtFbmNyeXB0ZWRBdHRhY2htZW50fSBhdHRhY2htZW50XG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGRlY3J5cHQoYXR0YWNobWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYXR0YWNobWVudCwgRW5jcnlwdGVkQXR0YWNobWVudCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYXR0YWNobWVudF9kZWNyeXB0KGF0dGFjaG1lbnQuX193YmdfcHRyKTtcbiAgICAgICAgaWYgKHJldFszXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzJdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHJldFswXSwgcmV0WzFdKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyZXRbMF0sIHJldFsxXSAqIDEsIDEpO1xuICAgICAgICByZXR1cm4gdjE7XG4gICAgfVxufVxuXG5jb25zdCBCYWNrdXBEZWNyeXB0aW9uS2V5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2JhY2t1cGRlY3J5cHRpb25rZXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogVGhlIHByaXZhdGUgcGFydCBvZiB0aGUgYmFja3VwIGtleSwgdGhlIG9uZSB1c2VkIGZvciByZWNvdmVyeS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhY2t1cERlY3J5cHRpb25LZXkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEJhY2t1cERlY3J5cHRpb25LZXkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQmFja3VwRGVjcnlwdGlvbktleUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBCYWNrdXBEZWNyeXB0aW9uS2V5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19iYWNrdXBkZWNyeXB0aW9ua2V5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHJhbmRvbSBbYEJhY2t1cERlY3J5cHRpb25LZXlgXS5cbiAgICAgKiBAcmV0dXJucyB7QmFja3VwRGVjcnlwdGlvbktleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUmFuZG9tS2V5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmJhY2t1cGRlY3J5cHRpb25rZXlfY3JlYXRlUmFuZG9tS2V5KCk7XG4gICAgICAgIHJldHVybiBCYWNrdXBEZWNyeXB0aW9uS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnkgdG8gY3JlYXRlIGEgW2BCYWNrdXBEZWNyeXB0aW9uS2V5YF0gZnJvbSBhIGJhc2UgNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtCYWNrdXBEZWNyeXB0aW9uS2V5fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmFzZTY0KGtleSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoa2V5LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmFja3VwZGVjcnlwdGlvbmtleV9mcm9tQmFzZTY0KHB0cjAsIGxlbjApO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCYWNrdXBEZWNyeXB0aW9uS2V5Ll9fd3JhcChyZXRbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBiYWNrdXAgZGVjcnlwdGlvbiBrZXkgdG8gYSBiYXNlIDY0IGVuY29kZWQgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9CYXNlNjQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmFja3VwZGVjcnlwdGlvbmtleV90b0Jhc2U2NCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHVibGljIHBhcnQgb2YgdGhlIGJhY2t1cCBrZXkuXG4gICAgICogQHJldHVybnMge01lZ29sbVYxQmFja3VwS2V5fVxuICAgICAqL1xuICAgIGdldCBtZWdvbG1WMVB1YmxpY0tleSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5iYWNrdXBkZWNyeXB0aW9ua2V5X21lZ29sbVYxUHVibGljS2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE1lZ29sbVYxQmFja3VwS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnkgdG8gZGVjcnlwdCBhIG1lc3NhZ2UgdGhhdCB3YXMgZW5jcnlwdGVkIHVzaW5nIHRoZSBwdWJsaWMgcGFydCBvZiB0aGVcbiAgICAgKiBiYWNrdXAga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlcGhlbWVyYWxfa2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaXBoZXJ0ZXh0XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBkZWNyeXB0VjEoZXBoZW1lcmFsX2tleSwgbWFjLCBjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDVfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkNV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGVwaGVtZXJhbF9rZXksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAobWFjLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgY29uc3QgcHRyMiA9IHBhc3NTdHJpbmdUb1dhc20wKGNpcGhlcnRleHQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjIgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLmJhY2t1cGRlY3J5cHRpb25rZXlfZGVjcnlwdFYxKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yKTtcbiAgICAgICAgICAgIHZhciBwdHI0ID0gcmV0WzBdO1xuICAgICAgICAgICAgdmFyIGxlbjQgPSByZXRbMV07XG4gICAgICAgICAgICBpZiAocmV0WzNdKSB7XG4gICAgICAgICAgICAgICAgcHRyNCA9IDA7IGxlbjQgPSAwO1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZDVfMCA9IHB0cjQ7XG4gICAgICAgICAgICBkZWZlcnJlZDVfMSA9IGxlbjQ7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjQsIGxlbjQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQ1XzAsIGRlZmVycmVkNV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgQmFja3VwS2V5c0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19iYWNrdXBrZXlzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFN0b3JlZCB2ZXJzaW9ucyBvZiB0aGUgYmFja3VwIGtleXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYWNrdXBLZXlzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShCYWNrdXBLZXlzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEJhY2t1cEtleXNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQmFja3VwS2V5c0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYmFja3Vwa2V5c19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBrZXkgdXNlZCB0byBkZWNyeXB0IGJhY2tlZCB1cCByb29tIGtleXNcbiAgICAgKiBAcmV0dXJucyB7QmFja3VwRGVjcnlwdGlvbktleSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgZGVjcnlwdGlvbktleSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfYmFja3Vwa2V5c19kZWNyeXB0aW9uS2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IEJhY2t1cERlY3J5cHRpb25LZXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBrZXkgdXNlZCB0byBkZWNyeXB0IGJhY2tlZCB1cCByb29tIGtleXNcbiAgICAgKiBAcGFyYW0ge0JhY2t1cERlY3J5cHRpb25LZXkgfCB1bmRlZmluZWR9IFthcmcwXVxuICAgICAqL1xuICAgIHNldCBkZWNyeXB0aW9uS2V5KGFyZzApIHtcbiAgICAgICAgbGV0IHB0cjAgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUoYXJnMCkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhcmcwLCBCYWNrdXBEZWNyeXB0aW9uS2V5KTtcbiAgICAgICAgICAgIHB0cjAgPSBhcmcwLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2JhY2t1cGtleXNfZGVjcnlwdGlvbktleSh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIHRoYXQgd2UgYXJlIHVzaW5nIGZvciBiYWNrdXBzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IGJhY2t1cFZlcnNpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2JhY2t1cGtleXNfYmFja3VwVmVyc2lvbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHJldFswXSAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyZXRbMF0sIHJldFsxXSAqIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHZlcnNpb24gdGhhdCB3ZSBhcmUgdXNpbmcgZm9yIGJhY2t1cHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFthcmcwXVxuICAgICAqL1xuICAgIHNldCBiYWNrdXBWZXJzaW9uKGFyZzApIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGFyZzApID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2JhY2t1cGtleXNfYmFja3VwVmVyc2lvbih0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBrZXkgdXNlZCB0byBkZWNyeXB0IGJhY2tlZCB1cCByb29tIGtleXMsIGVuY29kZWQgYXMgYmFzZTY0XG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYEJhY2t1cEtleXMuZGVjcnlwdGlvbktleS50b0Jhc2U2NCgpYFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IGRlY3J5cHRpb25LZXlCYXNlNjQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmFja3Vwa2V5c19kZWNyeXB0aW9uS2V5QmFzZTY0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG5cbmNvbnN0IEJhY2t1cFNlY3JldHNCdW5kbGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYmFja3Vwc2VjcmV0c2J1bmRsZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBUaGUgYmFja3VwLXNwZWNpZmljIHBhcnRzIG9mIGEgc2VjcmV0cyBidW5kbGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYWNrdXBTZWNyZXRzQnVuZGxlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShCYWNrdXBTZWNyZXRzQnVuZGxlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEJhY2t1cFNlY3JldHNCdW5kbGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQmFja3VwU2VjcmV0c0J1bmRsZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYmFja3Vwc2VjcmV0c2J1bmRsZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBiYWNrdXAgZGVjcnlwdGlvbiBrZXksIGVuY29kZWQgYXMgdW5wYWRkZWQgYmFzZTY0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGtleSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9iYWNrdXBzZWNyZXRzYnVuZGxlX2tleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBiYWNrdXAgZGVjcnlwdGlvbiBrZXksIGVuY29kZWQgYXMgdW5wYWRkZWQgYmFzZTY0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGtleShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2JhY2t1cHNlY3JldHNidW5kbGVfa2V5KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJhY2t1cCB2ZXJzaW9uIHdoaWNoIHRoaXMgYmFja3VwIGRlY3J5cHRpb24ga2V5IGlzIHVzZWQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBiYWNrdXBfdmVyc2lvbigpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9iYWNrdXBzZWNyZXRzYnVuZGxlX2JhY2t1cF92ZXJzaW9uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcmV0WzBdO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByZXRbMV07XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJhY2t1cCB2ZXJzaW9uIHdoaWNoIHRoaXMgYmFja3VwIGRlY3J5cHRpb24ga2V5IGlzIHVzZWQgd2l0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBiYWNrdXBfdmVyc2lvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2JhY2t1cHNlY3JldHNidW5kbGVfYmFja3VwX3ZlcnNpb24odGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbn1cblxuY29uc3QgQmFzZU1pZ3JhdGlvbkRhdGFGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYmFzZW1pZ3JhdGlvbmRhdGFfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogVGhlIGJhc2UgZGF0YXNldCB0aGF0IGlzIGltcG9ydGFudCB0byBtaWdyYXRlIHRvIHRoZSBSdXN0IFNESy5cbiAqXG4gKiBDYW4gYmUgaW1wb3J0ZWQgaW50byB0aGUgcnVzdCBzdG9yZSB3aXRoIHtAbGluayAjbWlncmF0ZUJhc2VEYXRhfS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VNaWdyYXRpb25EYXRhIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQmFzZU1pZ3JhdGlvbkRhdGFGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2Jhc2VtaWdyYXRpb25kYXRhX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXIgaWQgb2YgdGhlIGFjY291bnQgb3duZXIuXG4gICAgICogQHJldHVybnMge1VzZXJJZCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgdXNlcklkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9iYXNlbWlncmF0aW9uZGF0YV91c2VySWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogVXNlcklkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdXNlciBpZCBvZiB0aGUgYWNjb3VudCBvd25lci5cbiAgICAgKiBAcGFyYW0ge1VzZXJJZCB8IHVuZGVmaW5lZH0gW2FyZzBdXG4gICAgICovXG4gICAgc2V0IHVzZXJJZChhcmcwKSB7XG4gICAgICAgIGxldCBwdHIwID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGFyZzApKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYXJnMCwgVXNlcklkKTtcbiAgICAgICAgICAgIHB0cjAgPSBhcmcwLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2Jhc2VtaWdyYXRpb25kYXRhX3VzZXJJZCh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkZXZpY2UgSUQgb2YgdGhlIGFjY291bnQgb3duZXIuXG4gICAgICogQHJldHVybnMge0RldmljZUlkIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBkZXZpY2VJZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfYmFzZW1pZ3JhdGlvbmRhdGFfZGV2aWNlSWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogRGV2aWNlSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkZXZpY2UgSUQgb2YgdGhlIGFjY291bnQgb3duZXIuXG4gICAgICogQHBhcmFtIHtEZXZpY2VJZCB8IHVuZGVmaW5lZH0gW2FyZzBdXG4gICAgICovXG4gICAgc2V0IGRldmljZUlkKGFyZzApIHtcbiAgICAgICAgbGV0IHB0cjAgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUoYXJnMCkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhcmcwLCBEZXZpY2VJZCk7XG4gICAgICAgICAgICBwdHIwID0gYXJnMC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICB3YXNtLl9fd2JnX3NldF9iYXNlbWlncmF0aW9uZGF0YV9kZXZpY2VJZCh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwaWNrbGUgc3RyaW5nIGhvbGRpbmcgdGhlIE9sbSBBY2NvdW50LCBhcyByZXR1cm5lZCBieVxuICAgICAqIGBvbG1fcGlja2xlX2FjY291bnRgIGluIGxpYm9sbS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBwaWNrbGVkQWNjb3VudCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9iYXNlbWlncmF0aW9uZGF0YV9waWNrbGVkQWNjb3VudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwaWNrbGUgc3RyaW5nIGhvbGRpbmcgdGhlIE9sbSBBY2NvdW50LCBhcyByZXR1cm5lZCBieVxuICAgICAqIGBvbG1fcGlja2xlX2FjY291bnRgIGluIGxpYm9sbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBwaWNrbGVkQWNjb3VudChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2JhY2t1cHNlY3JldHNidW5kbGVfa2V5KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJhY2t1cCB2ZXJzaW9uIHRoYXQgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBiYWNrdXBWZXJzaW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9iYXNlbWlncmF0aW9uZGF0YV9iYWNrdXBWZXJzaW9uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBpZiAocmV0WzBdICE9PSAwKSB7XG4gICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHJldFswXSwgcmV0WzFdICogMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYmFja3VwIHZlcnNpb24gdGhhdCBpcyBjdXJyZW50bHkgYWN0aXZlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbYXJnMF1cbiAgICAgKi9cbiAgICBzZXQgYmFja3VwVmVyc2lvbihhcmcwKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShhcmcwKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9iYXNlbWlncmF0aW9uZGF0YV9iYWNrdXBWZXJzaW9uKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJhY2t1cCByZWNvdmVyeSBrZXksIGFzIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IGJhY2t1cFJlY292ZXJ5S2V5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9iYXNlbWlncmF0aW9uZGF0YV9iYWNrdXBSZWNvdmVyeUtleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHJldFswXSAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyZXRbMF0sIHJldFsxXSAqIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJhY2t1cCByZWNvdmVyeSBrZXksIGFzIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbYXJnMF1cbiAgICAgKi9cbiAgICBzZXQgYmFja3VwUmVjb3ZlcnlLZXkoYXJnMCkge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoYXJnMCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfYmFzZW1pZ3JhdGlvbmRhdGFfYmFja3VwUmVjb3ZlcnlLZXkodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcHJpdmF0ZSwgYmFzZTY0LWVuY29kZWQsIG1hc3RlciBjcm9zcy1zaWduaW5nIGtleS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBwcml2YXRlQ3Jvc3NTaWduaW5nTWFzdGVyS2V5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9iYXNlbWlncmF0aW9uZGF0YV9wcml2YXRlQ3Jvc3NTaWduaW5nTWFzdGVyS2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBpZiAocmV0WzBdICE9PSAwKSB7XG4gICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHJldFswXSwgcmV0WzFdICogMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcHJpdmF0ZSwgYmFzZTY0LWVuY29kZWQsIG1hc3RlciBjcm9zcy1zaWduaW5nIGtleS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW2FyZzBdXG4gICAgICovXG4gICAgc2V0IHByaXZhdGVDcm9zc1NpZ25pbmdNYXN0ZXJLZXkoYXJnMCkge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoYXJnMCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfYmFzZW1pZ3JhdGlvbmRhdGFfcHJpdmF0ZUNyb3NzU2lnbmluZ01hc3RlcktleSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwcml2YXRlLCBiYXNlNjQtZW5jb2RlZCwgc2VsZi1zaWduaW5nIGtleS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBwcml2YXRlQ3Jvc3NTaWduaW5nU2VsZlNpZ25pbmdLZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2Jhc2VtaWdyYXRpb25kYXRhX3ByaXZhdGVDcm9zc1NpZ25pbmdTZWxmU2lnbmluZ0tleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHJldFswXSAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyZXRbMF0sIHJldFsxXSAqIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHByaXZhdGUsIGJhc2U2NC1lbmNvZGVkLCBzZWxmLXNpZ25pbmcga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbYXJnMF1cbiAgICAgKi9cbiAgICBzZXQgcHJpdmF0ZUNyb3NzU2lnbmluZ1NlbGZTaWduaW5nS2V5KGFyZzApIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGFyZzApID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2Jhc2VtaWdyYXRpb25kYXRhX3ByaXZhdGVDcm9zc1NpZ25pbmdTZWxmU2lnbmluZ0tleSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwcml2YXRlLCBiYXNlNjQtZW5jb2RlZCwgdXNlci1zaWduaW5nIGtleS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBwcml2YXRlQ3Jvc3NTaWduaW5nVXNlclNpZ25pbmdLZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2Jhc2VtaWdyYXRpb25kYXRhX3ByaXZhdGVDcm9zc1NpZ25pbmdVc2VyU2lnbmluZ0tleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHJldFswXSAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyZXRbMF0sIHJldFsxXSAqIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHByaXZhdGUsIGJhc2U2NC1lbmNvZGVkLCB1c2VyLXNpZ25pbmcga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbYXJnMF1cbiAgICAgKi9cbiAgICBzZXQgcHJpdmF0ZUNyb3NzU2lnbmluZ1VzZXJTaWduaW5nS2V5KGFyZzApIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGFyZzApID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2Jhc2VtaWdyYXRpb25kYXRhX3ByaXZhdGVDcm9zc1NpZ25pbmdVc2VyU2lnbmluZ0tleSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBgQmFzZU1pZ3JhdGlvbkRhdGFgIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmFzZW1pZ3JhdGlvbmRhdGFfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBCYXNlTWlncmF0aW9uRGF0YUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuY29uc3QgQ2FuY2VsSW5mb0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19jYW5jZWxpbmZvX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjYW5jZWxsYXRpb24gb2YgYSB2ZXJpZmljYXRpb24gcmVxdWVzdCBvclxuICogdmVyaWZpY2F0aW9uIGZsb3cuXG4gKi9cbmV4cG9ydCBjbGFzcyBDYW5jZWxJbmZvIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShDYW5jZWxJbmZvLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIENhbmNlbEluZm9GaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQ2FuY2VsSW5mb0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfY2FuY2VsaW5mb19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgcmVhc29uIG9mIHRoZSBjYW5jZWxsYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICByZWFzb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uY2FuY2VsaW5mb19yZWFzb24odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGBjb2RlYCAoZS5nLiBgbS51c2VyYCkgdGhhdCB3YXMgdXNlZCB0byBjYW5jZWwgdGhlXG4gICAgICogdmVyaWZpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgY2FuY2VsQ29kZSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNhbmNlbGluZm9fY2FuY2VsQ29kZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhcyB0aGUgdmVyaWZpY2F0aW9uIGNhbmNlbGxlZCBieSB1cz9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5jZWxsZWRieVVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNhbmNlbGluZm9fY2FuY2VsbGVkYnlVcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxufVxuXG5jb25zdCBDaGVja0NvZGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfY2hlY2tjb2RlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEEgY2hlY2sgY29kZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbmZpcm0gdGhhdCB0d28gW2BFc3RhYmxpc2hlZEVjaWVzYF1cbiAqIG9iamVjdHMgc2hhcmUgdGhlIHNhbWUgc2VjcmV0LiBUaGlzIGlzIHN1cHBvc2VkIHRvIGJlIHNoYXJlZCBvdXQtb2YtYmFuZCB0b1xuICogcHJvdGVjdCBhZ2FpbnN0IGFjdGl2ZSBNYW4taW4tdGhlLW1pZGRsZSAoTUlUTSkgYXR0YWNrcy5cbiAqXG4gKiBTaW5jZSB0aGUgaW5pdGlhdG9yIGRldmljZSBjYW4gYWx3YXlzIHRlbGwgd2hldGhlciBhIE1JVE0gYXR0YWNrIGlzIGluXG4gKiBwcm9ncmVzcyBhZnRlciBjaGFubmVsIGVzdGFibGlzaG1lbnQsIHRoaXMgY29kZSB0ZWNobmljYWxseSBjYXJyaWVzIG9ubHkgYVxuICogc2luZ2xlIGJpdCBvZiBpbmZvcm1hdGlvbiwgcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhlIGluaXRpYXRvciBoYXMgZGV0ZXJtaW5lZFxuICogdGhhdCB0aGUgY2hhbm5lbCBpcyBcInNlY3VyZVwiIG9yIFwibm90IHNlY3VyZVwiLlxuICpcbiAqIEhvd2V2ZXIsIGdpdmVuIHRoaXMgd2lsbCBuZWVkIHRvIGJlIGludGVyYWN0aXZlbHkgY29uZmlybWVkIGJ5IHRoZSB1c2VyLFxuICogdGhlcmUgaXMgcmlzayB0aGF0IHRoZSB1c2VyIHdvdWxkIGNvbmZpcm0gdGhlIGRpYWxvZ3VlIHdpdGhvdXQgcGF5aW5nXG4gKiBhdHRlbnRpb24gdG8gaXRzIGNvbnRlbnQuIEJ5IGV4cGFuZGluZyB0aGlzIHNpbmdsZSBiaXQgaW50byBhIGRldGVybWluaXN0aWNcbiAqIHR3by1kaWdpdCBjaGVjayBjb2RlLCB0aGUgdXNlciBpcyBmb3JjZWQgdG8gcGF5IG1vcmUgYXR0ZW50aW9uIGJ5IGhhdmluZyB0b1xuICogZW50ZXIgaXQgaW5zdGVhZCBvZiBqdXN0IGNsaWNraW5nIHRocm91Z2ggYSBkaWFsb2d1ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIENoZWNrQ29kZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQ2hlY2tDb2RlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIENoZWNrQ29kZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBDaGVja0NvZGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2NoZWNrY29kZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoZWNrIGNvZGUgdG8gYW4gYXJyYXkgb2YgdHdvIGJ5dGVzLlxuICAgICAqXG4gICAgICogVGhlIGJ5dGVzIGNhbiBiZSBjb252ZXJ0ZWQgdG8gYSBtb3JlIHVzZXItZnJpZW5kbHkgcmVwcmVzZW50YXRpb24uIFRoZVxuICAgICAqIFtgQ2hlY2tDb2RlOjp0b19kaWdpdGBdIGNvbnZlcnRzIHRoZSBieXRlcyB0byBhIHR3by1kaWdpdCBudW1iZXIuXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgYXNfYnl0ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uY2hlY2tjb2RlX2FzX2J5dGVzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyZXRbMF0sIHJldFsxXSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocmV0WzBdLCByZXRbMV0gKiAxLCAxKTtcbiAgICAgICAgcmV0dXJuIHYxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjaGVjayBjb2RlIHRvIHR3byBiYXNlLTEwIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBUaGUgbnVtYmVyIHNob3VsZCBiZSBkaXNwbGF5ZWQgd2l0aCBhIGxlYWRpbmcgMCBpbiBjYXNlIHRoZSBmaXJzdCBkaWdpdFxuICAgICAqIGlzIGEgMC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRvX2RpZ2l0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNoZWNrY29kZV90b19kaWdpdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuXG5jb25zdCBDb2xsZWN0U3RyYXRlZ3lGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfY29sbGVjdHN0cmF0ZWd5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFN0cmF0ZWd5IHRvIGNvbGxlY3QgdGhlIGRldmljZXMgdGhhdCBzaG91bGQgcmVjZWl2ZSByb29tIGtleXMgZm9yIHRoZVxuICogY3VycmVudCBkaXNjdXNzaW9uLlxuICovXG5leHBvcnQgY2xhc3MgQ29sbGVjdFN0cmF0ZWd5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShDb2xsZWN0U3RyYXRlZ3kucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQ29sbGVjdFN0cmF0ZWd5RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIENvbGxlY3RTdHJhdGVneUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfY29sbGVjdHN0cmF0ZWd5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdHMgZm9yIGVxdWFsaXR5IGJldHdlZW4gdHdvIFtgQ29sbGVjdFN0cmF0ZWd5YF1zLlxuICAgICAqIEBwYXJhbSB7Q29sbGVjdFN0cmF0ZWd5fSBvdGhlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhvdGhlciwgQ29sbGVjdFN0cmF0ZWd5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jb2xsZWN0c3RyYXRlZ3lfZXEodGhpcy5fX3diZ19wdHIsIG90aGVyLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldmljZSBiYXNlZCBzaGFyaW5nIHN0cmF0ZWd5LlxuICAgICAqXG4gICAgICogSWYgYG9ubHlfYWxsb3dfdHJ1c3RlZF9kZXZpY2VzYCBpcyBgdHJ1ZWAsIGRldmljZXMgdGhhdCBhcmUgbm90IHRydXN0ZWRcbiAgICAgKiB3aWxsIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGNvbnZlcnNhdGlvbi4gQSBkZXZpY2UgaXMgdHJ1c3RlZCBpZiBhbnkgb2ZcbiAgICAgKiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gICAgICogICAgIC0gSXQgd2FzIG1hbnVhbGx5IG1hcmtlZCBhcyB0cnVzdGVkLlxuICAgICAqICAgICAtIEl0IHdhcyBtYXJrZWQgYXMgdmVyaWZpZWQgdmlhIGludGVyYWN0aXZlIHZlcmlmaWNhdGlvbi5cbiAgICAgKiAgICAgLSBJdCBpcyBzaWduZWQgYnkgaXRzIG93bmVyIGlkZW50aXR5LCBhbmQgdGhpcyBpZGVudGl0eSBoYXMgYmVlblxuICAgICAqICAgICAgIHRydXN0ZWQgdmlhIGludGVyYWN0aXZlIHZlcmlmaWNhdGlvbi5cbiAgICAgKiAgICAgLSBJdCBpcyB0aGUgY3VycmVudCBvd24gZGV2aWNlIG9mIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogSWYgYGVycm9yX29uX3ZlcmlmaWVkX3VzZXJgIGlzIGB0cnVlYCwgYW5kIGEgdmVyaWZpZWQgdXNlciBoYXMgYW5cbiAgICAgKiB1bnNpZ25lZCBkZXZpY2UsIGtleSBzaGFyaW5nIHdpbGwgZmFpbCB3aXRoIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogSWYgYGVycm9yX29uX3ZlcmlmaWVkX3VzZXJgIGlzIGB0cnVlYCwgYW5kIGEgdmVyaWZpZWQgdXNlciBoYXMgcmVwbGFjZWRcbiAgICAgKiB0aGVpciBpZGVudGl0eSwga2V5IHNoYXJpbmcgd2lsbCBmYWlsIHdpdGggYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBPdGhlcndpc2UsIGtleXMgYXJlIHNoYXJlZCB3aXRoIHVuc2lnbmVkIGRldmljZXMgYXMgbm9ybWFsLlxuICAgICAqXG4gICAgICogT25jZSB0aGUgcHJvYmxlbWF0aWMgZGV2aWNlcyBhcmUgYmxhY2tsaXN0ZWQgb3Igd2hpdGVsaXN0ZWQgdGhlXG4gICAgICogY2FsbGVyIGNhbiByZXRyeSB0byBzaGFyZSBhIHNlY29uZCB0aW1lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25seV9hbGxvd190cnVzdGVkX2RldmljZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVycm9yX29uX3ZlcmlmaWVkX3VzZXJfcHJvYmxlbVxuICAgICAqIEByZXR1cm5zIHtDb2xsZWN0U3RyYXRlZ3l9XG4gICAgICovXG4gICAgc3RhdGljIGRldmljZUJhc2VkU3RyYXRlZ3kob25seV9hbGxvd190cnVzdGVkX2RldmljZXMsIGVycm9yX29uX3ZlcmlmaWVkX3VzZXJfcHJvYmxlbSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNvbGxlY3RzdHJhdGVneV9kZXZpY2VCYXNlZFN0cmF0ZWd5KG9ubHlfYWxsb3dfdHJ1c3RlZF9kZXZpY2VzLCBlcnJvcl9vbl92ZXJpZmllZF91c2VyX3Byb2JsZW0pO1xuICAgICAgICByZXR1cm4gQ29sbGVjdFN0cmF0ZWd5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaGFyZSBiYXNlZCBvbiBpZGVudGl0eS4gT25seSBkaXN0cmlidXRlIHRvIGRldmljZXMgc2lnbmVkIGJ5IHRoZWlyXG4gICAgICogb3duZXIuIElmIGEgdXNlciBoYXMgbm8gcHVibGlzaGVkIGlkZW50aXR5IGhlIHdpbGwgbm90IHJlY2VpdmVcbiAgICAgKiBhbnkgcm9vbSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtDb2xsZWN0U3RyYXRlZ3l9XG4gICAgICovXG4gICAgc3RhdGljIGlkZW50aXR5QmFzZWRTdHJhdGVneSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jb2xsZWN0c3RyYXRlZ3lfaWRlbnRpdHlCYXNlZFN0cmF0ZWd5KCk7XG4gICAgICAgIHJldHVybiBDb2xsZWN0U3RyYXRlZ3kuX193cmFwKHJldCk7XG4gICAgfVxufVxuXG5jb25zdCBDcm9zc1NpZ25pbmdCb290c3RyYXBSZXF1ZXN0c0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19jcm9zc3NpZ25pbmdib290c3RyYXByZXF1ZXN0c19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBIHNldCBvZiByZXF1ZXN0cyB0byBiZSBleGVjdXRlZCB3aGVuIGJvb3RzdHJhcHBpbmcgY3Jvc3Mtc2lnbmluZyB1c2luZ1xuICoge0BsaW5rIE9sbU1hY2hpbmUuYm9vdHN0cmFwQ3Jvc3NTaWduaW5nfS5cbiAqL1xuZXhwb3J0IGNsYXNzIENyb3NzU2lnbmluZ0Jvb3RzdHJhcFJlcXVlc3RzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShDcm9zc1NpZ25pbmdCb290c3RyYXBSZXF1ZXN0cy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBDcm9zc1NpZ25pbmdCb290c3RyYXBSZXF1ZXN0c0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBDcm9zc1NpZ25pbmdCb290c3RyYXBSZXF1ZXN0c0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfY3Jvc3NzaWduaW5nYm9vdHN0cmFwcmVxdWVzdHNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBvcHRpb25hbCByZXF1ZXN0IHRvIHVwbG9hZCBhIGRldmljZSBrZXkuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgZWl0aGVyIGJlIGB1bmRlZmluZWRgLCBvciBhbiBcIm91dGdvaW5nIHJlcXVlc3RcIiBhcyByZXR1cm5lZCBieVxuICAgICAqIHtAbGluayBPbG1NYWNoaW5lLm91dGdvaW5nUmVxdWVzdHN9LlxuICAgICAqXG4gICAgICogSWYgaXQgaXMgZGVmaW5lZCwgdGhlIHJlcXVlc3Qgc2hvdWxkIGJlIHNlbnQgZmlyc3QsIGFuZCB0aGUgcmVzdWx0IHNlbnRcbiAgICAgKiBiYWNrIHdpdGgge0BsaW5rIE9sbU1hY2hpbmUubWFya1JlcXVlc3RBc1NlbnR9LlxuICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICovXG4gICAgZ2V0IHVwbG9hZEtleXNSZXF1ZXN0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9jcm9zc3NpZ25pbmdib290c3RyYXByZXF1ZXN0c191cGxvYWRLZXlzUmVxdWVzdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdG8gdXBsb2FkIHRoZSBjcm9zcy1zaWduaW5nIGtleXMuXG4gICAgICpcbiAgICAgKiBTaG91bGQgYmUgc2VudCBzZWNvbmQuXG4gICAgICogQHJldHVybnMge1VwbG9hZFNpZ25pbmdLZXlzUmVxdWVzdH1cbiAgICAgKi9cbiAgICBnZXQgdXBsb2FkU2lnbmluZ0tleXNSZXF1ZXN0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9jcm9zc3NpZ25pbmdib290c3RyYXByZXF1ZXN0c191cGxvYWRTaWduaW5nS2V5c1JlcXVlc3QodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVXBsb2FkU2lnbmluZ0tleXNSZXF1ZXN0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHRvIHVwbG9hZCBrZXkgc2lnbmF0dXJlcywgaW5jbHVkaW5nIHRob3NlIGZvciB0aGUgY3Jvc3Mtc2lnbmluZ1xuICAgICAqIGtleXMsIGFuZCBtYXliZSBzb21lIGZvciB0aGUgb3B0aW9uYWwgdXBsb2FkZWQga2V5IHRvby5cbiAgICAgKlxuICAgICAqIFNob3VsZCBiZSBzZW50IGxhc3QuXG4gICAgICogQHJldHVybnMge1NpZ25hdHVyZVVwbG9hZFJlcXVlc3R9XG4gICAgICovXG4gICAgZ2V0IHVwbG9hZFNpZ25hdHVyZXNSZXF1ZXN0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9jcm9zc3NpZ25pbmdib290c3RyYXByZXF1ZXN0c191cGxvYWRTaWduYXR1cmVzUmVxdWVzdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmVVcGxvYWRSZXF1ZXN0Ll9fd3JhcChyZXQpO1xuICAgIH1cbn1cblxuY29uc3QgQ3Jvc3NTaWduaW5nS2V5RXhwb3J0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2Nyb3Nzc2lnbmluZ2tleWV4cG9ydF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBIHN0cnVjdCBjb250YWluaW5nIHByaXZhdGUgY3Jvc3Mgc2lnbmluZyBrZXlzIHRoYXQgY2FuIGJlIGJhY2tlZFxuICogdXAgb3IgdXBsb2FkZWQgdG8gdGhlIHNlY3JldCBzdG9yZS5cbiAqL1xuZXhwb3J0IGNsYXNzIENyb3NzU2lnbmluZ0tleUV4cG9ydCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQ3Jvc3NTaWduaW5nS2V5RXhwb3J0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIENyb3NzU2lnbmluZ0tleUV4cG9ydEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBDcm9zc1NpZ25pbmdLZXlFeHBvcnRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2Nyb3Nzc2lnbmluZ2tleWV4cG9ydF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzZWVkIG9mIHRoZSBtYXN0ZXIga2V5IGVuY29kZWQgYXMgdW5wYWRkZWQgYmFzZTY0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IG1hc3RlcktleSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jcm9zc3NpZ25pbmdrZXlleHBvcnRfbWFzdGVyS2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBpZiAocmV0WzBdICE9PSAwKSB7XG4gICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHJldFswXSwgcmV0WzFdICogMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2VlZCBvZiB0aGUgc2VsZiBzaWduaW5nIGtleSBlbmNvZGVkIGFzIHVucGFkZGVkIGJhc2U2NC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBzZWxmX3NpZ25pbmdfa2V5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNyb3Nzc2lnbmluZ2tleWV4cG9ydF9zZWxmX3NpZ25pbmdfa2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBpZiAocmV0WzBdICE9PSAwKSB7XG4gICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHJldFswXSwgcmV0WzFdICogMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2VlZCBvZiB0aGUgdXNlciBzaWduaW5nIGtleSBlbmNvZGVkIGFzIHVucGFkZGVkIGJhc2U2NC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCB1c2VyU2lnbmluZ0tleSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jcm9zc3NpZ25pbmdrZXlleHBvcnRfdXNlclNpZ25pbmdLZXkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICBsZXQgdjE7XG4gICAgICAgIGlmIChyZXRbMF0gIT09IDApIHtcbiAgICAgICAgICAgIHYxID0gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocmV0WzBdLCByZXRbMV0gKiAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjE7XG4gICAgfVxufVxuXG5jb25zdCBDcm9zc1NpZ25pbmdTdGF0dXNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfY3Jvc3NzaWduaW5nc3RhdHVzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFN0cnVjdCByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIG91ciBwcml2YXRlIGNyb3NzIHNpZ25pbmcga2V5cyxcbiAqIGl0IHNob3dzIHdoaWNoIHByaXZhdGUgY3Jvc3Mgc2lnbmluZyBrZXlzIHdlIGhhdmUgbG9jYWxseSBzdG9yZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBDcm9zc1NpZ25pbmdTdGF0dXMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKENyb3NzU2lnbmluZ1N0YXR1cy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBDcm9zc1NpZ25pbmdTdGF0dXNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQ3Jvc3NTaWduaW5nU3RhdHVzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19jcm9zc3NpZ25pbmdzdGF0dXNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEbyB3ZSBoYXZlIHRoZSBtYXN0ZXIga2V5P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBoYXNNYXN0ZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uY3Jvc3NzaWduaW5nc3RhdHVzX2hhc01hc3Rlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvIHdlIGhhdmUgdGhlIHNlbGYgc2lnbmluZyBrZXk/IFRoaXMgb25lIGlzIG5lY2Vzc2FyeSB0byBzaWduXG4gICAgICogb3VyIG93biBkZXZpY2VzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBoYXNTZWxmU2lnbmluZygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jcm9zc3NpZ25pbmdzdGF0dXNfaGFzU2VsZlNpZ25pbmcodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEbyB3ZSBoYXZlIHRoZSB1c2VyIHNpZ25pbmcga2V5PyBUaGlzIG9uZSBpcyBuZWNlc3NhcnkgdG8gc2lnblxuICAgICAqIG90aGVyIHVzZXJzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBoYXNVc2VyU2lnbmluZygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jcm9zc3NpZ25pbmdzdGF0dXNfaGFzVXNlclNpZ25pbmcodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbn1cblxuY29uc3QgQ3VydmUyNTUxOVB1YmxpY0tleUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19jdXJ2ZTI1NTE5cHVibGlja2V5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEEgQ3VydmUyNTUxOSBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgY2xhc3MgQ3VydmUyNTUxOVB1YmxpY0tleSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQ3VydmUyNTUxOVB1YmxpY0tleS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBDdXJ2ZTI1NTE5UHVibGljS2V5RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEN1cnZlMjU1MTlQdWJsaWNLZXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2N1cnZlMjU1MTlwdWJsaWNrZXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgW2BDdXJ2ZTI1NTE5UHVibGljS2V5YF0gZnJvbSBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChrZXksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jdXJ2ZTI1NTE5cHVibGlja2V5X25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldFswXSA+Pj4gMDtcbiAgICAgICAgQ3VydmUyNTUxOVB1YmxpY0tleUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIGEgQ3VydmUyNTUxOSBwdWJsaWMga2V5IGhhcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uY3VydmUyNTUxOXB1YmxpY2tleV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgYW4gQ3VydmUyNTUxOSBwdWJsaWMga2V5IHRvIGFuIHVucGFkZGVkIGJhc2U2NFxuICAgICAqIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9CYXNlNjQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jdXJ2ZTI1NTE5cHVibGlja2V5X3RvQmFzZTY0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcmV0WzBdO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByZXRbMV07XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IERlY3J5cHRlZFJvb21FdmVudEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19kZWNyeXB0ZWRyb29tZXZlbnRfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQSBkZWNyeXB0ZWQgcm9vbSBldmVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIERlY3J5cHRlZFJvb21FdmVudCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRGVjcnlwdGVkUm9vbUV2ZW50LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIERlY3J5cHRlZFJvb21FdmVudEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBEZWNyeXB0ZWRSb29tRXZlbnRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2RlY3J5cHRlZHJvb21ldmVudF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBKU09OLWVuY29kZWQgZGVjcnlwdGVkIGV2ZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGV2ZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9kZWNyeXB0ZWRyb29tZXZlbnRfZXZlbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdXNlciBJRCBvZiB0aGUgZXZlbnQgc2VuZGVyLCBub3RlIHRoaXMgaXMgdW50cnVzdGVkIGRhdGFcbiAgICAgKiB1bmxlc3MgdGhlIGB2ZXJpZmljYXRpb25fc3RhdGVgIGlzIGFzIHdlbGwgdHJ1c3RlZC5cbiAgICAgKiBAcmV0dXJucyB7VXNlcklkIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBzZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGVjcnlwdGVkcm9vbWV2ZW50X3NlbmRlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBVc2VySWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkZXZpY2UgSUQgb2YgdGhlIGRldmljZSB0aGF0IHNlbnQgdXMgdGhlIGV2ZW50LCBub3RlIHRoaXNcbiAgICAgKiBpcyB1bnRydXN0ZWQgZGF0YSB1bmxlc3MgYHZlcmlmaWNhdGlvbl9zdGF0ZWAgaXMgYXMgd2VsbFxuICAgICAqIHRydXN0ZWQuXG4gICAgICogQHJldHVybnMge0RldmljZUlkIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBzZW5kZXJEZXZpY2UoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGVjcnlwdGVkcm9vbWV2ZW50X3NlbmRlckRldmljZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBEZXZpY2VJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIEN1cnZlMjU1MTkga2V5IG9mIHRoZSBkZXZpY2UgdGhhdCBjcmVhdGVkIHRoZSBtZWdvbG1cbiAgICAgKiBkZWNyeXB0aW9uIGtleSBvcmlnaW5hbGx5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IHNlbmRlckN1cnZlMjU1MTlLZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGVjcnlwdGVkcm9vbWV2ZW50X3NlbmRlckN1cnZlMjU1MTlLZXkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2lnbmluZyBFZDI1NTE5IGtleSB0aGF0IGhhdmUgY3JlYXRlZCB0aGUgbWVnb2xtIGtleSB0aGF0XG4gICAgICogd2FzIHVzZWQgdG8gZGVjcnlwdCB0aGlzIHNlc3Npb24uXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgc2VuZGVyQ2xhaW1lZEVkMjU1MTlLZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGVjcnlwdGVkcm9vbWV2ZW50X3NlbmRlckNsYWltZWRFZDI1NTE5S2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBlbXB0eSBhcnJheVxuICAgICAqXG4gICAgICogUHJldmlvdXNseSwgdGhpcyByZXR1cm5lZCB0aGUgY2hhaW4gb2YgQ3VydmUyNTUxOSBrZXlzIHRocm91Z2ggd2hpY2hcbiAgICAgKiB0aGlzIHNlc3Npb24gd2FzIGZvcndhcmRlZCwgdmlhIGBtLmZvcndhcmRlZF9yb29tX2tleWAgZXZlbnRzLlxuICAgICAqIEhvd2V2ZXIsIHRoYXQgaXMgbm90IGNyeXB0b2dyYXBoaWNhbGx5IHJlbGlhYmxlLCBhbmQgY2xpZW50cyBzaG91bGQgbm90XG4gICAgICogYmUgdXNpbmcgaXQuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRyaXgtb3JnL21hdHJpeC1zcGVjL2lzc3Vlcy8xMDg5XG4gICAgICogQHJldHVybnMge0FycmF5PGFueT59XG4gICAgICovXG4gICAgZ2V0IGZvcndhcmRpbmdDdXJ2ZTI1NTE5S2V5Q2hhaW4oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGVjcnlwdGVkcm9vbWV2ZW50X2ZvcndhcmRpbmdDdXJ2ZTI1NTE5S2V5Q2hhaW4odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdmVyaWZpY2F0aW9uIHN0YXRlIG9mIHRoZSBkZXZpY2UgdGhhdCBzZW50IHVzIHRoZSBldmVudC5cbiAgICAgKiBOb3RlIHRoaXMgaXMgdGhlIHN0YXRlIG9mIHRoZSBkZXZpY2UgYXQgdGhlIHRpbWUgb2ZcbiAgICAgKiBkZWNyeXB0aW9uLiBJdCBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUgaWYgYSBkZXZpY2UgZ2V0c1xuICAgICAqIHZlcmlmaWVkIG9yIGRlbGV0ZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdHJpY3RcbiAgICAgKiBAcmV0dXJucyB7U2hpZWxkU3RhdGUgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgc2hpZWxkU3RhdGUoc3RyaWN0KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGVjcnlwdGVkcm9vbWV2ZW50X3NoaWVsZFN0YXRlKHRoaXMuX193YmdfcHRyLCBzdHJpY3QpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogU2hpZWxkU3RhdGUuX193cmFwKHJldCk7XG4gICAgfVxufVxuXG5jb25zdCBEZWNyeXB0aW9uU2V0dGluZ3NGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZGVjcnlwdGlvbnNldHRpbmdzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFNldHRpbmdzIGZvciBkZWNyeXB0aW5nIG1lc3NhZ2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWNyeXB0aW9uU2V0dGluZ3Mge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBEZWNyeXB0aW9uU2V0dGluZ3NGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2RlY3J5cHRpb25zZXR0aW5nc19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0cnVzdCBsZXZlbCByZXF1aXJlZCB0byBkZWNyeXB0IHRoZSBldmVudFxuICAgICAqIEByZXR1cm5zIHtUcnVzdFJlcXVpcmVtZW50fVxuICAgICAqL1xuICAgIGdldCBzZW5kZXJfZGV2aWNlX3RydXN0X3JlcXVpcmVtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9kZWNyeXB0aW9uc2V0dGluZ3Nfc2VuZGVyX2RldmljZV90cnVzdF9yZXF1aXJlbWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0cnVzdCBsZXZlbCByZXF1aXJlZCB0byBkZWNyeXB0IHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7VHJ1c3RSZXF1aXJlbWVudH0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzZW5kZXJfZGV2aWNlX3RydXN0X3JlcXVpcmVtZW50KGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfZGVjcnlwdGlvbnNldHRpbmdzX3NlbmRlcl9kZXZpY2VfdHJ1c3RfcmVxdWlyZW1lbnQodGhpcy5fX3diZ19wdHIsIGFyZzApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYERlY3J5cHRpb25TZXR0aW5nc2Agd2l0aCB0aGUgZ2l2ZW4gdHJ1c3QgcmVxdWlyZW1lbnQuXG4gICAgICogQHBhcmFtIHtUcnVzdFJlcXVpcmVtZW50fSBzZW5kZXJfZGV2aWNlX3RydXN0X3JlcXVpcmVtZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VuZGVyX2RldmljZV90cnVzdF9yZXF1aXJlbWVudCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRlY3J5cHRpb25zZXR0aW5nc19uZXcoc2VuZGVyX2RldmljZV90cnVzdF9yZXF1aXJlbWVudCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBEZWNyeXB0aW9uU2V0dGluZ3NGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNvbnN0IERlaHlkcmF0ZWREZXZpY2VGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZGVoeWRyYXRlZGRldmljZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBIGRlaHlkcmF0ZWQgZGV2aWNlIHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIHRoZSBzZXJ2ZXJcbiAqL1xuZXhwb3J0IGNsYXNzIERlaHlkcmF0ZWREZXZpY2Uge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKERlaHlkcmF0ZWREZXZpY2UucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgRGVoeWRyYXRlZERldmljZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBEZWh5ZHJhdGVkRGV2aWNlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19kZWh5ZHJhdGVkZGV2aWNlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSByZXF1ZXN0IHRvIHVwbG9hZCB0aGUgZGVoeWRyYXRlZCBkZXZpY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5pdGlhbF9kZXZpY2VfZGlzcGxheV9uYW1lXG4gICAgICogQHBhcmFtIHtEZWh5ZHJhdGVkRGV2aWNlS2V5fSBkZWh5ZHJhdGVkX2RldmljZV9rZXlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQdXREZWh5ZHJhdGVkRGV2aWNlUmVxdWVzdD59XG4gICAgICovXG4gICAga2V5c0ZvclVwbG9hZChpbml0aWFsX2RldmljZV9kaXNwbGF5X25hbWUsIGRlaHlkcmF0ZWRfZGV2aWNlX2tleSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZGVoeWRyYXRlZF9kZXZpY2Vfa2V5LCBEZWh5ZHJhdGVkRGV2aWNlS2V5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZWh5ZHJhdGVkZGV2aWNlX2tleXNGb3JVcGxvYWQodGhpcy5fX3diZ19wdHIsIGluaXRpYWxfZGV2aWNlX2Rpc3BsYXlfbmFtZSwgZGVoeWRyYXRlZF9kZXZpY2Vfa2V5Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuXG5jb25zdCBEZWh5ZHJhdGVkRGV2aWNlS2V5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2RlaHlkcmF0ZWRkZXZpY2VrZXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogRGVoeWRyYXRlZCBkZXZpY2Uga2V5XG4gKi9cbmV4cG9ydCBjbGFzcyBEZWh5ZHJhdGVkRGV2aWNlS2V5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShEZWh5ZHJhdGVkRGV2aWNlS2V5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIERlaHlkcmF0ZWREZXZpY2VLZXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRGVoeWRyYXRlZERldmljZUtleUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZGVoeWRyYXRlZGRldmljZWtleV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyByYW5kb20gZGVoeWRyYXRlZCBkZXZpY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHtEZWh5ZHJhdGVkRGV2aWNlS2V5fVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSYW5kb21LZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGVoeWRyYXRlZGRldmljZWtleV9jcmVhdGVSYW5kb21LZXkoKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVoeWRyYXRlZERldmljZUtleS5fX3dyYXAocmV0WzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgZGVoeWRyYXRlZCBkZXZpY2Uga2V5IGZyb20gYSBnaXZlbiBhcnJheS5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5XG4gICAgICogQHJldHVybnMge0RlaHlkcmF0ZWREZXZpY2VLZXl9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUtleUZyb21BcnJheShhcnJheSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRlaHlkcmF0ZWRkZXZpY2VrZXlfY3JlYXRlS2V5RnJvbUFycmF5KGFycmF5KTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVoeWRyYXRlZERldmljZUtleS5fX3dyYXAocmV0WzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgZGVoeWRyYXRlZCBkZXZpY2Uga2V5IHRvIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9CYXNlNjQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGVoeWRyYXRlZGRldmljZWtleV90b0Jhc2U2NCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuXG5jb25zdCBEZWh5ZHJhdGVkRGV2aWNlc0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19kZWh5ZHJhdGVkZGV2aWNlc19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBTdHJ1Y3QgY29sbGVjdGluZyBtZXRob2RzIHRvIGNyZWF0ZSBhbmQgcmVoeWRyYXRlIGRlaHlkcmF0ZWQgZGV2aWNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIERlaHlkcmF0ZWREZXZpY2VzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShEZWh5ZHJhdGVkRGV2aWNlcy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBEZWh5ZHJhdGVkRGV2aWNlc0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBEZWh5ZHJhdGVkRGV2aWNlc0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZGVoeWRyYXRlZGRldmljZXNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcge0BsaW5rIERlaHlkcmF0ZWREZXZpY2V9IHdoaWNoIGNhbiBiZSB1cGxvYWRlZCB0byB0aGVcbiAgICAgKiBzZXJ2ZXIuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RGVoeWRyYXRlZERldmljZT59XG4gICAgICovXG4gICAgY3JlYXRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRlaHlkcmF0ZWRkZXZpY2VzX2NyZWF0ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlaHlkcmF0ZSBhIGRlaHlkcmF0ZWQgZGV2aWNlLlxuICAgICAqIEBwYXJhbSB7RGVoeWRyYXRlZERldmljZUtleX0gZGVoeWRyYXRlZF9kZXZpY2Vfa2V5XG4gICAgICogQHBhcmFtIHtEZXZpY2VJZH0gZGV2aWNlX2lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRldmljZV9kYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVoeWRyYXRlZERldmljZT59XG4gICAgICovXG4gICAgcmVoeWRyYXRlKGRlaHlkcmF0ZWRfZGV2aWNlX2tleSwgZGV2aWNlX2lkLCBkZXZpY2VfZGF0YSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZGVoeWRyYXRlZF9kZXZpY2Vfa2V5LCBEZWh5ZHJhdGVkRGV2aWNlS2V5KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGRldmljZV9pZCwgRGV2aWNlSWQpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZGV2aWNlX2RhdGEsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZWh5ZHJhdGVkZGV2aWNlc19yZWh5ZHJhdGUodGhpcy5fX3diZ19wdHIsIGRlaHlkcmF0ZWRfZGV2aWNlX2tleS5fX3diZ19wdHIsIGRldmljZV9pZC5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNhY2hlZCBkZWh5ZHJhdGVkIGRldmljZSBrZXkgaWYgYW55LlxuICAgICAqXG4gICAgICogYE5vbmVgIGlmIHRoZSBrZXkgd2FzIG5vdCBwcmV2aW91c2x5IGNhY2hlZCAodmlhXG4gICAgICoge0BsaW5rIERlaHlkcmF0ZWREZXZpY2VzLnNhdmVEZWh5ZHJhdGVkRGV2aWNlS2V5fSkuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RGVoeWRyYXRlZERldmljZUtleSB8IHVuZGVmaW5lZD59XG4gICAgICovXG4gICAgZ2V0RGVoeWRyYXRlZERldmljZUtleSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZWh5ZHJhdGVkZGV2aWNlc19nZXREZWh5ZHJhdGVkRGV2aWNlS2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcmUgdGhlIGRlaHlkcmF0ZWQgZGV2aWNlIGtleSBpbiB0aGUgY3J5cHRvIHN0b3JlLlxuICAgICAqIEBwYXJhbSB7RGVoeWRyYXRlZERldmljZUtleX0gZGVoeWRyYXRlZF9kZXZpY2Vfa2V5XG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgc2F2ZURlaHlkcmF0ZWREZXZpY2VLZXkoZGVoeWRyYXRlZF9kZXZpY2Vfa2V5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhkZWh5ZHJhdGVkX2RldmljZV9rZXksIERlaHlkcmF0ZWREZXZpY2VLZXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRlaHlkcmF0ZWRkZXZpY2VzX3NhdmVEZWh5ZHJhdGVkRGV2aWNlS2V5KHRoaXMuX193YmdfcHRyLCBkZWh5ZHJhdGVkX2RldmljZV9rZXkuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGRlaHlkcmF0ZWQgZGV2aWNlIGtleSBzYXZlZCBpbiB0aGUgY3J5cHRvIHN0b3JlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGRlbGV0ZURlaHlkcmF0ZWREZXZpY2VLZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGVoeWRyYXRlZGRldmljZXNfZGVsZXRlRGVoeWRyYXRlZERldmljZUtleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuXG5jb25zdCBEZXZpY2VGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZGV2aWNlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEEgZGV2aWNlIHJlcHJlc2VudHMgYSBFMkVFIGNhcGFibGUgY2xpZW50IG9mIGFuIHVzZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZXZpY2Uge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKERldmljZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBEZXZpY2VGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRGV2aWNlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19kZXZpY2VfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGFuIGludGVyYWN0aXZlIHZlcmlmaWNhdGlvbiB3aXRoIHRoaXMgZGV2aWNlLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIDItZWxlbWVudCBhcnJheSBgW1ZlcmlmaWNhdGlvblJlcXVlc3QsIFRvRGV2aWNlUmVxdWVzdF1gLlxuICAgICAqIEBwYXJhbSB7YW55W10gfCB1bmRlZmluZWR9IFttZXRob2RzXVxuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIHJlcXVlc3RWZXJpZmljYXRpb24obWV0aG9kcykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUobWV0aG9kcykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAobWV0aG9kcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRldmljZV9yZXF1ZXN0VmVyaWZpY2F0aW9uKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jcnlwdCBhIHRvLWRldmljZSBtZXNzYWdlIHRvIGJlIHNlbnQgdG8gdGhpcyBkZXZpY2UsIHVzaW5nIE9sbVxuICAgICAqIGVuY3J5cHRpb24uXG4gICAgICpcbiAgICAgKiBQcmlvciB0byBjYWxsaW5nIHRoaXMgbWV0aG9kIHlvdSBtdXN0IGVuc3VyZSB0aGF0IGFuIE9sbSBzZXNzaW9uIGlzXG4gICAgICogYXZhaWxhYmxlIGZvciB0aGUgdGFyZ2V0IGRldmljZS4gVGhpcyBjYW4gYmUgZG9uZSBieSBjYWxsaW5nXG4gICAgICoge0BsaW5rIE9sbU1hY2hpbmUuZ2V0TWlzc2luZ1Nlc3Npb25zfS5cbiAgICAgKlxuICAgICAqIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIHNlbmRpbmcgdGhlIGVuY3J5cHRlZFxuICAgICAqIGV2ZW50IHRvIHRoZSB0YXJnZXQgZGV2aWNlLiBJZiBtdWx0aXBsZSBtZXNzYWdlcyBhcmVcbiAgICAgKiBlbmNyeXB0ZWQgZm9yIHRoZSBzYW1lIGRldmljZSB1c2luZyB0aGlzIG1ldGhvZCB0aGV5IHNob3VsZCBiZSBzZW50IGluXG4gICAgICogdGhlIHNhbWUgb3JkZXIgYXMgdGhleSBhcmUgZW5jcnlwdGVkLlxuICAgICAqXG4gICAgICogIyBSZXR1cm5zXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYSBKU09OIHN0cmluZyBjb250YWluaW5nIHRoZSBgY29udGVudGAgb2YgYW5cbiAgICAgKiBlbmNyeXB0ZWQgZXZlbnQsIHdoaWNoIGJlIHVzZWQgdG8gY3JlYXRlIHRoZSBwYXlsb2FkIGZvciBhXG4gICAgICogYC9zZW5kVG9EZXZpY2VgIEFQSS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfdHlwZVxuICAgICAqIEBwYXJhbSB7YW55fSBjb250ZW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKi9cbiAgICBlbmNyeXB0VG9EZXZpY2VFdmVudChldmVudF90eXBlLCBjb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChldmVudF90eXBlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGV2aWNlX2VuY3J5cHRUb0RldmljZUV2ZW50KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBjb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBkZXZpY2UgY29uc2lkZXJlZCB0byBiZSB2ZXJpZmllZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdHJ1ZSBpZiBlaXRoZXIgdGhlIGBpc19sb2NhbGx5X3RydXN0ZWRgXG4gICAgICogbWV0aG9kIHJldHVybnMgYHRydWVgIG9yIGlmIHRoZSBgaXNfY3Jvc3Nfc2lnbmluZ190cnVzdGVkYFxuICAgICAqIG1ldGhvZCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ZlcmlmaWVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRldmljZV9pc1ZlcmlmaWVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBkZXZpY2UgY29uc2lkZXJlZCB0byBiZSB2ZXJpZmllZCB1c2luZyBjcm9zcyBzaWduaW5nLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ3Jvc3NTaWduaW5nVHJ1c3RlZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VfaXNDcm9zc1NpZ25pbmdUcnVzdGVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBkZXZpY2UgY3Jvc3Mtc2lnbmVkIGJ5IGl0cyBvd25lcj9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0Nyb3NzU2lnbmVkQnlPd25lcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VfaXNDcm9zc1NpZ25lZEJ5T3duZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxvY2FsIHRydXN0IHN0YXRlIG9mIHRoZSBkZXZpY2UgdG8gdGhlIGdpdmVuIHN0YXRlLlxuICAgICAqXG4gICAgICogVGhpcyB3b27igJl0IGFmZmVjdCBhbnkgY3Jvc3Mgc2lnbmluZyB0cnVzdCBzdGF0ZSwgdGhpcyBvbmx5XG4gICAgICogc2V0cyBhIGZsYWcgbWFya2luZyB0byBoYXZlIHRoZSBnaXZlbiB0cnVzdCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIGB0cnVzdF9zdGF0ZWAgcmVwcmVzZW50cyB0aGUgbmV3IHRydXN0IHN0YXRlIHRoYXQgc2hvdWxkIGJlXG4gICAgICogc2V0IGZvciB0aGUgZGV2aWNlLlxuICAgICAqIEBwYXJhbSB7TG9jYWxUcnVzdH0gbG9jYWxfc3RhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHNldExvY2FsVHJ1c3QobG9jYWxfc3RhdGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2Vfc2V0TG9jYWxUcnVzdCh0aGlzLl9fd2JnX3B0ciwgbG9jYWxfc3RhdGUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdXNlciBJRCBvZiB0aGUgZGV2aWNlIG93bmVyLlxuICAgICAqIEByZXR1cm5zIHtVc2VySWR9XG4gICAgICovXG4gICAgZ2V0IHVzZXJJZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VfdXNlcklkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFVzZXJJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgZGV2aWNlLlxuICAgICAqIEByZXR1cm5zIHtEZXZpY2VJZH1cbiAgICAgKi9cbiAgICBnZXQgZGV2aWNlSWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGV2aWNlX2RldmljZUlkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIERldmljZUlkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIG5hbWUgb2YgdGhlIGRldmljZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBkaXNwbGF5TmFtZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VfZGlzcGxheU5hbWUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICBsZXQgdjE7XG4gICAgICAgIGlmIChyZXRbMF0gIT09IDApIHtcbiAgICAgICAgICAgIHYxID0gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocmV0WzBdLCByZXRbMV0gKiAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUga2V5IG9mIHRoZSBnaXZlbiBrZXkgYWxnb3JpdGhtIGJlbG9uZ2luZyB0byB0aGlzIGRldmljZS5cbiAgICAgKiBAcGFyYW0ge0RldmljZUtleUFsZ29yaXRobU5hbWV9IGFsZ29yaXRobVxuICAgICAqIEByZXR1cm5zIHtEZXZpY2VLZXkgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0S2V5KGFsZ29yaXRobSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRldmljZV9nZXRLZXkodGhpcy5fX3diZ19wdHIsIGFsZ29yaXRobSk7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldFswXSA9PT0gMCA/IHVuZGVmaW5lZCA6IERldmljZUtleS5fX3dyYXAocmV0WzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBDdXJ2ZTI1NTE5IGtleSBvZiB0aGUgZ2l2ZW4gZGV2aWNlLlxuICAgICAqIEByZXR1cm5zIHtDdXJ2ZTI1NTE5UHVibGljS2V5IHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBjdXJ2ZTI1NTE5S2V5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRldmljZV9jdXJ2ZTI1NTE5S2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IEN1cnZlMjU1MTlQdWJsaWNLZXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgRWQyNTUxOSBrZXkgb2YgdGhlIGdpdmVuIGRldmljZS5cbiAgICAgKiBAcmV0dXJucyB7RWQyNTUxOVB1YmxpY0tleSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgZWQyNTUxOUtleSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VfZWQyNTUxOUtleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBFZDI1NTE5UHVibGljS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBtYXAgY29udGFpbmluZyBhbGwgdGhlIGRldmljZSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtNYXA8YW55LCBhbnk+fVxuICAgICAqL1xuICAgIGdldCBrZXlzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRldmljZV9rZXlzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIGFsZ29yaXRobXMgdGhpcyBkZXZpY2Ugc3VwcG9ydHMuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGBBcnJheTxFbmNyeXB0aW9uQWxnb3JpdGhtPmAuXG4gICAgICogQHJldHVybnMge0FycmF5PGFueT59XG4gICAgICovXG4gICAgZ2V0IGFsZ29yaXRobXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGV2aWNlX2FsZ29yaXRobXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBtYXAgY29udGFpbmluZyBhbGwgdGhlIGRldmljZSBzaWduYXR1cmVzLlxuICAgICAqIEByZXR1cm5zIHtTaWduYXR1cmVzfVxuICAgICAqL1xuICAgIGdldCBzaWduYXR1cmVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRldmljZV9zaWduYXR1cmVzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZXMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHJ1c3Qgc3RhdGUgb2YgdGhlIGRldmljZS5cbiAgICAgKiBAcmV0dXJucyB7TG9jYWxUcnVzdH1cbiAgICAgKi9cbiAgICBnZXQgbG9jYWxUcnVzdFN0YXRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRldmljZV9sb2NhbFRydXN0U3RhdGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgZGV2aWNlIGxvY2FsbHkgbWFya2VkIGFzIHRydXN0ZWQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNMb2NhbGx5VHJ1c3RlZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VfaXNMb2NhbGx5VHJ1c3RlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBkZXZpY2UgbG9jYWxseSBtYXJrZWQgYXMgYmxhY2tsaXN0ZWQ/XG4gICAgICpcbiAgICAgKiBCbGFja2xpc3RlZCBkZXZpY2VzIHdvbuKAmXQgcmVjZWl2ZSBhbnkgZ3JvdXAgc2Vzc2lvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNCbGFja2xpc3RlZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VfaXNCbGFja2xpc3RlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBkZXZpY2UgZGVsZXRlZD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0RlbGV0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGV2aWNlX2lzRGVsZXRlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRpbWVzdGFtcCByZXByZXNlbnRpbmcgdGhlIGZpcnN0IHRpbWUgdGhpcyBkZXZpY2UgaGFzIGJlZW4gc2VlbiAoaW5cbiAgICAgKiBtaWxsaXNlY29uZHMpLlxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgZmlyc3RUaW1lU2VlbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VfZmlyc3RUaW1lU2Vlbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBCaWdJbnQuYXNVaW50Tig2NCwgcmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFyayB0aGlzIGRldmljZSBhcyB2ZXJpZmllZC5cbiAgICAgKiBXb3JrcyBvbmx5IGlmIHRoZSBkZXZpY2UgaXMgb3duZWQgYnkgdGhlIGN1cnJlbnQgdXNlci5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBzaWduYXR1cmUgdXBsb2FkIHJlcXVlc3QgdGhhdCBuZWVkcyB0byBiZSBzZW50IG91dC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHZlcmlmeSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VfdmVyaWZ5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIGRldmljZSBpcyBhIGRlaHlkcmF0ZWQgZGV2aWNlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBpc0RlaHlkcmF0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGV2aWNlX2lzRGVoeWRyYXRlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxufVxuXG5jb25zdCBEZXZpY2VJZEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19kZXZpY2VpZF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBIE1hdHJpeCBrZXkgSUQuXG4gKlxuICogRGV2aWNlIGlkZW50aWZpZXJzIGluIE1hdHJpeCBhcmUgY29tcGxldGVseSBvcGFxdWUgY2hhcmFjdGVyXG4gKiBzZXF1ZW5jZXMuIFRoaXMgdHlwZSBpcyBwcm92aWRlZCBzaW1wbHkgZm9yIGl0cyBzZW1hbnRpYyB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIERldmljZUlkIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShEZXZpY2VJZC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBEZXZpY2VJZEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBEZXZpY2VJZEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZGV2aWNlaWRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYERldmljZUlkYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoaWQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VpZF9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBEZXZpY2VJZEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRldmljZSBJRCBhcyBhIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGV2aWNlaWRfdG9TdHJpbmcodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByZXRbMF07XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHJldFsxXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgRGV2aWNlS2V5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2RldmljZWtleV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBbiBlbnVtIG92ZXIgdGhlIGRpZmZlcmVudCBrZXkgdHlwZXMgYSBkZXZpY2UgY2FuIGhhdmUuXG4gKlxuICogQ3VycmVudGx5IGRldmljZXMgaGF2ZSBhIGN1cnZlMjU1MTkgYW5kIGVkMjU1MTkga2V5cGFpci4gVGhlIGtleXNcbiAqIHRyYW5zcG9ydCBmb3JtYXQgaXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcsIGFueSB1bmtub3duIGtleSB0eXBlXG4gKiB3aWxsIGJlIGxlZnQgYXMgc3VjaCBhIHN0cmluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIERldmljZUtleSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRGV2aWNlS2V5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIERldmljZUtleUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBEZXZpY2VLZXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2RldmljZWtleV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgZGV2aWNlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RGV2aWNlS2V5TmFtZX1cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VrZXlfbmFtZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB0byB0aGUgYEN1cnZlMjU1MTlgIGRldmljZSBrZXkgbmFtZS5cbiAgICAgKiBAcmV0dXJucyB7Q3VydmUyNTUxOVB1YmxpY0tleSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgY3VydmUyNTUxOSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VrZXlfY3VydmUyNTUxOSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBDdXJ2ZTI1NTE5UHVibGljS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIGFzc29jaWF0ZWQgdG8gdGhlIGBFZDI1NTE5YCBkZXZpY2Uga2V5IG5hbWUuXG4gICAgICogQHJldHVybnMge0VkMjU1MTlQdWJsaWNLZXkgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IGVkMjU1MTkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGV2aWNla2V5X2VkMjU1MTkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogRWQyNTUxOVB1YmxpY0tleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHRvIHRoZSBgVW5rbm93bmAgZGV2aWNlIGtleSBuYW1lLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IHVua25vd24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGV2aWNla2V5X3Vua25vd24odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICBsZXQgdjE7XG4gICAgICAgIGlmIChyZXRbMF0gIT09IDApIHtcbiAgICAgICAgICAgIHYxID0gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocmV0WzBdLCByZXRbMV0gKiAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGBEZXZpY2VLZXlgIGludG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b0Jhc2U2NCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRldmljZWtleV90b0Jhc2U2NCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBEZXZpY2VLZXlBbGdvcml0aG1GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZGV2aWNla2V5YWxnb3JpdGhtX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFRoZSBiYXNpYyBrZXkgYWxnb3JpdGhtcyBpbiB0aGUgc3BlY2lmaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIERldmljZUtleUFsZ29yaXRobSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRGV2aWNlS2V5QWxnb3JpdGhtLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIERldmljZUtleUFsZ29yaXRobUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBEZXZpY2VLZXlBbGdvcml0aG1GaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2RldmljZWtleWFsZ29yaXRobV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGRldmljZSBrZXkgYWxnb3JpdGhtJ3MgbmFtZS4gSWYgdGhlIG5hbWUgaXNcbiAgICAgKiBgVW5rbm93bmAsIG9uZSBtYXkgYmUgaW50ZXJlc3RlZCBieSB0aGUgYHRvX3N0cmluZ2AgbWV0aG9kIHRvXG4gICAgICogcmVhZCB0aGUgb3JpZ2luYWwgbmFtZS5cbiAgICAgKiBAcmV0dXJucyB7RGV2aWNlS2V5QWxnb3JpdGhtTmFtZX1cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VrZXlhbGdvcml0aG1fbmFtZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGV2aWNlIGtleSBhbGdvcml0aG0gYXMgYSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRldmljZWtleWFsZ29yaXRobV90b1N0cmluZyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBEZXZpY2VLZXlJZEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19kZXZpY2VrZXlpZF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBIE1hdHJpeCBkZXZpY2Uga2V5IElELlxuICpcbiAqIEEga2V5IGFsZ29yaXRobSBhbmQgYSBkZXZpY2UgSUQsIGNvbWJpbmVkIHdpdGggYSDigJg64oCZLlxuICovXG5leHBvcnQgY2xhc3MgRGV2aWNlS2V5SWQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKERldmljZUtleUlkLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIERldmljZUtleUlkRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIERldmljZUtleUlkRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19kZXZpY2VrZXlpZF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlL3ZhbGlkYXRlIGFuZCBjcmVhdGUgYSBuZXcgYERldmljZUtleUlkYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoaWQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VrZXlpZF9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXRbMF0gPj4+IDA7XG4gICAgICAgIERldmljZUtleUlkRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMga2V5IGFsZ29yaXRobSBvZiB0aGUgZGV2aWNlIGtleSBJRC5cbiAgICAgKiBAcmV0dXJucyB7RGV2aWNlS2V5QWxnb3JpdGhtfVxuICAgICAqL1xuICAgIGdldCBhbGdvcml0aG0oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGV2aWNla2V5aWRfYWxnb3JpdGhtKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIERldmljZUtleUFsZ29yaXRobS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkZXZpY2UgSUQgb2YgdGhlIGRldmljZSBrZXkgSUQuXG4gICAgICogQHJldHVybnMge0RldmljZUlkfVxuICAgICAqL1xuICAgIGdldCBkZXZpY2VJZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VrZXlpZF9kZXZpY2VJZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBEZXZpY2VJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkZXZpY2Uga2V5IElEIGFzIGEgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VrZXlpZF90b1N0cmluZyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBEZXZpY2VMaXN0c0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19kZXZpY2VsaXN0c19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBJbmZvcm1hdGlvbiBvbiBFMkUgZGV2aWNlIHVwZGF0ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZXZpY2VMaXN0cyB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIERldmljZUxpc3RzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19kZXZpY2VsaXN0c19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBlbXB0eSBgRGV2aWNlTGlzdHNgLlxuICAgICAqXG4gICAgICogYGNoYW5nZWRgIGFuZCBgbGVmdGAgbXVzdCBiZSBhbiBhcnJheSBvZiBgVXNlcklkYC5cbiAgICAgKlxuICAgICAqIEl0ZW1zIGluc2lkZSBgY2hhbmdlZGAgYW5kIGBsZWZ0YCB3aWxsIGJlIGludmFsaWRhdGVkIGJ5IHRoaXMgbWV0aG9kLiBCZVxuICAgICAqIGNhcmVmdWwgbm90IHRvIHVzZSB0aGUgYFVzZXJJZGBzIGFmdGVyIHRoaXMgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0geyhVc2VySWQpW10gfCB1bmRlZmluZWR9IFtjaGFuZ2VkXVxuICAgICAqIEBwYXJhbSB7KFVzZXJJZClbXSB8IHVuZGVmaW5lZH0gW2xlZnRdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbmdlZCwgbGVmdCkge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoY2hhbmdlZCkgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoY2hhbmdlZCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMSA9IGlzTGlrZU5vbmUobGVmdCkgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAobGVmdCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmRldmljZWxpc3RzX25ldyhwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldFswXSA+Pj4gMDtcbiAgICAgICAgRGV2aWNlTGlzdHNGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBubyBkZXZpY2UgbGlzdCB1cGRhdGVzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZGV2aWNlbGlzdHNfaXNFbXB0eSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgdXNlcnMgd2hvIGhhdmUgdXBkYXRlZCB0aGVpciBkZXZpY2UgaWRlbnRpdHkga2V5cyBvclxuICAgICAqIHdobyBub3cgc2hhcmUgYW4gZW5jcnlwdGVkIHJvb20gd2l0aCB0aGUgY2xpZW50IHNpbmNlIHRoZVxuICAgICAqIHByZXZpb3VzIHN5bmNcbiAgICAgKiBAcmV0dXJucyB7KFVzZXJJZClbXX1cbiAgICAgKi9cbiAgICBnZXQgY2hhbmdlZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VsaXN0c19jaGFuZ2VkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyZXRbMF0sIHJldFsxXSAqIDQsIDQpO1xuICAgICAgICByZXR1cm4gdjE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgdXNlcnMgd2hvIG5vIGxvbmdlciBzaGFyZSBlbmNyeXB0ZWQgcm9vbXMgc2luY2UgdGhlXG4gICAgICogcHJldmlvdXMgc3luYyByZXNwb25zZS5cbiAgICAgKiBAcmV0dXJucyB7KFVzZXJJZClbXX1cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5kZXZpY2VsaXN0c19sZWZ0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyZXRbMF0sIHJldFsxXSAqIDQsIDQpO1xuICAgICAgICByZXR1cm4gdjE7XG4gICAgfVxufVxuXG5jb25zdCBFY2llc0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19lY2llc19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBbiB1bmVzdGFibGlzaGVkIEVDSUVTIHNlc3Npb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBFY2llcyB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEVjaWVzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19lY2llc19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldywgcmFuZG9tLCB1bmVzdGFibGlzaGVkIEVDSUVTIHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHVzZSB0aGVcbiAgICAgKiBbYE1BVFJJWF9RUl9DT0RFX0xPR0lOYF0oaHR0cHM6Ly9naXRodWIuY29tL21hdHJpeC1vcmcvbWF0cml4LXNwZWMtcHJvcG9zYWxzL3B1bGwvNDEwOClcbiAgICAgKiBpbmZvIGZvciBkb21haW4gc2VwYXJhdGlvbiB3aGVuIGNyZWF0aW5nIHRoZSBzZXNzaW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVjaWVzX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgRWNpZXNGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG91ciBbYEN1cnZlMjU1MTlQdWJsaWNLZXlgXS5cbiAgICAgKlxuICAgICAqIFRoaXMgcHVibGljIGtleSBuZWVkcyB0byBiZSBzZW50IHRvIHRoZSBvdGhlciBzaWRlIHRvIGJlIGFibGUgdG9cbiAgICAgKiBlc3RhYmxpc2ggYW4gRUNJRVMgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJucyB7Q3VydmUyNTUxOVB1YmxpY0tleX1cbiAgICAgKi9cbiAgICBwdWJsaWNfa2V5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVjaWVzX3B1YmxpY19rZXkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQ3VydmUyNTUxOVB1YmxpY0tleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgW2BFc3RhYmxpc2hlZEVjaWVzYF0gZnJvbSBhbiBpbml0aWFsIG1lc3NhZ2UgZW5jcnlwdGVkIGJ5IHRoZVxuICAgICAqIG90aGVyIHNpZGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluaXRpYWxfbWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtJbmJvdW5kQ3JlYXRpb25SZXN1bHR9XG4gICAgICovXG4gICAgZXN0YWJsaXNoX2luYm91bmRfY2hhbm5lbChpbml0aWFsX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGluaXRpYWxfbWVzc2FnZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVjaWVzX2VzdGFibGlzaF9pbmJvdW5kX2NoYW5uZWwodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJbmJvdW5kQ3JlYXRpb25SZXN1bHQuX193cmFwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBbYEVzdGFibGlzaGVkRWNpZXNgXSBzZXNzaW9uIHVzaW5nIHRoZSBvdGhlciBzaWRlJ3MgQ3VydmUyNTUxOVxuICAgICAqIHB1YmxpYyBrZXkgYW5kIGFuIGluaXRpYWwgcGxhaW50ZXh0LlxuICAgICAqXG4gICAgICogQWZ0ZXIgdGhlIGNoYW5uZWwgaGFzIGJlZW4gZXN0YWJsaXNoZWQsIHdlIGNhbiBlbmNyeXB0IG1lc3NhZ2VzIHRvIHNlbmRcbiAgICAgKiB0byB0aGUgb3RoZXIgc2lkZS4gVGhlIG90aGVyIHNpZGUgdXNlcyB0aGUgaW5pdGlhbCBtZXNzYWdlIHRvXG4gICAgICogZXN0YWJsaXNoZXMgdGhlIHNhbWUgY2hhbm5lbCBvbiBpdHMgc2lkZS5cbiAgICAgKiBAcGFyYW0ge0N1cnZlMjU1MTlQdWJsaWNLZXl9IHB1YmxpY19rZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5pdGlhbF9tZXNzYWdlXG4gICAgICogQHJldHVybnMge091dGJvdW5kQ3JlYXRpb25SZXN1bHR9XG4gICAgICovXG4gICAgZXN0YWJsaXNoX291dGJvdW5kX2NoYW5uZWwocHVibGljX2tleSwgaW5pdGlhbF9tZXNzYWdlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwdWJsaWNfa2V5LCBDdXJ2ZTI1NTE5UHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGluaXRpYWxfbWVzc2FnZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVjaWVzX2VzdGFibGlzaF9vdXRib3VuZF9jaGFubmVsKHRoaXMuX193YmdfcHRyLCBwdWJsaWNfa2V5Ll9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE91dGJvdW5kQ3JlYXRpb25SZXN1bHQuX193cmFwKHJldFswXSk7XG4gICAgfVxufVxuXG5jb25zdCBFZDI1NTE5UHVibGljS2V5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2VkMjU1MTlwdWJsaWNrZXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQW4gRWQyNTUxOSBwdWJsaWMga2V5LCB1c2VkIHRvIHZlcmlmeSBkaWdpdGFsIHNpZ25hdHVyZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFZDI1NTE5UHVibGljS2V5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShFZDI1NTE5UHVibGljS2V5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEVkMjU1MTlQdWJsaWNLZXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRWQyNTUxOVB1YmxpY0tleUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZWQyNTUxOXB1YmxpY2tleV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgYnl0ZXMgYW4gRWQyNTUxOSBwdWJsaWMga2V5IGhhcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZWQyNTUxOXB1YmxpY2tleV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgYW4gRWQyNTUxOSBwdWJsaWMga2V5IHRvIGFuIHVucGFkZGVkIGJhc2U2NFxuICAgICAqIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9CYXNlNjQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5lZDI1NTE5cHVibGlja2V5X3RvQmFzZTY0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcmV0WzBdO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByZXRbMV07XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IEVkMjU1MTlTaWduYXR1cmVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZWQyNTUxOXNpZ25hdHVyZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBbiBFZDI1NTE5IGRpZ2l0YWwgc2lnbmF0dXJlLCBjYW4gYmUgdXNlZCB0byB2ZXJpZnkgdGhlXG4gKiBhdXRoZW50aWNpdHkgb2YgYSBtZXNzYWdlLlxuICovXG5leHBvcnQgY2xhc3MgRWQyNTUxOVNpZ25hdHVyZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRWQyNTUxOVNpZ25hdHVyZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBFZDI1NTE5U2lnbmF0dXJlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEVkMjU1MTlTaWduYXR1cmVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2VkMjU1MTlzaWduYXR1cmVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnkgdG8gY3JlYXRlIGFuIEVkMjU1MTkgc2lnbmF0dXJlIGZyb20gYW4gdW5wYWRkZWQgYmFzZTY0XG4gICAgICogcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoc2lnbmF0dXJlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZWQyNTUxOXNpZ25hdHVyZV9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXRbMF0gPj4+IDA7XG4gICAgICAgIEVkMjU1MTlTaWduYXR1cmVGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIGEgRWQyNTUxOSBzaWduYXR1cmUgdG8gYW4gdW5wYWRkZWQgYmFzZTY0XG4gICAgICogcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b0Jhc2U2NCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVkMjU1MTlzaWduYXR1cmVfdG9CYXNlNjQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByZXRbMF07XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHJldFsxXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgRW1vamlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZW1vamlfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQW4gZW1vamkgdGhhdCBpcyB1c2VkIGZvciBpbnRlcmFjdGl2ZSB2ZXJpZmljYXRpb24gdXNpbmcgYSBzaG9ydFxuICogYXV0aCBzdHJpbmcuXG4gKlxuICogVGhpcyB3aWxsIGNvbnRhaW4gYSBzaW5nbGUgZW1vamkgYW5kIGRlc2NyaXB0aW9uIGZyb20gdGhlIGxpc3Qgb2ZcbiAqIGVtb2ppcyBmcm9tIFt0aGUgc3BlY2lmaWNhdGlvbl0uXG4gKlxuICogW3RoZSBzcGVjaWZpY2F0aW9uXTogaHR0cHM6Ly9zcGVjLm1hdHJpeC5vcmcvdW5zdGFibGUvY2xpZW50LXNlcnZlci1hcGkvI3Nhcy1tZXRob2QtZW1vamlcbiAqL1xuZXhwb3J0IGNsYXNzIEVtb2ppIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShFbW9qaS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBFbW9qaUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBFbW9qaUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZW1vamlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZW1vamkgc3ltYm9sIHRoYXQgcmVwcmVzZW50cyBhIHBhcnQgb2YgdGhlIHNob3J0IGF1dGhcbiAgICAgKiBzdHJpbmcsIGZvciBleGFtcGxlOiDwn5C2XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgc3ltYm9sKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVtb2ppX3N5bWJvbCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZW1vamksIGZvciBleGFtcGxlIOKAmERvZ+KAmS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5lbW9qaV9kZXNjcmlwdGlvbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuXG5jb25zdCBFbmNyeXB0ZWRBdHRhY2htZW50RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2VuY3J5cHRlZGF0dGFjaG1lbnRfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQW4gZW5jcnlwdGVkIGF0dGFjaG1lbnQsIHVzdWFsbHkgY3JlYXRlZCBmcm9tIGBBdHRhY2htZW50LmVuY3J5cHRgLlxuICovXG5leHBvcnQgY2xhc3MgRW5jcnlwdGVkQXR0YWNobWVudCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRW5jcnlwdGVkQXR0YWNobWVudC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBFbmNyeXB0ZWRBdHRhY2htZW50RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEVuY3J5cHRlZEF0dGFjaG1lbnRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2VuY3J5cHRlZGF0dGFjaG1lbnRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZW5jcnlwdGVkIGF0dGFjaG1lbnQgbWFudWFsbHkuXG4gICAgICpcbiAgICAgKiBJdCBuZWVkcyBlbmNyeXB0ZWQgZGF0YSwgc3RvcmVkIGluIGFuIGBVaW50OEFycmF5YCwgYW5kIGFcbiAgICAgKiBbbWVkaWEgZW5jcnlwdGlvblxuICAgICAqIGluZm9ybWF0aW9uXShodHRwczovL2RvY3MucnMvbWF0cml4LXNkay1jcnlwdG8vbGF0ZXN0L21hdHJpeF9zZGtfY3J5cHRvL3N0cnVjdC5NZWRpYUVuY3J5cHRpb25JbmZvLmh0bWwpLFxuICAgICAqIGFzIGEgSlNPTi1lbmNvZGVkIHN0cmluZy5cbiAgICAgKlxuICAgICAqIFRoZSBtZWRpYSBlbmNyeXB0aW9uIGluZm9ybWF0aW9uIGFyZW4ndCBzdG9yZWQgYXMgYSBzdHJpbmc6XG4gICAgICogdGhleSBhcmUgcGFyc2VkLCB2YWxpZGF0ZWQgYW5kIGZ1bGx5IGRlc2VyaWFsaXplZC5cbiAgICAgKlxuICAgICAqIFNlZSBbdGhlIHNwZWNpZmljYXRpb24gdG8gbGVhcm5cbiAgICAgKiBtb3JlXShodHRwczovL3NwZWMubWF0cml4Lm9yZy91bnN0YWJsZS9jbGllbnQtc2VydmVyLWFwaS8jZXh0ZW5zaW9ucy10by1tcm9vbW1lc3NhZ2UtbXNndHlwZXMpLlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gZW5jcnlwdGVkX2RhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVkaWFfZW5jcnlwdGlvbl9pbmZvXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW5jcnlwdGVkX2RhdGEsIG1lZGlhX2VuY3J5cHRpb25faW5mbykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoZW5jcnlwdGVkX2RhdGEsIHdhc20uX193YmluZGdlbl9tYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAobWVkaWFfZW5jcnlwdGlvbl9pbmZvLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZW5jcnlwdGVkYXR0YWNobWVudF9uZXcocHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXRbMF0gPj4+IDA7XG4gICAgICAgIEVuY3J5cHRlZEF0dGFjaG1lbnRGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFjdHVhbCBlbmNyeXB0ZWQgZGF0YS5cbiAgICAgKlxuICAgICAqICoqV2FybmluZyoqOiBJdCByZXR1cm5zIGEgKipjb3B5Kiogb2YgdGhlIGVudGlyZSBlbmNyeXB0ZWRcbiAgICAgKiBkYXRhOyBiZSBuaWNlIHdpdGggeW91ciBtZW1vcnkuXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IGVuY3J5cHRlZERhdGEoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZW5jcnlwdGVkYXR0YWNobWVudF9lbmNyeXB0ZWREYXRhKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyZXRbMF0sIHJldFsxXSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocmV0WzBdLCByZXRbMV0gKiAxLCAxKTtcbiAgICAgICAgcmV0dXJuIHYxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG1lZGlhIGVuY3J5cHRpb24gaW5mbyBhcyBhIEpTT04tZW5jb2RlZCBzdHJpbmcuIFRoZVxuICAgICAqIHN0cnVjdHVyZSBpcyBmdWxseSB2YWxpZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBtZWRpYSBlbmNyeXB0aW9uIGluZm8gaGF2ZSBiZWVuIGNvbnN1bWVkIGFscmVhZHksIGl0XG4gICAgICogd2lsbCByZXR1cm4gYG51bGxgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IG1lZGlhRW5jcnlwdGlvbkluZm8oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZW5jcnlwdGVkYXR0YWNobWVudF9tZWRpYUVuY3J5cHRpb25JbmZvKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBpZiAocmV0WzBdICE9PSAwKSB7XG4gICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHJldFswXSwgcmV0WzFdICogMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBtZWRpYSBlbmNyeXB0aW9uIGluZm8gaGFzIGJlZW4gY29uc3VtZWQgYnlcbiAgICAgKiBgQXR0YWNobWVudC5kZWNyeXB0YCBhbHJlYWR5LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBoYXNNZWRpYUVuY3J5cHRpb25JbmZvQmVlbkNvbnN1bWVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVuY3J5cHRlZGF0dGFjaG1lbnRfaGFzTWVkaWFFbmNyeXB0aW9uSW5mb0JlZW5Db25zdW1lZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxufVxuXG5jb25zdCBFbmNyeXB0aW9uSW5mb0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19lbmNyeXB0aW9uaW5mb19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBTdHJ1Y3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBvbiBob3cgYW4gZXZlbnQgd2FzIGRlY3J5cHRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuY3J5cHRpb25JbmZvIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShFbmNyeXB0aW9uSW5mby5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBFbmNyeXB0aW9uSW5mb0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBFbmNyeXB0aW9uSW5mb0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZW5jcnlwdGlvbmluZm9fZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdXNlciBJRCBvZiB0aGUgZXZlbnQgc2VuZGVyLiBOb3RlIHRoaXMgaXMgdW50cnVzdGVkIGRhdGFcbiAgICAgKiB1bmxlc3MgYHZlcmlmaWNhdGlvbl9zdGF0ZWAgaXMgYWxzbyB0cnVzdGVkLlxuICAgICAqIEByZXR1cm5zIHtVc2VySWR9XG4gICAgICovXG4gICAgZ2V0IHNlbmRlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5lbmNyeXB0aW9uaW5mb19zZW5kZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVXNlcklkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZGV2aWNlIElEIG9mIHRoZSBkZXZpY2UgdGhhdCBzZW50IHVzIHRoZSBldmVudC4gTm90ZSB0aGlzXG4gICAgICogaXMgdW50cnVzdGVkIGRhdGEgdW5sZXNzIGB2ZXJpZmljYXRpb25fc3RhdGVgIGlzIGFsc29cbiAgICAgKiB0cnVzdGVkLlxuICAgICAqIEByZXR1cm5zIHtEZXZpY2VJZCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgc2VuZGVyRGV2aWNlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVuY3J5cHRpb25pbmZvX3NlbmRlckRldmljZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBEZXZpY2VJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIEN1cnZlMjU1MTkga2V5IG9mIHRoZSBkZXZpY2UgdGhhdCBjcmVhdGVkIHRoZSBtZWdvbG1cbiAgICAgKiBkZWNyeXB0aW9uIGtleSBvcmlnaW5hbGx5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IHNlbmRlckN1cnZlMjU1MTlLZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZW5jcnlwdGlvbmluZm9fc2VuZGVyQ3VydmUyNTUxOUtleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzaWduaW5nIEVkMjU1MTkga2V5IHRoYXQgY3JlYXRlZCB0aGUgbWVnb2xtIGtleSB0aGF0XG4gICAgICogd2FzIHVzZWQgdG8gZGVjcnlwdCB0aGlzIHNlc3Npb24uXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgc2VuZGVyQ2xhaW1lZEVkMjU1MTlLZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZW5jcnlwdGlvbmluZm9fc2VuZGVyQ2xhaW1lZEVkMjU1MTlLZXkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdmVyaWZpY2F0aW9uIHN0YXRlIG9mIHRoZSBkZXZpY2UgdGhhdCBzZW50IHVzIHRoZSBldmVudC5cbiAgICAgKiBOb3RlIHRoaXMgaXMgdGhlIHN0YXRlIG9mIHRoZSBkZXZpY2UgYXQgdGhlIHRpbWUgb2ZcbiAgICAgKiBkZWNyeXB0aW9uLiBJdCBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUgaWYgYSBkZXZpY2UgZ2V0c1xuICAgICAqIHZlcmlmaWVkIG9yIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiAjIEFyZ3VtZW50c1xuICAgICAqXG4gICAgICogKiBgc3RyaWN0YCAtIHdoZXRoZXIgdG8gZW5hYmxlIFwic3RyaWN0IG1vZGVcIiB2ZXJpZmljYXRpb24uIEluIG5vbi1zdHJpY3RcbiAgICAgKiAgIG1vZGUsIHVudmVyaWZpZWQgdXNlcnMgYXJlIGdpdmVuIG5vIHNoaWVsZCwgYW5kIGtleXMgdGhhdCBoYXZlIGJlZW5cbiAgICAgKiAgIGZvcndhcmRlZCBvciByZXN0b3JlZCBmcm9tIGFuIGluc2VjdXJlIGJhY2t1cCBhcmUgZ2l2ZW4gYSBncmV5IHNoaWVsZFxuICAgICAqICAgKGJvdGggZ2V0IGEgcmVkIHNoaWVsZCBpbiBzdHJpY3QgbW9kZSkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdHJpY3RcbiAgICAgKiBAcmV0dXJucyB7U2hpZWxkU3RhdGV9XG4gICAgICovXG4gICAgc2hpZWxkU3RhdGUoc3RyaWN0KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZW5jcnlwdGlvbmluZm9fc2hpZWxkU3RhdGUodGhpcy5fX3diZ19wdHIsIHN0cmljdCk7XG4gICAgICAgIHJldHVybiBTaGllbGRTdGF0ZS5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5cbmNvbnN0IEVuY3J5cHRpb25TZXR0aW5nc0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19lbmNyeXB0aW9uc2V0dGluZ3NfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogU2V0dGluZ3MgZm9yIGFuIGVuY3J5cHRlZCByb29tLlxuICpcbiAqIFRoaXMgZGV0ZXJtaW5lcyB0aGUgYWxnb3JpdGhtIGFuZCByb3RhdGlvbiBwZXJpb2RzIG9mIGEgZ3JvdXBcbiAqIHNlc3Npb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBFbmNyeXB0aW9uU2V0dGluZ3Mge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBFbmNyeXB0aW9uU2V0dGluZ3NGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2VuY3J5cHRpb25zZXR0aW5nc19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB0aGF0IHNob3VsZCBiZSB1c2VkIGluIHRoZSByb29tLlxuICAgICAqIEByZXR1cm5zIHtFbmNyeXB0aW9uQWxnb3JpdGhtfVxuICAgICAqL1xuICAgIGdldCBhbGdvcml0aG0oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2VuY3J5cHRpb25zZXR0aW5nc19hbGdvcml0aG0odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZW5jcnlwdGlvbiBhbGdvcml0aG0gdGhhdCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgcm9vbS5cbiAgICAgKiBAcGFyYW0ge0VuY3J5cHRpb25BbGdvcml0aG19IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgYWxnb3JpdGhtKGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfZW5jcnlwdGlvbnNldHRpbmdzX2FsZ29yaXRobSh0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhvdyBsb25nIHRoZSBzZXNzaW9uIHNob3VsZCBiZSB1c2VkIGJlZm9yZSBjaGFuZ2luZyBpdCxcbiAgICAgKiBleHByZXNzZWQgaW4gbWljcm9zZWNvbmRzLlxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgZ2V0IHJvdGF0aW9uUGVyaW9kKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9lbmNyeXB0aW9uc2V0dGluZ3Nfcm90YXRpb25QZXJpb2QodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQmlnSW50LmFzVWludE4oNjQsIHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhvdyBsb25nIHRoZSBzZXNzaW9uIHNob3VsZCBiZSB1c2VkIGJlZm9yZSBjaGFuZ2luZyBpdCxcbiAgICAgKiBleHByZXNzZWQgaW4gbWljcm9zZWNvbmRzLlxuICAgICAqIEBwYXJhbSB7YmlnaW50fSBhcmcwXG4gICAgICovXG4gICAgc2V0IHJvdGF0aW9uUGVyaW9kKGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfZW5jcnlwdGlvbnNldHRpbmdzX3JvdGF0aW9uUGVyaW9kKHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSG93IG1hbnkgbWVzc2FnZXMgc2hvdWxkIGJlIHNlbnQgYmVmb3JlIGNoYW5naW5nIHRoZSBzZXNzaW9uLlxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgZ2V0IHJvdGF0aW9uUGVyaW9kTWVzc2FnZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2VuY3J5cHRpb25zZXR0aW5nc19yb3RhdGlvblBlcmlvZE1lc3NhZ2VzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEJpZ0ludC5hc1VpbnROKDY0LCByZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIb3cgbWFueSBtZXNzYWdlcyBzaG91bGQgYmUgc2VudCBiZWZvcmUgY2hhbmdpbmcgdGhlIHNlc3Npb24uXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgcm90YXRpb25QZXJpb2RNZXNzYWdlcyhhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2VuY3J5cHRpb25zZXR0aW5nc19yb3RhdGlvblBlcmlvZE1lc3NhZ2VzKHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGhpc3RvcnkgdmlzaWJpbGl0eSBvZiB0aGUgcm9vbSB3aGVuIHRoZSBzZXNzaW9uIHdhc1xuICAgICAqIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMge0hpc3RvcnlWaXNpYmlsaXR5fVxuICAgICAqL1xuICAgIGdldCBoaXN0b3J5VmlzaWJpbGl0eSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfZW5jcnlwdGlvbnNldHRpbmdzX2hpc3RvcnlWaXNpYmlsaXR5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGhpc3RvcnkgdmlzaWJpbGl0eSBvZiB0aGUgcm9vbSB3aGVuIHRoZSBzZXNzaW9uIHdhc1xuICAgICAqIGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHtIaXN0b3J5VmlzaWJpbGl0eX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBoaXN0b3J5VmlzaWJpbGl0eShhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2VuY3J5cHRpb25zZXR0aW5nc19oaXN0b3J5VmlzaWJpbGl0eSh0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3VsZCB1bnRydXN0ZWQgZGV2aWNlcyByZWNlaXZlIHRoZSByb29tIGtleSwgb3Igc2hvdWxkIHRoZXkgYmVcbiAgICAgKiBleGNsdWRlZCBmcm9tIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICogQHJldHVybnMge0NvbGxlY3RTdHJhdGVneX1cbiAgICAgKi9cbiAgICBnZXQgc2hhcmluZ1N0cmF0ZWd5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9lbmNyeXB0aW9uc2V0dGluZ3Nfc2hhcmluZ1N0cmF0ZWd5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIENvbGxlY3RTdHJhdGVneS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdWxkIHVudHJ1c3RlZCBkZXZpY2VzIHJlY2VpdmUgdGhlIHJvb20ga2V5LCBvciBzaG91bGQgdGhleSBiZVxuICAgICAqIGV4Y2x1ZGVkIGZyb20gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0NvbGxlY3RTdHJhdGVneX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzaGFyaW5nU3RyYXRlZ3koYXJnMCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYXJnMCwgQ29sbGVjdFN0cmF0ZWd5KTtcbiAgICAgICAgdmFyIHB0cjAgPSBhcmcwLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9lbmNyeXB0aW9uc2V0dGluZ3Nfc2hhcmluZ1N0cmF0ZWd5KHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGBFbmNyeXB0aW9uU2V0dGluZ3NgIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZW5jcnlwdGlvbnNldHRpbmdzX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgRW5jcnlwdGlvblNldHRpbmdzRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5jb25zdCBFc3RhYmxpc2hlZEVjaWVzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2VzdGFibGlzaGVkZWNpZXNfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQW4gZXN0YWJsaXNoZWQgRUNJRVMgc2Vzc2lvbi5cbiAqXG4gKiBUaGlzIHNlc3Npb24gY2FuIGJlIHVzZWQgdG8gZW5jcnlwdCBhbmQgZGVjcnlwdCBtZXNzYWdlcyBiZXR3ZWVuIHRoZSB0d29cbiAqIHNpZGVzIG9mIHRoZSBjaGFubmVsLlxuICovXG5leHBvcnQgY2xhc3MgRXN0YWJsaXNoZWRFY2llcyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRXN0YWJsaXNoZWRFY2llcy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBFc3RhYmxpc2hlZEVjaWVzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEVzdGFibGlzaGVkRWNpZXNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2VzdGFibGlzaGVkZWNpZXNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgb3VyIFtgQ3VydmUyNTUxOVB1YmxpY0tleWBdLlxuICAgICAqXG4gICAgICogVGhpcyBwdWJsaWMga2V5IG5lZWRzIHRvIGJlIHNlbnQgdG8gdGhlIG90aGVyIHNpZGUgc28gdGhhdCBpdCBjYW5cbiAgICAgKiBjb21wbGV0ZSB0aGUgRUNJRVMgY2hhbm5lbCBlc3RhYmxpc2htZW50LlxuICAgICAqIEByZXR1cm5zIHtDdXJ2ZTI1NTE5UHVibGljS2V5fVxuICAgICAqL1xuICAgIHB1YmxpY19rZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXN0YWJsaXNoZWRlY2llc19wdWJsaWNfa2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEN1cnZlMjU1MTlQdWJsaWNLZXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgdGhlIGdpdmVuIHBsYWludGV4dCB1c2luZyB0aGlzIFtgRXN0YWJsaXNoZWRFY2llc2BdIHNlc3Npb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGVuY3J5cHQobWVzc2FnZSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChtZXNzYWdlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5lc3RhYmxpc2hlZGVjaWVzX2VuY3J5cHQodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgZGVmZXJyZWQyXzAgPSByZXRbMF07XG4gICAgICAgICAgICBkZWZlcnJlZDJfMSA9IHJldFsxXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQyXzAsIGRlZmVycmVkMl8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0IHRoZSBnaXZlbiBtZXNzYWdlIHVzaW5nIHRoaXMgW2BFc3RhYmxpc2hlZEVjaWVzYF0gc2Vzc2lvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZGVjcnlwdChtZXNzYWdlKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDNfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkM18xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKG1lc3NhZ2UsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVzdGFibGlzaGVkZWNpZXNfZGVjcnlwdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcHRyMiA9IHJldFswXTtcbiAgICAgICAgICAgIHZhciBsZW4yID0gcmV0WzFdO1xuICAgICAgICAgICAgaWYgKHJldFszXSkge1xuICAgICAgICAgICAgICAgIHB0cjIgPSAwOyBsZW4yID0gMDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWQzXzAgPSBwdHIyO1xuICAgICAgICAgICAgZGVmZXJyZWQzXzEgPSBsZW4yO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIyLCBsZW4yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkM18wLCBkZWZlcnJlZDNfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBbYENoZWNrQ29kZWBdIHdoaWNoIHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhpc1xuICAgICAqIFtgRXN0YWJsaXNoZWRFY2llc2BdIHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGNoZWNrIGNvZGUgY2FuIGJlIHVzZWQgdG8gdmVyaWZ5IGFuZCBjb25maXJtIHRoYXQgYm90aCBzaWRlcyBvZiB0aGVcbiAgICAgKiBzZXNzaW9uIGFyZSBpbmRlZWQgdXNpbmcgdGhlIHNhbWUgc2hhcmVkIHNlY3JldC5cbiAgICAgKiBAcmV0dXJucyB7Q2hlY2tDb2RlfVxuICAgICAqL1xuICAgIGNoZWNrX2NvZGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXN0YWJsaXNoZWRlY2llc19jaGVja19jb2RlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIENoZWNrQ29kZS5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5cbmNvbnN0IEV2ZW50SWRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZXZlbnRpZF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBIE1hdHJpeCBbZXZlbnQgSURdLlxuICpcbiAqIEFuIGBFdmVudElkYCBpcyBnZW5lcmF0ZWQgcmFuZG9tbHkgb3IgY29udmVydGVkIGZyb20gYSBzdHJpbmdcbiAqIHNsaWNlLCBhbmQgY2FuIGJlIGNvbnZlcnRlZCBiYWNrIGludG8gYSBzdHJpbmcgYXMgbmVlZGVkLlxuICpcbiAqIFtldmVudCBJRF06IGh0dHBzOi8vc3BlYy5tYXRyaXgub3JnL3YxLjIvYXBwZW5kaWNlcy8jcm9vbS1pZHMtYW5kLWV2ZW50LWlkc1xuICovXG5leHBvcnQgY2xhc3MgRXZlbnRJZCB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEV2ZW50SWRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2V2ZW50aWRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZS92YWxpZGF0ZSBhbmQgY3JlYXRlIGEgbmV3IGBFdmVudElkYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoaWQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ldmVudGlkX25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldFswXSA+Pj4gMDtcbiAgICAgICAgRXZlbnRJZEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBldmVudCdzIGxvY2FscGFydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBsb2NhbHBhcnQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ldmVudGlkX2xvY2FscGFydCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNlcnZlciBuYW1lIG9mIHRoZSBldmVudCBJRC5cbiAgICAgKiBAcmV0dXJucyB7U2VydmVyTmFtZSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgc2VydmVyTmFtZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ldmVudGlkX3NlcnZlck5hbWUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogU2VydmVyTmFtZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBldmVudCBJRCBhcyBhIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXZlbnRpZF90b1N0cmluZyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBJZGVudGl0eUtleXNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfaWRlbnRpdHlrZXlzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFN0cnVjdCBob2xkaW5nIHRoZSB0d28gcHVibGljIGlkZW50aXR5IGtleXMgb2YgYW4gYWNjb3VudC5cbiAqL1xuZXhwb3J0IGNsYXNzIElkZW50aXR5S2V5cyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoSWRlbnRpdHlLZXlzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIElkZW50aXR5S2V5c0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBJZGVudGl0eUtleXNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2lkZW50aXR5a2V5c19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBFZDI1NTE5IHB1YmxpYyBrZXksIHVzZWQgZm9yIHNpZ25pbmcuXG4gICAgICogQHJldHVybnMge0VkMjU1MTlQdWJsaWNLZXl9XG4gICAgICovXG4gICAgZ2V0IGVkMjU1MTkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2lkZW50aXR5a2V5c19lZDI1NTE5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEVkMjU1MTlQdWJsaWNLZXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBFZDI1NTE5IHB1YmxpYyBrZXksIHVzZWQgZm9yIHNpZ25pbmcuXG4gICAgICogQHBhcmFtIHtFZDI1NTE5UHVibGljS2V5fSBhcmcwXG4gICAgICovXG4gICAgc2V0IGVkMjU1MTkoYXJnMCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYXJnMCwgRWQyNTUxOVB1YmxpY0tleSk7XG4gICAgICAgIHZhciBwdHIwID0gYXJnMC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfaWRlbnRpdHlrZXlzX2VkMjU1MTkodGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgQ3VydmUyNTUxOSBwdWJsaWMga2V5LCB1c2VkIGZvciBlc3RhYmxpc2ggc2hhcmVkIHNlY3JldHMuXG4gICAgICogQHJldHVybnMge0N1cnZlMjU1MTlQdWJsaWNLZXl9XG4gICAgICovXG4gICAgZ2V0IGN1cnZlMjU1MTkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2lkZW50aXR5a2V5c19jdXJ2ZTI1NTE5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEN1cnZlMjU1MTlQdWJsaWNLZXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBDdXJ2ZTI1NTE5IHB1YmxpYyBrZXksIHVzZWQgZm9yIGVzdGFibGlzaCBzaGFyZWQgc2VjcmV0cy5cbiAgICAgKiBAcGFyYW0ge0N1cnZlMjU1MTlQdWJsaWNLZXl9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgY3VydmUyNTUxOShhcmcwKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhcmcwLCBDdXJ2ZTI1NTE5UHVibGljS2V5KTtcbiAgICAgICAgdmFyIHB0cjAgPSBhcmcwLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9pZGVudGl0eWtleXNfY3VydmUyNTUxOSh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgfVxufVxuXG5jb25zdCBJbmJvdW5kQ3JlYXRpb25SZXN1bHRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfaW5ib3VuZGNyZWF0aW9ucmVzdWx0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFRoZSByZXN1bHQgb2YgYW4gaW5ib3VuZCBFQ0lFUyBjaGFubmVsIGVzdGFibGlzaG1lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmJvdW5kQ3JlYXRpb25SZXN1bHQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEluYm91bmRDcmVhdGlvblJlc3VsdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBJbmJvdW5kQ3JlYXRpb25SZXN1bHRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgSW5ib3VuZENyZWF0aW9uUmVzdWx0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19pbmJvdW5kY3JlYXRpb25yZXN1bHRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZXN0YWJsaXNoZWQgRUNJRVMgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJucyB7RXN0YWJsaXNoZWRFY2llc31cbiAgICAgKi9cbiAgICBnZXQgY2hhbm5lbCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfaW5ib3VuZGNyZWF0aW9ucmVzdWx0X2NoYW5uZWwodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRXN0YWJsaXNoZWRFY2llcy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGVzdGFibGlzaGVkIEVDSUVTIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIHtFc3RhYmxpc2hlZEVjaWVzfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGNoYW5uZWwoYXJnMCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYXJnMCwgRXN0YWJsaXNoZWRFY2llcyk7XG4gICAgICAgIHZhciBwdHIwID0gYXJnMC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfaW5ib3VuZGNyZWF0aW9ucmVzdWx0X2NoYW5uZWwodGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcGxhaW50ZXh0IG9mIHRoZSBpbml0aWFsIG1lc3NhZ2UuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9pbmJvdW5kY3JlYXRpb25yZXN1bHRfbWVzc2FnZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwbGFpbnRleHQgb2YgdGhlIGluaXRpYWwgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBtZXNzYWdlKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfYmFja3Vwc2VjcmV0c2J1bmRsZV9rZXkodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbn1cblxuY29uc3QgSW5ib3VuZEdyb3VwU2Vzc2lvbkZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19pbmJvdW5kZ3JvdXBzZXNzaW9uX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEluYm91bmQgZ3JvdXAgc2Vzc2lvbi5cbiAqXG4gKiBJbmJvdW5kIGdyb3VwIHNlc3Npb25zIGFyZSB1c2VkIHRvIGV4Y2hhbmdlIHJvb20gbWVzc2FnZXMgYmV0d2VlbiBhIGdyb3VwIG9mXG4gKiBwYXJ0aWNpcGFudHMuIEluYm91bmQgZ3JvdXAgc2Vzc2lvbnMgYXJlIHVzZWQgdG8gZGVjcnlwdCB0aGUgcm9vbSBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEluYm91bmRHcm91cFNlc3Npb24ge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEluYm91bmRHcm91cFNlc3Npb24ucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgSW5ib3VuZEdyb3VwU2Vzc2lvbkZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBJbmJvdW5kR3JvdXBTZXNzaW9uRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19pbmJvdW5kZ3JvdXBzZXNzaW9uX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJvb20gd2hlcmUgdGhpcyBzZXNzaW9uIGlzIHVzZWQgaW4uXG4gICAgICogQHJldHVybnMge1Jvb21JZH1cbiAgICAgKi9cbiAgICBnZXQgcm9vbUlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmluYm91bmRncm91cHNlc3Npb25fcm9vbUlkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFJvb21JZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIEN1cnZlMjU1MTkga2V5IG9mIHRoZSBzZW5kZXIgb2YgdGhpcyBzZXNzaW9uLCBhcyBhXG4gICAgICogW0N1cnZlMjU1MTlQdWJsaWNLZXldLlxuICAgICAqIEByZXR1cm5zIHtDdXJ2ZTI1NTE5UHVibGljS2V5fVxuICAgICAqL1xuICAgIGdldCBzZW5kZXJLZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5ib3VuZGdyb3Vwc2Vzc2lvbl9zZW5kZXJLZXkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQ3VydmUyNTUxOVB1YmxpY0tleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBzZXNzaW9uSWQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbmJvdW5kZ3JvdXBzZXNzaW9uX3Nlc3Npb25JZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhcyB0aGUgc2Vzc2lvbiBiZWVuIGltcG9ydGVkIGZyb20gYSBmaWxlIG9yIHNlcnZlci1zaWRlIGJhY2t1cD8gQXNcbiAgICAgKiBvcHBvc2VkIHRvIGJlaW5nIGRpcmVjdGx5IHJlY2VpdmVkIGFzIGFuIGBtLnJvb21fa2V5YCBldmVudC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNCZWVuSW1wb3J0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5ib3VuZGdyb3Vwc2Vzc2lvbl9oYXNCZWVuSW1wb3J0ZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbn1cblxuY29uc3QgS2V5c0JhY2t1cFJlcXVlc3RGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfa2V5c2JhY2t1cHJlcXVlc3RfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQSByZXF1ZXN0IHRoYXQgd2lsbCBiYWNrIHVwIGEgYmF0Y2ggb2Ygcm9vbSBrZXlzIHRvIHRoZSBzZXJ2ZXJcbiAqIChbc3BlY2lmaWNhdGlvbl0pLlxuICpcbiAqIFtzcGVjaWZpY2F0aW9uXTogaHR0cHM6Ly9zcGVjLm1hdHJpeC5vcmcvdW5zdGFibGUvY2xpZW50LXNlcnZlci1hcGkvI3B1dF9tYXRyaXhjbGllbnR2M3Jvb21fa2V5c2tleXNcbiAqL1xuZXhwb3J0IGNsYXNzIEtleXNCYWNrdXBSZXF1ZXN0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShLZXlzQmFja3VwUmVxdWVzdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBLZXlzQmFja3VwUmVxdWVzdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBLZXlzQmFja3VwUmVxdWVzdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfa2V5c2JhY2t1cHJlcXVlc3RfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVxdWVzdCBJRC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfa2V5c2JhY2t1cHJlcXVlc3RfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIEpTT04tZW5jb2RlZCBzdHJpbmcgY29udGFpbmluZyB0aGUgcmVzdCBvZiB0aGUgcGF5bG9hZDogYHJvb21zYC5cbiAgICAgKlxuICAgICAqIEl0IHJlcHJlc2VudHMgdGhlIGJvZHkgb2YgdGhlIEhUVFAgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBib2R5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9rZXlzYmFja3VwcmVxdWVzdF9ib2R5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJhY2t1cCB2ZXJzaW9uIHRoYXQgdGhlc2Ugcm9vbSBrZXlzIHNob3VsZCBiZSBwYXJ0IG9mLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHZlcnNpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2tleXNiYWNrdXByZXF1ZXN0X3ZlcnNpb24odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYEtleXNCYWNrdXBSZXF1ZXN0YC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYm9keVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWQsIGJvZHksIHZlcnNpb24pIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5rZXlzYmFja3VwcmVxdWVzdF9uZXcoaWQsIGJvZHksIHZlcnNpb24pO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgS2V5c0JhY2t1cFJlcXVlc3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGl0cyByZXF1ZXN0IHR5cGUuXG4gICAgICogQHJldHVybnMge1JlcXVlc3RUeXBlfVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmtleXNiYWNrdXByZXF1ZXN0X3R5cGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cblxuY29uc3QgS2V5c0NsYWltUmVxdWVzdEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19rZXlzY2xhaW1yZXF1ZXN0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIERhdGEgZm9yIGEgcmVxdWVzdCB0byB0aGUgYC9rZXlzL2NsYWltYCBBUEkgZW5kcG9pbnRcbiAqIChbc3BlY2lmaWNhdGlvbl0pLlxuICpcbiAqIENsYWltcyBvbmUtdGltZSBrZXlzIHRoYXQgY2FuIGJlIHVzZWQgdG8gZXN0YWJsaXNoIDEtdG8tMSBFMkVFXG4gKiBzZXNzaW9ucy5cbiAqXG4gKiBbc3BlY2lmaWNhdGlvbl06IGh0dHBzOi8vc3BlYy5tYXRyaXgub3JnL3Vuc3RhYmxlL2NsaWVudC1zZXJ2ZXItYXBpLyNwb3N0X21hdHJpeGNsaWVudHYza2V5c2NsYWltXG4gKi9cbmV4cG9ydCBjbGFzcyBLZXlzQ2xhaW1SZXF1ZXN0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShLZXlzQ2xhaW1SZXF1ZXN0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEtleXNDbGFpbVJlcXVlc3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgS2V5c0NsYWltUmVxdWVzdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfa2V5c2NsYWltcmVxdWVzdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0IElELlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9rZXlzY2xhaW1yZXF1ZXN0X2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBKU09OLWVuY29kZWQgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHJlc3Qgb2YgdGhlIHBheWxvYWQ6IGB0aW1lb3V0YCxcbiAgICAgKiBgb25lX3RpbWVfa2V5c2AuXG4gICAgICpcbiAgICAgKiBJdCByZXByZXNlbnRzIHRoZSBib2R5IG9mIHRoZSBIVFRQIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfa2V5c2NsYWltcmVxdWVzdF9ib2R5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGBLZXlzQ2xhaW1SZXF1ZXN0YC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYm9keVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlkLCBib2R5KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ua2V5c2NsYWltcmVxdWVzdF9uZXcoaWQsIGJvZHkpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgS2V5c0NsYWltUmVxdWVzdEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgaXRzIHJlcXVlc3QgdHlwZS5cbiAgICAgKiBAcmV0dXJucyB7UmVxdWVzdFR5cGV9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ua2V5c2NsYWltcmVxdWVzdF90eXBlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG5cbmNvbnN0IEtleXNRdWVyeVJlcXVlc3RGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfa2V5c3F1ZXJ5cmVxdWVzdF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBEYXRhIGZvciBhIHJlcXVlc3QgdG8gdGhlIGAva2V5cy9xdWVyeWAgQVBJIGVuZHBvaW50XG4gKiAoW3NwZWNpZmljYXRpb25dKS5cbiAqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRldmljZXMgYW5kIGlkZW50aXR5IGtleXMgZm9yIHRoZSBnaXZlbiB1c2Vycy5cbiAqXG4gKiBbc3BlY2lmaWNhdGlvbl06IGh0dHBzOi8vc3BlYy5tYXRyaXgub3JnL3Vuc3RhYmxlL2NsaWVudC1zZXJ2ZXItYXBpLyNwb3N0X21hdHJpeGNsaWVudHYza2V5c3F1ZXJ5XG4gKi9cbmV4cG9ydCBjbGFzcyBLZXlzUXVlcnlSZXF1ZXN0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShLZXlzUXVlcnlSZXF1ZXN0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEtleXNRdWVyeVJlcXVlc3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgS2V5c1F1ZXJ5UmVxdWVzdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfa2V5c3F1ZXJ5cmVxdWVzdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0IElELlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9rZXlzcXVlcnlyZXF1ZXN0X2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBKU09OLWVuY29kZWQgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHJlc3Qgb2YgdGhlIHBheWxvYWQ6IGB0aW1lb3V0YCxcbiAgICAgKiBgZGV2aWNlX2tleXNgLCBgdG9rZW5gLlxuICAgICAqXG4gICAgICogSXQgcmVwcmVzZW50cyB0aGUgYm9keSBvZiB0aGUgSFRUUCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2tleXNxdWVyeXJlcXVlc3RfYm9keSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBgS2V5c1F1ZXJ5UmVxdWVzdGAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJvZHlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZCwgYm9keSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmtleXNxdWVyeXJlcXVlc3RfbmV3KGlkLCBib2R5KTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIEtleXNRdWVyeVJlcXVlc3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGl0cyByZXF1ZXN0IHR5cGUuXG4gICAgICogQHJldHVybnMge1JlcXVlc3RUeXBlfVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmtleXNxdWVyeXJlcXVlc3RfdHlwZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuXG5jb25zdCBLZXlzVXBsb2FkUmVxdWVzdEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19rZXlzdXBsb2FkcmVxdWVzdF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBPdXRnb2luZyBSZXF1ZXN0cyAqXG4gKiBEYXRhIGZvciBhIHJlcXVlc3QgdG8gdGhlIGAva2V5cy91cGxvYWRgIEFQSSBlbmRwb2ludFxuICogKFtzcGVjaWZpY2F0aW9uXSkuXG4gKlxuICogUHVibGlzaGVzIGVuZC10by1lbmQgZW5jcnlwdGlvbiBrZXlzIGZvciB0aGUgZGV2aWNlLlxuICpcbiAqIFtzcGVjaWZpY2F0aW9uXTogaHR0cHM6Ly9zcGVjLm1hdHJpeC5vcmcvdW5zdGFibGUvY2xpZW50LXNlcnZlci1hcGkvI3Bvc3RfbWF0cml4Y2xpZW50djNrZXlzdXBsb2FkXG4gKi9cbmV4cG9ydCBjbGFzcyBLZXlzVXBsb2FkUmVxdWVzdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoS2V5c1VwbG9hZFJlcXVlc3QucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgS2V5c1VwbG9hZFJlcXVlc3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgS2V5c1VwbG9hZFJlcXVlc3RGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2tleXN1cGxvYWRyZXF1ZXN0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlcXVlc3QgSUQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2tleXN1cGxvYWRyZXF1ZXN0X2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBKU09OLWVuY29kZWQgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHJlc3Qgb2YgdGhlIHBheWxvYWQ6IGBkZXZpY2Vfa2V5c2AsXG4gICAgICogYG9uZV90aW1lX2tleXNgLCBgZmFsbGJhY2tfa2V5c2AuXG4gICAgICpcbiAgICAgKiBJdCByZXByZXNlbnRzIHRoZSBib2R5IG9mIHRoZSBIVFRQIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfa2V5c3VwbG9hZHJlcXVlc3RfYm9keSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBgS2V5c1VwbG9hZFJlcXVlc3RgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBib2R5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWQsIGJvZHkpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5rZXlzdXBsb2FkcmVxdWVzdF9uZXcoaWQsIGJvZHkpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgS2V5c1VwbG9hZFJlcXVlc3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGl0cyByZXF1ZXN0IHR5cGUuXG4gICAgICogQHJldHVybnMge1JlcXVlc3RUeXBlfVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmtleXN1cGxvYWRyZXF1ZXN0X3R5cGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cblxuY29uc3QgTWF5YmVTaWduYXR1cmVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfbWF5YmVzaWduYXR1cmVfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHNpZ25hdHVyZSB0aGF0IGlzIGVpdGhlciB2YWxpZCBfb3JfIHRoYXQgY291bGQgbm90IGJlXG4gKiBkZWNvZGVkLlxuICovXG5leHBvcnQgY2xhc3MgTWF5YmVTaWduYXR1cmUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE1heWJlU2lnbmF0dXJlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE1heWJlU2lnbmF0dXJlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE1heWJlU2lnbmF0dXJlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19tYXliZXNpZ25hdHVyZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIHNpZ25hdHVyZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZGVjb2RlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1heWJlc2lnbmF0dXJlX2lzVmFsaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBzaWduYXR1cmUgY291bGQgbm90IGJlIHN1Y2Nlc3NmdWxseSBkZWNvZGVkLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzSW52YWxpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5tYXliZXNpZ25hdHVyZV9pc0ludmFsaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2lnbmF0dXJlLCBpZiBzdWNjZXNzZnVsbHkgZGVjb2RlZC5cbiAgICAgKiBAcmV0dXJucyB7U2lnbmF0dXJlIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBzaWduYXR1cmUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWF5YmVzaWduYXR1cmVfc2lnbmF0dXJlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFNpZ25hdHVyZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0aGF0IGlzIGNsYWltZWQgdG8gY29udGFpbiBhXG4gICAgICogc2lnbmF0dXJlIGJ1dCBjb3VsZCBub3QgYmUgZGVjb2RlZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IGludmFsaWRTaWduYXR1cmVTb3VyY2UoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWF5YmVzaWduYXR1cmVfaW52YWxpZFNpZ25hdHVyZVNvdXJjZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHJldFswXSAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyZXRbMF0sIHJldFsxXSAqIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MTtcbiAgICB9XG59XG5cbmNvbnN0IE1lZ29sbURlY3J5cHRpb25FcnJvckZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19tZWdvbG1kZWNyeXB0aW9uZXJyb3JfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogSnMgRGVjcnlwdGlvbiBlcnJvciB3aXRoIGNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBNZWdvbG1EZWNyeXB0aW9uRXJyb3Ige1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE1lZ29sbURlY3J5cHRpb25FcnJvci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBNZWdvbG1EZWNyeXB0aW9uRXJyb3JGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTWVnb2xtRGVjcnlwdGlvbkVycm9yRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19tZWdvbG1kZWNyeXB0aW9uZXJyb3JfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvbiBjb2RlIGZvciB0aGUgZXJyb3IuIFNlZSBgRGVjcnlwdGlvbkVycm9yQ29kZWBcbiAgICAgKiBAcmV0dXJucyB7RGVjcnlwdGlvbkVycm9yQ29kZX1cbiAgICAgKi9cbiAgICBnZXQgY29kZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfbWVnb2xtZGVjcnlwdGlvbmVycm9yX2NvZGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBkZXRhaWxlZCBkZXNjcmlwdGlvblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9tZWdvbG1kZWNyeXB0aW9uZXJyb3JfZGVzY3JpcHRpb24odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaXRoaGVsZCBjb2RlIGlmIGFueS4gT25seSBmb3IgYFVua25vd25NZXNzYWdlSW5kZXhgIGVycm9yIGNvZGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBtYXliZV93aXRoaGVsZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfbWVnb2xtZGVjcnlwdGlvbmVycm9yX21heWJlX3dpdGhoZWxkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG5cbmNvbnN0IE1lZ29sbVYxQmFja3VwS2V5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX21lZ29sbXYxYmFja3Vwa2V5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFRoZSBwdWJsaWMgcGFydCBvZiB0aGUgYmFja3VwIGtleS5cbiAqL1xuZXhwb3J0IGNsYXNzIE1lZ29sbVYxQmFja3VwS2V5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShNZWdvbG1WMUJhY2t1cEtleS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBNZWdvbG1WMUJhY2t1cEtleUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBNZWdvbG1WMUJhY2t1cEtleUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfbWVnb2xtdjFiYWNrdXBrZXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYWN0dWFsIGJhc2U2NCBlbmNvZGVkIHB1YmxpYyBrZXkuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgcHVibGljS2V5QmFzZTY0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1lZ29sbXYxYmFja3Vwa2V5X3B1YmxpY0tleUJhc2U2NCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZnVsbCBuYW1lIG9mIHRoZSBiYWNrdXAgYWxnb3JpdGhtIHRoaXMgYmFja3VwIGtleSBzdXBwb3J0cy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBhbGdvcml0aG0oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWVnb2xtdjFiYWNrdXBrZXlfYWxnb3JpdGhtKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG5cbmNvbnN0IE1pZ3JhdGlvbkZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19taWdyYXRpb25fZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogTWlncmF0aW9uIHJvdXRpbmVzXG4gKlxuICogVGhlIHB1YmxpYyBtZXRob2RzIGFyZSBleHBvc2VkIGFzIHN0YXRpYyBtZXRob2RzIG9uIHRoaXMgY2xhc3MsIGZvclxuICogbmFtZXNwYWNpbmcgYW5kIHRvIGVuYWJsZSBlYXNpZXIgbW9ja2luZyBpbiB1bml0IHRlc3RzLlxuICovXG5leHBvcnQgY2xhc3MgTWlncmF0aW9uIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTWlncmF0aW9uRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19taWdyYXRpb25fZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBvcnQgdGhlIGJhc2UgZGF0YXNldCBmcm9tIGEgbGlib2xtLWJhc2VkIHNldHVwIHRvIGEgdm9kb3plbWFjLWJhc2VkXG4gICAgICogc2V0dXAgc3RvcmVkIGluIEluZGV4ZWREQi5cbiAgICAgKlxuICAgICAqIFBvcHVsYXRlcyB0aGUgdXNlciBjcmVkZW50aWFscywgT2xtIGFjY291bnQsIGJhY2t1cCBkYXRhLCBldGMuIFRoaXMgaXNcbiAgICAgKiB0aGUgZmlyc3Qgc3RlcCBpbiB0aGUgbWlncmF0aW9uIHByb2Nlc3MuIE9uY2UgdGhpcyBiYXNlIGRhdGEgaXNcbiAgICAgKiBpbXBvcnRlZCwgZnVydGhlciBkYXRhIGNhbiBiZSBpbXBvcnRlZCB3aXRoIHtAbGlua1xuICAgICAqICNtaWdyYXRlT2xtU2Vzc2lvbnN9LCB7QGxpbmsgI21pZ3JhdGVNZWdvbG1TZXNzaW9uc30sIGFuZCBUT0RPIHJvb20gc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiAjIEFyZ3VtZW50c1xuICAgICAqXG4gICAgICogKiBgZGF0YWAgLSBUaGUgZGF0YSB0byBiZSBtaWdyYXRlZFxuICAgICAqICogYHBpY2tsZV9rZXlgIC0gVGhlIGxpYm9sbSBwaWNrbGUga2V5IHRoYXQgd2FzIHVzZWQgdG8gcGlja2xlIHRoZSBvbG1cbiAgICAgKiAgIGFjY291bnQgb2JqZWN0cy5cbiAgICAgKiAqIGBzdG9yZV9oYW5kbGVgIC0gQSBjb25uZWN0aW9uIHRvIHRoZSBDcnlwdG9TdG9yZSB3aGljaCB3aWxsIGJlIHVzZWQgdG9cbiAgICAgKiAgIHN0b3JlIHRoZSB2b2RvemVtYWMgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0Jhc2VNaWdyYXRpb25EYXRhfSBkYXRhXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBwaWNrbGVfa2V5XG4gICAgICogQHBhcmFtIHtTdG9yZUhhbmRsZX0gc3RvcmVfaGFuZGxlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBzdGF0aWMgbWlncmF0ZUJhc2VEYXRhKGRhdGEsIHBpY2tsZV9rZXksIHN0b3JlX2hhbmRsZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZGF0YSwgQmFzZU1pZ3JhdGlvbkRhdGEpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc3RvcmVfaGFuZGxlLCBTdG9yZUhhbmRsZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWlncmF0aW9uX21pZ3JhdGVCYXNlRGF0YShkYXRhLl9fd2JnX3B0ciwgcGlja2xlX2tleSwgc3RvcmVfaGFuZGxlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1pZ3JhdGUgT2xtIHNlc3Npb25zIG9mIGEgbGlib2xtLWJhc2VkIHNldHVwIHRvIGEgdm9kb3plbWFjLWJhc2VkIHNldHVwXG4gICAgICogc3RvcmVkIGluIGFuIGluZGV4ZWREQiBjcnlwdG8gc3RvcmUuXG4gICAgICpcbiAgICAgKiBCZWZvcmUgdGhpcyBtZXRob2QgY2FuIGJlIHVzZWQsIHtAbGluayAjbWlncmF0ZUJhc2VEYXRhfSBtdXN0IGJlIHVzZWQgdG9cbiAgICAgKiBpbXBvcnQgdGhlIGJhc2UgZGF0YSBpbnRvIHRoZSBjcnlwdG8gc3RvcmUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGEgbnVtYmVyIG9mIHRpbWVzLCB3aXRoIHNlcGFyYXRlIGJhdGNoZXMgb2ZcbiAgICAgKiBgc2Vzc2lvbnNgLiBJZiBhIHByb2dyZXNzIGRpc3BsYXkgaXMgZ2l2ZW4sIGl0IGNhbiBiZSB1cGRhdGVkIGFmdGVyXG4gICAgICogZWFjaCBiYXRjaCBpcyBzdWNjZXNzZnVsbHkgaW1wb3J0ZWQuXG4gICAgICpcbiAgICAgKiAjIEFyZ3VtZW50c1xuICAgICAqXG4gICAgICogKiBgc2Vzc2lvbnNgIC0gQW4gYEFycmF5YCBvZiB7QGxpbmsgUGlja2xlZFNlc3Npb259cyB0byBpbXBvcnQuIEl0ZW1zXG4gICAgICogICBpbnNpZGUgYHNlc3Npb25zYCB3aWxsIGJlIGludmFsaWRhdGVkIGJ5IHRoaXMgbWV0aG9kLlxuICAgICAqICogYHBpY2tsZV9rZXlgIC0gVGhlIGxpYm9sbSBwaWNrbGUga2V5IHRoYXQgd2FzIHVzZWQgdG8gcGlja2xlIHRoZSBvbG1cbiAgICAgKiAgIHNlc3Npb24gb2JqZWN0cy5cbiAgICAgKiAqIGBzdG9yZV9oYW5kbGVgIC0gQSBjb25uZWN0aW9uIHRvIHRoZSBDcnlwdG9TdG9yZSB3aGljaCB3aWxsIGJlIHVzZWQgdG9cbiAgICAgKiAgIHN0b3JlIHRoZSB2b2RvemVtYWMgZGF0YS5cbiAgICAgKiBAcGFyYW0geyhQaWNrbGVkU2Vzc2lvbilbXX0gc2Vzc2lvbnNcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHBpY2tsZV9rZXlcbiAgICAgKiBAcGFyYW0ge1N0b3JlSGFuZGxlfSBzdG9yZV9oYW5kbGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHN0YXRpYyBtaWdyYXRlT2xtU2Vzc2lvbnMoc2Vzc2lvbnMsIHBpY2tsZV9rZXksIHN0b3JlX2hhbmRsZSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoc2Vzc2lvbnMsIHdhc20uX193YmluZGdlbl9tYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc3RvcmVfaGFuZGxlLCBTdG9yZUhhbmRsZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWlncmF0aW9uX21pZ3JhdGVPbG1TZXNzaW9ucyhwdHIwLCBsZW4wLCBwaWNrbGVfa2V5LCBzdG9yZV9oYW5kbGUuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWlncmF0ZSBNZWdvbG0gc2Vzc2lvbnMgb2YgYSBsaWJvbG0tYmFzZWQgc2V0dXAgdG8gYSB2b2RvemVtYWMtYmFzZWRcbiAgICAgKiBzZXR1cCBzdG9yZWQgaW4gYW4gaW5kZXhlZERCIGNyeXB0byBzdG9yZS5cbiAgICAgKlxuICAgICAqIEJlZm9yZSB0aGlzIG1ldGhvZCBjYW4gYmUgdXNlZCwge0BsaW5rICNtaWdyYXRlQmFzZURhdGF9IG11c3QgYmUgdXNlZCB0b1xuICAgICAqIGltcG9ydCB0aGUgYmFzZSBkYXRhIGludG8gdGhlIGNyeXB0byBzdG9yZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgYSBudW1iZXIgb2YgdGltZXMsIHdpdGggc2VwYXJhdGUgYmF0Y2hlcyBvZlxuICAgICAqIGBzZXNzaW9uc2AuIElmIGEgcHJvZ3Jlc3MgZGlzcGxheSBpcyBnaXZlbiwgaXQgY2FuIGJlIHVwZGF0ZWQgYWZ0ZXJcbiAgICAgKiBlYWNoIGJhdGNoIGlzIHN1Y2Nlc3NmdWxseSBpbXBvcnRlZC5cbiAgICAgKlxuICAgICAqICMgQXJndW1lbnRzXG4gICAgICpcbiAgICAgKiAqIGBzZXNzaW9uc2AgLSBBbiBgQXJyYXlgIG9mIHtAbGluayBQaWNrbGVkSW5ib3VuZEdyb3VwU2Vzc2lvbn1zIHRvXG4gICAgICogICBpbXBvcnQuIEl0ZW1zIGluc2lkZSBgc2Vzc2lvbnNgIHdpbGwgYmUgaW52YWxpZGF0ZWQgYnkgdGhpcyBtZXRob2QuXG4gICAgICogKiBgcGlja2xlX2tleWAgLSBUaGUgbGlib2xtIHBpY2tsZSBrZXkgdGhhdCB3YXMgdXNlZCB0byBwaWNrbGUgdGhlXG4gICAgICogICBtZWdvbG0gc2Vzc2lvbiBvYmplY3RzLlxuICAgICAqICogYHN0b3JlX2hhbmRsZWAgLSBBIGNvbm5lY3Rpb24gdG8gdGhlIENyeXB0b1N0b3JlIHdoaWNoIHdpbGwgYmUgdXNlZCB0b1xuICAgICAqICAgc3RvcmUgdGhlIHZvZG96ZW1hYyBkYXRhLlxuICAgICAqIEBwYXJhbSB7KFBpY2tsZWRJbmJvdW5kR3JvdXBTZXNzaW9uKVtdfSBzZXNzaW9uc1xuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gcGlja2xlX2tleVxuICAgICAqIEBwYXJhbSB7U3RvcmVIYW5kbGV9IHN0b3JlX2hhbmRsZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc3RhdGljIG1pZ3JhdGVNZWdvbG1TZXNzaW9ucyhzZXNzaW9ucywgcGlja2xlX2tleSwgc3RvcmVfaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChzZXNzaW9ucywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzdG9yZV9oYW5kbGUsIFN0b3JlSGFuZGxlKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5taWdyYXRpb25fbWlncmF0ZU1lZ29sbVNlc3Npb25zKHB0cjAsIGxlbjAsIHBpY2tsZV9rZXksIHN0b3JlX2hhbmRsZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cblxuY29uc3QgT2xtTWFjaGluZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19vbG1tYWNoaW5lX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFN0YXRlIG1hY2hpbmUgaW1wbGVtZW50YXRpb24gb2YgdGhlIE9sbS9NZWdvbG0gZW5jcnlwdGlvbiBwcm90b2NvbFxuICogdXNlZCBmb3IgTWF0cml4IGVuZCB0byBlbmQgZW5jcnlwdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIE9sbU1hY2hpbmUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE9sbU1hY2hpbmUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgT2xtTWFjaGluZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBPbG1NYWNoaW5lRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19vbG1tYWNoaW5lX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3Igd2lsbCBhbHdheXMgZmFpbC4gVG8gY3JlYXRlIGEgbmV3IGBPbG1NYWNoaW5lYCwgcGxlYXNlIHVzZVxuICAgICAqIHRoZSBgaW5pdGlhbGl6ZWAgbWV0aG9kLlxuICAgICAqXG4gICAgICogV2h5IHRoaXMgcGF0dGVybj8gYGluaXRpYWxpemVgIHJldHVybnMgYSBgUHJvbWlzZWAuIFJldHVybmluZyBhXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9uZXcoKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldFswXSA+Pj4gMDtcbiAgICAgICAgT2xtTWFjaGluZUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYE9sbU1hY2hpbmVgLlxuICAgICAqXG4gICAgICogVGhlIGNyZWF0ZWQgbWFjaGluZSB3aWxsIGtlZXAgdGhlIGVuY3J5cHRpb24ga2V5cyBlaXRoZXIgaW4gYSBJbmRleGVkREJcbiAgICAgKiBiYXNlZCBzdG9yZSwgb3IgaW4gYSBtZW1vcnkgc3RvcmUgYW5kIG9uY2UgdGhlIG9iamVjdHMgaXMgZHJvcHBlZCxcbiAgICAgKiB0aGUga2V5cyB3aWxsIGJlIGxvc3QuXG4gICAgICpcbiAgICAgKiAjIEFyZ3VtZW50c1xuICAgICAqXG4gICAgICogKiBgdXNlcl9pZGAgLSByZXByZXNlbnRzIHRoZSB1bmlxdWUgSUQgb2YgdGhlIHVzZXIgdGhhdCBvd25zIHRoaXNcbiAgICAgKiBtYWNoaW5lLlxuICAgICAqXG4gICAgICogKiBgZGV2aWNlX2lkYCAtIHJlcHJlc2VudHMgdGhlIHVuaXF1ZSBJRCBvZiB0aGUgZGV2aWNlXG4gICAgICogdGhhdCBvd25zIHRoaXMgbWFjaGluZS5cbiAgICAgKlxuICAgICAqICogYHN0b3JlX25hbWVgIC0gVGhlIG5hbWUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBvcGVuIHRoZSBJbmRleGVkREJcbiAgICAgKiAgIGJhc2VkIGRhdGFiYXNlLiBJZiB0aGlzIGlzbid0IHByb3ZpZGVkLCBhIG1lbW9yeS1vbmx5IHN0b3JlIHdpbGwgYmVcbiAgICAgKiAgIHVzZWQuICpOb3RlKiB0aGUgbWVtb3J5LW9ubHkgc3RvcmUgd2lsbCBsb3NlIHlvdXIgRTJFRSBrZXlzIHdoZW4gdGhlXG4gICAgICogICBgT2xtTWFjaGluZWAgZ2V0cyBkcm9wcGVkLlxuICAgICAqXG4gICAgICogKiBgc3RvcmVfcGFzc3BocmFzZWAgLSBUaGUgcGFzc3BocmFzZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGVuY3J5cHQgdGhlXG4gICAgICogICBJbmRleGVkREItYmFzZWQgc3RvcmUuXG4gICAgICogQHBhcmFtIHtVc2VySWR9IHVzZXJfaWRcbiAgICAgKiBAcGFyYW0ge0RldmljZUlkfSBkZXZpY2VfaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW3N0b3JlX25hbWVdXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtzdG9yZV9wYXNzcGhyYXNlXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc3RhdGljIGluaXRpYWxpemUodXNlcl9pZCwgZGV2aWNlX2lkLCBzdG9yZV9uYW1lLCBzdG9yZV9wYXNzcGhyYXNlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh1c2VyX2lkLCBVc2VySWQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZGV2aWNlX2lkLCBEZXZpY2VJZCk7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShzdG9yZV9uYW1lKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChzdG9yZV9uYW1lLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMSA9IGlzTGlrZU5vbmUoc3RvcmVfcGFzc3BocmFzZSkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoc3RvcmVfcGFzc3BocmFzZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2luaXRpYWxpemUodXNlcl9pZC5fX3diZ19wdHIsIGRldmljZV9pZC5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYE9sbU1hY2hpbmVgIGJhY2tlZCBieSBhbiBleGlzdGluZyBzdG9yZS5cbiAgICAgKlxuICAgICAqICMgQXJndW1lbnRzXG4gICAgICpcbiAgICAgKiAqIGB1c2VyX2lkYCAtIHJlcHJlc2VudHMgdGhlIHVuaXF1ZSBJRCBvZiB0aGUgdXNlciB0aGF0IG93bnMgdGhpc1xuICAgICAqIG1hY2hpbmUuXG4gICAgICpcbiAgICAgKiAqIGBkZXZpY2VfaWRgIC0gcmVwcmVzZW50cyB0aGUgdW5pcXVlIElEIG9mIHRoZSBkZXZpY2VcbiAgICAgKiB0aGF0IG93bnMgdGhpcyBtYWNoaW5lLlxuICAgICAqXG4gICAgICogKiBgc3RvcmVfaGFuZGxlYCAtIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBjcnlwdG8gc3RvcmUgdG8gYmUgdXNlZCBmb3JcbiAgICAgKiAgIHRoaXMgbWFjaGluZS5cbiAgICAgKiBAcGFyYW0ge1VzZXJJZH0gdXNlcl9pZFxuICAgICAqIEBwYXJhbSB7RGV2aWNlSWR9IGRldmljZV9pZFxuICAgICAqIEBwYXJhbSB7U3RvcmVIYW5kbGV9IHN0b3JlX2hhbmRsZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc3RhdGljIGluaXRGcm9tU3RvcmUodXNlcl9pZCwgZGV2aWNlX2lkLCBzdG9yZV9oYW5kbGUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHVzZXJfaWQsIFVzZXJJZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhkZXZpY2VfaWQsIERldmljZUlkKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHN0b3JlX2hhbmRsZSwgU3RvcmVIYW5kbGUpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfaW5pdEZyb21TdG9yZSh1c2VyX2lkLl9fd2JnX3B0ciwgZGV2aWNlX2lkLl9fd2JnX3B0ciwgc3RvcmVfaGFuZGxlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB1bmlxdWUgdXNlciBJRCB0aGF0IG93bnMgdGhpcyBgT2xtTWFjaGluZWAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge1VzZXJJZH1cbiAgICAgKi9cbiAgICBnZXQgdXNlcklkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfdXNlcklkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFVzZXJJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBkZXZpY2UgSUQgdGhhdCBpZGVudGlmaWVzIHRoaXMgYE9sbU1hY2hpbmVgLlxuICAgICAqIEByZXR1cm5zIHtEZXZpY2VJZH1cbiAgICAgKi9cbiAgICBnZXQgZGV2aWNlSWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9kZXZpY2VJZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBEZXZpY2VJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHRpbWUsIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgdW5peCBlcG9jaCwgYXQgd2hpY2ggdGhlIGBBY2NvdW50YFxuICAgICAqIGJhY2tpbmcgdGhpcyBgT2xtTWFjaGluZWAgd2FzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBBbiBgQWNjb3VudGAgaXMgY3JlYXRlZCB3aGVuIGFuIGBPbG1NYWNoaW5lYCBpcyBmaXJzdCBpbnN0YW50aWF0ZWRcbiAgICAgKiBhZ2FpbnN0IGEgZ2l2ZW4gYFN0b3JlYCwgYXQgd2hpY2ggcG9pbnQgaXQgY3JlYXRlcyBpZGVudGl0eSBrZXlzIGV0Yy5cbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSB0aW1lc3RhbXAsIGFjY29yZGluZyB0byB0aGUgbG9jYWwgY2xvY2ssIGF0XG4gICAgICogd2hpY2ggdGhhdCBoYXBwZW5lZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBkZXZpY2VDcmVhdGlvblRpbWVNcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2RldmljZUNyZWF0aW9uVGltZU1zKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwdWJsaWMgcGFydHMgb2Ygb3VyIE9sbSBpZGVudGl0eSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtJZGVudGl0eUtleXN9XG4gICAgICovXG4gICAgZ2V0IGlkZW50aXR5S2V5cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2lkZW50aXR5S2V5cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBJZGVudGl0eUtleXMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGlzcGxheSBuYW1lIG9mIG91ciBvd24gZGV2aWNlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZ2V0IGRpc3BsYXlOYW1lKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfZGlzcGxheU5hbWUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGF1dG9tYXRpYyB0cmFuc21pc3Npb24gb2Ygcm9vbSBrZXkgcmVxdWVzdHMgaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIFJvb20ga2V5IHJlcXVlc3RzIGFsbG93IHRoZSBkZXZpY2UgdG8gcmVxdWVzdCByb29tIGtleXMgdGhhdCBpdCBtaWdodFxuICAgICAqIGhhdmUgbWlzc2VkIGluIHRoZSBvcmlnaW5hbCBzaGFyZSB1c2luZyBgbS5yb29tX2tleV9yZXF1ZXN0YFxuICAgICAqIGV2ZW50cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgcm9vbUtleVJlcXVlc3RzRW5hYmxlZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX3Jvb21LZXlSZXF1ZXN0c0VuYWJsZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBhdXRvbWF0aWMgdHJhbnNtaXNzaW9uIG9mIHJvb20ga2V5IHJlcXVlc3RzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqL1xuICAgIHNldCByb29tS2V5UmVxdWVzdHNFbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgICAgd2FzbS5vbG1tYWNoaW5lX3NldF9yb29tS2V5UmVxdWVzdHNFbmFibGVkKHRoaXMuX193YmdfcHRyLCBlbmFibGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciByb29tIGtleSBmb3J3YXJkaW5nIGlzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBJZiByb29tIGtleSBmb3J3YXJkaW5nIGlzIGVuYWJsZWQsIHdlIHdpbGwgYXV0b21hdGljYWxseSByZXBseSB0b1xuICAgICAqIGluY29taW5nIGBtLnJvb21fa2V5X3JlcXVlc3RgIG1lc3NhZ2VzIGZyb20gdmVyaWZpZWQgZGV2aWNlcyBieVxuICAgICAqIGZvcndhcmRpbmcgdGhlIHJlcXVlc3RlZCBrZXkgKGlmIHdlIGhhdmUgaXQpLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCByb29tS2V5Rm9yd2FyZGluZ0VuYWJsZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9yb29tS2V5Rm9yd2FyZGluZ0VuYWJsZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSByb29tIGtleSBmb3J3YXJkaW5nLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqL1xuICAgIHNldCByb29tS2V5Rm9yd2FyZGluZ0VuYWJsZWQoZW5hYmxlZCkge1xuICAgICAgICB3YXNtLm9sbW1hY2hpbmVfc2V0X3Jvb21LZXlGb3J3YXJkaW5nRW5hYmxlZCh0aGlzLl9fd2JnX3B0ciwgZW5hYmxlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGlzdCBvZiB1c2VycyB3aG9zZSBkZXZpY2VzIHdlIGFyZSBjdXJyZW50bHkgdHJhY2tpbmcuXG4gICAgICpcbiAgICAgKiBBIHVzZXIgY2FuIGJlIG1hcmtlZCBmb3IgdHJhY2tpbmcgdXNpbmcgdGhlXG4gICAgICogW2B1cGRhdGVfdHJhY2tlZF91c2Vyc2BdKCNtZXRob2QudXBkYXRlX3RyYWNrZWRfdXNlcnMpIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBgU2V0PFVzZXJJZD5gLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgdHJhY2tlZFVzZXJzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfdHJhY2tlZFVzZXJzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBsaXN0IG9mIHRyYWNrZWQgdXNlcnMuXG4gICAgICpcbiAgICAgKiBUaGUgT2xtTWFjaGluZSBtYWludGFpbnMgYSBsaXN0IG9mIHVzZXJzIHdob3NlIGRldmljZXMgd2UgYXJlIGtlZXBpbmdcbiAgICAgKiB0cmFjayBvZjogdGhlc2UgYXJlIGtub3duIGFzIFwidHJhY2tlZCB1c2Vyc1wiLiBUaGVzZSBtdXN0IGJlIHVzZXJzXG4gICAgICogdGhhdCB3ZSBzaGFyZSBhIHJvb20gd2l0aCwgc28gdGhhdCB0aGUgc2VydmVyIHNlbmRzIHVzIHVwZGF0ZXMgZm9yXG4gICAgICogdGhlaXIgZGV2aWNlIGxpc3RzLlxuICAgICAqXG4gICAgICogIyBBcmd1bWVudHNcbiAgICAgKlxuICAgICAqICogYHVzZXJzYCAtIEFuIGFycmF5IG9mIHVzZXIgaWRzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBsaXN0IG9mXG4gICAgICogICB0cmFja2VkIHVzZXJzXG4gICAgICpcbiAgICAgKiBBbnkgdXNlcnMgdGhhdCBoYWRuJ3QgYmVlbiBzZWVuIGJlZm9yZSB3aWxsIGJlIGZsYWdnZWQgZm9yIGEga2V5IHF1ZXJ5XG4gICAgICogaW1tZWRpYXRlbHksIGFuZCB3aGVuZXZlciBgcmVjZWl2ZV9zeW5jX2NoYW5nZXNgIHJlY2VpdmVzIGFcbiAgICAgKiBcImNoYW5nZWRcIiBub3RpZmljYXRpb24gZm9yIHRoYXQgdXNlciBpbiB0aGUgZnV0dXJlLlxuICAgICAqXG4gICAgICogVXNlcnMgdGhhdCB3ZXJlIGFscmVhZHkgaW4gdGhlIGxpc3QgYXJlIHVuYWZmZWN0ZWQuXG4gICAgICpcbiAgICAgKiBJdGVtcyBpbnNpZGUgYHVzZXJzYCB3aWxsIGJlIGludmFsaWRhdGVkIGJ5IHRoaXMgbWV0aG9kLiBCZSBjYXJlZnVsIG5vdFxuICAgICAqIHRvIHVzZSB0aGUgYFVzZXJJZGBzIGFmdGVyIHRoaXMgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0geyhVc2VySWQpW119IHVzZXJzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICB1cGRhdGVUcmFja2VkVXNlcnModXNlcnMpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKHVzZXJzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX3VwZGF0ZVRyYWNrZWRVc2Vycyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmsgYWxsIHRyYWNrZWQgdXNlcnMgYXMgZGlydHkuXG4gICAgICpcbiAgICAgKiBBbGwgdXNlcnMgKndob3NlIGRldmljZSBsaXN0cyB3ZSBhcmUgdHJhY2tpbmcqIGFyZSBmbGFnZ2VkIGFzIG5lZWRpbmcgYVxuICAgICAqIGtleSBxdWVyeS4gVXNlcnMgd2hvc2UgZGV2aWNlcyB3ZSBhcmUgbm90IHRyYWNraW5nIGFyZSBpZ25vcmVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIG1hcmtBbGxUcmFja2VkVXNlcnNBc0RpcnR5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfbWFya0FsbFRyYWNrZWRVc2Vyc0FzRGlydHkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdG8tZGV2aWNlIGV2ZW50cyBhbmQgb25lLXRpbWUga2V5IGNvdW50cyBmcm9tIGEgc3luY1xuICAgICAqIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGRlY3J5cHQgYW5kIGhhbmRsZSB0by1kZXZpY2UgZXZlbnRzIHJldHVybmluZyB0aGVcbiAgICAgKiBkZWNyeXB0ZWQgdmVyc2lvbnMgb2YgdGhlbS5cbiAgICAgKlxuICAgICAqIFRvIGRlY3J5cHQgYW4gZXZlbnQgZnJvbSB0aGUgcm9vbSB0aW1lbGluZSBjYWxsXG4gICAgICogYGRlY3J5cHRfcm9vbV9ldmVudGAuXG4gICAgICpcbiAgICAgKiAjIEFyZ3VtZW50c1xuICAgICAqXG4gICAgICogKiBgdG9fZGV2aWNlX2V2ZW50c2A6IHRoZSBKU09OLWVuY29kZWQgdG8tZGV2aWNlIGV2ZW5zIGZyb20gdGhlIGAvc3luY2BcbiAgICAgKiAgIHJlc3BvbnNlXG4gICAgICogKiBgY2hhbmdlZF9kZXZpY2VzYDogdGhlIG1hcHBpbmcgb2YgY2hhbmdlZCBhbmQgbGVmdCBkZXZpY2VzLCBmcm9tIHRoZVxuICAgICAqICAgYC9zeW5jYCByZXNwb25zZVxuICAgICAqICogYG9uZV90aW1lX2tleXNfY291bnRzYDogVGhlIG51bWJlciBvZiBvbmUtdGltZSBrZXlzIG9uIHRoZSBzZXJ2ZXIsXG4gICAgICogICBmcm9tIHRoZSBgL3N5bmNgIHJlc3BvbnNlLiBBIGBNYXBgIGZyb20gc3RyaW5nIChlbmNyeXB0aW9uIGFsZ29yaXRobSlcbiAgICAgKiAgIHRvIG51bWJlciAobnVtYmVyIG9mIGtleXMpLlxuICAgICAqICogYHVudXNlZF9mYWxsYmFja19rZXlzYDogT3B0aW9uYWxseSwgYSBgU2V0YCBvZiB1bnVzZWQgZmFsbGJhY2sga2V5cyBvblxuICAgICAqICAgdGhlIHNlcnZlciwgZnJvbSB0aGUgYC9zeW5jYCByZXNwb25zZS4gSWYgdGhpcyBpcyBzZXQsIGl0IGlzIHVzZWQgdG9cbiAgICAgKiAgIGRldGVybWluZSBpZiBuZXcgZmFsbGJhY2sga2V5cyBzaG91bGQgYmUgdXBsb2FkZWQuXG4gICAgICpcbiAgICAgKiAjIFJldHVybnNcbiAgICAgKlxuICAgICAqIEEgbGlzdCBvZiBKU09OIHN0cmluZ3MsIGNvbnRhaW5pbmcgdGhlIGRlY3J5cHRlZCB0by1kZXZpY2UgZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b19kZXZpY2VfZXZlbnRzXG4gICAgICogQHBhcmFtIHtEZXZpY2VMaXN0c30gY2hhbmdlZF9kZXZpY2VzXG4gICAgICogQHBhcmFtIHtNYXA8YW55LCBhbnk+fSBvbmVfdGltZV9rZXlzX2NvdW50c1xuICAgICAqIEBwYXJhbSB7U2V0PGFueT4gfCB1bmRlZmluZWR9IFt1bnVzZWRfZmFsbGJhY2tfa2V5c11cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHJlY2VpdmVTeW5jQ2hhbmdlcyh0b19kZXZpY2VfZXZlbnRzLCBjaGFuZ2VkX2RldmljZXMsIG9uZV90aW1lX2tleXNfY291bnRzLCB1bnVzZWRfZmFsbGJhY2tfa2V5cykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAodG9fZGV2aWNlX2V2ZW50cywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoY2hhbmdlZF9kZXZpY2VzLCBEZXZpY2VMaXN0cyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9yZWNlaXZlU3luY0NoYW5nZXModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIGNoYW5nZWRfZGV2aWNlcy5fX3diZ19wdHIsIG9uZV90aW1lX2tleXNfY291bnRzLCBpc0xpa2VOb25lKHVudXNlZF9mYWxsYmFja19rZXlzKSA/IDAgOiBhZGRUb0V4dGVybnJlZlRhYmxlMCh1bnVzZWRfZmFsbGJhY2tfa2V5cykpO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG91dGdvaW5nIHJlcXVlc3RzIHRoYXQgbmVlZCB0byBiZSBzZW50IG91dC5cbiAgICAgKlxuICAgICAqIFRoaXMgcmV0dXJucyBhIGxpc3Qgb2YgdmFsdWVzLCBlYWNoIG9mIHdoaWNoIGNhbiBiZSBhbnkgb2Y6XG4gICAgICogICAqIHtAbGluayBLZXlzVXBsb2FkUmVxdWVzdH0sXG4gICAgICogICAqIHtAbGluayBLZXlzUXVlcnlSZXF1ZXN0fSxcbiAgICAgKiAgICoge0BsaW5rIEtleXNDbGFpbVJlcXVlc3R9LFxuICAgICAqICAgKiB7QGxpbmsgVG9EZXZpY2VSZXF1ZXN0fSxcbiAgICAgKiAgICoge0BsaW5rIFNpZ25hdHVyZVVwbG9hZFJlcXVlc3R9LFxuICAgICAqICAgKiB7QGxpbmsgUm9vbU1lc3NhZ2VSZXF1ZXN0fSwgb3JcbiAgICAgKiAgICoge0BsaW5rIEtleXNCYWNrdXBSZXF1ZXN0fS5cbiAgICAgKlxuICAgICAqIFRob3NlIHJlcXVlc3RzIG5lZWQgdG8gYmUgc2VudCBvdXQgdG8gdGhlIHNlcnZlciBhbmQgdGhlXG4gICAgICogcmVzcG9uc2VzIG5lZWQgdG8gYmUgcGFzc2VkIGJhY2sgdG8gdGhlIHN0YXRlIG1hY2hpbmVcbiAgICAgKiB1c2luZyB7QGxpbmsgT2xtTWFjaGluZS5tYXJrUmVxdWVzdEFzU2VudH0uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBvdXRnb2luZ1JlcXVlc3RzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfb3V0Z29pbmdSZXF1ZXN0cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmsgdGhlIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gcmVxdWVzdCBJRCBhcyBzZW50IChzZWVcbiAgICAgKiBgb3V0Z29pbmdfcmVxdWVzdHNgKS5cbiAgICAgKlxuICAgICAqIEFyZ3VtZW50cyBhcmU6XG4gICAgICpcbiAgICAgKiAqIGByZXF1ZXN0X2lkYCByZXByZXNlbnRzIHRoZSB1bmlxdWUgSUQgb2YgdGhlIHJlcXVlc3QgdGhhdCB3YXMgc2VudFxuICAgICAqICAgb3V0LiBUaGlzIGlzIG5lZWRlZCB0byBjb3VwbGUgdGhlIHJlc3BvbnNlIHdpdGggdGhlIG5vdyBzZW50IG91dFxuICAgICAqICAgcmVxdWVzdC5cbiAgICAgKiAqIGByZXNwb25zZV90eXBlYCByZXByZXNlbnRzIHRoZSB0eXBlIG9mIHRoZSByZXF1ZXN0IHRoYXQgd2FzIHNlbnQgb3V0LlxuICAgICAqICogYHJlc3BvbnNlYCByZXByZXNlbnRzIHRoZSByZXNwb25zZSB0aGF0IHdhcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKiAgIGFmdGVyIHRoZSBvdXRnb2luZyByZXF1ZXN0IHdhcyBzZW50IG91dC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdF9pZFxuICAgICAqIEBwYXJhbSB7UmVxdWVzdFR5cGV9IHJlcXVlc3RfdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgbWFya1JlcXVlc3RBc1NlbnQocmVxdWVzdF9pZCwgcmVxdWVzdF90eXBlLCByZXNwb25zZSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmVxdWVzdF9pZCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAocmVzcG9uc2UsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX21hcmtSZXF1ZXN0QXNTZW50KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCByZXF1ZXN0X3R5cGUsIHB0cjEsIGxlbjEpO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNyeXB0IGEgcm9vbSBtZXNzYWdlIGZvciB0aGUgZ2l2ZW4gcm9vbS5cbiAgICAgKlxuICAgICAqICoqTm90ZSoqOiBBIHJvb20ga2V5IG5lZWRzIHRvIGJlIHNoYXJlZCB3aXRoIHRoZSBncm91cCBvZiB1c2VycyB0aGF0IGFyZVxuICAgICAqIG1lbWJlcnMgaW4gdGhlIGdpdmVuIHJvb20uIElmIHRoaXMgaXMgbm90IGRvbmUgdGhpcyBtZXRob2Qgd2lsbCBwYW5pYy5cbiAgICAgKlxuICAgICAqIFRoZSB1c3VhbCBmbG93IHRvIGVuY3J5cHQgYW4gZXZlbnQgdXNpbmcgdGhpcyBzdGF0ZSBtYWNoaW5lIGlzIGFzXG4gICAgICogZm9sbG93czpcbiAgICAgKlxuICAgICAqIDEuIEdldCB0aGUgb25lLXRpbWUga2V5IGNsYWltIHJlcXVlc3QgdG8gZXN0YWJsaXNoIDE6MSBPbG0gc2Vzc2lvbnMgZm9yXG4gICAgICogICAgdGhlIHJvb20gbWVtYmVycyBvZiB0aGUgcm9vbSB3ZSB3aXNoIHRvIHBhcnRpY2lwYXRlIGluLiBUaGlzIGlzIGRvbmVcbiAgICAgKiAgICB1c2luZyB0aGUgW2BnZXRfbWlzc2luZ19zZXNzaW9ucygpYF0oU2VsZjo6Z2V0X21pc3Npbmdfc2Vzc2lvbnMpXG4gICAgICogICAgbWV0aG9kLiBUaGlzIG1ldGhvZCBjYWxsIHNob3VsZCBiZSBsb2NrZWQgcGVyIGNhbGwuXG4gICAgICpcbiAgICAgKiAyLiBTaGFyZSBhIHJvb20ga2V5IHdpdGggYWxsIHRoZSByb29tIG1lbWJlcnMgdXNpbmcgdGhlXG4gICAgICogICAgW2BzaGFyZV9yb29tX2tleSgpYF0oU2VsZjo6c2hhcmVfcm9vbV9rZXkpLiBUaGlzIG1ldGhvZCBjYWxsIHNob3VsZFxuICAgICAqICAgIGJlIGxvY2tlZCBwZXIgcm9vbS5cbiAgICAgKlxuICAgICAqIDMuIEVuY3J5cHQgdGhlIGV2ZW50IHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogNC4gU2VuZCB0aGUgZW5jcnlwdGVkIGV2ZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBBZnRlciB0aGUgcm9vbSBrZXkgaXMgc2hhcmVkIHN0ZXBzIDEgYW5kIDIgd2lsbCBiZWNvbWUgbm9vcHMsIHVubGVzc1xuICAgICAqIHRoZXJlJ3Mgc29tZSBjaGFuZ2VzIGluIHRoZSByb29tIG1lbWJlcnNoaXAgb3IgaW4gdGhlIGxpc3Qgb2YgZGV2aWNlcyBhXG4gICAgICogbWVtYmVyIGhhcy5cbiAgICAgKlxuICAgICAqXG4gICAgICogYHJvb21faWRgIGlzIHRoZSBJRCBvZiB0aGUgcm9vbSBmb3Igd2hpY2ggdGhlIG1lc3NhZ2Ugc2hvdWxkXG4gICAgICogYmUgZW5jcnlwdGVkLiBgZXZlbnRfdHlwZWAgaXMgdGhlIHR5cGUgb2YgdGhlIGV2ZW50LiBgY29udGVudGBcbiAgICAgKiBpcyB0aGUgcGxhaW50ZXh0IGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2UgdGhhdCBzaG91bGQgYmVcbiAgICAgKiBlbmNyeXB0ZWQuXG4gICAgICpcbiAgICAgKiAjIFBhbmljc1xuICAgICAqXG4gICAgICogUGFuaWNzIGlmIGEgZ3JvdXAgc2Vzc2lvbiBmb3IgdGhlIGdpdmVuIHJvb20gd2Fzbid0IHNoYXJlZFxuICAgICAqIGJlZm9yZWhhbmQuXG4gICAgICogQHBhcmFtIHtSb29tSWR9IHJvb21faWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBlbmNyeXB0Um9vbUV2ZW50KHJvb21faWQsIGV2ZW50X3R5cGUsIGNvbnRlbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHJvb21faWQsIFJvb21JZCk7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChldmVudF90eXBlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChjb250ZW50LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9lbmNyeXB0Um9vbUV2ZW50KHRoaXMuX193YmdfcHRyLCByb29tX2lkLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY3J5cHQgYW4gZXZlbnQgZnJvbSBhIHJvb20gdGltZWxpbmUuXG4gICAgICpcbiAgICAgKiAjIEFyZ3VtZW50c1xuICAgICAqXG4gICAgICogKiBgZXZlbnRgLCB0aGUgZXZlbnQgdGhhdCBzaG91bGQgYmUgZGVjcnlwdGVkLlxuICAgICAqICogYHJvb21faWRgLCB0aGUgSUQgb2YgdGhlIHJvb20gd2hlcmUgdGhlIGV2ZW50IHdhcyBzZW50IHRvLlxuICAgICAqXG4gICAgICogIyBSZXR1cm5zXG4gICAgICpcbiAgICAgKiBBIGBQcm9taXNlYCB3aGljaCByZXNvbHZlcyB0byBhIHtAbGluayBEZWNyeXB0ZWRSb29tRXZlbnR9IGluc3RhbmNlLCBvclxuICAgICAqIHJlamVjdHMgd2l0aCBhIHtAbGluayBNZWdvbG1EZWNyeXB0aW9uRXJyb3J9IGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7Um9vbUlkfSByb29tX2lkXG4gICAgICogQHBhcmFtIHtEZWNyeXB0aW9uU2V0dGluZ3N9IGRlY3J5cHRpb25fc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGRlY3J5cHRSb29tRXZlbnQoZXZlbnQsIHJvb21faWQsIGRlY3J5cHRpb25fc2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGV2ZW50LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIF9hc3NlcnRDbGFzcyhyb29tX2lkLCBSb29tSWQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZGVjcnlwdGlvbl9zZXR0aW5ncywgRGVjcnlwdGlvblNldHRpbmdzKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2RlY3J5cHRSb29tRXZlbnQodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHJvb21faWQuX193YmdfcHRyLCBkZWNyeXB0aW9uX3NldHRpbmdzLl9fd2JnX3B0cik7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbmNyeXB0aW9uIGluZm8gZm9yIGEgZGVjcnlwdGVkIHRpbWVsaW5lIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhpcyByZWNhbGN1bGF0ZXMgdGhlIGBFbmNyeXB0aW9uSW5mb2AgZGF0YSB0aGF0IGlzIHJldHVybmVkIGJ5XG4gICAgICogYGRlY3J5cHRSb29tRXZlbnRgLCBiYXNlZCBvbiB0aGUgY3VycmVudFxuICAgICAqIHZlcmlmaWNhdGlvbiBzdGF0dXMgb2YgdGhlIHNlbmRlciwgZXRjLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhbiBlcnJvciBmb3IgYW4gdW5lbmNyeXB0ZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiAjIEFyZ3VtZW50c1xuICAgICAqXG4gICAgICogKiBgZXZlbnRgIC0gVGhlIGV2ZW50IHRvIGdldCBpbmZvcm1hdGlvbiBmb3IuXG4gICAgICogKiBgcm9vbV9pZGAgLSBUaGUgSUQgb2YgdGhlIHJvb20gd2hlcmUgdGhlIGV2ZW50IHdhcyBzZW50IHRvLlxuICAgICAqXG4gICAgICogIyBSZXR1cm5zXG4gICAgICpcbiAgICAgKiB7QGxpbmsgRW5jcnlwdGlvbkluZm99XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtIHtSb29tSWR9IHJvb21faWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGdldFJvb21FdmVudEVuY3J5cHRpb25JbmZvKGV2ZW50LCByb29tX2lkKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChldmVudCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mocm9vbV9pZCwgUm9vbUlkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2dldFJvb21FdmVudEVuY3J5cHRpb25JbmZvKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCByb29tX2lkLl9fd2JnX3B0cik7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhdHVzIG9mIHRoZSBwcml2YXRlIGNyb3NzIHNpZ25pbmcga2V5cy5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2hlY2sgd2hpY2ggcHJpdmF0ZSBjcm9zcyBzaWduaW5nIGtleXMgd2VcbiAgICAgKiBoYXZlIHN0b3JlZCBsb2NhbGx5LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgY3Jvc3NTaWduaW5nU3RhdHVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfY3Jvc3NTaWduaW5nU3RhdHVzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0IGFsbCB0aGUgc2VjcmV0cyB3ZSBoYXZlIGluIHRoZSBzdG9yZSBpbnRvIGEge0BsaW5rXG4gICAgICogU2VjcmV0c0J1bmRsZX0uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGV4cG9ydCBhbGwgdGhlIHByaXZhdGUgY3Jvc3Mtc2lnbmluZyBrZXlzIGFuZCwgaWZcbiAgICAgKiBhdmFpbGFibGUsIHRoZSBwcml2YXRlIHBhcnQgb2YgYSBiYWNrdXAga2V5IGFuZCBpdHMgYWNjb21wYW55aW5nXG4gICAgICogdmVyc2lvbi5cbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2Qgd2lsbCBmYWlsIGlmIHdlIGRvbid0IGhhdmUgYWxsIHRocmVlIHByaXZhdGUgY3Jvc3Mtc2lnbmluZ1xuICAgICAqIGtleXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogKipXYXJuaW5nKio6IE9ubHkgZXhwb3J0IHRoaXMgYW5kIHNoYXJlIGl0IHdpdGggYSB0cnVzdGVkIHJlY2lwaWVudCxcbiAgICAgKiBpLmUuIGlmIGFuIGV4aXN0aW5nIGRldmljZSBpcyBzaGFyaW5nIHRoaXMgd2l0aCBhIG5ldyBkZXZpY2UuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2VjcmV0c0J1bmRsZT59XG4gICAgICovXG4gICAgZXhwb3J0U2VjcmV0c0J1bmRsZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2V4cG9ydFNlY3JldHNCdW5kbGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBvcnQgYW5kIHBlcnNpc3RzIHNlY3JldHMgZnJvbSBhIHtAbGluayBTZWNyZXRzQnVuZGxlfS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgaW1wb3J0IGFsbCB0aGUgcHJpdmF0ZSBjcm9zcy1zaWduaW5nIGtleXMgYW5kLCBpZlxuICAgICAqIGF2YWlsYWJsZSwgdGhlIHByaXZhdGUgcGFydCBvZiBhIGJhY2t1cCBrZXkgYW5kIGl0cyBhY2NvbXBhbnlpbmdcbiAgICAgKiB2ZXJzaW9uIGludG8gdGhlIHN0b3JlLlxuICAgICAqXG4gICAgICogKipXYXJuaW5nKio6IE9ubHkgaW1wb3J0IHRoaXMgZnJvbSBhIHRydXN0ZWQgc291cmNlLCBpLmUuIGlmIGFuIGV4aXN0aW5nXG4gICAgICogZGV2aWNlIGlzIHNoYXJpbmcgdGhpcyB3aXRoIGEgbmV3IGRldmljZS4gVGhlIGltcG9ydGVkIGNyb3NzLXNpZ25pbmdcbiAgICAgKiBrZXlzIHdpbGwgY3JlYXRlIGEge0BsaW5rIE93blVzZXJJZGVudGl0eX0gYW5kIG1hcmsgaXQgYXMgdmVyaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYmFja3VwIGtleSB3aWxsIGJlIHBlcnNpc3RlZCBpbiB0aGUgc3RvcmUgYW5kIGNhbiBiZSBlbmFibGVkIHVzaW5nXG4gICAgICogdGhlIHtAbGluayBCYWNrdXBNYWNoaW5lfS5cbiAgICAgKlxuICAgICAqIFRoZSBwcm92aWRlZCBgU2VjcmV0c0J1bmRsZWAgaXMgZnJlZWQgYnkgdGhpcyBtZXRob2Q7IGJlIGNhcmVmdWwgbm90IHRvXG4gICAgICogdXNlIGl0IG9uY2UgdGhpcyBtZXRob2QgaGFzIGJlZW4gY2FsbGVkLlxuICAgICAqIEBwYXJhbSB7U2VjcmV0c0J1bmRsZX0gYnVuZGxlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgaW1wb3J0U2VjcmV0c0J1bmRsZShidW5kbGUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGJ1bmRsZSwgU2VjcmV0c0J1bmRsZSk7XG4gICAgICAgIHZhciBwdHIwID0gYnVuZGxlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfaW1wb3J0U2VjcmV0c0J1bmRsZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydCBhbGwgdGhlIHByaXZhdGUgY3Jvc3Mgc2lnbmluZyBrZXlzIHdlIGhhdmUuXG4gICAgICpcbiAgICAgKiBUaGUgZXhwb3J0IHdpbGwgY29udGFpbiB0aGUgc2VlZHMgZm9yIHRoZSBlZDI1NTE5IGtleXMgYXNcbiAgICAgKiB1bnBhZGRlZCBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgbnVsbGAgaWYgd2UgZG9u4oCZdCBoYXZlIGFueSBwcml2YXRlIGNyb3NzIHNpZ25pbmcga2V5cztcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBhIGBDcm9zc1NpZ25pbmdLZXlFeHBvcnRgLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZXhwb3J0Q3Jvc3NTaWduaW5nS2V5cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2V4cG9ydENyb3NzU2lnbmluZ0tleXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBvcnQgb3VyIHByaXZhdGUgY3Jvc3Mgc2lnbmluZyBrZXlzLlxuICAgICAqXG4gICAgICogVGhlIGtleXMgc2hvdWxkIGJlIHByb3ZpZGVkIGFzIHVucGFkZGVkLWJhc2U2NC1lbmNvZGVkIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgYENyb3NzU2lnbmluZ1N0YXR1c2AuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFttYXN0ZXJfa2V5XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbc2VsZl9zaWduaW5nX2tleV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW3VzZXJfc2lnbmluZ19rZXldXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBpbXBvcnRDcm9zc1NpZ25pbmdLZXlzKG1hc3Rlcl9rZXksIHNlbGZfc2lnbmluZ19rZXksIHVzZXJfc2lnbmluZ19rZXkpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKG1hc3Rlcl9rZXkpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKG1hc3Rlcl9rZXksIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShzZWxmX3NpZ25pbmdfa2V5KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChzZWxmX3NpZ25pbmdfa2V5LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMiA9IGlzTGlrZU5vbmUodXNlcl9zaWduaW5nX2tleSkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAodXNlcl9zaWduaW5nX2tleSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2ltcG9ydENyb3NzU2lnbmluZ0tleXModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHB0cjIsIGxlbjIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgY3Jvc3Mgc2lnbmluZyBpZGVudGl0eSBhbmQgZ2V0IHRoZSB1cGxvYWQgcmVxdWVzdFxuICAgICAqIHRvIHB1c2ggdGhlIG5ldyBwdWJsaWMga2V5cyB0byB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogV2FybmluZzogVGhpcyB3aWxsIGRlbGV0ZSBhbnkgZXhpc3RpbmcgY3Jvc3Mgc2lnbmluZyBrZXlzIHRoYXRcbiAgICAgKiBtaWdodCBleGlzdCBvbiB0aGUgc2VydmVyIGFuZCB0aHVzIHdpbGwgcmVzZXQgdGhlIHRydXN0XG4gICAgICogYmV0d2VlbiBhbGwgdGhlIGRldmljZXMuXG4gICAgICpcbiAgICAgKiBVcGxvYWRpbmcgdGhlc2Uga2V5cyB3aWxsIHJlcXVpcmUgdXNlciBpbnRlcmFjdGl2ZSBhdXRoLlxuICAgICAqXG4gICAgICogIyBBcmd1bWVudHNcbiAgICAgKlxuICAgICAqICogYHJlc2V0YCwgd2hldGhlciB0aGUgbWV0aG9kIHNob3VsZCBjcmVhdGUgYSBuZXcgaWRlbnRpdHkgb3IgdXNlIHRoZVxuICAgICAqICAgZXhpc3Rpbmcgb25lIGR1cmluZyB0aGUgcmVxdWVzdC4gSWYgc2V0IHRvIHRydWUsIHRoZSByZXF1ZXN0IHdpbGxcbiAgICAgKiAgIGF0dGVtcHQgdG8gdXBsb2FkIGEgbmV3IGlkZW50aXR5LiBJZiBzZXQgdG8gZmFsc2UsIHRoZSByZXF1ZXN0IHdpbGxcbiAgICAgKiAgIGF0dGVtcHQgdG8gdXBsb2FkIHRoZSBleGlzdGluZyBpZGVudGl0eS4gU2luY2UgdGhlIHVwbG9hZGluZyBwcm9jZXNzXG4gICAgICogICByZXF1aXJlcyB1c2VyIGludGVyYWN0aXZlIGF1dGhlbnRpY2F0aW9uLCB3aGljaCBpbnZvbHZlcyBzZW5kaW5nIG91dFxuICAgICAqICAgdGhlIHNhbWUgcmVxdWVzdCBtdWx0aXBsZSB0aW1lcywgc2V0dGluZyB0aGlzIGFyZ3VtZW50IHRvIGZhbHNlXG4gICAgICogICBlbmFibGVzIHlvdSB0byByZXVzZSB0aGUgc2FtZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBDcm9zc1NpZ25pbmdCb290c3RyYXBSZXF1ZXN0c30uXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXNldFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYm9vdHN0cmFwQ3Jvc3NTaWduaW5nKHJlc2V0KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9ib290c3RyYXBDcm9zc1NpZ25pbmcodGhpcy5fX3diZ19wdHIsIHJlc2V0KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjcm9zcyBzaWduaW5nIHVzZXIgaWRlbnRpdHkgb2YgYSB1c2VyLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgZm9yIGFuIHtAbGluayBpZGVudGl0aWVzLk93blVzZXJJZGVudGl0eX0sIGFcbiAgICAgKiB7QGxpbmsgaWRlbnRpdGllcy5PdGhlclVzZXJJZGVudGl0eX0sIG9yIGB1bmRlZmluZWRgLlxuICAgICAqIEBwYXJhbSB7VXNlcklkfSB1c2VyX2lkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBnZXRJZGVudGl0eSh1c2VyX2lkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh1c2VyX2lkLCBVc2VySWQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfZ2V0SWRlbnRpdHkodGhpcy5fX3diZ19wdHIsIHVzZXJfaWQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbiB0aGUgZ2l2ZW4gbWVzc2FnZSB1c2luZyBvdXIgZGV2aWNlIGtleSBhbmQgaWYgYXZhaWxhYmxlXG4gICAgICogY3Jvc3Mtc2lnbmluZyBtYXN0ZXIga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBzaWduKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKG1lc3NhZ2UsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX3NpZ24odGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIHRoZSBjdXJyZW50bHkgYWN0aXZlIG91dGJvdW5kIGdyb3VwIHNlc3Npb24gZm9yIHRoZVxuICAgICAqIGdpdmVuIHJvb20uXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYSBzZXNzaW9uIHdhcyBpbnZhbGlkYXRlZCwgZmFsc2UgaWYgdGhlcmUgd2FzXG4gICAgICogbm8gc2Vzc2lvbiB0byBpbnZhbGlkYXRlLlxuICAgICAqIEBwYXJhbSB7Um9vbUlkfSByb29tX2lkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBpbnZhbGlkYXRlR3JvdXBTZXNzaW9uKHJvb21faWQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHJvb21faWQsIFJvb21JZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9pbnZhbGlkYXRlR3JvdXBTZXNzaW9uKHRoaXMuX193YmdfcHRyLCByb29tX2lkLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0by1kZXZpY2UgcmVxdWVzdHMgdG8gc2hhcmUgYSByb29tIGtleSB3aXRoIHVzZXJzIGluIGEgcm9vbS5cbiAgICAgKlxuICAgICAqIGByb29tX2lkYCBpcyB0aGUgcm9vbSBJRC4gYHVzZXJzYCBpcyBhbiBhcnJheSBvZiBgVXNlcklkYFxuICAgICAqIG9iamVjdHMuIGBlbmNyeXB0aW9uX3NldHRpbmdzYCBhcmUgYW4gYEVuY3J5cHRpb25TZXR0aW5nc2BcbiAgICAgKiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBOb3RlOiBDYXJlIHNob3VsZCBiZSB0YWtlbiB0aGF0IG9ubHkgb25lIHN1Y2ggcmVxdWVzdCBhdCBhXG4gICAgICogdGltZSBpcyBpbiBmbGlnaHQgZm9yIHRoZSBzYW1lIHJvb20sIGUuZy4gdXNpbmcgYSBsb2NrLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBgVG9EZXZpY2VSZXF1ZXN0YHMuXG4gICAgICpcbiAgICAgKiBJdGVtcyBpbnNpZGUgYHVzZXJzYCB3aWxsIGJlIGludmFsaWRhdGVkIGJ5IHRoaXMgbWV0aG9kLiBCZSBjYXJlZnVsIG5vdFxuICAgICAqIHRvIHVzZSB0aGUgYFVzZXJJZGBzIGFmdGVyIHRoaXMgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0ge1Jvb21JZH0gcm9vbV9pZFxuICAgICAqIEBwYXJhbSB7KFVzZXJJZClbXX0gdXNlcnNcbiAgICAgKiBAcGFyYW0ge0VuY3J5cHRpb25TZXR0aW5nc30gZW5jcnlwdGlvbl9zZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc2hhcmVSb29tS2V5KHJvb21faWQsIHVzZXJzLCBlbmNyeXB0aW9uX3NldHRpbmdzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhyb29tX2lkLCBSb29tSWQpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAodXNlcnMsIHdhc20uX193YmluZGdlbl9tYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZW5jcnlwdGlvbl9zZXR0aW5ncywgRW5jcnlwdGlvblNldHRpbmdzKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX3NoYXJlUm9vbUtleSh0aGlzLl9fd2JnX3B0ciwgcm9vbV9pZC5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIGVuY3J5cHRpb25fc2V0dGluZ3MuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gXCJvdXQtb2YtYmFuZFwiIGtleSBxdWVyeSByZXF1ZXN0IGZvciB0aGUgZ2l2ZW4gc2V0IG9mIHVzZXJzLlxuICAgICAqXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGlmIHdlIG5lZWQgdGhlIHJlc3VsdHMgZnJvbSBgZ2V0SWRlbnRpdHlgIG9yXG4gICAgICogYGdldFVzZXJEZXZpY2VzYCB0byBiZSBhcyB1cC10by1kYXRlIGFzIHBvc3NpYmxlLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIGBLZXlzUXVlcnlSZXF1ZXN0YCBvYmplY3QuIFRoZSByZXNwb25zZSBvZiB0aGUgcmVxdWVzdCBzaG91bGRcbiAgICAgKiBiZSBwYXNzZWQgdG8gdGhlIGBPbG1NYWNoaW5lYCB3aXRoIHRoZSBgbWFya19yZXF1ZXN0X2FzX3NlbnRgLlxuICAgICAqXG4gICAgICogSXRlbXMgaW5zaWRlIGB1c2Vyc2Agd2lsbCBiZSBpbnZhbGlkYXRlZCBieSB0aGlzIG1ldGhvZC4gQmUgY2FyZWZ1bCBub3RcbiAgICAgKiB0byB1c2UgdGhlIGBVc2VySWRgcyBhZnRlciB0aGlzIG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICogQHBhcmFtIHsoVXNlcklkKVtdfSB1c2Vyc1xuICAgICAqIEByZXR1cm5zIHtLZXlzUXVlcnlSZXF1ZXN0fVxuICAgICAqL1xuICAgIHF1ZXJ5S2V5c0ZvclVzZXJzKHVzZXJzKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMCh1c2Vycywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9xdWVyeUtleXNGb3JVc2Vycyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEtleXNRdWVyeVJlcXVlc3QuX193cmFwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYSBrZXkgY2xhaW1pbmcgcmVxdWVzdCBmb3IgdGhlIHVzZXIvZGV2aWNlIHBhaXJzIHRoYXRcbiAgICAgKiB3ZSBhcmUgbWlzc2luZyBPbG0gc2Vzc2lvbnMgZm9yLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgbnVsbGAgaWYgbm8ga2V5IGNsYWltaW5nIHJlcXVlc3QgbmVlZHMgdG8gYmUgc2VudFxuICAgICAqIG91dCwgb3RoZXJ3aXNlIGl0IHJldHVybnMgYSBgS2V5c0NsYWltUmVxdWVzdGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2Vzc2lvbnMgbmVlZCB0byBiZSBlc3RhYmxpc2hlZCBiZXR3ZWVuIGRldmljZXMgc28gZ3JvdXBcbiAgICAgKiBzZXNzaW9ucyBmb3IgYSByb29tIGNhbiBiZSBzaGFyZWQgd2l0aCB0aGVtLlxuICAgICAqXG4gICAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBncm91cCBzZXNzaW9uIG5lZWRzIHRvIGJlXG4gICAgICogc2hhcmVkIGFzIHdlbGwgYXMgYmV0d2VlbiBzeW5jIGNhbGxzLiBBZnRlciBhIHN5bmMgc29tZVxuICAgICAqIGRldmljZXMgbWF5IHJlcXVlc3Qgcm9vbSBrZXlzIHdpdGhvdXQgdXMgaGF2aW5nIGEgdmFsaWQgT2xtXG4gICAgICogc2Vzc2lvbiB3aXRoIHRoZW0sIG1ha2luZyBpdCBpbXBvc3NpYmxlIHRvIHNlcnZlciB0aGUgcm9vbSBrZXlcbiAgICAgKiByZXF1ZXN0LCB0aHVzIGl04oCZcyBuZWNlc3NhcnkgdG8gY2hlY2sgZm9yIG1pc3Npbmcgc2Vzc2lvbnNcbiAgICAgKiBiZXR3ZWVuIHN5bmMgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IENhcmUgc2hvdWxkIGJlIHRha2VuIHRoYXQgb25seSBvbmUgc3VjaCByZXF1ZXN0IGF0IGFcbiAgICAgKiB0aW1lIGlzIGluIGZsaWdodCwgZS5nLiB1c2luZyBhIGxvY2suXG4gICAgICpcbiAgICAgKiBUaGUgcmVzcG9uc2Ugb2YgYSBzdWNjZXNzZnVsIGtleSBjbGFpbWluZyByZXF1ZXN0cyBuZWVkcyB0byBiZVxuICAgICAqIHBhc3NlZCB0byB0aGUgYE9sbU1hY2hpbmVgIHdpdGggdGhlIGBtYXJrX3JlcXVlc3RfYXNfc2VudGAuXG4gICAgICpcbiAgICAgKiBgdXNlcnNgIHJlcHJlc2VudHMgdGhlIGxpc3Qgb2YgdXNlcnMgdGhhdCB3ZSBzaG91bGQgY2hlY2sgaWZcbiAgICAgKiB3ZSBsYWNrIGEgc2Vzc2lvbiB3aXRoIG9uZSBvZiB0aGVpciBkZXZpY2VzLiBUaGlzIGNhbiBiZSBhblxuICAgICAqIGVtcHR5IGl0ZXJhdG9yIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBiZXR3ZWVuIHN5bmMgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiBJdGVtcyBpbnNpZGUgYHVzZXJzYCB3aWxsIGJlIGludmFsaWRhdGVkIGJ5IHRoaXMgbWV0aG9kLiBCZSBjYXJlZnVsIG5vdFxuICAgICAqIHRvIHVzZSB0aGUgYFVzZXJJZGBzIGFmdGVyIHRoaXMgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0geyhVc2VySWQpW119IHVzZXJzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBnZXRNaXNzaW5nU2Vzc2lvbnModXNlcnMpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKHVzZXJzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2dldE1pc3NpbmdTZXNzaW9ucyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIG1hcCBob2xkaW5nIGFsbCB0aGUgZGV2aWNlcyBvZiBhIHVzZXIuXG4gICAgICpcbiAgICAgKiAjIyMgUGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogKiBgdXNlcl9pZGAgLSBUaGUgdW5pcXVlIElEIG9mIHRoZSB1c2VyIHRoYXQgdGhlIGRldmljZSBiZWxvbmdzIHRvLlxuICAgICAqXG4gICAgICogKiBgdGltZW91dF9zZWNzYCAtIFRoZSBhbW91bnQgb2YgdGltZSB3ZSBzaG91bGQgd2FpdCBmb3IgYSBgL2tleXMvcXVlcnlgXG4gICAgICogICByZXNwb25zZSBiZWZvcmUgcmV0dXJuaW5nIGlmIHRoZSB1c2VyJ3MgZGV2aWNlIGxpc3QgaGFzIGJlZW4gbWFya2VkIGFzXG4gICAgICogICBzdGFsZS4gKipOb3RlKiosIHRoaXMgYXNzdW1lcyB0aGF0IHRoZSByZXF1ZXN0cyBmcm9tIHtAbGlua1xuICAgICAqICAgT2xtTWFjaGluZS5vdXRnb2luZ1JlcXVlc3RzfSBhcmUgYmVpbmcgcHJvY2Vzc2VkIGFuZCBzZW50IG91dC5cbiAgICAgKlxuICAgICAqICAgSWYgdW5zZXQsIHdlIHdpbGwgcmV0dXJuIGltbWVkaWF0ZWx5IGV2ZW4gaWYgdGhlIGRldmljZSBsaXN0IGlzIHN0YWxlLlxuICAgICAqXG4gICAgICogIyMjIFJldHVybnNcbiAgICAgKlxuICAgICAqIEEge0BsaW5rIFVzZXJEZXZpY2VzfSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtVc2VySWR9IHVzZXJfaWRcbiAgICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gW3RpbWVvdXRfc2Vjc11cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGdldFVzZXJEZXZpY2VzKHVzZXJfaWQsIHRpbWVvdXRfc2Vjcykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3ModXNlcl9pZCwgVXNlcklkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2dldFVzZXJEZXZpY2VzKHRoaXMuX193YmdfcHRyLCB1c2VyX2lkLl9fd2JnX3B0ciwgIWlzTGlrZU5vbmUodGltZW91dF9zZWNzKSwgaXNMaWtlTm9uZSh0aW1lb3V0X3NlY3MpID8gMCA6IHRpbWVvdXRfc2Vjcyk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHNwZWNpZmljIGRldmljZSBvZiBhIHVzZXIuXG4gICAgICpcbiAgICAgKiAjIyMgUGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogKiBgdXNlcl9pZGAgLSBUaGUgdW5pcXVlIElEIG9mIHRoZSB1c2VyIHRoYXQgdGhlIGRldmljZSBiZWxvbmdzIHRvLlxuICAgICAqXG4gICAgICogKiBgZGV2aWNlX2lkYCAtIFRoZSB1bmlxdWUgSUQgb2YgdGhlIGRldmljZS5cbiAgICAgKlxuICAgICAqICogYHRpbWVvdXRfc2Vjc2AgLSBUaGUgYW1vdW50IG9mIHRpbWUgd2Ugc2hvdWxkIHdhaXQgZm9yIGEgYC9rZXlzL3F1ZXJ5YFxuICAgICAqICAgcmVzcG9uc2UgYmVmb3JlIHJldHVybmluZyBpZiB0aGUgdXNlcidzIGRldmljZSBsaXN0IGhhcyBiZWVuIG1hcmtlZCBhc1xuICAgICAqICAgc3RhbGUuICoqTm90ZSoqLCB0aGlzIGFzc3VtZXMgdGhhdCB0aGUgcmVxdWVzdHMgZnJvbSB7QGxpbmtcbiAgICAgKiAgIE9sbU1hY2hpbmUub3V0Z29pbmdSZXF1ZXN0c30gYXJlIGJlaW5nIHByb2Nlc3NlZCBhbmQgc2VudCBvdXQuXG4gICAgICpcbiAgICAgKiAgIElmIHVuc2V0LCB3ZSB3aWxsIHJldHVybiBpbW1lZGlhdGVseSBldmVuIGlmIHRoZSBkZXZpY2UgbGlzdCBpcyBzdGFsZS5cbiAgICAgKlxuICAgICAqICMjIyBSZXR1cm5zXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZGV2aWNlIGlzIGtub3duLCBhIHtAbGluayBEZXZpY2V9LiBPdGhlcndpc2UsIGB1bmRlZmluZWRgLlxuICAgICAqIEBwYXJhbSB7VXNlcklkfSB1c2VyX2lkXG4gICAgICogQHBhcmFtIHtEZXZpY2VJZH0gZGV2aWNlX2lkXG4gICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IFt0aW1lb3V0X3NlY3NdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBnZXREZXZpY2UodXNlcl9pZCwgZGV2aWNlX2lkLCB0aW1lb3V0X3NlY3MpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHVzZXJfaWQsIFVzZXJJZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhkZXZpY2VfaWQsIERldmljZUlkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2dldERldmljZSh0aGlzLl9fd2JnX3B0ciwgdXNlcl9pZC5fX3diZ19wdHIsIGRldmljZV9pZC5fX3diZ19wdHIsICFpc0xpa2VOb25lKHRpbWVvdXRfc2VjcyksIGlzTGlrZU5vbmUodGltZW91dF9zZWNzKSA/IDAgOiB0aW1lb3V0X3NlY3MpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSB2ZXJpZmljYXRpb24gb2JqZWN0IGZvciB0aGUgZ2l2ZW4gdXNlciBJRCB3aXRoIHRoZSBnaXZlblxuICAgICAqIGZsb3cgSUQgKGEgdG8tZGV2aWNlIHJlcXVlc3QgSUQgaWYgdGhlIHZlcmlmaWNhdGlvbiBoYXMgYmVlblxuICAgICAqIHJlcXVlc3RlZCBieSBhIHRvLWRldmljZSByZXF1ZXN0LCBvciBhIHJvb20gZXZlbnQgSUQgaWYgdGhlXG4gICAgICogdmVyaWZpY2F0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZCBieSBhIHJvb20gZXZlbnQpLlxuICAgICAqXG4gICAgICogSXQgcmV0dXJucyBhIOKAnGBWZXJpZmljYXRpb25gIG9iamVjdOKAnSwgd2hpY2ggaXMgZWl0aGVyIGEgYFNhc2BcbiAgICAgKiBvciBgUXJgIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1VzZXJJZH0gdXNlcl9pZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmbG93X2lkXG4gICAgICogQHJldHVybnMge2FueX1cbiAgICAgKi9cbiAgICBnZXRWZXJpZmljYXRpb24odXNlcl9pZCwgZmxvd19pZCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3ModXNlcl9pZCwgVXNlcklkKTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGZsb3dfaWQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2dldFZlcmlmaWNhdGlvbih0aGlzLl9fd2JnX3B0ciwgdXNlcl9pZC5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSB2ZXJpZmljYXRpb24gcmVxdWVzdCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gZmxvdyBJRC5cbiAgICAgKiBAcGFyYW0ge1VzZXJJZH0gdXNlcl9pZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmbG93X2lkXG4gICAgICogQHJldHVybnMge1ZlcmlmaWNhdGlvblJlcXVlc3QgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0VmVyaWZpY2F0aW9uUmVxdWVzdCh1c2VyX2lkLCBmbG93X2lkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh1c2VyX2lkLCBVc2VySWQpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZmxvd19pZCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfZ2V0VmVyaWZpY2F0aW9uUmVxdWVzdCh0aGlzLl9fd2JnX3B0ciwgdXNlcl9pZC5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogVmVyaWZpY2F0aW9uUmVxdWVzdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgdmVyaWZpY2F0aW9uIHJlcXVlc3RzIG9mIGEgZ2l2ZW4gdXNlci5cbiAgICAgKiBAcGFyYW0ge1VzZXJJZH0gdXNlcl9pZFxuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIGdldFZlcmlmaWNhdGlvblJlcXVlc3RzKHVzZXJfaWQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHVzZXJfaWQsIFVzZXJJZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9nZXRWZXJpZmljYXRpb25SZXF1ZXN0cyh0aGlzLl9fd2JnX3B0ciwgdXNlcl9pZC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNlaXZlIGEgdmVyaWZpY2F0aW9uIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gcGFzcyB2ZXJpZmljYXRpb24gZXZlbnRzIHRoYXQgYXJlIGhhcHBlbmluZ1xuICAgICAqIGluIHJvb21zIHRvIHRoZSBgT2xtTWFjaGluZWAuIFRoZSBldmVudCBzaG91bGQgYmUgaW4gdGhlIGRlY3J5cHRlZCBmb3JtLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7Um9vbUlkfSByb29tX2lkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICByZWNlaXZlVmVyaWZpY2F0aW9uRXZlbnQoZXZlbnQsIHJvb21faWQpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGV2ZW50LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIF9hc3NlcnRDbGFzcyhyb29tX2lkLCBSb29tSWQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfcmVjZWl2ZVZlcmlmaWNhdGlvbkV2ZW50KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCByb29tX2lkLl9fd2JnX3B0cik7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydCB0aGUga2V5cyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBgcHJlZGljYXRlYCBpcyBhIGNsb3N1cmUgdGhhdCB3aWxsIGJlIGNhbGxlZCBmb3IgZXZlcnkga25vd25cbiAgICAgKiBgSW5ib3VuZEdyb3VwU2Vzc2lvbmAsIHdoaWNoIHJlcHJlc2VudHMgYSByb29tIGtleS4gSWYgdGhlIGNsb3N1cmVcbiAgICAgKiByZXR1cm5zIGB0cnVlYCwgdGhlIGBJbmJvdW5kR3JvdXBTZXNzaW9uYCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZVxuICAgICAqIGV4cG9ydDsgb3RoZXJ3aXNlIGl0IHdvbid0LlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIFByb21pc2UgY29udGFpbmluZyBhIFJlc3VsdCBjb250YWluaW5nIGEgU3RyaW5nIHdoaWNoIGlzIGFcbiAgICAgKiBKU09OLWVuY29kZWQgYXJyYXkgb2YgRXhwb3J0ZWRSb29tS2V5IG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBleHBvcnRSb29tS2V5cyhwcmVkaWNhdGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2V4cG9ydFJvb21LZXlzKHRoaXMuX193YmdfcHRyLCBwcmVkaWNhdGUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBvcnQgdGhlIGdpdmVuIHJvb20ga2V5cyBpbnRvIG91ciBzdG9yZS5cbiAgICAgKlxuICAgICAqIE1vc3RseSwgYSBkZXByZWNhdGVkIGFsaWFzIGZvciBgaW1wb3J0RXhwb3J0ZWRSb29tS2V5c2AsIHRob3VnaCB0aGVcbiAgICAgKiByZXR1cm4gdHlwZSBpcyBkaWZmZXJlbnQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgU3RyaW5nIGNvbnRhaW5pbmcgYSBKU09OLWVuY29kZWQgb2JqZWN0LCBob2xkaW5nIHRocmVlXG4gICAgICogcHJvcGVydGllczpcbiAgICAgKiAgKiBgdG90YWxfY291bnRgICh0aGUgdG90YWwgbnVtYmVyIG9mIGtleXMgZm91bmQgaW4gdGhlIGV4cG9ydCBkYXRhKS5cbiAgICAgKiAgKiBgaW1wb3J0ZWRfY291bnRgICh0aGUgbnVtYmVyIG9mIGtleXMgdGhhdCB3ZXJlIGltcG9ydGVkKS5cbiAgICAgKiAgKiBga2V5c2AgKHRoZSBrZXlzIHRoYXQgd2VyZSBpbXBvcnRlZDsgYSBtYXAgZnJvbSByb29tIGlkIHRvIGEgbWFwIG9mXG4gICAgICogICAgdGhlIHNlbmRlciBrZXkgdG8gYSBsaXN0IG9mIHNlc3Npb24gaWRzKS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgaW1wb3J0RXhwb3J0ZWRSb29tS2V5c2Agb3IgYGltcG9ydEJhY2tlZFVwUm9vbUtleXNgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBvcnRlZF9yb29tX2tleXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9ncmVzc19saXN0ZW5lclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgaW1wb3J0Um9vbUtleXMoZXhwb3J0ZWRfcm9vbV9rZXlzLCBwcm9ncmVzc19saXN0ZW5lcikge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZXhwb3J0ZWRfcm9vbV9rZXlzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9pbXBvcnRSb29tS2V5cyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHJvZ3Jlc3NfbGlzdGVuZXIpO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBvcnQgdGhlIGdpdmVuIHJvb20ga2V5cyBpbnRvIG91ciBzdG9yZS5cbiAgICAgKlxuICAgICAqIGBleHBvcnRlZF9rZXlzYCBpcyBhIEpTT04tZW5jb2RlZCBsaXN0IG9mIHByZXZpb3VzbHkgZXhwb3J0ZWQga2V5cyB0aGF0XG4gICAgICogc2hvdWxkIGJlIGltcG9ydGVkIGludG8gb3VyIHN0b3JlLiBJZiB3ZSBhbHJlYWR5IGhhdmUgYSBiZXR0ZXJcbiAgICAgKiB2ZXJzaW9uIG9mIGEga2V5LCB0aGUga2V5IHdpbGwgX25vdF8gYmUgaW1wb3J0ZWQuXG4gICAgICpcbiAgICAgKiBgcHJvZ3Jlc3NfbGlzdGVuZXJgIGlzIGEgY2xvc3VyZSB0aGF0IHRha2VzIDIgYEJpZ0ludGAgYXJndW1lbnRzOlxuICAgICAqIGBwcm9ncmVzc2AgYW5kIGB0b3RhbGAsIGFuZCByZXR1cm5zIG5vdGhpbmcuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIFJvb21LZXlJbXBvcnRSZXN1bHR9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBvcnRlZF9yb29tX2tleXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9ncmVzc19saXN0ZW5lclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgaW1wb3J0RXhwb3J0ZWRSb29tS2V5cyhleHBvcnRlZF9yb29tX2tleXMsIHByb2dyZXNzX2xpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChleHBvcnRlZF9yb29tX2tleXMsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2ltcG9ydEV4cG9ydGVkUm9vbUtleXModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHByb2dyZXNzX2xpc3RlbmVyKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1wb3J0IHRoZSBnaXZlbiByb29tIGtleXMgaW50byBvdXIgc3RvcmUuXG4gICAgICpcbiAgICAgKiAjIEFyZ3VtZW50c1xuICAgICAqXG4gICAgICogKiBgYmFja2VkX3VwX3Jvb21fa2V5c2A6IGtleXMgdGhhdCB3ZXJlIHJldHJpZXZlZCBmcm9tIGJhY2t1cCBhbmQgdGhhdFxuICAgICAqICAgc2hvdWxkIGJlIGFkZGVkIHRvIG91ciBzdG9yZSAocHJvdmlkZWQgdGhleSBhcmUgYmV0dGVyIHRoYW4gb3VyXG4gICAgICogICBjdXJyZW50IHZlcnNpb25zIG9mIHRob3NlIGtleXMpLiBTcGVjaWZpY2FsbHksIGl0IHNob3VsZCBiZSBhIE1hcCBmcm9tXG4gICAgICogICB7QGxpbmsgUm9vbUlkfSwgdG8gYSBNYXAgZnJvbSBzZXNzaW9uIElEIHRvIGEgKGRlY3J5cHRlZCkgc2Vzc2lvbiBkYXRhXG4gICAgICogICBzdHJ1Y3R1cmUuXG4gICAgICpcbiAgICAgKiAqIGBwcm9ncmVzc19saXN0ZW5lcmA6IGFuIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgdGFrZXMgMyBhcmd1bWVudHM6XG4gICAgICogICBgcHJvZ3Jlc3NgICh0aGUgbnVtYmVyIG9mIGtleXMgdGhhdCBoYXZlIHN1Y2Nlc3NmdWxseSBiZWVuIGltcG9ydGVkKSxcbiAgICAgKiAgIGB0b3RhbGAgKHRoZSB0b3RhbCBudW1iZXIgb2Yga2V5cyksIGFuZCBgZmFpbHVyZXNgICh0aGUgbnVtYmVyIG9mIGtleXNcbiAgICAgKiAgIHRoYXQgZmFpbGVkIHRvIGltcG9ydCksIGFuZCByZXR1cm5zIG5vdGhpbmcuXG4gICAgICpcbiAgICAgKiAjIFJldHVybnNcbiAgICAgKlxuICAgICAqIEEge0BsaW5rIFJvb21LZXlJbXBvcnRSZXN1bHR9LlxuICAgICAqIEBwYXJhbSB7TWFwPGFueSwgYW55Pn0gYmFja2VkX3VwX3Jvb21fa2V5c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb24gfCB1bmRlZmluZWR9IHByb2dyZXNzX2xpc3RlbmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhY2t1cF92ZXJzaW9uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBpbXBvcnRCYWNrZWRVcFJvb21LZXlzKGJhY2tlZF91cF9yb29tX2tleXMsIHByb2dyZXNzX2xpc3RlbmVyLCBiYWNrdXBfdmVyc2lvbikge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYmFja3VwX3ZlcnNpb24sIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2ltcG9ydEJhY2tlZFVwUm9vbUtleXModGhpcy5fX3diZ19wdHIsIGJhY2tlZF91cF9yb29tX2tleXMsIGlzTGlrZU5vbmUocHJvZ3Jlc3NfbGlzdGVuZXIpID8gMCA6IGFkZFRvRXh0ZXJucmVmVGFibGUwKHByb2dyZXNzX2xpc3RlbmVyKSwgcHRyMCwgbGVuMCk7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3JlIHRoZSBiYWNrdXAgZGVjcnlwdGlvbiBrZXkgaW4gdGhlIGNyeXB0byBzdG9yZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGlmIHRoZSBjbGllbnQgd2FudHMgdG8gc3VwcG9ydCBnb3NzaXBpbmcgb2YgdGhlIGJhY2t1cFxuICAgICAqIGtleS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYFByb21pc2U8dm9pZD5gLlxuICAgICAqIEBwYXJhbSB7QmFja3VwRGVjcnlwdGlvbktleX0gZGVjcnlwdGlvbl9rZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc2F2ZUJhY2t1cERlY3J5cHRpb25LZXkoZGVjcnlwdGlvbl9rZXksIHZlcnNpb24pIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGRlY3J5cHRpb25fa2V5LCBCYWNrdXBEZWNyeXB0aW9uS2V5KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHZlcnNpb24sIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX3NhdmVCYWNrdXBEZWNyeXB0aW9uS2V5KHRoaXMuX193YmdfcHRyLCBkZWNyeXB0aW9uX2tleS5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJhY2t1cCBrZXlzIHdlIGhhdmUgc2F2ZWQgaW4gb3VyIHN0b3JlLlxuICAgICAqIFJldHVybnMgYSBgUHJvbWlzZWAgZm9yIHtAbGluayBCYWNrdXBLZXlzfS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGdldEJhY2t1cEtleXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9nZXRCYWNrdXBLZXlzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIGJhY2t1cCBoYXMgYmVlbiB2ZXJpZmllZCBieSB1cyBvciBieSBhbm90aGVyIG9mIG91clxuICAgICAqIGRldmljZXMgdGhhdCB3ZSB0cnVzdC5cbiAgICAgKlxuICAgICAqIFRoZSBgYmFja3VwX2luZm9gIHNob3VsZCBiZSBhIEphdmFzY3JpcHQgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICAgICAqIGZvcm1hdDpcbiAgICAgKlxuICAgICAqIGBgYGpzb25cbiAgICAgKiB7XG4gICAgICogICAgIFwiYWxnb3JpdGhtXCI6IFwibS5tZWdvbG1fYmFja3VwLnYxLmN1cnZlMjU1MTktYWVzLXNoYTJcIixcbiAgICAgKiAgICAgXCJhdXRoX2RhdGFcIjoge1xuICAgICAqICAgICAgICAgXCJwdWJsaWNfa2V5XCI6XCJYamhXVENqVzdsNTlwYmZ4OXRsQ0JRb2xmbklRV0FSb0tPempUT1BTbFdNXCIsXG4gICAgICogICAgICAgICBcInNpZ25hdHVyZXNcIjoge31cbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgU2lnbmF0dXJlVmVyaWZpY2F0aW9ufSBvYmplY3QuXG4gICAgICogQHBhcmFtIHthbnl9IGJhY2t1cF9pbmZvXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICB2ZXJpZnlCYWNrdXAoYmFja3VwX2luZm8pIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX3ZlcmlmeUJhY2t1cCh0aGlzLl9fd2JnX3B0ciwgYmFja3VwX2luZm8pO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZSB0aGUgZ2l2ZW4gYmFja3VwIGtleSB0byBiZSB1c2VkIHdpdGggdGhlIGdpdmVuIGJhY2t1cCB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogKipXYXJuaW5nKio6IFRoZSBjYWxsZXIgbmVlZHMgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGdpdmVuIGBCYWNrdXBLZXlgIGlzXG4gICAgICogdHJ1c3RlZCwgb3RoZXJ3aXNlIHdlIG1pZ2h0IGJlIGVuY3J5cHRpbmcgcm9vbSBrZXlzIHRoYXQgYSBtYWxpY2lvdXNcbiAgICAgKiBwYXJ0eSBjb3VsZCBkZWNyeXB0LlxuICAgICAqXG4gICAgICogVGhlIHtAbGluayAjdmVyaWZ5QmFja3VwfSBtZXRob2QgY2FuIGJlIHVzZWQgdG8gZG8gc28uXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGBQcm9taXNlPHZvaWQ+YC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2tleV9iYXNlXzY0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGVuYWJsZUJhY2t1cFYxKHB1YmxpY19rZXlfYmFzZV82NCwgdmVyc2lvbikge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocHVibGljX2tleV9iYXNlXzY0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMCh2ZXJzaW9uLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9lbmFibGVCYWNrdXBWMSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFyZSB3ZSBhYmxlIHRvIGVuY3J5cHQgcm9vbSBrZXlzLlxuICAgICAqXG4gICAgICogVGhpcyByZXR1cm5zIHRydWUgaWYgd2UgaGF2ZSBhbiBhY3RpdmUgYEJhY2t1cEtleWAgYW5kIGJhY2t1cCB2ZXJzaW9uXG4gICAgICogcmVnaXN0ZXJlZCB3aXRoIHRoZSBzdGF0ZSBtYWNoaW5lLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgUHJvbWlzZTxib29sPmAuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBpc0JhY2t1cEVuYWJsZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9pc0JhY2t1cEVuYWJsZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIGFuZCByZXNldCBvdXIgYmFja3VwIHN0YXRlLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIHJlbW92ZSBhbnkgcGVuZGluZyBiYWNrdXAgcmVxdWVzdCwgcmVtb3ZlIHRoZSBiYWNrdXAga2V5IGFuZFxuICAgICAqIHJlc2V0IHRoZSBiYWNrdXAgc3RhdGUgb2YgZWFjaCByb29tIGtleSB3ZSBoYXZlLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgUHJvbWlzZTx2b2lkPmAuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBkaXNhYmxlQmFja3VwKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfZGlzYWJsZUJhY2t1cCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgYSBiYXRjaCBvZiByb29tIGtleXMgYW5kIHJldHVybiBhIHJlcXVlc3QgdGhhdCBuZWVkcyB0byBiZSBzZW50XG4gICAgICogb3V0IHRvIGJhY2t1cCB0aGUgcm9vbSBrZXlzLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhbiBvcHRpb25hbCB7QGxpbmsgS2V5c0JhY2t1cFJlcXVlc3R9LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYmFja3VwUm9vbUtleXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9iYWNrdXBSb29tS2V5cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGJhY2tlZCB1cCByb29tIGtleXMgYW5kIHRoZSB0b3RhbCBudW1iZXIgb2Ygcm9vbSBrZXlzLlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgUm9vbUtleUNvdW50c30uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICByb29tS2V5Q291bnRzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfcm9vbUtleUNvdW50cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgdGhlIGxpc3Qgb2YgZXhwb3J0ZWQgcm9vbSBrZXlzIHVzaW5nIHRoZSBnaXZlbiBwYXNzcGhyYXNlLlxuICAgICAqXG4gICAgICogYGV4cG9ydGVkX3Jvb21fa2V5c2AgaXMgYSBsaXN0IG9mIHNlc3Npb25zIHRoYXQgc2hvdWxkIGJlIGVuY3J5cHRlZFxuICAgICAqIChpdCdzIGdlbmVyYWxseSByZXR1cm5lZCBieSBgZXhwb3J0X3Jvb21fa2V5c2ApLiBgcGFzc3BocmFzZWAgaXMgdGhlXG4gICAgICogcGFzc3BocmFzZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBlbmNyeXB0IHRoZSBleHBvcnRlZCByb29tIGtleXMuIEFuZFxuICAgICAqIGByb3VuZHNgIGlzIHRoZSBudW1iZXIgb2Ygcm91bmRzIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIHRoZSBrZXlcbiAgICAgKiBkZXJpdmF0aW9uIHdoZW4gdGhlIHBhc3NwaHJhc2UgZ2V0cyB0dXJuZWQgaW50byBhbiBBRVMga2V5LiBNb3JlIHJvdW5kc1xuICAgICAqIGFyZSBpbmNyZWFzaW5nbHkgY29tcHV0YXRpb25uYWxseSBpbnRlbnNpdmUgYW5kIGFzIHN1Y2ggaGVscCBhZ2FpbnN0XG4gICAgICogYnJ1dGUtZm9yY2UgYXR0YWNrcy4gU2hvdWxkIGJlIGF0IGxlYXN0IGAxMF8wMDBgLCB3aGlsZSB2YWx1ZXMgaW4gdGhlXG4gICAgICogYDEwMF8wMDBgIHJhbmdlcyBzaG91bGQgYmUgcHJlZmVycmVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBvcnRlZF9yb29tX2tleXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3BocmFzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3VuZHNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBlbmNyeXB0RXhwb3J0ZWRSb29tS2V5cyhleHBvcnRlZF9yb29tX2tleXMsIHBhc3NwaHJhc2UsIHJvdW5kcykge1xuICAgICAgICBsZXQgZGVmZXJyZWQ0XzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDRfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChleHBvcnRlZF9yb29tX2tleXMsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAocGFzc3BocmFzZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9lbmNyeXB0RXhwb3J0ZWRSb29tS2V5cyhwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCByb3VuZHMpO1xuICAgICAgICAgICAgdmFyIHB0cjMgPSByZXRbMF07XG4gICAgICAgICAgICB2YXIgbGVuMyA9IHJldFsxXTtcbiAgICAgICAgICAgIGlmIChyZXRbM10pIHtcbiAgICAgICAgICAgICAgICBwdHIzID0gMDsgbGVuMyA9IDA7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkNF8wID0gcHRyMztcbiAgICAgICAgICAgIGRlZmVycmVkNF8xID0gbGVuMztcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMywgbGVuMyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDRfMCwgZGVmZXJyZWQ0XzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyeSB0byBkZWNyeXB0IGEgcmVhZGVyIGludG8gYSBsaXN0IG9mIGV4cG9ydGVkIHJvb20ga2V5cy5cbiAgICAgKlxuICAgICAqIGBlbmNyeXB0ZWRfZXhwb3J0ZWRfcm9vbV9rZXlzYCBpcyB0aGUgcmVzdWx0IGZyb21cbiAgICAgKiBgZW5jcnlwdF9leHBvcnRlZF9yb29tX2tleXNgLiBgcGFzc3BocmFzZWAgaXMgdGhlIHBhc3NwaHJhc2UgdGhhdCB3YXNcbiAgICAgKiB1c2VkIHdoZW4gY2FsbGluZyBgZW5jcnlwdF9leHBvcnRlZF9yb29tX2tleXNgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmNyeXB0ZWRfZXhwb3J0ZWRfcm9vbV9rZXlzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3NwaHJhc2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZWNyeXB0RXhwb3J0ZWRSb29tS2V5cyhlbmNyeXB0ZWRfZXhwb3J0ZWRfcm9vbV9rZXlzLCBwYXNzcGhyYXNlKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDRfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkNF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGVuY3J5cHRlZF9leHBvcnRlZF9yb29tX2tleXMsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAocGFzc3BocmFzZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9kZWNyeXB0RXhwb3J0ZWRSb29tS2V5cyhwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgICAgIHZhciBwdHIzID0gcmV0WzBdO1xuICAgICAgICAgICAgdmFyIGxlbjMgPSByZXRbMV07XG4gICAgICAgICAgICBpZiAocmV0WzNdKSB7XG4gICAgICAgICAgICAgICAgcHRyMyA9IDA7IGxlbjMgPSAwO1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZDRfMCA9IHB0cjM7XG4gICAgICAgICAgICBkZWZlcnJlZDRfMSA9IGxlbjM7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjMsIGxlbjMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQ0XzAsIGRlZmVycmVkNF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZXJlIGlzIGFuIHVwZGF0ZSB0b1xuICAgICAqIGEgcm9vbSBrZXkuXG4gICAgICpcbiAgICAgKiBgY2FsbGJhY2tgIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQgKGFuIGFycmF5XG4gICAgICogb2Yge0BsaW5rIFJvb21LZXlJbmZvfSkgYW5kIHJldHVybnMgYSBQcm9taXNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgcmVnaXN0ZXJSb29tS2V5VXBkYXRlZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9yZWdpc3RlclJvb21LZXlVcGRhdGVkQ2FsbGJhY2sodGhpcy5fX3diZ19wdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB3ZSByZWNlaXZlIGFcbiAgICAgKiBub3RpZmljYXRpb24gdGhhdCBzb21lIHJvb20ga2V5cyBoYXZlIGJlZW4gd2l0aGhlbGQuXG4gICAgICpcbiAgICAgKiBgY2FsbGJhY2tgIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQgKGFuIGFycmF5XG4gICAgICogb2Yge0BsaW5rIFJvb21LZXlXaXRoaGVsZEluZm99KSBhbmQgcmV0dXJucyBhIFByb21pc2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICByZWdpc3RlclJvb21LZXlzV2l0aGhlbGRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfcmVnaXN0ZXJSb29tS2V5c1dpdGhoZWxkQ2FsbGJhY2sodGhpcy5fX3diZ19wdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGVyZSBpcyBhbiB1cGRhdGUgdG9cbiAgICAgKiBhIHVzZXIgaWRlbnRpdHkuXG4gICAgICpcbiAgICAgKiBgY2FsbGJhY2tgIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQgKGEge0BsaW5rXG4gICAgICogVXNlcklkfSkgYW5kIHJldHVybnMgYSBQcm9taXNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgcmVnaXN0ZXJVc2VySWRlbnRpdHlVcGRhdGVkQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX3JlZ2lzdGVyVXNlcklkZW50aXR5VXBkYXRlZENhbGxiYWNrKHRoaXMuX193YmdfcHRyLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlcmUgaXMgYW4gdXBkYXRlIHRvXG4gICAgICogYSBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBgY2FsbGJhY2tgIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQgKGFuIGFycmF5XG4gICAgICogb2YgdXNlciBJRHMgYXMgc3RyaW5ncykgYW5kIHJldHVybnMgYSBQcm9taXNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgcmVnaXN0ZXJEZXZpY2VzVXBkYXRlZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub2xtbWFjaGluZV9yZWdpc3RlckRldmljZXNVcGRhdGVkQ2FsbGJhY2sodGhpcy5fX3diZ19wdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIHNlY3JldFxuICAgICAqIChgbS5zZWNyZXQuc2VuZGApIGlzIHJlY2VpdmVkLlxuICAgICAqXG4gICAgICogVGhlIG9ubHkgc2VjcmV0IHRoaXMgd2lsbCBjdXJyZW50bHkgYnJvYWRjYXN0IGlzIHRoZVxuICAgICAqIGBtLm1lZ29sbV9iYWNrdXAudjFgICh0aGUgY3Jvc3Mgc2lnbmluZyBzZWNyZXRzIGFyZSBoYW5kbGVkIGludGVybmFsbHkpLlxuICAgICAqXG4gICAgICogVG8gcmVxdWVzdCBhIHNlY3JldCBmcm9tIG90aGVyIGRldmljZXMsIGEgY2xpZW50IHNlbmRzIGFuXG4gICAgICogYG0uc2VjcmV0LnJlcXVlc3RgIGRldmljZSBldmVudCB3aXRoIGBhY3Rpb25gIHNldCB0byBgcmVxdWVzdGAgYW5kXG4gICAgICogYG5hbWVgIHNldCB0byB0aGUgaWRlbnRpZmllciBvZiB0aGUgc2VjcmV0LiBBIGRldmljZSB0aGF0IHdpc2hlcyB0b1xuICAgICAqIHNoYXJlIHRoZSBzZWNyZXQgd2lsbCByZXBseSB3aXRoIGFuIGBtLnNlY3JldC5zZW5kYCBldmVudCwgZW5jcnlwdGVkXG4gICAgICogdXNpbmcgb2xtLlxuICAgICAqXG4gICAgICogVGhlIHNlY3JldHMgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSBiZWVuIHJlY2VpdmVkIG92ZXIgYSAxLXRvLTEgZW5jcnlwdGVkXG4gICAgICogdG9fZGV2aWNlIG1lc3NhZ2UgZnJvbSBhIG9uZSBvZiB0aGUgdXNlcidzIG93biB2ZXJpZmllZCBkZXZpY2VzLlxuICAgICAqXG4gICAgICogU2VlIGh0dHBzOi8vbWF0cml4LW9yZy5naXRodWIuaW8vbWF0cml4LXJ1c3Qtc2RrL21hdHJpeF9zZGtfY3J5cHRvL3N0b3JlL3N0cnVjdC5TdG9yZS5odG1sI21ldGhvZC5zZWNyZXRzX3N0cmVhbSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIGBjYWxsYmFja2Agc2hvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyAyIGFyZ3VtZW50czogdGhlIHNlY3JldCBuYW1lXG4gICAgICogKHN0cmluZykgYW5kIHZhbHVlIChzdHJpbmcpLlxuICAgICAqXG4gICAgICogKipOb3RlKio6IGlmIHRoZSBzZWNyZXQgaXMgdmFsaWQgYW5kIGhhbmRsZWQgb24gdGhlIGphdmFzY3JpcHQgc2lkZSwgdGhlXG4gICAgICogc2VjcmV0IGluYm94IHNob3VsZCBiZSBjbGVhcmVkIGJ5IGNhbGxpbmdcbiAgICAgKiBgZGVsZXRlX3NlY3JldHNfZnJvbV9pbmJveGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICByZWdpc3RlclJlY2VpdmVTZWNyZXRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfcmVnaXN0ZXJSZWNlaXZlU2VjcmV0Q2FsbGJhY2sodGhpcy5fX3diZ19wdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgc2VjcmV0cyB3aXRoIHRoZSBnaXZlbiBzZWNyZXRfbmFtZSB3ZSBoYXZlIGN1cnJlbnRseVxuICAgICAqIHN0b3JlZC5cbiAgICAgKiBUaGUgb25seSBzZWNyZXQgdGhpcyB3aWxsIGN1cnJlbnRseSByZXR1cm4gaXMgdGhlXG4gICAgICogYG0ubWVnb2xtX2JhY2t1cC52MWAgc2VjcmV0LlxuICAgICAqXG4gICAgICogVXN1YWxseSB5b3Ugd291bGQganVzdCByZWdpc3RlciBhIGNhbGxiYWNrIHdpdGhcbiAgICAgKiBbYHJlZ2lzdGVyX3JlY2VpdmVfc2VjcmV0X2NhbGxiYWNrYF0sIGJ1dCBpZiB0aGUgY2xpZW50IGlzIHNodXQgZG93blxuICAgICAqIGJlZm9yZSBoYW5kbGluZyB0aGVtLCB0aGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZSB0aGVtLlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCB0aGVyZWZvcmUgYmUgY2FsbGVkIGF0IGNsaWVudCBzdGFydHVwIHRvIHJldHJpZXZlIGFueVxuICAgICAqIHNlY3JldHMgcmVjZWl2ZWQgZHVyaW5nIHRoZSBwcmV2aW91cyBzZXNzaW9uLlxuICAgICAqXG4gICAgICogVGhlIHNlY3JldHMgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSBiZWVuIHJlY2VpdmVkIG92ZXIgYSAxLXRvLTEgZW5jcnlwdGVkXG4gICAgICogdG9fZGV2aWNlIG1lc3NhZ2UgZnJvbSBvbmUgb2YgdGhlIHVzZXIncyBvd24gdmVyaWZpZWQgZGV2aWNlcy5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBgUHJvbWlzZWAgZm9yIGEgYFNldGAgb2YgYFN0cmluZ2AgY29ycmVzcG9uZGluZyB0byB0aGUgc2VjcmV0XG4gICAgICogdmFsdWVzLlxuICAgICAqXG4gICAgICogSWYgdGhlIHNlY3JldCBpcyB2YWxpZCBhbmQgaGFuZGxlZCwgdGhlIHNlY3JldCBpbmJveCBzaG91bGQgYmUgY2xlYXJlZFxuICAgICAqIGJ5IGNhbGxpbmcgYGRlbGV0ZV9zZWNyZXRzX2Zyb21faW5ib3hgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXRfbmFtZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFByb21pc2U8YW55Pj59XG4gICAgICovXG4gICAgZ2V0U2VjcmV0c0Zyb21JbmJveChzZWNyZXRfbmFtZSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoc2VjcmV0X25hbWUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2dldFNlY3JldHNGcm9tSW5ib3godGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYWxsIHNlY3JldHMgd2l0aCB0aGUgZ2l2ZW4gc2VjcmV0IG5hbWUgZnJvbSB0aGUgaW5ib3guXG4gICAgICpcbiAgICAgKiBTaG91bGQgYmUgY2FsbGVkIGFmdGVyIGhhbmRsaW5nIHRoZSBzZWNyZXRzIHdpdGhcbiAgICAgKiBgZ2V0X3NlY3JldHNfZnJvbV9pbmJveGAuXG4gICAgICpcbiAgICAgKiAjIEFyZ3VtZW50c1xuICAgICAqXG4gICAgICogKiBgc2VjcmV0X25hbWVgIC0gVGhlIG5hbWUgb2YgdGhlIHNlY3JldCB0byBkZWxldGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldF9uYW1lXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UHJvbWlzZTxhbnk+Pn1cbiAgICAgKi9cbiAgICBkZWxldGVTZWNyZXRzRnJvbUluYm94KHNlY3JldF9uYW1lKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChzZWNyZXRfbmFtZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfZGVsZXRlU2VjcmV0c0Zyb21JbmJveCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgbWlzc2luZyBsb2NhbCBzZWNyZXRzIGZyb20gb3VyIG90aGVyIHRydXN0ZWQgZGV2aWNlcy5cbiAgICAgKlxuICAgICAqIFwiTG9jYWwgc2VjcmV0c1wiIHJlZmVycyB0byBzZWNyZXRzIHdoaWNoIGNhbiBiZSBzaGFyZWQgYmV0d2VlbiB0cnVzdGVkXG4gICAgICogZGV2aWNlcywgc3VjaCBhcyBwcml2YXRlIGNyb3NzLXNpZ25pbmcga2V5cywgYW5kIHRoZSBtZWdvbG0gYmFja3VwXG4gICAgICogZGVjcnlwdGlvbiBrZXkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBzZGsgdG8gZ2VuZXJhdGVkIG91dGdvaW5nIHNlY3JldCByZXF1ZXN0c1xuICAgICAqIChgbS5zZWNyZXQucmVxdWVzdGApIHRvIGdldCB0aGUgbWlzc2luZyBzZWNyZXRzLiBUaGVzZSByZXF1ZXN0cyB3aWxsXG4gICAgICogdGhlbiBiZSByZXR1cm5lZCBieSBhIGZ1dHVyZSBjYWxsIHRvIHtAbGlua1xuICAgICAqIE9sbU1hY2hpbmUjb3V0Z29pbmdfcmVxdWVzdHN9LlxuICAgICAqXG4gICAgICogIyBSZXR1cm5zXG4gICAgICpcbiAgICAgKiBBIGBQcm9taXNlYCBmb3IgYSBgYm9vbGAgcmVzdWx0LCB3aGljaCB3aWxsIGJlIHRydWUgaWYgIHNlY3JldHMgd2VyZVxuICAgICAqIG1pc3NpbmcsIGFuZCBhIHJlcXVlc3Qgd2FzIGdlbmVyYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcm9taXNlPGFueT4+fVxuICAgICAqL1xuICAgIHJlcXVlc3RNaXNzaW5nU2VjcmV0c0lmTmVlZGVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfcmVxdWVzdE1pc3NpbmdTZWNyZXRzSWZOZWVkZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0b3JlZCByb29tIHNldHRpbmdzLCBzdWNoIGFzIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBvclxuICAgICAqIHdoZXRoZXIgdG8gZW5jcnlwdCBvbmx5IGZvciB0cnVzdGVkIGRldmljZXMuXG4gICAgICpcbiAgICAgKiBUaGVzZSBzZXR0aW5ncyBjYW4gYmUgbW9kaWZpZWQgdmlhIHtAbGluayAjc2V0Um9vbVNldHRpbmdzfS5cbiAgICAgKlxuICAgICAqICMgUmV0dXJuc1xuICAgICAqXG4gICAgICogYFByb21pc2U8Um9vbVNldHRpbmdzfHVuZGVmaW5lZD5gXG4gICAgICogQHBhcmFtIHtSb29tSWR9IHJvb21faWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGdldFJvb21TZXR0aW5ncyhyb29tX2lkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhyb29tX2lkLCBSb29tSWQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm9sbW1hY2hpbmVfZ2V0Um9vbVNldHRpbmdzKHRoaXMuX193YmdfcHRyLCByb29tX2lkLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3JlIGVuY3J5cHRpb24gc2V0dGluZ3MgZm9yIHRoZSBnaXZlbiByb29tLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIHRoZSBuZXcgc2V0dGluZ3MgYXJlIFwic2FmZVwiIC0tIGllLCB0aGF0IHRoZXkgZG9cbiAgICAgKiBub3QgcmVwcmVzZW50IGEgZG93bmdyYWRlIGluIGVuY3J5cHRpb24gc2VjdXJpdHkgZnJvbSBhbnkgcHJldmlvdXNcbiAgICAgKiBzZXR0aW5ncy4gQXR0ZW1wdHMgdG8gZG93bmdyYWRlIHNlY3VyaXR5IHdpbGwgcmVzdWx0IGluIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogSWYgdGhlIHNldHRpbmdzIGFyZSB2YWxpZCwgdGhleSB3aWxsIGJlIHBlcnNpc3RlZCB0byB0aGUgY3J5cHRvIHN0b3JlLlxuICAgICAqIFRoZXNlIHNldHRpbmdzIGFyZSBub3QgdXNlZCBkaXJlY3RseSBieSB0aGlzIGxpYnJhcnksIGJ1dCB0aGUgc2F2ZWRcbiAgICAgKiBzZXR0aW5ncyBjYW4gYmUgcmV0cmlldmVkIHZpYSB7QGxpbmsgI2dldFJvb21TZXR0aW5nc30uXG4gICAgICogQHBhcmFtIHtSb29tSWR9IHJvb21faWRcbiAgICAgKiBAcGFyYW0ge1Jvb21TZXR0aW5nc30gcm9vbV9zZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIHNldFJvb21TZXR0aW5ncyhyb29tX2lkLCByb29tX3NldHRpbmdzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhyb29tX2lkLCBSb29tSWQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mocm9vbV9zZXR0aW5ncywgUm9vbVNldHRpbmdzKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX3NldFJvb21TZXR0aW5ncyh0aGlzLl9fd2JnX3B0ciwgcm9vbV9pZC5fX3diZ19wdHIsIHJvb21fc2V0dGluZ3MuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFuYWdlIGRlaHlkcmF0ZWQgZGV2aWNlc1xuICAgICAqIEByZXR1cm5zIHtEZWh5ZHJhdGVkRGV2aWNlc31cbiAgICAgKi9cbiAgICBkZWh5ZHJhdGVkRGV2aWNlcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vbG1tYWNoaW5lX2RlaHlkcmF0ZWREZXZpY2VzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIERlaHlkcmF0ZWREZXZpY2VzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaHV0IGRvd24gdGhlIGBPbG1NYWNoaW5lYC5cbiAgICAgKlxuICAgICAqIFRoZSBgT2xtTWFjaGluZWAgY2Fubm90IGJlIHVzZWQgYWZ0ZXIgdGhpcyBtZXRob2QgaGFzIGJlZW4gY2FsbGVkLlxuICAgICAqXG4gICAgICogQWxsIGFzc29jaWF0ZWQgcmVzb3VyY2VzIHdpbGwgYmUgY2xvc2VkIHRvbywgbGlrZSBJbmRleGVkREJcbiAgICAgKiBjb25uZWN0aW9ucy5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5vbG1tYWNoaW5lX2Nsb3NlKHB0cik7XG4gICAgfVxufVxuXG5jb25zdCBPdGhlclVzZXJJZGVudGl0eUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19vdGhlcnVzZXJpZGVudGl0eV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBTdHJ1Y3QgcmVwcmVzZW50aW5nIGEgY3Jvc3Mgc2lnbmluZyBpZGVudGl0eSBvZiBhIHVzZXIuXG4gKlxuICogVGhpcyBpcyB0aGUgdXNlciBpZGVudGl0eSBvZiBhIHVzZXIgdGhhdCBpc24ndCBvdXIgb3duLiBPdGhlciB1c2VycyB3aWxsXG4gKiBvbmx5IGNvbnRhaW4gYSBtYXN0ZXIga2V5IGFuZCBhIHNlbGYgc2lnbmluZyBrZXksIG1lYW5pbmcgdGhhdCBvbmx5IGRldmljZVxuICogc2lnbmF0dXJlcyBjYW4gYmUgY2hlY2tlZCB3aXRoIHRoaXMgaWRlbnRpdHkuXG4gKlxuICogVGhpcyBzdHJ1Y3Qgd3JhcHMgYSByZWFkLW9ubHkgdmVyc2lvbiBvZiB0aGUgc3RydWN0IGFuZCBhbGxvd3MgdmVyaWZpY2F0aW9uc1xuICogdG8gYmUgcmVxdWVzdGVkIHRvIHZlcmlmeSBvdXIgb3duIGRldmljZSB3aXRoIHRoZSB1c2VyIGlkZW50aXR5LlxuICovXG5leHBvcnQgY2xhc3MgT3RoZXJVc2VySWRlbnRpdHkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE90aGVyVXNlcklkZW50aXR5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE90aGVyVXNlcklkZW50aXR5RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE90aGVyVXNlcklkZW50aXR5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19vdGhlcnVzZXJpZGVudGl0eV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgdXNlciBpZGVudGl0eSB2ZXJpZmllZD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ZlcmlmaWVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm90aGVydXNlcmlkZW50aXR5X2lzVmVyaWZpZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYW51YWxseSB2ZXJpZnkgdGhpcyB1c2VyLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBhdHRlbXB0IHRvIHNpZ24gdGhlIHVzZXIgaWRlbnRpdHkgdXNpbmcgb3VyIHByaXZhdGVcbiAgICAgKiBjcm9zcyBzaWduaW5nIGtleS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGZhaWxzIGlmIHdlIGRvbid0IGhhdmUgdGhlIHByaXZhdGUgcGFydCBvZiBvdXIgdXNlci1zaWduaW5nXG4gICAgICoga2V5LlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIHJlcXVlc3QgdGhhdCBuZWVkcyB0byBiZSBzZW50IG91dCBmb3IgdGhlIHVzZXIgdG8gYmUgbWFya2VkIGFzXG4gICAgICogdmVyaWZpZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICB2ZXJpZnkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3RoZXJ1c2VyaWRlbnRpdHlfdmVyaWZ5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgYFZlcmlmaWNhdGlvblJlcXVlc3RgIG9iamVjdCBhZnRlciB0aGUgdmVyaWZpY2F0aW9uXG4gICAgICogcmVxdWVzdCBjb250ZW50IGhhcyBiZWVuIHNlbnQgb3V0LlxuICAgICAqIEBwYXJhbSB7Um9vbUlkfSByb29tX2lkXG4gICAgICogQHBhcmFtIHtFdmVudElkfSByZXF1ZXN0X2V2ZW50X2lkXG4gICAgICogQHBhcmFtIHthbnlbXSB8IHVuZGVmaW5lZH0gW21ldGhvZHNdXG4gICAgICogQHJldHVybnMge1ZlcmlmaWNhdGlvblJlcXVlc3R9XG4gICAgICovXG4gICAgcmVxdWVzdFZlcmlmaWNhdGlvbihyb29tX2lkLCByZXF1ZXN0X2V2ZW50X2lkLCBtZXRob2RzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhyb29tX2lkLCBSb29tSWQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocmVxdWVzdF9ldmVudF9pZCwgRXZlbnRJZCk7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShtZXRob2RzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChtZXRob2RzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3RoZXJ1c2VyaWRlbnRpdHlfcmVxdWVzdFZlcmlmaWNhdGlvbih0aGlzLl9fd2JnX3B0ciwgcm9vbV9pZC5fX3diZ19wdHIsIHJlcXVlc3RfZXZlbnRfaWQuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmVyaWZpY2F0aW9uUmVxdWVzdC5fX3dyYXAocmV0WzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHZlcmlmaWNhdGlvbiByZXF1ZXN0IHRvIHRoZSBnaXZlbiB1c2VyLlxuICAgICAqXG4gICAgICogVGhlIHJldHVybmVkIGNvbnRlbnQgbmVlZHMgdG8gYmUgc2VudCBvdXQgaW50byBhIERNIHJvb20gd2l0aCB0aGUgZ2l2ZW5cbiAgICAgKiB1c2VyLlxuICAgICAqXG4gICAgICogQWZ0ZXIgdGhlIGNvbnRlbnQgaGFzIGJlZW4gc2VudCBvdXQgYSBWZXJpZmljYXRpb25SZXF1ZXN0IGNhbiBiZSBzdGFydGVkXG4gICAgICogd2l0aCB0aGUgYHJlcXVlc3RfdmVyaWZpY2F0aW9uYCBtZXRob2QuXG4gICAgICogQHBhcmFtIHthbnlbXSB8IHVuZGVmaW5lZH0gW21ldGhvZHNdXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB2ZXJpZmljYXRpb25SZXF1ZXN0Q29udGVudChtZXRob2RzKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDNfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkM18xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKG1ldGhvZHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKG1ldGhvZHMsIHdhc20uX193YmluZGdlbl9tYWxsb2MpO1xuICAgICAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLm90aGVydXNlcmlkZW50aXR5X3ZlcmlmaWNhdGlvblJlcXVlc3RDb250ZW50KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciBwdHIyID0gcmV0WzBdO1xuICAgICAgICAgICAgdmFyIGxlbjIgPSByZXRbMV07XG4gICAgICAgICAgICBpZiAocmV0WzNdKSB7XG4gICAgICAgICAgICAgICAgcHRyMiA9IDA7IGxlbjIgPSAwO1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZDNfMCA9IHB0cjI7XG4gICAgICAgICAgICBkZWZlcnJlZDNfMSA9IGxlbjI7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjIsIGxlbjIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQzXzAsIGRlZmVycmVkM18xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1hc3RlciBrZXkgb2YgdGhlIGlkZW50aXR5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IG1hc3RlcktleSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLm90aGVydXNlcmlkZW50aXR5X21hc3RlcktleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcHRyMSA9IHJldFswXTtcbiAgICAgICAgICAgIHZhciBsZW4xID0gcmV0WzFdO1xuICAgICAgICAgICAgaWYgKHJldFszXSkge1xuICAgICAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWQyXzAgPSBwdHIxO1xuICAgICAgICAgICAgZGVmZXJyZWQyXzEgPSBsZW4xO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIxLCBsZW4xKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMl8wLCBkZWZlcnJlZDJfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzZWxmLXNpZ25pbmcga2V5IG9mIHRoZSBpZGVudGl0eS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBzZWxmU2lnbmluZ0tleSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLm90aGVydXNlcmlkZW50aXR5X3NlbGZTaWduaW5nS2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciBwdHIxID0gcmV0WzBdO1xuICAgICAgICAgICAgdmFyIGxlbjEgPSByZXRbMV07XG4gICAgICAgICAgICBpZiAocmV0WzNdKSB7XG4gICAgICAgICAgICAgICAgcHRyMSA9IDA7IGxlbjEgPSAwO1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZDJfMCA9IHB0cjE7XG4gICAgICAgICAgICBkZWZlcnJlZDJfMSA9IGxlbjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjEsIGxlbjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQyXzAsIGRlZmVycmVkMl8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQaW4gdGhlIGN1cnJlbnQgaWRlbnRpdHkgKHB1YmxpYyBwYXJ0IG9mIHRoZSBtYXN0ZXIgc2lnbmluZyBrZXkpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcGluQ3VycmVudE1hc3RlcktleSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdGhlcnVzZXJpZGVudGl0eV9waW5DdXJyZW50TWFzdGVyS2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFzIHRoZSBpZGVudGl0eSBjaGFuZ2VkIGluIGEgd2F5IHRoYXQgcmVxdWlyZXMgYXBwcm92YWwgZnJvbSB0aGUgdXNlcj9cbiAgICAgKlxuICAgICAqIEEgdXNlciBpZGVudGl0eSBuZWVkcyBhcHByb3ZhbCBpZiBpdCBjaGFuZ2VkIGFmdGVyIHRoZSBjcnlwdG8gbWFjaGluZVxuICAgICAqIGhhcyBhbHJlYWR5IG9ic2VydmVkIChcInBpbm5lZFwiKSBhIGRpZmZlcmVudCBpZGVudGl0eSBmb3IgdGhhdCB1c2VyLFxuICAgICAqIHVubGVzcyBpdCBpcyBhbiBleHBsaWNpdGx5IHZlcmlmaWVkIGlkZW50aXR5ICh1c2luZyBmb3IgZXhhbXBsZVxuICAgICAqIGludGVyYWN0aXZlIHZlcmlmaWNhdGlvbikuXG4gICAgICpcbiAgICAgKiBUaGlzIHNpdHVhdGlvbiBjYW4gYmUgcmVzb2x2ZWQgYnk6XG4gICAgICpcbiAgICAgKiAtIFZlcmlmeWluZyB0aGUgbmV3IGlkZW50aXR5IHdpdGgge0BsaW5rIHJlcXVlc3RWZXJpZmljYXRpb259LCBvcjpcbiAgICAgKiAtIFVwZGF0aW5nIHRoZSBwaW4gdG8gdGhlIG5ldyBpZGVudGl0eSB3aXRoIHtAbGluayBwaW5DdXJyZW50TWFzdGVyS2V5fS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpZGVudGl0eU5lZWRzVXNlckFwcHJvdmFsKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm90aGVydXNlcmlkZW50aXR5X2lkZW50aXR5TmVlZHNVc2VyQXBwcm92YWwodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHdlIHZlcmlmaWVkIHRoaXMgaWRlbnRpdHkgKHdpdGggYW55IG93biBpZGVudGl0eSwgYXQgYW55XG4gICAgICogcG9pbnQpLlxuICAgICAqXG4gICAgICogVG8gc2V0IHRoaXMgbGF0Y2ggYmFjayB0byBmYWxzZSwgY2FsbCB7QGxpbmsgd2l0aGRyYXdWZXJpZmljYXRpb259LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHdhc1ByZXZpb3VzbHlWZXJpZmllZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdGhlcnVzZXJpZGVudGl0eV93YXNQcmV2aW91c2x5VmVyaWZpZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHJlcXVpcmVtZW50IGZvciB0aGlzIGlkZW50aXR5IHRvIGJlIHZlcmlmaWVkLlxuICAgICAqXG4gICAgICogSWYgYW4gaWRlbnRpdHkgd2FzIHByZXZpb3VzbHkgdmVyaWZpZWQgYW5kIGlzIG5vdCBhbnltb3JlIGl0IHdpbGwgYmVcbiAgICAgKiByZXBvcnRlZCB0byB0aGUgdXNlci4gSW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgbm90aWNlIHVzZXJzIGhhdmUgdG9cbiAgICAgKiB2ZXJpZnkgYWdhaW4gb3IgdG8gd2l0aGRyYXcgdGhlIHZlcmlmaWNhdGlvbiByZXF1aXJlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHdpdGhkcmF3VmVyaWZpY2F0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm90aGVydXNlcmlkZW50aXR5X3dpdGhkcmF3VmVyaWZpY2F0aW9uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FzIHRoaXMgaWRlbnRpdHkgdmVyaWZpZWQgc2luY2UgaW5pdGlhbCBvYnNlcnZhdGlvbiBhbmQgaXMgbm90IGFueW1vcmU/XG4gICAgICpcbiAgICAgKiBTdWNoIGEgdmlvbGF0aW9uIHNob3VsZCBiZSByZXBvcnRlZCB0byB0aGUgbG9jYWwgdXNlciBieSB0aGVcbiAgICAgKiBhcHBsaWNhdGlvbiwgYW5kIHJlc29sdmVkIGJ5XG4gICAgICpcbiAgICAgKiAtIFZlcmlmeWluZyB0aGUgbmV3IGlkZW50aXR5IHdpdGgge0BsaW5rIHJlcXVlc3RWZXJpZmljYXRpb259LCBvcjpcbiAgICAgKiAtIFdpdGhkcmF3aW5nIHRoZSB2ZXJpZmljYXRpb24gcmVxdWlyZW1lbnQgd2l0aCB7QGxpbmtcbiAgICAgKiAgIHdpdGhkcmF3VmVyaWZpY2F0aW9ufS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNWZXJpZmljYXRpb25WaW9sYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3RoZXJ1c2VyaWRlbnRpdHlfaGFzVmVyaWZpY2F0aW9uVmlvbGF0aW9uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG59XG5cbmNvbnN0IE91dGJvdW5kQ3JlYXRpb25SZXN1bHRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfb3V0Ym91bmRjcmVhdGlvbnJlc3VsdF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBUaGUgcmVzdWx0IG9mIGFuIG91dGJvdW5kIEVDSUVTIGNoYW5uZWwgZXN0YWJsaXNobWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIE91dGJvdW5kQ3JlYXRpb25SZXN1bHQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE91dGJvdW5kQ3JlYXRpb25SZXN1bHQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgT3V0Ym91bmRDcmVhdGlvblJlc3VsdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBPdXRib3VuZENyZWF0aW9uUmVzdWx0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19vdXRib3VuZGNyZWF0aW9ucmVzdWx0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGVzdGFibGlzaGVkIEVDSUVTIGNoYW5uZWwuXG4gICAgICogQHJldHVybnMge0VzdGFibGlzaGVkRWNpZXN9XG4gICAgICovXG4gICAgZ2V0IGNoYW5uZWwoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2luYm91bmRjcmVhdGlvbnJlc3VsdF9jaGFubmVsKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEVzdGFibGlzaGVkRWNpZXMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBlc3RhYmxpc2hlZCBFQ0lFUyBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB7RXN0YWJsaXNoZWRFY2llc30gYXJnMFxuICAgICAqL1xuICAgIHNldCBjaGFubmVsKGFyZzApIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFyZzAsIEVzdGFibGlzaGVkRWNpZXMpO1xuICAgICAgICB2YXIgcHRyMCA9IGFyZzAuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2luYm91bmRjcmVhdGlvbnJlc3VsdF9jaGFubmVsKHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGluaXRpYWwgZW5jcnlwdGVkIG1lc3NhZ2UuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgaW5pdGlhbF9tZXNzYWdlKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X291dGJvdW5kY3JlYXRpb25yZXN1bHRfaW5pdGlhbF9tZXNzYWdlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcmV0WzBdO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByZXRbMV07XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGluaXRpYWwgZW5jcnlwdGVkIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgaW5pdGlhbF9tZXNzYWdlKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfYmFja3Vwc2VjcmV0c2J1bmRsZV9rZXkodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbn1cblxuY29uc3QgT3duVXNlcklkZW50aXR5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX293bnVzZXJpZGVudGl0eV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBTdHJ1Y3QgcmVwcmVzZW50aW5nIGEgY3Jvc3Mgc2lnbmluZyBpZGVudGl0eSBvZiBhIHVzZXIuXG4gKlxuICogVGhpcyBpcyB0aGUgdXNlciBpZGVudGl0eSBvZiBhIHVzZXIgdGhhdCBpcyBvdXIgb3duLlxuICovXG5leHBvcnQgY2xhc3MgT3duVXNlcklkZW50aXR5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShPd25Vc2VySWRlbnRpdHkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgT3duVXNlcklkZW50aXR5RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE93blVzZXJJZGVudGl0eUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfb3dudXNlcmlkZW50aXR5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhpcyB1c2VyIGlkZW50aXR5IHZlcmlmaWVkP1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzVmVyaWZpZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3dudXNlcmlkZW50aXR5X2lzVmVyaWZpZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrIG91ciB1c2VyIGlkZW50aXR5IGFzIHZlcmlmaWVkLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIG1hcmsgdGhlIGlkZW50aXR5IGxvY2FsbHkgYXMgdmVyaWZpZWQgYW5kIHNpZ24gaXQgd2l0aCBvdXIgb3duXG4gICAgICogZGV2aWNlLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIHNpZ25hdHVyZSB1cGxvYWQgcmVxdWVzdCB0aGF0IG5lZWRzIHRvIGJlIHNlbnQgb3V0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgdmVyaWZ5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm93bnVzZXJpZGVudGl0eV92ZXJpZnkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgdmVyaWZpY2F0aW9uIHJlcXVlc3QgdG8gb3VyIG90aGVyIGRldmljZXMuXG4gICAgICogQHBhcmFtIHthbnlbXSB8IHVuZGVmaW5lZH0gW21ldGhvZHNdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICByZXF1ZXN0VmVyaWZpY2F0aW9uKG1ldGhvZHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKG1ldGhvZHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKG1ldGhvZHMsIHdhc20uX193YmluZGdlbl9tYWxsb2MpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vd251c2VyaWRlbnRpdHlfcmVxdWVzdFZlcmlmaWNhdGlvbih0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgb3VyIHVzZXIgaWRlbnRpdHkgdHJ1c3Qgb3VyIG93biBkZXZpY2UsIGkuZS4gaGF2ZSB3ZSBzaWduZWQgb3VyIG93blxuICAgICAqIGRldmljZSBrZXlzIHdpdGggb3VyIHNlbGYtc2lnbmluZyBrZXk/XG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICB0cnVzdHNPdXJPd25EZXZpY2UoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3dudXNlcmlkZW50aXR5X3RydXN0c091ck93bkRldmljZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWFzdGVyIGtleSBvZiB0aGUgaWRlbnRpdHkuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbWFzdGVyS2V5KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3dudXNlcmlkZW50aXR5X21hc3RlcktleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcHRyMSA9IHJldFswXTtcbiAgICAgICAgICAgIHZhciBsZW4xID0gcmV0WzFdO1xuICAgICAgICAgICAgaWYgKHJldFszXSkge1xuICAgICAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWQyXzAgPSBwdHIxO1xuICAgICAgICAgICAgZGVmZXJyZWQyXzEgPSBsZW4xO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIxLCBsZW4xKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMl8wLCBkZWZlcnJlZDJfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzZWxmLXNpZ25pbmcga2V5IG9mIHRoZSBpZGVudGl0eS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBzZWxmU2lnbmluZ0tleSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLm93bnVzZXJpZGVudGl0eV9zZWxmU2lnbmluZ0tleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcHRyMSA9IHJldFswXTtcbiAgICAgICAgICAgIHZhciBsZW4xID0gcmV0WzFdO1xuICAgICAgICAgICAgaWYgKHJldFszXSkge1xuICAgICAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWQyXzAgPSBwdHIxO1xuICAgICAgICAgICAgZGVmZXJyZWQyXzEgPSBsZW4xO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIxLCBsZW4xKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMl8wLCBkZWZlcnJlZDJfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1c2VyLXNpZ25pbmcga2V5IG9mIHRoZSBpZGVudGl0eS4gVGhpcyBpcyBvbmx5IHByZXNlbnQgZm9yIG91clxuICAgICAqIG93biB1c2VyIGlkZW50aXR5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHVzZXJTaWduaW5nS2V5KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3dudXNlcmlkZW50aXR5X3VzZXJTaWduaW5nS2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciBwdHIxID0gcmV0WzBdO1xuICAgICAgICAgICAgdmFyIGxlbjEgPSByZXRbMV07XG4gICAgICAgICAgICBpZiAocmV0WzNdKSB7XG4gICAgICAgICAgICAgICAgcHRyMSA9IDA7IGxlbjEgPSAwO1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZDJfMCA9IHB0cjE7XG4gICAgICAgICAgICBkZWZlcnJlZDJfMSA9IGxlbjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjEsIGxlbjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQyXzAsIGRlZmVycmVkMl8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHdlIHZlcmlmaWVkIG91ciBvd24gaWRlbnRpdHkgYXQgc29tZSBwb2ludCBpbiB0aGUgcGFzdC5cbiAgICAgKlxuICAgICAqIFRvIHJlc2V0IHRoaXMgbGF0Y2ggYmFjayB0byBgZmFsc2VgLCBjYWxsIHtAbGluayB3aXRoZHJhd1ZlcmlmaWNhdGlvbn0uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgd2FzUHJldmlvdXNseVZlcmlmaWVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm93bnVzZXJpZGVudGl0eV93YXNQcmV2aW91c2x5VmVyaWZpZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHJlcXVpcmVtZW50IGZvciB0aGlzIGlkZW50aXR5IHRvIGJlIHZlcmlmaWVkLlxuICAgICAqXG4gICAgICogSWYgYW4gaWRlbnRpdHkgd2FzIHByZXZpb3VzbHkgdmVyaWZpZWQgYW5kIGlzIG5vdCBhbnkgbG9uZ2VyLCBpdCB3aWxsIGJlXG4gICAgICogcmVwb3J0ZWQgdG8gdGhlIHVzZXIuIEluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIG5vdGljZSB1c2VycyBoYXZlIHRvXG4gICAgICogdmVyaWZ5IGFnYWluIG9yIHRvIHdpdGhkcmF3IHRoZSB2ZXJpZmljYXRpb24gcmVxdWlyZW1lbnQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICB3aXRoZHJhd1ZlcmlmaWNhdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vd251c2VyaWRlbnRpdHlfd2l0aGRyYXdWZXJpZmljYXRpb24odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYXMgdGhpcyBpZGVudGl0eSB2ZXJpZmllZCBzaW5jZSBpbml0aWFsIG9ic2VydmF0aW9uIGFuZCBpcyBub3QgYW55bW9yZT9cbiAgICAgKlxuICAgICAqIFN1Y2ggYSB2aW9sYXRpb24gc2hvdWxkIGJlIHJlcG9ydGVkIHRvIHRoZSBsb2NhbCB1c2VyIGJ5IHRoZVxuICAgICAqIGFwcGxpY2F0aW9uLCBhbmQgcmVzb2x2ZWQgYnlcbiAgICAgKlxuICAgICAqIC0gVmVyaWZ5aW5nIHRoZSBuZXcgaWRlbnRpdHkgd2l0aCB7QGxpbmsgcmVxdWVzdFZlcmlmaWNhdGlvbn0sIG9yOlxuICAgICAqIC0gV2l0aGRyYXdpbmcgdGhlIHZlcmlmaWNhdGlvbiByZXF1aXJlbWVudCB3aXRoIHtAbGlua1xuICAgICAqICAgd2l0aGRyYXdWZXJpZmljYXRpb259LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1ZlcmlmaWNhdGlvblZpb2xhdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vd251c2VyaWRlbnRpdHlfaGFzVmVyaWZpY2F0aW9uVmlvbGF0aW9uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG59XG5cbmNvbnN0IFBpY2tsZWRJbmJvdW5kR3JvdXBTZXNzaW9uRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3BpY2tsZWRpbmJvdW5kZ3JvdXBzZXNzaW9uX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEEgcGlja2xlZCB2ZXJzaW9uIG9mIGFuIGBJbmJvdW5kR3JvdXBTZXNzaW9uYC5cbiAqXG4gKiBIb2xkcyBhbGwgdGhlIGluZm9ybWF0aW9uIHRoYXQgbmVlZHMgdG8gYmUgc3RvcmVkIGluIGEgZGF0YWJhc2UgdG8gcmVzdG9yZVxuICogYW4gSW5ib3VuZEdyb3VwU2Vzc2lvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFBpY2tsZWRJbmJvdW5kR3JvdXBTZXNzaW9uIHtcblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBQaWNrbGVkSW5ib3VuZEdyb3VwU2Vzc2lvbikpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUGlja2xlZEluYm91bmRHcm91cFNlc3Npb25GaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3BpY2tsZWRpbmJvdW5kZ3JvdXBzZXNzaW9uX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHBpY2tsZSBzdHJpbmcgaG9sZGluZyB0aGUgTWVnb2xtIFNlc3Npb24sIGFzIHJldHVybmVkIGJ5XG4gICAgICogYG9sbV9waWNrbGVfaW5ib3VuZF9ncm91cF9zZXNzaW9uYCBpbiBsaWJvbG0uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgcGlja2xlKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3BpY2tsZWRpbmJvdW5kZ3JvdXBzZXNzaW9uX3BpY2tsZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwaWNrbGUgc3RyaW5nIGhvbGRpbmcgdGhlIE1lZ29sbSBTZXNzaW9uLCBhcyByZXR1cm5lZCBieVxuICAgICAqIGBvbG1fcGlja2xlX2luYm91bmRfZ3JvdXBfc2Vzc2lvbmAgaW4gbGlib2xtLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHBpY2tsZShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2JhY2t1cHNlY3JldHNidW5kbGVfa2V5KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHB1YmxpYyBjdXJ2ZTI1NTE5IGtleSBvZiB0aGUgYWNjb3VudCB0aGF0IHNlbnQgdXMgdGhlIHNlc3Npb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgc2VuZGVyS2V5KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3BpY2tsZWRpbmJvdW5kZ3JvdXBzZXNzaW9uX3NlbmRlcktleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwdWJsaWMgY3VydmUyNTUxOSBrZXkgb2YgdGhlIGFjY291bnQgdGhhdCBzZW50IHVzIHRoZSBzZXNzaW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHNlbmRlcktleShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2JhY2t1cHNlY3JldHNidW5kbGVfYmFja3VwX3ZlcnNpb24odGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcHVibGljIGVkMjU1MTkga2V5IG9mIHRoZSBhY2NvdW50IHRoYXQgaXMgYmVsaWV2ZWQgdG8gaGF2ZSBpbml0aWF0ZWRcbiAgICAgKiB0aGUgc2Vzc2lvbiwgaWYga25vd24uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc2Vzc2lvbiB3YXMgcmVjZWl2ZWQgZGlyZWN0bHkgZnJvbSB0aGUgY3JlYXRvciB2aWEgYW5cbiAgICAgKiBPbG0tZW5jcnlwdGVkIGBtLnJvb21fa2V5YCBldmVudCwgdGhpcyB2YWx1ZSBpcyB0YWtlbiBmcm9tIHRoZSBga2V5c2BcbiAgICAgKiBwcm9wZXJ0eSBvZiB0aGUgcGxhaW50ZXh0IHBheWxvYWQgb2YgdGhhdCBldmVudCAoc2VlXG4gICAgICogW2BtLm9sbS52MS5jdXJ2ZTI1NTE5LWFlcy1zaGEyYF0pLlxuICAgICAqXG4gICAgICogSWYgdGhlIHNlc3Npb24gd2FzIGZvcndhcmRlZCB0byB1cyB1c2luZyBhbiBbYG0uZm9yd2FyZGVkX3Jvb21fa2V5YF0sXG4gICAgICogdGhpcyB2YWx1ZSBpcyBhIGNvcHkgb2YgdGhlIGBzZW5kZXJfY2xhaW1lZF9lZDI1NTE5X2tleWAgZnJvbSB0aGVcbiAgICAgKiBjb250ZW50IG9mIHRoZSBldmVudC5cbiAgICAgKlxuICAgICAqIFtgbS5vbG0udjEuY3VydmUyNTUxOS1hZXMtc2hhMmBdOiBodHRwczovL3NwZWMubWF0cml4Lm9yZy92MS45L2NsaWVudC1zZXJ2ZXItYXBpLyNtb2xtdjFjdXJ2ZTI1NTE5LWFlcy1zaGEyXG4gICAgICogW2BtLmZvcndhcmRlZF9yb29tX2tleWBdOiBodHRwczovL3NwZWMubWF0cml4Lm9yZy92MS45L2NsaWVudC1zZXJ2ZXItYXBpLyNtZm9yd2FyZGVkX3Jvb21fa2V5XG4gICAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgc2VuZGVyU2lnbmluZ0tleSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfcGlja2xlZGluYm91bmRncm91cHNlc3Npb25fc2VuZGVyU2lnbmluZ0tleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHJldFswXSAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyZXRbMF0sIHJldFsxXSAqIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHB1YmxpYyBlZDI1NTE5IGtleSBvZiB0aGUgYWNjb3VudCB0aGF0IGlzIGJlbGlldmVkIHRvIGhhdmUgaW5pdGlhdGVkXG4gICAgICogdGhlIHNlc3Npb24sIGlmIGtub3duLlxuICAgICAqXG4gICAgICogSWYgdGhlIHNlc3Npb24gd2FzIHJlY2VpdmVkIGRpcmVjdGx5IGZyb20gdGhlIGNyZWF0b3IgdmlhIGFuXG4gICAgICogT2xtLWVuY3J5cHRlZCBgbS5yb29tX2tleWAgZXZlbnQsIHRoaXMgdmFsdWUgaXMgdGFrZW4gZnJvbSB0aGUgYGtleXNgXG4gICAgICogcHJvcGVydHkgb2YgdGhlIHBsYWludGV4dCBwYXlsb2FkIG9mIHRoYXQgZXZlbnQgKHNlZVxuICAgICAqIFtgbS5vbG0udjEuY3VydmUyNTUxOS1hZXMtc2hhMmBdKS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBzZXNzaW9uIHdhcyBmb3J3YXJkZWQgdG8gdXMgdXNpbmcgYW4gW2BtLmZvcndhcmRlZF9yb29tX2tleWBdLFxuICAgICAqIHRoaXMgdmFsdWUgaXMgYSBjb3B5IG9mIHRoZSBgc2VuZGVyX2NsYWltZWRfZWQyNTUxOV9rZXlgIGZyb20gdGhlXG4gICAgICogY29udGVudCBvZiB0aGUgZXZlbnQuXG4gICAgICpcbiAgICAgKiBbYG0ub2xtLnYxLmN1cnZlMjU1MTktYWVzLXNoYTJgXTogaHR0cHM6Ly9zcGVjLm1hdHJpeC5vcmcvdjEuOS9jbGllbnQtc2VydmVyLWFwaS8jbW9sbXYxY3VydmUyNTUxOS1hZXMtc2hhMlxuICAgICAqIFtgbS5mb3J3YXJkZWRfcm9vbV9rZXlgXTogaHR0cHM6Ly9zcGVjLm1hdHJpeC5vcmcvdjEuOS9jbGllbnQtc2VydmVyLWFwaS8jbWZvcndhcmRlZF9yb29tX2tleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbYXJnMF1cbiAgICAgKi9cbiAgICBzZXQgc2VuZGVyU2lnbmluZ0tleShhcmcwKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShhcmcwKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9iYXNlbWlncmF0aW9uZGF0YV9iYWNrdXBSZWNvdmVyeUtleSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBpZCBvZiB0aGUgcm9vbSB0aGF0IHRoZSBzZXNzaW9uIGlzIHVzZWQgaW4uXG4gICAgICpcbiAgICAgKiBOdWxsYWJsZSBzbyB0aGF0IGEgYFBpY2tsZWRJbmJvdW5kR3JvdXBTZXNzaW9uYCBjYW4gYmUgY29uc3RydWN0ZWRcbiAgICAgKiBpbmNyZW1lbnRhbGx5LiBNdXN0IGJlIHBvcHVsYXRlZCFcbiAgICAgKiBAcmV0dXJucyB7Um9vbUlkIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCByb29tSWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3BpY2tsZWRpbmJvdW5kZ3JvdXBzZXNzaW9uX3Jvb21JZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSb29tSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBpZCBvZiB0aGUgcm9vbSB0aGF0IHRoZSBzZXNzaW9uIGlzIHVzZWQgaW4uXG4gICAgICpcbiAgICAgKiBOdWxsYWJsZSBzbyB0aGF0IGEgYFBpY2tsZWRJbmJvdW5kR3JvdXBTZXNzaW9uYCBjYW4gYmUgY29uc3RydWN0ZWRcbiAgICAgKiBpbmNyZW1lbnRhbGx5LiBNdXN0IGJlIHBvcHVsYXRlZCFcbiAgICAgKiBAcGFyYW0ge1Jvb21JZCB8IHVuZGVmaW5lZH0gW2FyZzBdXG4gICAgICovXG4gICAgc2V0IHJvb21JZChhcmcwKSB7XG4gICAgICAgIGxldCBwdHIwID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGFyZzApKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYXJnMCwgUm9vbUlkKTtcbiAgICAgICAgICAgIHB0cjAgPSBhcmcwLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3BpY2tsZWRpbmJvdW5kZ3JvdXBzZXNzaW9uX3Jvb21JZCh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsYWcgcmVtZW1iZXJpbmcgaWYgdGhlIHNlc3Npb24gd2FzIGRpcmVjdGx5IHNlbnQgdG8gdXMgYnkgdGhlIHNlbmRlclxuICAgICAqIG9yIGlmIGl0IHdhcyBpbXBvcnRlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgaW1wb3J0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3BpY2tsZWRpbmJvdW5kZ3JvdXBzZXNzaW9uX2ltcG9ydGVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxhZyByZW1lbWJlcmluZyBpZiB0aGUgc2Vzc2lvbiB3YXMgZGlyZWN0bHkgc2VudCB0byB1cyBieSB0aGUgc2VuZGVyXG4gICAgICogb3IgaWYgaXQgd2FzIGltcG9ydGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJnMFxuICAgICAqL1xuICAgIHNldCBpbXBvcnRlZChhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3BpY2tsZWRpbmJvdW5kZ3JvdXBzZXNzaW9uX2ltcG9ydGVkKHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxhZyByZW1lbWJlcmluZyBpZiB0aGUgc2Vzc2lvbiBoYXMgYmVlbiBiYWNrZWQgdXAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGJhY2tlZFVwKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9waWNrbGVkaW5ib3VuZGdyb3Vwc2Vzc2lvbl9iYWNrZWRVcCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsYWcgcmVtZW1iZXJpbmcgaWYgdGhlIHNlc3Npb24gaGFzIGJlZW4gYmFja2VkIHVwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJnMFxuICAgICAqL1xuICAgIHNldCBiYWNrZWRVcChhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3BpY2tsZWRpbmJvdW5kZ3JvdXBzZXNzaW9uX2JhY2tlZFVwKHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGBQaWNrbGVkSW5ib3VuZEdyb3VwU2Vzc2lvbmAsIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucGlja2xlZGluYm91bmRncm91cHNlc3Npb25fbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBQaWNrbGVkSW5ib3VuZEdyb3VwU2Vzc2lvbkZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuY29uc3QgUGlja2xlZFNlc3Npb25GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcGlja2xlZHNlc3Npb25fZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQSBwaWNrbGVkIHZlcnNpb24gb2YgYSBgU2Vzc2lvbmAuXG4gKlxuICogSG9sZHMgYWxsIHRoZSBpbmZvcm1hdGlvbiB0aGF0IG5lZWRzIHRvIGJlIHN0b3JlZCBpbiBhIGRhdGFiYXNlIHRvIHJlc3RvcmVcbiAqIGFuIE9sbSBTZXNzaW9uLiBDYW4gYmUgaW1wb3J0ZWQgaW50byB0aGUgcnVzdCBzdG9yZSB3aXRoIHtAbGlua1xuICogI21pZ3JhdGVPbG1TZXNzaW9uc30uXG4gKi9cbmV4cG9ydCBjbGFzcyBQaWNrbGVkU2Vzc2lvbiB7XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgUGlja2xlZFNlc3Npb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFBpY2tsZWRTZXNzaW9uRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19waWNrbGVkc2Vzc2lvbl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwaWNrbGUgc3RyaW5nIGhvbGRpbmcgdGhlIE9sbSBTZXNzaW9uLCBhcyByZXR1cm5lZCBieVxuICAgICAqIGBvbG1fcGlja2xlX3Nlc3Npb25gIGluIGxpYm9sbS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBwaWNrbGUoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfcGlja2xlZHNlc3Npb25fcGlja2xlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcmV0WzBdO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByZXRbMV07XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHBpY2tsZSBzdHJpbmcgaG9sZGluZyB0aGUgT2xtIFNlc3Npb24sIGFzIHJldHVybmVkIGJ5XG4gICAgICogYG9sbV9waWNrbGVfc2Vzc2lvbmAgaW4gbGlib2xtLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHBpY2tsZShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2JhY2t1cHNlY3JldHNidW5kbGVfa2V5KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJhc2U2NC1lbmNvZGVkIHB1YmxpYyBjdXJ2ZTI1NTE5IGtleSBvZiB0aGUgb3RoZXIgdXNlciB0aGF0IHdlIHNoYXJlXG4gICAgICogdGhpcyBzZXNzaW9uIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgc2VuZGVyS2V5KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3BpY2tsZWRzZXNzaW9uX3NlbmRlcktleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlNjQtZW5jb2RlZCBwdWJsaWMgY3VydmUyNTUxOSBrZXkgb2YgdGhlIG90aGVyIHVzZXIgdGhhdCB3ZSBzaGFyZVxuICAgICAqIHRoaXMgc2Vzc2lvbiB3aXRoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHNlbmRlcktleShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2JhY2t1cHNlY3JldHNidW5kbGVfYmFja3VwX3ZlcnNpb24odGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYXMgdGhlIHNlc3Npb24gY3JlYXRlZCB1c2luZyBhIGZhbGxiYWNrIGtleT9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY3JlYXRlZFVzaW5nRmFsbGJhY2tLZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3BpY2tsZWRzZXNzaW9uX2NyZWF0ZWRVc2luZ0ZhbGxiYWNrS2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FzIHRoZSBzZXNzaW9uIGNyZWF0ZWQgdXNpbmcgYSBmYWxsYmFjayBrZXk/XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcmcwXG4gICAgICovXG4gICAgc2V0IGNyZWF0ZWRVc2luZ0ZhbGxiYWNrS2V5KGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfcGlja2xlZHNlc3Npb25fY3JlYXRlZFVzaW5nRmFsbGJhY2tLZXkodGhpcy5fX3diZ19wdHIsIGFyZzApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBzZXNzaW9uIHdhcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIHtEYXRlfVxuICAgICAqL1xuICAgIGdldCBjcmVhdGlvblRpbWUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3BpY2tsZWRzZXNzaW9uX2NyZWF0aW9uVGltZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHNlc3Npb24gd2FzIGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHtEYXRlfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGNyZWF0aW9uVGltZShhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3BpY2tsZWRzZXNzaW9uX2NyZWF0aW9uVGltZSh0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHNlc3Npb24gd2FzIGxhc3QgdXNlZC5cbiAgICAgKiBAcmV0dXJucyB7RGF0ZX1cbiAgICAgKi9cbiAgICBnZXQgbGFzdFVzZVRpbWUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3BpY2tsZWRzZXNzaW9uX2xhc3RVc2VUaW1lKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgc2Vzc2lvbiB3YXMgbGFzdCB1c2VkLlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBsYXN0VXNlVGltZShhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3BpY2tsZWRzZXNzaW9uX2xhc3RVc2VUaW1lKHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGBQaWNrbGVkU2Vzc2lvbmAsIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucGlja2xlZHNlc3Npb25fbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBQaWNrbGVkU2Vzc2lvbkZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuY29uc3QgUHV0RGVoeWRyYXRlZERldmljZVJlcXVlc3RGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcHV0ZGVoeWRyYXRlZGRldmljZXJlcXVlc3RfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQSByZXF1ZXN0IHRoYXQgd2lsbCB1cGxvYWQgYSBkZWh5ZHJhdGVkIGRldmljZSB0byB0aGUgc2VydmVyLlxuICovXG5leHBvcnQgY2xhc3MgUHV0RGVoeWRyYXRlZERldmljZVJlcXVlc3Qge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFB1dERlaHlkcmF0ZWREZXZpY2VSZXF1ZXN0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFB1dERlaHlkcmF0ZWREZXZpY2VSZXF1ZXN0RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFB1dERlaHlkcmF0ZWREZXZpY2VSZXF1ZXN0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19wdXRkZWh5ZHJhdGVkZGV2aWNlcmVxdWVzdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgSlNPTi1lbmNvZGVkIHN0cmluZyBjb250YWluaW5nIHRoZSByZXN0IG9mIHRoZSBwYXlsb2FkOiBgcm9vbXNgLlxuICAgICAqXG4gICAgICogSXQgcmVwcmVzZW50cyB0aGUgYm9keSBvZiB0aGUgSFRUUCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3B1dGRlaHlkcmF0ZWRkZXZpY2VyZXF1ZXN0X2JvZHkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYFB1dERlaHlkcmF0ZWREZXZpY2VSZXF1ZXN0YFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBib2R5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYm9keSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnB1dGRlaHlkcmF0ZWRkZXZpY2VyZXF1ZXN0X25ldyhib2R5KTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIFB1dERlaHlkcmF0ZWREZXZpY2VSZXF1ZXN0RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5jb25zdCBRckZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19xcl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBRUiBjb2RlIGJhc2VkIHZlcmlmaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFFyIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShRci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBRckZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBRckZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcXJfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyByZXF1ZXN0LlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIGBRclN0YXRlYC5cbiAgICAgKiBAcmV0dXJucyB7UXJTdGF0ZX1cbiAgICAgKi9cbiAgICBzdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5xcl9zdGF0ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhcyB0aGUgUVIgdmVyaWZpY2F0aW9uIGJlZW4gc2Nhbm5lZCBieSB0aGUgb3RoZXIgc2lkZS5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIHZlcmlmaWNhdGlvbiBvYmplY3QgaXMgaW4gdGhpcyBzdGF0ZSBpdOKAmXMgcmVxdWlyZWRcbiAgICAgKiB0aGF0IHRoZSB1c2VyIGNvbmZpcm1zIHRoYXQgdGhlIG90aGVyIHNpZGUgaGFzIHNjYW5uZWQgdGhlIFFSXG4gICAgICogY29kZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNCZWVuU2Nhbm5lZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5xcl9oYXNCZWVuU2Nhbm5lZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhcyB0aGUgc2Nhbm5pbmcgb2YgdGhlIFFSIGNvZGUgYmVlbiBjb25maXJtZWQgYnkgdXM/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzQmVlbkNvbmZpcm1lZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5xcl9oYXNCZWVuQ29uZmlybWVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG91ciBvd24gdXNlciBJRC5cbiAgICAgKiBAcmV0dXJucyB7VXNlcklkfVxuICAgICAqL1xuICAgIGdldCB1c2VySWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJfdXNlcklkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFVzZXJJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1c2VyIGlkIG9mIHRoZSBvdGhlciB1c2VyIHRoYXQgaXMgcGFydGljaXBhdGluZyBpblxuICAgICAqIHRoaXMgdmVyaWZpY2F0aW9uIGZsb3cuXG4gICAgICogQHJldHVybnMge1VzZXJJZH1cbiAgICAgKi9cbiAgICBnZXQgb3RoZXJVc2VySWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJfb3RoZXJVc2VySWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVXNlcklkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRldmljZSBJRCBvZiB0aGUgb3RoZXIgc2lkZS5cbiAgICAgKiBAcmV0dXJucyB7RGV2aWNlSWR9XG4gICAgICovXG4gICAgZ2V0IG90aGVyRGV2aWNlSWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJfb3RoZXJEZXZpY2VJZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBEZXZpY2VJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlkIHdlIGluaXRpYXRlIHRoZSB2ZXJpZmljYXRpb24gcmVxdWVzdD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB3ZVN0YXJ0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJfd2VTdGFydGVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGluZm8gYWJvdXQgdGhlIGNhbmNlbGxhdGlvbiBpZiB0aGUgdmVyaWZpY2F0aW9uIGZsb3cgaGFzXG4gICAgICogYmVlbiBjYW5jZWxsZWQuXG4gICAgICogQHJldHVybnMge0NhbmNlbEluZm8gfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgY2FuY2VsSW5mbygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5xcl9jYW5jZWxJbmZvKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IENhbmNlbEluZm8uX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhcyB0aGUgdmVyaWZpY2F0aW9uIGZsb3cgY29tcGxldGVkP1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRG9uZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5xcl9pc0RvbmUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYXMgdGhlIHZlcmlmaWNhdGlvbiBmbG93IGJlZW4gY2FuY2VsbGVkP1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ2FuY2VsbGVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnFyX2lzQ2FuY2VsbGVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBhIHZlcmlmaWNhdGlvbiB0aGF0IGlzIHZlcmlmeWluZyBvbmUgb2Ygb3VyIG93biBkZXZpY2VzP1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzU2VsZlZlcmlmaWNhdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5xcl9pc1NlbGZWZXJpZmljYXRpb24odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYXZlIHdlIHN1Y2Nlc3NmdWxseSBzY2FubmVkIHRoZSBRUiBjb2RlIGFuZCBhcmUgYWJsZSB0byBzZW5kXG4gICAgICogYSByZWNpcHJvY2F0aW9uIGV2ZW50P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHJlY2lwcm9jYXRlZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5xcl9yZWNpcHJvY2F0ZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVuaXF1ZSBJRCB0aGF0IGlkZW50aWZpZXMgdGhpcyBRUiB2ZXJpZmljYXRpb24gZmxvdyxcbiAgICAgKiBiZSBlaXRoZXIgYSB0by1kZXZpY2UgcmVxdWVzdCBJRCBvciBhIHJvb20gZXZlbnQgSUQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgZmxvd0lkKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJfZmxvd0lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcmV0WzBdO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByZXRbMV07XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByb29tIGlkIGlmIHRoZSB2ZXJpZmljYXRpb24gaXMgaGFwcGVuaW5nIGluc2lkZSBhXG4gICAgICogcm9vbS5cbiAgICAgKiBAcmV0dXJucyB7Um9vbUlkIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCByb29tSWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJfcm9vbUlkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFJvb21JZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBRUiBjb2RlIG9iamVjdCB0aGF0IGlzIHJlcHJlc2VudGluZyB0aGlzXG4gICAgICogdmVyaWZpY2F0aW9uIGZsb3cuXG4gICAgICpcbiAgICAgKiBUaGUgUXJDb2RlIGNhbiB0aGVuIGJlIHJlbmRlcmVkIGFzIGFuIGltYWdlIG9yIGFzIGFuIHVuaWNvZGVcbiAgICAgKiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgYHRvX2J5dGVzYCBtZXRob2QgY2FuIGJlIHVzZWQgdG8gaW5zdGVhZCBvdXRwdXQgdGhlIHJhd1xuICAgICAqIGJ5dGVzIHRoYXQgc2hvdWxkIGJlIGVuY29kZWQgYXMgYSBRUiBjb2RlLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIGBRckNvZGVgLlxuICAgICAqIEByZXR1cm5zIHtRckNvZGV9XG4gICAgICovXG4gICAgdG9RckNvZGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJfdG9RckNvZGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBRckNvZGUuX193cmFwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdGhlIHJhdyBieXRlcyB0aGF0IHNob3VsZCBiZSBlbmNvZGVkIGFzIGEgUVIgY29kZVxuICAgICAqIGlzIHJlcHJlc2VudGluZyB0aGlzIHZlcmlmaWNhdGlvbiBmbG93LlxuICAgICAqXG4gICAgICogVGhlIGB0b19xcl9jb2RlYCBtZXRob2QgY2FuIGJlIHVzZWQgdG8gaW5zdGVhZCBvdXRwdXQgYSBRckNvZGVcbiAgICAgKiBvYmplY3QgdGhhdCBjYW4gYmUgcmVuZGVyZWQuXG4gICAgICogQHJldHVybnMge1VpbnQ4Q2xhbXBlZEFycmF5fVxuICAgICAqL1xuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJfdG9CeXRlcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmeSB0aGUgb3RoZXIgc2lkZSB0aGF0IHdlIGhhdmUgc3VjY2Vzc2Z1bGx5IHNjYW5uZWQgdGhlIFFSXG4gICAgICogY29kZSBhbmQgdGhhdCB0aGUgUVIgdmVyaWZpY2F0aW9uIGZsb3cgY2FuIHN0YXJ0LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIHJldHVybiBzb21lIE91dGdvaW5nQ29udGVudCBpZiB0aGUgb2JqZWN0IGlzIGluIHRoZVxuICAgICAqIGNvcnJlY3Qgc3RhdGUgdG8gc3RhcnQgdGhlIHZlcmlmaWNhdGlvbiBmbG93LCBvdGhlcndpc2UgTm9uZS5cbiAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAqL1xuICAgIHJlY2lwcm9jYXRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnFyX3JlY2lwcm9jYXRlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlybSB0aGF0IHRoZSBvdGhlciBzaWRlIGhhcyBzY2FubmVkIG91ciBRUiBjb2RlLlxuICAgICAqXG4gICAgICogUmV0dXJucyBlaXRoZXIgYW4gYE91dGdvaW5nUmVxdWVzdGAgd2hpY2ggc2hvdWxkIGJlIHNlbnQgb3V0LCBvclxuICAgICAqIGB1bmRlZmluZWRgIGlmIHRoZSB2ZXJpZmljYXRpb24gaXMgYWxyZWFkeSBjb25maXJtZWQuXG4gICAgICogQHJldHVybnMge2FueX1cbiAgICAgKi9cbiAgICBjb25maXJtU2Nhbm5pbmcoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJfY29uZmlybVNjYW5uaW5nKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoZSB2ZXJpZmljYXRpb24gZmxvdy5cbiAgICAgKlxuICAgICAqIFJldHVybnMgZWl0aGVyIGFuIGBPdXRnb2luZ1JlcXVlc3RgIHdoaWNoIHNob3VsZCBiZSBzZW50IG91dCwgb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBpZiB0aGUgdmVyaWZpY2F0aW9uIGlzIGFscmVhZHkgY2FuY2VsbGVkLlxuICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnFyX2NhbmNlbCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbCB0aGUgdmVyaWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBjYW5jZWxzIHRoZSB2ZXJpZmljYXRpb24gd2l0aCBnaXZlbiBjb2RlIChlLmcuIGBtLnVzZXJgKS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgZWl0aGVyIGFuIGBPdXRnb2luZ1JlcXVlc3RgIHdoaWNoIHNob3VsZCBiZSBzZW50IG91dCwgb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBpZiB0aGUgdmVyaWZpY2F0aW9uIGlzIGFscmVhZHkgY2FuY2VsbGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAgICogQHJldHVybnMge2FueX1cbiAgICAgKi9cbiAgICBjYW5jZWxXaXRoQ29kZShjb2RlKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjb2RlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJfY2FuY2VsV2l0aENvZGUodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZXJlIGlzIGFuIHVwZGF0ZSB0b1xuICAgICAqIHRoZSByZXF1ZXN0XG4gICAgICpcbiAgICAgKiBUaGUgYGNhbGxiYWNrYCBpcyBjYWxsZWQgd2l0aCBubyBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgcmVnaXN0ZXJDaGFuZ2VzQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgd2FzbS5xcl9yZWdpc3RlckNoYW5nZXNDYWxsYmFjayh0aGlzLl9fd2JnX3B0ciwgY2FsbGJhY2spO1xuICAgIH1cbn1cblxuY29uc3QgUXJDb2RlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3FyY29kZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBIFFSIGNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBRckNvZGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFFyQ29kZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBRckNvZGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUXJDb2RlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19xcmNvZGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGhlIFFSIGNvZGUgaW50byBhIGBVaW50OENsYW1wZWRBcnJheWAgd2hlcmUgMSByZXByZXNlbnRzIGFcbiAgICAgKiBkYXJrIHBpeGVsIGFuZCAwIGEgd2hpdGUgcGl4ZWwuXG4gICAgICogQHJldHVybnMge1VpbnQ4Q2xhbXBlZEFycmF5fVxuICAgICAqL1xuICAgIHJlbmRlckludG9CdWZmZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJjb2RlX3JlbmRlckludG9CdWZmZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMF0pO1xuICAgIH1cbn1cblxuY29uc3QgUXJDb2RlRGF0YUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19xcmNvZGVkYXRhX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIERhdGEgZm9yIHRoZSBRUiBjb2RlIGxvZ2luIG1lY2hhbmlzbS5cbiAqXG4gKiBUaGUge0BsaW5rIFFyQ29kZURhdGF9IGNhbiBiZSBzZXJpYWxpemVkIGFuZCBlbmNvZGVkIGFzIGEgUVIgY29kZSBvciBpdCBjYW5cbiAqIGJlIGRlY29kZWQgZnJvbSBhIFFSIGNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBRckNvZGVEYXRhIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShRckNvZGVEYXRhLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFFyQ29kZURhdGFGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUXJDb2RlRGF0YUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcXJjb2RlZGF0YV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBuZXcge0BsaW5rIFFyQ29kZURhdGF9IGZyb20gYSBnaXZlbiBwdWJsaWMga2V5LCBhIHJlbmRlenZvdXMgVVJMXG4gICAgICogYW5kLCBvcHRpb25hbGx5LCBhIHNlcnZlciBuYW1lIGZvciB0aGUgaG9tZXNlcnZlci5cbiAgICAgKlxuICAgICAqIElmIGEgc2VydmVyIG5hbWUgaXMgZ2l2ZW4sIHRoZW4gdGhlIHtAbGluayBRckNvZGVEYXRhfSBtb2RlIHdpbGwgYmVcbiAgICAgKiB7QGxpbmsgUXJDb2RlTW9kZS5SZWNpcHJvY2F0ZX0sIGkuZS4gdGhlIFFSIGNvZGUgd2lsbCBjb250YWluIGRhdGEgZm9yXG4gICAgICogdGhlIGV4aXN0aW5nIGRldmljZSB0byBkaXNwbGF5IHRoZSBRUiBjb2RlLlxuICAgICAqXG4gICAgICogSWYgbm8gc2VydmVyIG5hbWUgaXMgZ2l2ZW4sIHRoZSB7QGxpbmsgUXJDb2RlRGF0YX0gbW9kZSB3aWxsIGJlXG4gICAgICoge0BsaW5rIFFyQ29kZU1vZGUuTG9naW59LCBpLmUuIHRoZSBRUiBjb2RlIHdpbGwgY29udGFpbiBkYXRhIGZvciB0aGVcbiAgICAgKiBuZXcgZGV2aWNlIHRvIGRpc3BsYXkgdGhlIFFSIGNvZGUuXG4gICAgICogQHBhcmFtIHtDdXJ2ZTI1NTE5UHVibGljS2V5fSBwdWJsaWNfa2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlbmRlenZvdXNfdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtzZXJ2ZXJfbmFtZV1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWNfa2V5LCByZW5kZXp2b3VzX3VybCwgc2VydmVyX25hbWUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHB1YmxpY19rZXksIEN1cnZlMjU1MTlQdWJsaWNLZXkpO1xuICAgICAgICB2YXIgcHRyMCA9IHB1YmxpY19rZXkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChyZW5kZXp2b3VzX3VybCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMiA9IGlzTGlrZU5vbmUoc2VydmVyX25hbWUpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHNlcnZlcl9uYW1lLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnFyY29kZWRhdGFfbmV3KHB0cjAsIHB0cjEsIGxlbjEsIHB0cjIsIGxlbjIpO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0WzBdID4+PiAwO1xuICAgICAgICBRckNvZGVEYXRhRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gZGVjb2RlIGEgc2xpY2Ugb2YgYnl0ZXMgaW50byBhIHtAbGluayBRckNvZGVEYXRhfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGUgc2xpY2Ugb2YgYnl0ZXMgd291bGQgZ2VuZXJhbGx5IGJlIHJldHVybmVkIGJ5IGEgUVIgY29kZSBkZWNvZGVyLlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7UXJDb2RlRGF0YX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChieXRlcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJjb2RlZGF0YV9mcm9tQnl0ZXMocHRyMCwgbGVuMCk7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFFyQ29kZURhdGEuX193cmFwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUge0BsaW5rIFFyQ29kZURhdGF9IGludG8gYSBsaXN0IG9mIGJ5dGVzLlxuICAgICAqXG4gICAgICogVGhlIGxpc3Qgb2YgYnl0ZXMgY2FuIGJlIHVzZWQgYnkgYSBRUiBjb2RlIGdlbmVyYXRvciB0byBjcmVhdGUgYW4gaW1hZ2VcbiAgICAgKiBjb250YWluaW5nIGEgUVIgY29kZS5cbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0b0J5dGVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnFyY29kZWRhdGFfdG9CeXRlcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHJldFswXSwgcmV0WzFdICogMSwgMSk7XG4gICAgICAgIHJldHVybiB2MTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBkZWNvZGUgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgaW50byBhIHtAbGluayBRckNvZGVEYXRhfVxuICAgICAqIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICAgICAqIEByZXR1cm5zIHtRckNvZGVEYXRhfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmFzZTY0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRhdGEsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5xcmNvZGVkYXRhX2Zyb21CYXNlNjQocHRyMCwgbGVuMCk7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFFyQ29kZURhdGEuX193cmFwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUge0BsaW5rIFFyQ29kZURhdGF9IGludG8gYSBzdHJpbmcgdXNpbmcgYmFzZTY0LlxuICAgICAqXG4gICAgICogVGhpcyBmb3JtYXQgY2FuIGJlIHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBhbmQgdGhlXG4gICAgICogW2BRcmNvZGVEYXRhOjpmcm9tX2Jhc2U2NCgpYF0gbWV0aG9kIGNhbiBiZSB1c2VkIHRvIHBhcnNlIHRoZSBzdHJpbmdcbiAgICAgKiBhZ2Fpbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvQmFzZTY0KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJjb2RlZGF0YV90b0Jhc2U2NCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgQ3VydmUyNTUxOSBwdWJsaWMga2V5IGVtYmVkZGVkIGluIHRoZSB7QGxpbmsgUXJDb2RlRGF0YX0uXG4gICAgICpcbiAgICAgKiBUaGlzIEN1cnZlMjU1MTkgcHVibGljIGtleSBzaG91bGQgYmUgdXNlZCB0byBlc3RhYmxpc2ggYW5cbiAgICAgKiBbRUNJRVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVncmF0ZWRfRW5jcnlwdGlvbl9TY2hlbWUpXG4gICAgICogKEVsbGlwdGljIEN1cnZlIEludGVncmF0ZWQgRW5jcnlwdGlvbiBTY2hlbWUpIGNoYW5uZWwgd2l0aCB0aGUgb3RoZXJcbiAgICAgKiBkZXZpY2UuXG4gICAgICogQHJldHVybnMge0N1cnZlMjU1MTlQdWJsaWNLZXl9XG4gICAgICovXG4gICAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5xcmNvZGVkYXRhX3B1YmxpY0tleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBDdXJ2ZTI1NTE5UHVibGljS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFVSTCBvZiB0aGUgcmVuZGV6dm91cyBzZXJ2ZXIgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGV4Y2hhbmdlXG4gICAgICogbWVzc2FnZXMgYmV0d2VlbiB0aGUgdHdvIGRldmljZXMuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgcmVuZGV6dm91c1VybCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLnFyY29kZWRhdGFfcmVuZGV6dm91c1VybCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2VydmVyIG5hbWUgb2YgdGhlIGhvbWVzZXJ2ZXIgd2hpY2ggdGhlIG5ldyBkZXZpY2Ugd2lsbCBiZVxuICAgICAqIGxvZ2dlZCBpbiB0by5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBiZSBvbmx5IGF2YWlsYWJsZSBpZiB0aGUgZXhpc3RpbmcgZGV2aWNlIGhhcyBnZW5lcmF0ZWQgdGhlIFFSXG4gICAgICogY29kZSBhbmQgdGhlIG5ldyBkZXZpY2UgaXMgdGhlIG9uZSBzY2FubmluZyB0aGUgUVIgY29kZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBzZXJ2ZXJOYW1lKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnFyY29kZWRhdGFfc2VydmVyTmFtZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHJldFswXSAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyZXRbMF0sIHJldFsxXSAqIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtb2RlIG9mIHRoaXMge0BsaW5rIFFyQ29kZURhdGF9IGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtRckNvZGVNb2RlfVxuICAgICAqL1xuICAgIGdldCBtb2RlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnFyY29kZWRhdGFfbW9kZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuXG5jb25zdCBRckNvZGVTY2FuRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3FyY29kZXNjYW5fZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQSBzY2FubmVkIFFSIGNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBRckNvZGVTY2FuIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShRckNvZGVTY2FuLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFFyQ29kZVNjYW5GaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUXJDb2RlU2NhbkZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcXJjb2Rlc2Nhbl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBkZWNvZGVkIHBheWxvYWQgb2YgYSBRUiBjb2RlIGluIGJ5dGUgc2xpY2UgZm9ybS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBpZiB5b3Ugd291bGQgbGlrZSB0byBkbyB5b3VyIG93biBjdXN0b20gUVIgY29kZVxuICAgICAqIGRlY29kaW5nLlxuICAgICAqIEBwYXJhbSB7VWludDhDbGFtcGVkQXJyYXl9IGJ1ZmZlclxuICAgICAqIEByZXR1cm5zIHtRckNvZGVTY2FufVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucXJjb2Rlc2Nhbl9mcm9tQnl0ZXMoYnVmZmVyKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUXJDb2RlU2Nhbi5fX3dyYXAocmV0WzBdKTtcbiAgICB9XG59XG5cbmNvbnN0IFJlaHlkcmF0ZWREZXZpY2VGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmVoeWRyYXRlZGRldmljZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBIHJlaHlkcmF0ZWQgZGV2aWNlXG4gKlxuICogVGhpcyBkZXZpY2UgY2FuIHJlY2VpdmUgdG8tZGV2aWNlIGV2ZW50cyB0byBnZXQgcm9vbSBrZXlzIHRoYXQgd2VyZSBzZW5kIHRvXG4gKiBpdC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlaHlkcmF0ZWREZXZpY2Uge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFJlaHlkcmF0ZWREZXZpY2UucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmVoeWRyYXRlZERldmljZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSZWh5ZHJhdGVkRGV2aWNlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yZWh5ZHJhdGVkZGV2aWNlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjZWl2ZSB0aGUgdG8tZGV2aWNlIGV2ZW50cyB0aGF0IHNlbnQgdG8gdGhlIGRlaHlkcmF0ZWQgZGV2aWNlXG4gICAgICpcbiAgICAgKiBUaGUgcmVoeWRyYXRlZCBkZXZpY2Ugd2lsbCBkZWNyeXB0IHRoZSBldmVudHMgYW5kIHBhc3MgdGhlIHJvb20ga2V5c1xuICAgICAqIGludG8gdGhlIGBPbG1NYWNoaW5lYC5cbiAgICAgKlxuICAgICAqIGB0b19kZXZpY2VfZXZlbnRzYCBpcyBhIEpTT04tZW5jb2RlZCByZXN1bHQgb2YgdGhlIGBldmVudHNgIGFycmF5IGZyb21cbiAgICAgKiBgL2RlaHlkcmF0ZWRfZGV2aWNlL3tkZXZpY2VfaWR9L2V2ZW50c2AuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGBSb29tS2V5SW5mb2AsIGluZGljYXRpbmcgdGhlIHJvb20ga2V5cyB0aGF0IHdlcmVcbiAgICAgKiByZWNlaXZlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9fZGV2aWNlX2V2ZW50c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PGFueT4+fVxuICAgICAqL1xuICAgIHJlY2VpdmVFdmVudHModG9fZGV2aWNlX2V2ZW50cykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAodG9fZGV2aWNlX2V2ZW50cywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJlaHlkcmF0ZWRkZXZpY2VfcmVjZWl2ZUV2ZW50cyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuXG5jb25zdCBSb29tSWRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfcm9vbWlkX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEEgTWF0cml4IFtyb29tIElEXS5cbiAqXG4gKiBbcm9vbSBJRF06IGh0dHBzOi8vc3BlYy5tYXRyaXgub3JnL3YxLjIvYXBwZW5kaWNlcy8jcm9vbS1pZHMtYW5kLWV2ZW50LWlkc1xuICovXG5leHBvcnQgY2xhc3MgUm9vbUlkIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSb29tSWQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUm9vbUlkRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgUm9vbUlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSb29tSWRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Jvb21pZF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlL3ZhbGlkYXRlIGFuZCBjcmVhdGUgYSBuZXcgYFJvb21JZGAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWQpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGlkLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucm9vbWlkX25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldFswXSA+Pj4gMDtcbiAgICAgICAgUm9vbUlkRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcm9vbSBJRCBhcyBhIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20ucm9vbWlkX3RvU3RyaW5nKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcmV0WzBdO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByZXRbMV07XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IFJvb21LZXlDb3VudHNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfcm9vbWtleWNvdW50c19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBTdHJ1Y3QgaG9sZGluZyB0aGUgbnVtYmVyIG9mIHJvb20ga2V5cyB3ZSBoYXZlLlxuICovXG5leHBvcnQgY2xhc3MgUm9vbUtleUNvdW50cyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUm9vbUtleUNvdW50cy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBSb29tS2V5Q291bnRzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJvb21LZXlDb3VudHNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Jvb21rZXljb3VudHNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIHJvb20ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB0b3RhbCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfcm9vbWtleWNvdW50c190b3RhbCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2Ygcm9vbSBrZXlzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHRvdGFsKGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfcm9vbWtleWNvdW50c190b3RhbCh0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgYmFja2VkIHVwIHJvb20ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBiYWNrZWRVcCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfcm9vbWtleWNvdW50c19iYWNrZWRVcCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgYmFja2VkIHVwIHJvb20ga2V5cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJnMFxuICAgICAqL1xuICAgIHNldCBiYWNrZWRVcChhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3Jvb21rZXljb3VudHNfYmFja2VkVXAodGhpcy5fX3diZ19wdHIsIGFyZzApO1xuICAgIH1cbn1cblxuY29uc3QgUm9vbUtleUltcG9ydFJlc3VsdEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19yb29ta2V5aW1wb3J0cmVzdWx0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFRoZSByZXN1bHQgb2YgYSBjYWxsIHRvIHtAbGluayBPbG1NYWNoaW5lLmltcG9ydEV4cG9ydGVkUm9vbUtleXN9IG9yXG4gKiB7QGxpbmsgT2xtTWFjaGluZS5pbXBvcnRCYWNrZWRVcFJvb21LZXlzfS5cbiAqL1xuZXhwb3J0IGNsYXNzIFJvb21LZXlJbXBvcnRSZXN1bHQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFJvb21LZXlJbXBvcnRSZXN1bHQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUm9vbUtleUltcG9ydFJlc3VsdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSb29tS2V5SW1wb3J0UmVzdWx0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yb29ta2V5aW1wb3J0cmVzdWx0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiByb29tIGtleXMgdGhhdCB3ZXJlIGltcG9ydGVkLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGltcG9ydGVkQ291bnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3Jvb21rZXlpbXBvcnRyZXN1bHRfaW1wb3J0ZWRDb3VudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2Ygcm9vbSBrZXlzIHRoYXQgd2VyZSBmb3VuZCBpbiB0aGUgZXhwb3J0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHRvdGFsQ291bnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3Jvb21rZXlpbXBvcnRyZXN1bHRfdG90YWxDb3VudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBrZXlzIHRoYXQgd2VyZSBpbXBvcnRlZC5cbiAgICAgKlxuICAgICAqIEEgTWFwIGZyb20gcm9vbSBpZCB0byBhIE1hcCBvZiB0aGUgc2VuZGVyIGtleSB0byBhIFNldCBvZiBzZXNzaW9uIGlkcy5cbiAgICAgKlxuICAgICAqIFR5cGVzY3JpcHQgdHlwZTogYE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PmAuXG4gICAgICogQHJldHVybnMge01hcDxhbnksIGFueT59XG4gICAgICovXG4gICAga2V5cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yb29ta2V5aW1wb3J0cmVzdWx0X2tleXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cblxuY29uc3QgUm9vbUtleUluZm9GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfcm9vbWtleWluZm9fZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogSW5mb3JtYXRpb24gb24gYSByb29tIGtleSB0aGF0IGhhcyBiZWVuIHJlY2VpdmVkIG9yIGltcG9ydGVkLlxuICovXG5leHBvcnQgY2xhc3MgUm9vbUtleUluZm8ge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFJvb21LZXlJbmZvLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFJvb21LZXlJbmZvRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJvb21LZXlJbmZvRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yb29ta2V5aW5mb19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgRW5jcnlwdGlvbkFsZ29yaXRobX0gdGhhdCB0aGlzIGtleSBpcyB1c2VkIGZvci4gV2lsbCBiZSBvbmVcbiAgICAgKiBvZiB0aGUgYG0ubWVnb2xtLipgIGFsZ29yaXRobXMuXG4gICAgICogQHJldHVybnMge0VuY3J5cHRpb25BbGdvcml0aG19XG4gICAgICovXG4gICAgZ2V0IGFsZ29yaXRobSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yb29ta2V5aW5mb19hbGdvcml0aG0odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcm9vbSB3aGVyZSB0aGUga2V5IGlzIHVzZWQuXG4gICAgICogQHJldHVybnMge1Jvb21JZH1cbiAgICAgKi9cbiAgICBnZXQgcm9vbUlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJvb21rZXlpbmZvX3Jvb21JZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBSb29tSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBDdXJ2ZTI1NTE5IGtleSBvZiB0aGUgZGV2aWNlIHdoaWNoIGluaXRpYXRlZCB0aGUgc2Vzc2lvbiBvcmlnaW5hbGx5LlxuICAgICAqIEByZXR1cm5zIHtDdXJ2ZTI1NTE5UHVibGljS2V5fVxuICAgICAqL1xuICAgIGdldCBzZW5kZXJLZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucm9vbWtleWluZm9fc2VuZGVyS2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEN1cnZlMjU1MTlQdWJsaWNLZXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgc2Vzc2lvbiB0aGF0IHRoZSBrZXkgaXMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHNlc3Npb25JZCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJvb21rZXlpbmZvX3Nlc3Npb25JZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBSb29tS2V5V2l0aGhlbGRJbmZvRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Jvb21rZXl3aXRoaGVsZGluZm9fZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogSW5mb3JtYXRpb24gb24gYSByZWNlaXZlZCBgbS5yb29tX2tleS53aXRoaGVsZGAgZXZlbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBSb29tS2V5V2l0aGhlbGRJbmZvIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSb29tS2V5V2l0aGhlbGRJbmZvLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFJvb21LZXlXaXRoaGVsZEluZm9GaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUm9vbUtleVdpdGhoZWxkSW5mb0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfcm9vbWtleXdpdGhoZWxkaW5mb19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBVc2VyIElEIG9mIHRoZSB1c2VyIHRoYXQgc2VudCB1cyB0aGUgYG0ucm9vbV9rZXkud2l0aGhlbGRgIG1lc3NhZ2UuXG4gICAgICogQHJldHVybnMge1VzZXJJZH1cbiAgICAgKi9cbiAgICBnZXQgc2VuZGVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJvb21rZXl3aXRoaGVsZGluZm9fc2VuZGVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFVzZXJJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIG9mIHRoZSBzZXNzaW9uIHRoYXQgaXMgYmVpbmcgd2l0aGhlbGQuXG4gICAgICogQHJldHVybnMge0VuY3J5cHRpb25BbGdvcml0aG19XG4gICAgICovXG4gICAgZ2V0IGFsZ29yaXRobSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yb29ta2V5d2l0aGhlbGRpbmZvX2FsZ29yaXRobSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBgY29kZWAgZnJvbSB0aGUgYG0ucm9vbV9rZXkud2l0aGhlbGRgIG1lc3NhZ2UsIHN1Y2ggYXNcbiAgICAgKiBgbS51bnZlcmlmaWVkYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB3aXRoaGVsZENvZGUoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yb29ta2V5d2l0aGhlbGRpbmZvX3dpdGhoZWxkQ29kZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByb29tIElEIG9mIHRoZSBzZXNzaW9uIHRoYXQgaXMgYmVpbmcgd2l0aGhlbGQuXG4gICAgICogQHJldHVybnMge1Jvb21JZH1cbiAgICAgKi9cbiAgICBnZXQgcm9vbUlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJvb21rZXl3aXRoaGVsZGluZm9fcm9vbUlkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFJvb21JZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNlc3Npb24gSUQgb2YgdGhlIHNlc3Npb24gdGhhdCBpcyBiZWluZyB3aXRoaGVsZC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBzZXNzaW9uSWQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yb29ta2V5d2l0aGhlbGRpbmZvX3Nlc3Npb25JZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBSb29tTWVzc2FnZVJlcXVlc3RGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfcm9vbW1lc3NhZ2VyZXF1ZXN0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEEgY3VzdG9taXplZCBvd25lZCByZXF1ZXN0IHR5cGUgZm9yIHNlbmRpbmcgb3V0IHJvb20gbWVzc2FnZXNcbiAqIChbc3BlY2lmaWNhdGlvbl0pLlxuICpcbiAqIFtzcGVjaWZpY2F0aW9uXTogaHR0cHM6Ly9zcGVjLm1hdHJpeC5vcmcvdW5zdGFibGUvY2xpZW50LXNlcnZlci1hcGkvI3B1dF9tYXRyaXhjbGllbnR2M3Jvb21zcm9vbWlkc2VuZGV2ZW50dHlwZXR4bmlkXG4gKi9cbmV4cG9ydCBjbGFzcyBSb29tTWVzc2FnZVJlcXVlc3Qge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFJvb21NZXNzYWdlUmVxdWVzdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBSb29tTWVzc2FnZVJlcXVlc3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUm9vbU1lc3NhZ2VSZXF1ZXN0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yb29tbWVzc2FnZXJlcXVlc3RfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVxdWVzdCBJRC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfcm9vbW1lc3NhZ2VyZXF1ZXN0X2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByb29tIHRvIHNlbmQgdGhlIGV2ZW50IHRvLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHJvb21faWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3Jvb21tZXNzYWdlcmVxdWVzdF9yb29tX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0cmFuc2FjdGlvbiBJRCBmb3IgdGhpcyBldmVudC5cbiAgICAgKlxuICAgICAqIENsaWVudHMgc2hvdWxkIGdlbmVyYXRlIGFuIElEIHVuaXF1ZSBhY3Jvc3MgcmVxdWVzdHMgd2l0aCB0aGUgc2FtZVxuICAgICAqIGFjY2VzcyB0b2tlbjsgaXQgd2lsbCBiZSB1c2VkIGJ5IHRoZSBzZXJ2ZXIgdG8gZW5zdXJlIGlkZW1wb3RlbmN5IG9mXG4gICAgICogcmVxdWVzdHMuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdHhuX2lkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9yb29tbWVzc2FnZXJlcXVlc3RfdHhuX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIGV2ZW50IHRvIGJlIHNlbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRfdHlwZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfcm9vbW1lc3NhZ2VyZXF1ZXN0X2V2ZW50X3R5cGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIEpTT04tZW5jb2RlZCBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSdzIGNvbnRlbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfcm9vbW1lc3NhZ2VyZXF1ZXN0X2JvZHkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYFJvb21NZXNzYWdlUmVxdWVzdGAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvb21faWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHhuX2lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlkLCByb29tX2lkLCB0eG5faWQsIGV2ZW50X3R5cGUsIGNvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yb29tbWVzc2FnZXJlcXVlc3RfbmV3KGlkLCByb29tX2lkLCB0eG5faWQsIGV2ZW50X3R5cGUsIGNvbnRlbnQpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgUm9vbU1lc3NhZ2VSZXF1ZXN0RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBpdHMgcmVxdWVzdCB0eXBlLlxuICAgICAqIEByZXR1cm5zIHtSZXF1ZXN0VHlwZX1cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yb29tbWVzc2FnZXJlcXVlc3RfdHlwZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuXG5jb25zdCBSb29tU2V0dGluZ3NGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfcm9vbXNldHRpbmdzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFJvb20gZW5jcnlwdGlvbiBzZXR0aW5ncyB3aGljaCBhcmUgbW9kaWZpZWQgYnkgc3RhdGUgZXZlbnRzIG9yIHVzZXIgb3B0aW9uc1xuICovXG5leHBvcnQgY2xhc3MgUm9vbVNldHRpbmdzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSb29tU2V0dGluZ3MucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUm9vbVNldHRpbmdzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJvb21TZXR0aW5nc0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfcm9vbXNldHRpbmdzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIHRoYXQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIHJvb20uXG4gICAgICpcbiAgICAgKiBTaG91bGQgYmUgb25lIG9mIHRoZSBtZW1iZXJzIG9mIHtAbGluayBFbmNyeXB0aW9uQWxnb3JpdGhtfS5cbiAgICAgKiBAcmV0dXJucyB7RW5jcnlwdGlvbkFsZ29yaXRobX1cbiAgICAgKi9cbiAgICBnZXQgYWxnb3JpdGhtKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9yb29tc2V0dGluZ3NfYWxnb3JpdGhtKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIHRoYXQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIHJvb20uXG4gICAgICpcbiAgICAgKiBTaG91bGQgYmUgb25lIG9mIHRoZSBtZW1iZXJzIG9mIHtAbGluayBFbmNyeXB0aW9uQWxnb3JpdGhtfS5cbiAgICAgKiBAcGFyYW0ge0VuY3J5cHRpb25BbGdvcml0aG19IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgYWxnb3JpdGhtKGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfcm9vbXNldHRpbmdzX2FsZ29yaXRobSh0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdW50cnVzdGVkIGRldmljZXMgc2hvdWxkIHJlY2VpdmUgcm9vbSBrZXlzLiBJZiB0aGlzIGlzIGBmYWxzZWAsXG4gICAgICogdGhleSB3aWxsIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgb25seUFsbG93VHJ1c3RlZERldmljZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3Jvb21zZXR0aW5nc19vbmx5QWxsb3dUcnVzdGVkRGV2aWNlcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdW50cnVzdGVkIGRldmljZXMgc2hvdWxkIHJlY2VpdmUgcm9vbSBrZXlzLiBJZiB0aGlzIGlzIGBmYWxzZWAsXG4gICAgICogdGhleSB3aWxsIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgb25seUFsbG93VHJ1c3RlZERldmljZXMoYXJnMCkge1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9yb29tc2V0dGluZ3Nfb25seUFsbG93VHJ1c3RlZERldmljZXModGhpcy5fX3diZ19wdHIsIGFyZzApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSB0aW1lLCBpbiBtaWxsaXNlY29uZHMsIHRoYXQgYW4gZW5jcnlwdGlvbiBzZXNzaW9uIHNob3VsZCBiZVxuICAgICAqIHVzZWQgZm9yLCBiZWZvcmUgaXQgaXMgcm90YXRlZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBzZXNzaW9uUm90YXRpb25QZXJpb2RNcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfcm9vbXNldHRpbmdzX3Nlc3Npb25Sb3RhdGlvblBlcmlvZE1zKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldFswXSA9PT0gMCA/IHVuZGVmaW5lZCA6IHJldFsxXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gdGltZSwgaW4gbWlsbGlzZWNvbmRzLCB0aGF0IGFuIGVuY3J5cHRpb24gc2Vzc2lvbiBzaG91bGQgYmVcbiAgICAgKiB1c2VkIGZvciwgYmVmb3JlIGl0IGlzIHJvdGF0ZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IFthcmcwXVxuICAgICAqL1xuICAgIHNldCBzZXNzaW9uUm90YXRpb25QZXJpb2RNcyhhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3Jvb21zZXR0aW5nc19zZXNzaW9uUm90YXRpb25QZXJpb2RNcyh0aGlzLl9fd2JnX3B0ciwgIWlzTGlrZU5vbmUoYXJnMCksIGlzTGlrZU5vbmUoYXJnMCkgPyAwIDogYXJnMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtZXNzYWdlcyBhbiBlbmNyeXB0aW9uIHNlc3Npb24gc2hvdWxkIGJlIHVzZWQgZm9yLFxuICAgICAqIGJlZm9yZSBpdCBpcyByb3RhdGVkLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IHNlc3Npb25Sb3RhdGlvblBlcmlvZE1lc3NhZ2VzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9yb29tc2V0dGluZ3Nfc2Vzc2lvblJvdGF0aW9uUGVyaW9kTWVzc2FnZXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0WzBdID09PSAwID8gdW5kZWZpbmVkIDogcmV0WzFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgYW4gZW5jcnlwdGlvbiBzZXNzaW9uIHNob3VsZCBiZSB1c2VkIGZvcixcbiAgICAgKiBiZWZvcmUgaXQgaXMgcm90YXRlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gW2FyZzBdXG4gICAgICovXG4gICAgc2V0IHNlc3Npb25Sb3RhdGlvblBlcmlvZE1lc3NhZ2VzKGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfcm9vbXNldHRpbmdzX3Nlc3Npb25Sb3RhdGlvblBlcmlvZE1lc3NhZ2VzKHRoaXMuX193YmdfcHRyLCAhaXNMaWtlTm9uZShhcmcwKSwgaXNMaWtlTm9uZShhcmcwKSA/IDAgOiBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGBSb29tU2V0dGluZ3NgIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucm9vbXNldHRpbmdzX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgUm9vbVNldHRpbmdzRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5jb25zdCBTYXNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc2FzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFNob3J0IEF1dGhlbnRpY2F0aW9uIFN0cmluZyAoU0FTKSB2ZXJpZmljYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBTYXMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFNhcy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTYXNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU2FzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zYXNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgb3VyIG93biB1c2VyIElELlxuICAgICAqIEByZXR1cm5zIHtVc2VySWR9XG4gICAgICovXG4gICAgZ2V0IHVzZXJJZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zYXNfdXNlcklkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFVzZXJJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG91ciBvd24gZGV2aWNlIElELlxuICAgICAqIEByZXR1cm5zIHtEZXZpY2VJZH1cbiAgICAgKi9cbiAgICBnZXQgZGV2aWNlSWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2FzX2RldmljZUlkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIERldmljZUlkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVzZXIgaWQgb2YgdGhlIG90aGVyIHNpZGUuXG4gICAgICogQHJldHVybnMge1VzZXJJZH1cbiAgICAgKi9cbiAgICBnZXQgb3RoZXJVc2VySWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2FzX290aGVyVXNlcklkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFVzZXJJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZXZpY2UgSUQgb2YgdGhlIG90aGVyIHNpZGUuXG4gICAgICogQHJldHVybnMge0RldmljZUlkfVxuICAgICAqL1xuICAgIGdldCBvdGhlckRldmljZUlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNhc19vdGhlckRldmljZUlkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIERldmljZUlkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVuaXF1ZSBJRCB0aGF0IGlkZW50aWZpZXMgdGhpcyBTQVMgdmVyaWZpY2F0aW9uIGZsb3csXG4gICAgICogYmUgZWl0aGVyIGEgdG8tZGV2aWNlIHJlcXVlc3QgSUQgb3IgYSByb29tIGV2ZW50IElELlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGZsb3dJZCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNhc19mbG93SWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByZXRbMF07XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHJldFsxXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJvb20gSUQgaWYgdGhlIHZlcmlmaWNhdGlvbiBpcyBoYXBwZW5pbmcgaW5zaWRlIGFcbiAgICAgKiByb29tLlxuICAgICAqIEByZXR1cm5zIHtSb29tSWQgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IHJvb21JZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zYXNfcm9vbUlkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFJvb21JZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9lcyB0aGlzIHZlcmlmaWNhdGlvbiBmbG93IHN1cHBvcnQgZGlzcGxheWluZyBlbW9qaSBmb3IgdGhlXG4gICAgICogc2hvcnQgYXV0aGVudGljYXRpb24gc3RyaW5nP1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN1cHBvcnRzRW1vamkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2FzX3N1cHBvcnRzRW1vamkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaWQgdGhpcyB2ZXJpZmljYXRpb24gZmxvdyBzdGFydCBmcm9tIGEgdmVyaWZpY2F0aW9uIHJlcXVlc3Q/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhcnRlZEZyb21SZXF1ZXN0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNhc19zdGFydGVkRnJvbVJlcXVlc3QodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIGEgdmVyaWZpY2F0aW9uIHRoYXQgaXMgdmVyaWZ5aW5nIG9uZSBvZiBvdXIgb3duXG4gICAgICogZGV2aWNlcz9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1NlbGZWZXJpZmljYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2FzX2lzU2VsZlZlcmlmaWNhdGlvbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhdmUgd2UgY29uZmlybWVkIHRoYXQgdGhlIHNob3J0IGF1dGggc3RyaW5nIG1hdGNoZXM/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGF2ZVdlQ29uZmlybWVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNhc19oYXZlV2VDb25maXJtZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYXMgdGhlIHZlcmlmaWNhdGlvbiBiZWVuIGFjY2VwdGVkIGJ5IGJvdGggcGFydGllcz9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNCZWVuQWNjZXB0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2FzX2hhc0JlZW5BY2NlcHRlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBpbmZvIGFib3V0IHRoZSBjYW5jZWxsYXRpb24gaWYgdGhlIHZlcmlmaWNhdGlvbiBmbG93IGhhc1xuICAgICAqIGJlZW4gY2FuY2VsbGVkLlxuICAgICAqIEByZXR1cm5zIHtDYW5jZWxJbmZvIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGNhbmNlbEluZm8oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2FzX2NhbmNlbEluZm8odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogQ2FuY2VsSW5mby5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB3ZSBpbml0aWF0ZWQgdGhlIHZlcmlmaWNhdGlvbiBmbG93IChpZSwgd2Ugc2VudCB0aGVcbiAgICAgKiBgbS5rZXkudmVyaWZpY2F0aW9uLnJlcXVlc3RgKS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB3ZVN0YXJ0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2FzX3dlU3RhcnRlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdCB0aGUgU0FTIHZlcmlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgZG9lcyBub3RoaW5nIChhbmQgcmV0dXJucyBgdW5kZWZpbmVkYCkgaWYgdGhlIHZlcmlmaWNhdGlvbiB3YXNcbiAgICAgKiBhbHJlYWR5IGFjY2VwdGVkLCBvdGhlcndpc2UgaXQgcmV0dXJucyBhbiBgT3V0Z29pbmdSZXF1ZXN0YFxuICAgICAqIHRoYXQgbmVlZHMgdG8gYmUgc2VudCBvdXQuXG4gICAgICogQHJldHVybnMge2FueX1cbiAgICAgKi9cbiAgICBhY2NlcHQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2FzX2FjY2VwdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFswXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpcm0gdGhlIFNBUyB2ZXJpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGNvbmZpcm1zIHRoYXQgdGhlIHNob3J0IGF1dGggc3RyaW5ncyBtYXRjaCBvbiBib3RoIHNpZGVzLlxuICAgICAqXG4gICAgICogRG9lcyBub3RoaW5nIGlmIHdl4oCZcmUgbm90IGluIGEgc3RhdGUgd2hlcmUgd2UgY2FuIGNvbmZpcm0gdGhlXG4gICAgICogc2hvcnQgYXV0aCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgYFByb21pc2VgIGZvciBhbiBhcnJheSBvZiBgT3V0Z29pbmdSZXF1ZXN0YHMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBjb25maXJtKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNhc19jb25maXJtKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoZSB2ZXJpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGVpdGhlciBhbiBgT3V0Z29pbmdSZXF1ZXN0YCB3aGljaCBzaG91bGQgYmUgc2VudCBvdXQsIG9yXG4gICAgICogYHVuZGVmaW5lZGAgaWYgdGhlIHZlcmlmaWNhdGlvbiBpcyBhbHJlYWR5IGNhbmNlbGxlZC5cbiAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zYXNfY2FuY2VsKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoZSB2ZXJpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbmNlbHMgdGhlIHZlcmlmaWNhdGlvbiB3aXRoIGdpdmVuIGNvZGUgKGUuZy4gYG0udXNlcmApLlxuICAgICAqXG4gICAgICogUmV0dXJucyBlaXRoZXIgYW4gYE91dGdvaW5nUmVxdWVzdGAgd2hpY2ggc2hvdWxkIGJlIHNlbnQgb3V0LCBvclxuICAgICAqIGB1bmRlZmluZWRgIGlmIHRoZSB2ZXJpZmljYXRpb24gaXMgYWxyZWFkeSBjYW5jZWxsZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAqL1xuICAgIGNhbmNlbFdpdGhDb2RlKGNvZGUpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGNvZGUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zYXNfY2FuY2VsV2l0aENvZGUodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYXMgdGhlIFNBUyB2ZXJpZmljYXRpb24gZmxvdyB0aW1lZCBvdXQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGltZWRPdXQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2FzX3RpbWVkT3V0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXJlIHdlIGluIGEgc3RhdGUgd2hlcmUgd2UgY2FuIHNob3cgdGhlIHNob3J0IGF1dGggc3RyaW5nP1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhbkJlUHJlc2VudGVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNhc19jYW5CZVByZXNlbnRlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBTQVMgZmxvdyBkb25lP1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRG9uZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zYXNfaXNEb25lKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIFNBUyBmbG93IGNhbmNlbGxlZD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0NhbmNlbGxlZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zYXNfaXNDYW5jZWxsZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGVtb2ppIHZlcnNpb24gb2YgdGhlIHNob3J0IGF1dGggc3RyaW5nLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB3ZSBjYW4ndCB5ZXQgcHJlc2VudCB0aGUgc2hvcnQgYXV0aCBzdHJpbmcsXG4gICAgICogb3RoZXJ3aXNlIGFuIGFycmF5IG9mIHNldmVuIGBFbW9qaWAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7KEVtb2ppKVtdIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGVtb2ppKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNhc19lbW9qaSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHJldFswXSAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyZXRbMF0sIHJldFsxXSAqIDQsIDQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgZW1vamkgcmVwcmVzZW50aW5nIHRoZSBzaG9ydCBhdXRoIHN0cmluZ1xuICAgICAqXG4gICAgICogUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB3ZSBjYW7igJl0IHlldCBwcmVzZW50IHRoZSBzaG9ydCBhdXRoXG4gICAgICogc3RyaW5nLCBvdGhlcndpc2Ugc2V2ZW4gYHU4YCBudW1iZXJzIGluIHRoZSByYW5nZSBmcm9tIDAgdG8gNjNcbiAgICAgKiBpbmNsdXNpdmUgd2hpY2ggY2FuIGJlIGNvbnZlcnRlZCB0byBhbiBlbW9qaSB1c2luZyBbdGhlXG4gICAgICogcmVsZXZhbnQgc3BlY2lmaWNhdGlvblxuICAgICAqIGVudHJ5XShodHRwczovL3NwZWMubWF0cml4Lm9yZy91bnN0YWJsZS9jbGllbnQtc2VydmVyLWFwaS8jc2FzLW1ldGhvZC1lbW9qaSkuXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXkgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZW1vamlJbmRleCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zYXNfZW1vamlJbmRleCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHJldFswXSAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHJldFswXSwgcmV0WzFdKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocmV0WzBdLCByZXRbMV0gKiAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVjaW1hbCB2ZXJzaW9uIG9mIHRoZSBzaG9ydCBhdXRoIHN0cmluZy5cbiAgICAgKlxuICAgICAqIFJldHVybnMgTm9uZSBpZiB3ZSBjYW7igJl0IHlldCBwcmVzZW50IHRoZSBzaG9ydCBhdXRoIHN0cmluZyxcbiAgICAgKiBvdGhlcndpc2UgYSB0dXBsZSBjb250YWluaW5nIHRocmVlIDQtZGlnaXQgaW50ZWdlcnMgdGhhdFxuICAgICAqIHJlcHJlc2VudCB0aGUgc2hvcnQgYXV0aCBzdHJpbmcuXG4gICAgICogQHJldHVybnMge1VpbnQxNkFycmF5IHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGRlY2ltYWxzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNhc19kZWNpbWFscyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHJldFswXSAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRBcnJheVUxNkZyb21XYXNtMChyZXRbMF0sIHJldFsxXSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHJldFswXSwgcmV0WzFdICogMiwgMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZXJlIGlzIGFuIHVwZGF0ZSB0b1xuICAgICAqIHRoZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogVGhlIGBjYWxsYmFja2AgaXMgY2FsbGVkIHdpdGggbm8gcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHJlZ2lzdGVyQ2hhbmdlc0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHdhc20uc2FzX3JlZ2lzdGVyQ2hhbmdlc0NhbGxiYWNrKHRoaXMuX193YmdfcHRyLCBjYWxsYmFjayk7XG4gICAgfVxufVxuXG5jb25zdCBTZWNyZXRzQnVuZGxlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3NlY3JldHNidW5kbGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogU3RydWN0IGNvbnRhaW5pbmcgdGhlIGJ1bmRsZSBvZiBzZWNyZXRzIHRvIGZ1bGx5IGFjdGl2YXRlIGEgbmV3IGRldmljZSBmb3JcbiAqIGVuZC10by1lbmQgZW5jcnlwdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFNlY3JldHNCdW5kbGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFNlY3JldHNCdW5kbGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU2VjcmV0c0J1bmRsZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTZWNyZXRzQnVuZGxlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zZWNyZXRzYnVuZGxlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNlZWQgb2YgdGhlIG1hc3RlciBrZXkgZW5jb2RlZCBhcyB1bnBhZGRlZCBiYXNlNjQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbWFzdGVyS2V5KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2VjcmV0c2J1bmRsZV9tYXN0ZXJLZXkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByZXRbMF07XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHJldFsxXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2VlZCBvZiB0aGUgc2VsZiBzaWduaW5nIGtleSBlbmNvZGVkIGFzIHVucGFkZGVkIGJhc2U2NC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBzZWxmU2lnbmluZ0tleSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNlY3JldHNidW5kbGVfc2VsZlNpZ25pbmdLZXkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByZXRbMF07XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHJldFsxXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2VlZCBvZiB0aGUgdXNlciBzaWduaW5nIGtleSBlbmNvZGVkIGFzIHVucGFkZGVkIGJhc2U2NC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB1c2VyU2lnbmluZ0tleSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNlY3JldHNidW5kbGVfdXNlclNpZ25pbmdLZXkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByZXRbMF07XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHJldFsxXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYnVuZGxlIG9mIHRoZSBiYWNrdXAgZGVjcnlwdGlvbiBrZXkgYW5kIGJhY2t1cCB2ZXJzaW9uIGlmIGFueS5cbiAgICAgKiBAcmV0dXJucyB7QmFja3VwU2VjcmV0c0J1bmRsZSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgYmFja3VwQnVuZGxlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNlY3JldHNidW5kbGVfYmFja3VwQnVuZGxlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IEJhY2t1cFNlY3JldHNCdW5kbGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgW2BTZWNyZXRzQnVuZGxlYF0gdG8gYSBKU09OIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAqL1xuICAgIHRvX2pzb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2VjcmV0c2J1bmRsZV90b19qc29uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemUgdGhlIFtgU2VjcmV0c0J1bmRsZWBdIGZyb20gYSBKU09OIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2FueX0ganNvblxuICAgICAqIEByZXR1cm5zIHtTZWNyZXRzQnVuZGxlfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tX2pzb24oanNvbikge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNlY3JldHNidW5kbGVfZnJvbV9qc29uKGpzb24pO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTZWNyZXRzQnVuZGxlLl9fd3JhcChyZXRbMF0pO1xuICAgIH1cbn1cblxuY29uc3QgU2VydmVyTmFtZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zZXJ2ZXJuYW1lX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEEgTWF0cml4LXNwZWMgY29tcGxpYW50IFtzZXJ2ZXIgbmFtZV0uXG4gKlxuICogSXQgY29uc2lzdHMgb2YgYSBob3N0IGFuZCBhbiBvcHRpb25hbCBwb3J0IChzZXBhcmF0ZWQgYnkgYSBjb2xvbiBpZlxuICogcHJlc2VudCkuXG4gKlxuICogW3NlcnZlciBuYW1lXTogaHR0cHM6Ly9zcGVjLm1hdHJpeC5vcmcvdjEuMi9hcHBlbmRpY2VzLyNzZXJ2ZXItbmFtZVxuICovXG5leHBvcnQgY2xhc3MgU2VydmVyTmFtZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoU2VydmVyTmFtZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTZXJ2ZXJOYW1lRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFNlcnZlck5hbWVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3NlcnZlcm5hbWVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZS92YWxpZGF0ZSBhbmQgY3JlYXRlIGEgbmV3IGBTZXJ2ZXJOYW1lYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKG5hbWUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zZXJ2ZXJuYW1lX25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldFswXSA+Pj4gMDtcbiAgICAgICAgU2VydmVyTmFtZUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBob3N0IG9mIHRoZSBzZXJ2ZXIgbmFtZS5cbiAgICAgKlxuICAgICAqIFRoYXQgaXM6IFJldHVybiB0aGUgcGFydCBvZiB0aGUgc2VydmVyIGJlZm9yZSBgOjxwb3J0PmAgb3IgdGhlXG4gICAgICogZnVsbCBzZXJ2ZXIgbmFtZSBpZiB0aGVyZSBpcyBubyBwb3J0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGhvc3QoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zZXJ2ZXJuYW1lX2hvc3QodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByZXRbMF07XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHJldFsxXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3J0IG9mIHRoZSBzZXJ2ZXIgbmFtZSBpZiBhbnkuXG4gICAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgcG9ydCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zZXJ2ZXJuYW1lX3BvcnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAweEZGRkZGRiA/IHVuZGVmaW5lZCA6IHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBzZXJ2ZXIgbmFtZSBpcyBhbiBJUHY0IG9yIElQdjZcbiAgICAgKiBhZGRyZXNzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzSXBMaXRlcmFsKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNlcnZlcm5hbWVfaXNJcExpdGVyYWwodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbn1cblxuY29uc3QgU2hpZWxkU3RhdGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc2hpZWxkc3RhdGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogVGFrZSBhIGxvb2sgYXQgW2BtYXRyaXhfc2RrX2NvbW1vbjo6ZGVzZXJpYWxpemVkX3Jlc3BvbnNlczo6U2hpZWxkU3RhdGVgXVxuICogZm9yIG1vcmUgaW5mby5cbiAqL1xuZXhwb3J0IGNsYXNzIFNoaWVsZFN0YXRlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTaGllbGRTdGF0ZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTaGllbGRTdGF0ZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTaGllbGRTdGF0ZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2hpZWxkc3RhdGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2hpZWxkIGNvbG9yXG4gICAgICogQHJldHVybnMge1NoaWVsZENvbG9yfVxuICAgICAqL1xuICAgIGdldCBjb2xvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfc2hpZWxkc3RhdGVfY29sb3IodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2hpZWxkIGNvbG9yXG4gICAgICogQHBhcmFtIHtTaGllbGRDb2xvcn0gYXJnMFxuICAgICAqL1xuICAgIHNldCBjb2xvcihhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NoaWVsZHN0YXRlX2NvbG9yKHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtYWNoaW5lLXJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhdXRoZW50aWNpdHkgZm9yIGFcbiAgICAgKiBgU2hpZWxkU3RhdGVgLlxuICAgICAqIEByZXR1cm5zIHtTaGllbGRTdGF0ZUNvZGUgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IGNvZGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3NoaWVsZHN0YXRlX2NvZGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSA2ID8gdW5kZWZpbmVkIDogcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1hY2hpbmUtcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGF1dGhlbnRpY2l0eSBmb3IgYVxuICAgICAqIGBTaGllbGRTdGF0ZWAuXG4gICAgICogQHBhcmFtIHtTaGllbGRTdGF0ZUNvZGUgfCB1bmRlZmluZWR9IFthcmcwXVxuICAgICAqL1xuICAgIHNldCBjb2RlKGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2hpZWxkc3RhdGVfY29kZSh0aGlzLl9fd2JnX3B0ciwgaXNMaWtlTm9uZShhcmcwKSA/IDYgOiBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXJyb3IgbWVzc2FnZSB0aGF0IGNhbiBiZSBkaXNwbGF5ZWQgYXMgYSB0b29sdGlwXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zaGllbGRzdGF0ZV9tZXNzYWdlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBpZiAocmV0WzBdICE9PSAwKSB7XG4gICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHJldFswXSwgcmV0WzFdICogMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYxO1xuICAgIH1cbn1cblxuY29uc3QgU2lnbmF0dXJlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3NpZ25hdHVyZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgcG90ZW50aWFsbHkgZGVjb2RlZCBzaWduYXR1cmUgKGJ1dCBub3QgYSB2YWxpZGF0ZWRcbiAqIG9uZSkuXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduYXR1cmUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFNpZ25hdHVyZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTaWduYXR1cmVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU2lnbmF0dXJlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zaWduYXR1cmVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEVkMjU1MTkgc2lnbmF0dXJlLCBpZiB0aGlzIGlzIG9uZS5cbiAgICAgKiBAcmV0dXJucyB7RWQyNTUxOVNpZ25hdHVyZSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgZWQyNTUxOSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zaWduYXR1cmVfZWQyNTUxOSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBFZDI1NTE5U2lnbmF0dXJlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBzaWduYXR1cmUgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b0Jhc2U2NCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25hdHVyZV90b0Jhc2U2NCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBTaWduYXR1cmVVcGxvYWRSZXF1ZXN0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3NpZ25hdHVyZXVwbG9hZHJlcXVlc3RfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogRGF0YSBmb3IgYSByZXF1ZXN0IHRvIHRoZSBgL2tleXMvc2lnbmF0dXJlcy91cGxvYWRgIEFQSSBlbmRwb2ludFxuICogKFtzcGVjaWZpY2F0aW9uXSkuXG4gKlxuICogUHVibGlzaGVzIGNyb3NzLXNpZ25pbmcgc2lnbmF0dXJlcyBmb3IgdGhlIHVzZXIuXG4gKlxuICogW3NwZWNpZmljYXRpb25dOiBodHRwczovL3NwZWMubWF0cml4Lm9yZy91bnN0YWJsZS9jbGllbnQtc2VydmVyLWFwaS8jcG9zdF9tYXRyaXhjbGllbnR2M2tleXNzaWduYXR1cmVzdXBsb2FkXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduYXR1cmVVcGxvYWRSZXF1ZXN0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTaWduYXR1cmVVcGxvYWRSZXF1ZXN0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFNpZ25hdHVyZVVwbG9hZFJlcXVlc3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU2lnbmF0dXJlVXBsb2FkUmVxdWVzdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2lnbmF0dXJldXBsb2FkcmVxdWVzdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0IElELlxuICAgICAqIFNvbWUgc2lnbmF0dXJlIHVwbG9hZCB3aWxsIGhhdmUgdG8gYW4gYGlkYCBmaWVsZCwgc29tZSB3b24ndC5cbiAgICAgKiBUaGV5IGhhdmUgb25lIHdoZW4gdGhleSBhcmUgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyBhbiBpbnRlcmFjdGl2ZVxuICAgICAqIHZlcmlmaWNhdGlvbiwgb3RoZXJ3aXNlIHRoZXkgZG9uJ3QuXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3NpZ25hdHVyZXVwbG9hZHJlcXVlc3RfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIEpTT04tZW5jb2RlZCBzdHJpbmcgY29udGFpbmluZyB0aGUgcGF5bG9hZCBvZiB0aGUgcmVxdWVzdFxuICAgICAqXG4gICAgICogSXQgcmVwcmVzZW50cyB0aGUgYm9keSBvZiB0aGUgSFRUUCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3NpZ25hdHVyZXVwbG9hZHJlcXVlc3RfYm9keSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBgU2lnbmF0dXJlVXBsb2FkUmVxdWVzdGAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25lZF9rZXlzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWQsIHNpZ25lZF9rZXlzKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmF0dXJldXBsb2FkcmVxdWVzdF9uZXcoaWQsIHNpZ25lZF9rZXlzKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIFNpZ25hdHVyZVVwbG9hZFJlcXVlc3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGl0cyByZXF1ZXN0IHR5cGUuXG4gICAgICogQHJldHVybnMge1JlcXVlc3RUeXBlfVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25hdHVyZXVwbG9hZHJlcXVlc3RfdHlwZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuXG5jb25zdCBTaWduYXR1cmVWZXJpZmljYXRpb25GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc2lnbmF0dXJldmVyaWZpY2F0aW9uX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFRoZSByZXN1bHQgb2YgYSBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIG9mIGEgc2lnbmVkIEpTT04gb2JqZWN0LlxuICovXG5leHBvcnQgY2xhc3MgU2lnbmF0dXJlVmVyaWZpY2F0aW9uIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTaWduYXR1cmVWZXJpZmljYXRpb24ucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU2lnbmF0dXJlVmVyaWZpY2F0aW9uRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFNpZ25hdHVyZVZlcmlmaWNhdGlvbkZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2lnbmF0dXJldmVyaWZpY2F0aW9uX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZSB0aGUgYmFja3VwIHNpZ25hdHVyZSBzdGF0ZSBmcm9tIHRoZSBjdXJyZW50IGRldmljZS5cbiAgICAgKiBTZWUgU2lnbmF0dXJlU3RhdGUgZm9yIHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHtTaWduYXR1cmVTdGF0ZX1cbiAgICAgKi9cbiAgICBnZXQgZGV2aWNlU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmF0dXJldmVyaWZpY2F0aW9uX2RldmljZVN0YXRlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZSB0aGUgYmFja3VwIHNpZ25hdHVyZSBzdGF0ZSBmcm9tIHRoZSBjdXJyZW50IHVzZXIgaWRlbnRpdHkuXG4gICAgICogU2VlIFNpZ25hdHVyZVN0YXRlIGZvciB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7U2lnbmF0dXJlU3RhdGV9XG4gICAgICovXG4gICAgZ2V0IHVzZXJTdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zaWduYXR1cmV2ZXJpZmljYXRpb25fdXNlclN0YXRlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIHJlc3VsdCBjb25zaWRlcmVkIHRvIGJlIHRydXN0ZWQ/XG4gICAgICpcbiAgICAgKiBUaGlzIHRlbGxzIHVzIGlmIHRoZSByZXN1bHQgaGFzIGEgdmFsaWQgc2lnbmF0dXJlIGZyb20gYW55IG9mIHRoZVxuICAgICAqIGZvbGxvd2luZzpcbiAgICAgKlxuICAgICAqICogT3VyIG93biBkZXZpY2VcbiAgICAgKiAqIE91ciBvd24gdXNlciBpZGVudGl0eSwgcHJvdmlkZWQgdGhlIGlkZW50aXR5IGlzIHRydXN0ZWQgYXMgd2VsbFxuICAgICAqICogQW55IG9mIG91ciBvd24gZGV2aWNlcywgcHJvdmlkZWQgdGhlIGRldmljZSBpcyB0cnVzdGVkIGFzIHdlbGxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0cnVzdGVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25hdHVyZXZlcmlmaWNhdGlvbl90cnVzdGVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG59XG5cbmNvbnN0IFNpZ25hdHVyZXNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc2lnbmF0dXJlc19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgYFNpZ25hdHVyZWAuXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduYXR1cmVzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTaWduYXR1cmVzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFNpZ25hdHVyZXNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU2lnbmF0dXJlc0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2lnbmF0dXJlc19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5LCBzaWduYXR1cmVzIGNvbGxlY3Rpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmF0dXJlc19uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIFNpZ25hdHVyZXNGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBnaXZlbiBzaWduYXR1cmUgZnJvbSB0aGUgZ2l2ZW4gc2lnbmVyIGFuZCB0aGUgZ2l2ZW4ga2V5IElEIHRvXG4gICAgICogdGhlIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtVc2VySWR9IHNpZ25lclxuICAgICAqIEBwYXJhbSB7RGV2aWNlS2V5SWR9IGtleV9pZFxuICAgICAqIEBwYXJhbSB7RWQyNTUxOVNpZ25hdHVyZX0gc2lnbmF0dXJlXG4gICAgICogQHJldHVybnMge01heWJlU2lnbmF0dXJlIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGFkZFNpZ25hdHVyZShzaWduZXIsIGtleV9pZCwgc2lnbmF0dXJlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaWduZXIsIFVzZXJJZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhrZXlfaWQsIERldmljZUtleUlkKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNpZ25hdHVyZSwgRWQyNTUxOVNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmF0dXJlc19hZGRTaWduYXR1cmUodGhpcy5fX3diZ19wdHIsIHNpZ25lci5fX3diZ19wdHIsIGtleV9pZC5fX3diZ19wdHIsIHNpZ25hdHVyZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogTWF5YmVTaWduYXR1cmUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyeSB0byBmaW5kIGFuIEVkMjU1MTkgc2lnbmF0dXJlIGZyb20gdGhlIGdpdmVuIHNpZ25lciB3aXRoXG4gICAgICogdGhlIGdpdmVuIGtleSBJRC5cbiAgICAgKiBAcGFyYW0ge1VzZXJJZH0gc2lnbmVyXG4gICAgICogQHBhcmFtIHtEZXZpY2VLZXlJZH0ga2V5X2lkXG4gICAgICogQHJldHVybnMge0VkMjU1MTlTaWduYXR1cmUgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0U2lnbmF0dXJlKHNpZ25lciwga2V5X2lkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaWduZXIsIFVzZXJJZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhrZXlfaWQsIERldmljZUtleUlkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zaWduYXR1cmVzX2dldFNpZ25hdHVyZSh0aGlzLl9fd2JnX3B0ciwgc2lnbmVyLl9fd2JnX3B0ciwga2V5X2lkLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBFZDI1NTE5U2lnbmF0dXJlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1hcCBvZiBzaWduYXR1cmVzIHRoYXQgYmVsb25nIHRvIHRoZSBnaXZlbiB1c2VyLlxuICAgICAqIEBwYXJhbSB7VXNlcklkfSBzaWduZXJcbiAgICAgKiBAcmV0dXJucyB7TWFwPGFueSwgYW55PiB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQoc2lnbmVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaWduZXIsIFVzZXJJZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmF0dXJlc19nZXQodGhpcy5fX3diZ19wdHIsIHNpZ25lci5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIHRoZSBzaWduYXR1cmVzIHdlIGN1cnJlbnRseSBob2xkLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB3YXNtLnNpZ25hdHVyZXNfY2xlYXIodGhpcy5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEbyB3ZSBob2xkIGFueSBzaWduYXR1cmVzIG9yIGlzIG91ciBjb2xsZWN0aW9uIGNvbXBsZXRlbHlcbiAgICAgKiBlbXB0eS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25hdHVyZXNfaXNFbXB0eSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhvdyBtYW55IHNpZ25hdHVyZXMgZG8gd2UgY3VycmVudGx5IGhvbGQuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgY291bnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmF0dXJlc19jb3VudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUganNvbiB3aXRoIGFsbCBzaWduYXR1cmVzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBhc0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmF0dXJlc19hc0pTT04odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMF0pO1xuICAgIH1cbn1cblxuY29uc3QgU3RvcmVIYW5kbGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc3RvcmVoYW5kbGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQSBzdHJ1Y3QgY29udGFpbmluZyBhbiBvcGVuIGNvbm5lY3Rpb24gdG8gYSBDcnlwdG9TdG9yZS5cbiAqXG4gKiBPcGVuaW5nIHRoZSBDcnlwdG9TdG9yZSBjYW4gdGFrZSBzb21lIHRpbWUsIGR1ZSB0byB0aGUgUEJLREYgY2FsY3VsYXRpb25cbiAqIGludm9sdmVkLCBzbyBpZiBtdWx0aXBsZSBvcGVyYXRpb25zIGFyZSBiZWluZyBkb25lIG9uIHRoZSBzYW1lIHN0b3JlLCBpdCBpc1xuICogbW9yZSBlZmZpY2llbnQgdG8gb3BlbiBpdCBvbmNlLlxuICovXG5leHBvcnQgY2xhc3MgU3RvcmVIYW5kbGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFN0b3JlSGFuZGxlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFN0b3JlSGFuZGxlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFN0b3JlSGFuZGxlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zdG9yZWhhbmRsZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW4gYSBjcnlwdG8gc3RvcmUuXG4gICAgICpcbiAgICAgKiBUaGUgY3JlYXRlZCBzdG9yZSB3aWxsIGJlIGJhc2VkIG9uIEluZGV4ZWREQiBpZiBhIGBzdG9yZV9uYW1lYCBpc1xuICAgICAqIHByb3ZpZGVkOyBvdGhlcndpc2UgaXQgd2lsbCBiZSBiYXNlZCBvbiBhIG1lbW9yeSBzdG9yZSBhbmQgb25jZSB0aGVcbiAgICAgKiBvYmplY3RzIGlzIGRyb3BwZWQsIHRoZSBrZXlzIHdpbGwgYmUgbG9zdC5cbiAgICAgKlxuICAgICAqICMgQXJndW1lbnRzXG4gICAgICpcbiAgICAgKiAqIGBzdG9yZV9uYW1lYCAtIFRoZSBuYW1lIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gb3BlbiB0aGUgSW5kZXhlZERCXG4gICAgICogICBiYXNlZCBkYXRhYmFzZS4gSWYgdGhpcyBpc24ndCBwcm92aWRlZCwgYSBtZW1vcnktb25seSBzdG9yZSB3aWxsIGJlXG4gICAgICogICB1c2VkLiAqTm90ZSogdGhlIG1lbW9yeS1vbmx5IHN0b3JlIHdpbGwgbG9zZSB5b3VyIEUyRUUga2V5cyB3aGVuIHRoZVxuICAgICAqICAgYFN0b3JlSGFuZGxlYCBnZXRzIGRyb3BwZWQuXG4gICAgICpcbiAgICAgKiAqIGBzdG9yZV9wYXNzcGhyYXNlYCAtIFRoZSBwYXNzcGhyYXNlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZW5jcnlwdCB0aGVcbiAgICAgKiAgIHN0b3JlLCBmb3IgSW5kZXhlZERCLWJhc2VkIHN0b3Jlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbc3RvcmVfbmFtZV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW3N0b3JlX3Bhc3NwaHJhc2VdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U3RvcmVIYW5kbGU+fVxuICAgICAqL1xuICAgIHN0YXRpYyBvcGVuKHN0b3JlX25hbWUsIHN0b3JlX3Bhc3NwaHJhc2UpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKHN0b3JlX25hbWUpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHN0b3JlX25hbWUsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShzdG9yZV9wYXNzcGhyYXNlKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChzdG9yZV9wYXNzcGhyYXNlLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnN0b3JlaGFuZGxlX29wZW4ocHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW4gYSBjcnlwdG8gc3RvcmUgYmFzZWQgb24gSW5kZXhlZERCLCB1c2luZyB0aGUgZ2l2ZW4ga2V5IGZvclxuICAgICAqIGVuY3J5cHRpb24uXG4gICAgICpcbiAgICAgKiAjIEFyZ3VtZW50c1xuICAgICAqXG4gICAgICogKiBgc3RvcmVfbmFtZWAgLSBUaGUgbmFtZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIG9wZW4gdGhlIEluZGV4ZWREQlxuICAgICAqICAgYmFzZWQgZGF0YWJhc2UuXG4gICAgICpcbiAgICAgKiAqIGBzdG9yZV9rZXlgIC0gVGhlIGtleSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGVuY3J5cHQgdGhlIHN0b3JlLCBmb3JcbiAgICAgKiAgIEluZGV4ZWREQi1iYXNlZCBzdG9yZXMuIE11c3QgYmUgYSAzMi1ieXRlIGFycmF5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZV9uYW1lXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBzdG9yZV9rZXlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdG9yZUhhbmRsZT59XG4gICAgICovXG4gICAgc3RhdGljIG9wZW5XaXRoS2V5KHN0b3JlX25hbWUsIHN0b3JlX2tleSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoc3RvcmVfbmFtZSwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc0FycmF5OFRvV2FzbTAoc3RvcmVfa2V5LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zdG9yZWhhbmRsZV9vcGVuV2l0aEtleShwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG5cbmNvbnN0IFRvRGV2aWNlUmVxdWVzdEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190b2RldmljZXJlcXVlc3RfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogRGF0YSBmb3IgYSByZXF1ZXN0IHRvIHRoZSBgL3NlbmRUb0RldmljZWAgQVBJIGVuZHBvaW50XG4gKiAoW3NwZWNpZmljYXRpb25dKS5cbiAqXG4gKiBTZW5kIGFuIGV2ZW50IHRvIGEgc2luZ2xlIGRldmljZSBvciB0byBhIGdyb3VwIG9mIGRldmljZXMuXG4gKlxuICogW3NwZWNpZmljYXRpb25dOiBodHRwczovL3NwZWMubWF0cml4Lm9yZy91bnN0YWJsZS9jbGllbnQtc2VydmVyLWFwaS8jcHV0X21hdHJpeGNsaWVudHYzc2VuZHRvZGV2aWNlZXZlbnR0eXBldHhuaWRcbiAqL1xuZXhwb3J0IGNsYXNzIFRvRGV2aWNlUmVxdWVzdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVG9EZXZpY2VSZXF1ZXN0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRvRGV2aWNlUmVxdWVzdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUb0RldmljZVJlcXVlc3RGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RvZGV2aWNlcmVxdWVzdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0IElELlxuICAgICAqIEZvciB0by1kZXZpY2UgcmVxdWVzdCB0aGlzIHdvdWxkIGJlIHRoZSBzYW1lIHZhbHVlIGFzIGB0eG5faWRgLiBJdCBpc1xuICAgICAqIGV4cG9zZWQgYWxzbyBhcyBgaWRgIHNvIHRoYXQgdGhlIGpzIGJpbmRpbmdzIGFyZSBjb25zaXN0ZW50IHdpdGggdGhlXG4gICAgICogb3RoZXIgcmVxdWVzdCB0eXBlcyBieSB1c2luZyB0aGlzIGZpZWxkIHRvIG1hcmsgYXMgc2VudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfdG9kZXZpY2VyZXF1ZXN0X2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIGV2ZW50IGJlaW5nIHNlbnQgdG8gZWFjaCBkZXZpY2VzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGV2ZW50X3R5cGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3RvZGV2aWNlcmVxdWVzdF9ldmVudF90eXBlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgcmVxdWVzdCBpZGVudGlmaWVyIHVuaXF1ZSB0byB0aGUgYWNjZXNzIHRva2VuXG4gICAgICogdXNlZCB0byBzZW5kIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHR4bl9pZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfdG9kZXZpY2VyZXF1ZXN0X3R4bl9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgSlNPTi1lbmNvZGVkIHN0cmluZyBjb250YWluaW5nIHRoZSByZXN0IG9mIHRoZSBwYXlsb2FkOiBgbWVzc2FnZXNgLlxuICAgICAqXG4gICAgICogSXQgcmVwcmVzZW50cyB0aGUgYm9keSBvZiB0aGUgSFRUUCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3RvZGV2aWNlcmVxdWVzdF9ib2R5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGBUb0RldmljZVJlcXVlc3RgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF90eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR4bl9pZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBib2R5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWQsIGV2ZW50X3R5cGUsIHR4bl9pZCwgYm9keSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRvZGV2aWNlcmVxdWVzdF9uZXcoaWQsIGV2ZW50X3R5cGUsIHR4bl9pZCwgYm9keSk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBUb0RldmljZVJlcXVlc3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGl0cyByZXF1ZXN0IHR5cGUuXG4gICAgICogQHJldHVybnMge1JlcXVlc3RUeXBlfVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRvZGV2aWNlcmVxdWVzdF90eXBlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG5cbmNvbnN0IFRyYWNpbmdGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhY2luZ19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBUeXBlIHRvIGluc3RhbGwgYW5kIHRvIG1hbmlwdWxhdGUgdGhlIHRyYWNpbmcgbGF5ZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFjaW5nIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhY2luZ0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhY2luZ19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGB0cmFjaW5nYCBmZWF0dXJlIGhhcyBiZWVuIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZDogYHRyYWNpbmdgIGlzIG5vdyBhbHdheXMgZW5hYmxlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhY2luZ19pc0F2YWlsYWJsZSgpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnN0YWxsIHRoZSB0cmFjaW5nIGxheWVyLlxuICAgICAqIEBwYXJhbSB7TG9nZ2VyTGV2ZWx9IG1pbl9sZXZlbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1pbl9sZXZlbCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYWNpbmdfbmV3KG1pbl9sZXZlbCk7XG4gICAgICAgIGlmIChyZXRbMl0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXRbMF0gPj4+IDA7XG4gICAgICAgIFRyYWNpbmdGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmUtZGVmaW5lIHRoZSBtaW5pbXVtIGxvZ2dlciBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0xvZ2dlckxldmVsfSBtaW5fbGV2ZWxcbiAgICAgKi9cbiAgICBzZXQgbWluTGV2ZWwobWluX2xldmVsKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhY2luZ19zZXRfbWluTGV2ZWwodGhpcy5fX3diZ19wdHIsIG1pbl9sZXZlbCk7XG4gICAgICAgIGlmIChyZXRbMV0pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFswXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHVybiB0aGUgbG9nZ2VyIG9uLCBpLmUuIGl0IGVtaXRzIGxvZ3MgYWdhaW4gaWYgaXQgd2FzIHR1cm5lZFxuICAgICAqIG9mZi5cbiAgICAgKi9cbiAgICB0dXJuT24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhY2luZ190dXJuT24odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICBpZiAocmV0WzFdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR1cm4gdGhlIGxvZ2dlciBvZmYsIGkuZS4gaXQgbm8gbG9uZ2VyIGVtaXRzIGxvZ3MuXG4gICAgICovXG4gICAgdHVybk9mZigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFjaW5nX3R1cm5PZmYodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICBpZiAocmV0WzFdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMF0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBVcGxvYWRTaWduaW5nS2V5c1JlcXVlc3RGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdXBsb2Fkc2lnbmluZ2tleXNyZXF1ZXN0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIE90aGVyIFJlcXVlc3RzICpcbiAqIFJlcXVlc3QgdGhhdCB3aWxsIHB1Ymxpc2ggYSBjcm9zcyBzaWduaW5nIGlkZW50aXR5LlxuICpcbiAqIFRoaXMgdXBsb2FkcyB0aGUgcHVibGljIGNyb3NzIHNpZ25pbmcga2V5IHRyaXBsZXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBVcGxvYWRTaWduaW5nS2V5c1JlcXVlc3Qge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFVwbG9hZFNpZ25pbmdLZXlzUmVxdWVzdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBVcGxvYWRTaWduaW5nS2V5c1JlcXVlc3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVXBsb2FkU2lnbmluZ0tleXNSZXF1ZXN0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ191cGxvYWRzaWduaW5na2V5c3JlcXVlc3RfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIEpTT04tZW5jb2RlZCBzdHJpbmcgY29udGFpbmluZyB0aGUgcmVzdCBvZiB0aGUgcGF5bG9hZDogYG1hc3Rlcl9rZXlgLFxuICAgICAqIGBzZWxmX3NpZ25pbmdfa2V5YCwgYHVzZXJfc2lnbmluZ19rZXlgLlxuICAgICAqXG4gICAgICogSXQgcmVwcmVzZW50cyB0aGUgYm9keSBvZiB0aGUgSFRUUCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3VwbG9hZHNpZ25pbmdrZXlzcmVxdWVzdF9ib2R5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGBVcGxvYWRTaWduaW5nS2V5c1JlcXVlc3RgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBib2R5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYm9keSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnVwbG9hZHNpZ25pbmdrZXlzcmVxdWVzdF9uZXcoYm9keSk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBVcGxvYWRTaWduaW5nS2V5c1JlcXVlc3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNvbnN0IFVzZXJEZXZpY2VzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3VzZXJkZXZpY2VzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEEgcmVhZCBvbmx5IHZpZXcgb3ZlciBhbGwgZGV2aWNlcyBiZWxvbmdpbmcgdG8gYSB1c2VyLlxuICovXG5leHBvcnQgY2xhc3MgVXNlckRldmljZXMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFVzZXJEZXZpY2VzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFVzZXJEZXZpY2VzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFVzZXJEZXZpY2VzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ191c2VyZGV2aWNlc19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3BlY2lmaWMgZGV2aWNlIHdpdGggdGhlIGdpdmVuIGRldmljZSBJRC5cbiAgICAgKiBAcGFyYW0ge0RldmljZUlkfSBkZXZpY2VfaWRcbiAgICAgKiBAcmV0dXJucyB7RGV2aWNlIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldChkZXZpY2VfaWQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGRldmljZV9pZCwgRGV2aWNlSWQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnVzZXJkZXZpY2VzX2dldCh0aGlzLl9fd2JnX3B0ciwgZGV2aWNlX2lkLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBEZXZpY2UuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZGV2aWNlcyBvZiB0aGlzIHVzZXJcbiAgICAgKiB0aGF0IGlzIGNvbnNpZGVyZWQgdG8gYmUgdmVyaWZpZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIFRoaXMgd29uJ3QgY29uc2lkZXIgeW91ciBvd24gZGV2aWNlIGFzIHZlcmlmaWVkLCBhcyB5b3VyIG93blxuICAgICAqIGRldmljZSBpcyBhbHdheXMgaW1wbGljaXRseSB2ZXJpZmllZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0FueVZlcmlmaWVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnVzZXJkZXZpY2VzX2lzQW55VmVyaWZpZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcnJheSBvdmVyIGFsbCB0aGUgZGV2aWNlIElEcyBvZiB0aGUgdXNlciBkZXZpY2VzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIGtleXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udXNlcmRldmljZXNfa2V5cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdG9yIG92ZXIgYWxsIHRoZSBkZXZpY2VzIG9mIHRoZSB1c2VyIGRldmljZXMuXG4gICAgICogQHJldHVybnMge0FycmF5PGFueT59XG4gICAgICovXG4gICAgZGV2aWNlcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS51c2VyZGV2aWNlc19kZXZpY2VzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG5cbmNvbnN0IFVzZXJJZEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ191c2VyaWRfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQSBNYXRyaXggW3VzZXIgSURdLlxuICpcbiAqIFt1c2VyIElEXTogaHR0cHM6Ly9zcGVjLm1hdHJpeC5vcmcvdjEuMi9hcHBlbmRpY2VzLyN1c2VyLWlkZW50aWZpZXJzXG4gKi9cbmV4cG9ydCBjbGFzcyBVc2VySWQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFVzZXJJZC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBVc2VySWRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBVc2VySWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFVzZXJJZEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdXNlcmlkX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UvdmFsaWRhdGUgYW5kIGNyZWF0ZSBhIG5ldyBgVXNlcklkYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoaWQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS51c2VyaWRfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0WzBdID4+PiAwO1xuICAgICAgICBVc2VySWRGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdXNlcidzIGxvY2FscGFydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBsb2NhbHBhcnQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS51c2VyaWRfbG9jYWxwYXJ0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcmV0WzBdO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByZXRbMV07XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2VydmVyIG5hbWUgb2YgdGhlIHVzZXIgSUQuXG4gICAgICogQHJldHVybnMge1NlcnZlck5hbWV9XG4gICAgICovXG4gICAgZ2V0IHNlcnZlck5hbWUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udXNlcmlkX3NlcnZlck5hbWUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gU2VydmVyTmFtZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIHVzZXIgSUQgaXMgYSBoaXN0b3JpY2FsIG9uZS5cbiAgICAgKlxuICAgICAqIEEgaGlzdG9yaWNhbCB1c2VyIElEIGlzIG9uZSB0aGF0IGRvZXNuJ3QgY29uZm9ybSB0byB0aGUgbGF0ZXN0XG4gICAgICogc3BlY2lmaWNhdGlvbiBvZiB0aGUgdXNlciBJRCBncmFtbWFyIGJ1dCBpcyBzdGlsbCBhY2NlcHRlZFxuICAgICAqIGJlY2F1c2UgaXQgd2FzIHByZXZpb3VzbHkgYWxsb3dlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0hpc3RvcmljYWwoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udXNlcmlkX2lzSGlzdG9yaWNhbCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdXNlciBJRCBhcyBhIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20udXNlcmlkX3RvU3RyaW5nKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcmV0WzBdO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByZXRbMV07XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBgVXNlcklkYC5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHBhc3NpbmcgYSBgVXNlcklkYCBpbnN0YW5jZSB0byBtZXRob2RzIHN1Y2ggYXNcbiAgICAgKiB7QGxpbmsgT2xtTWFjaGluZS51cGRhdGVUcmFja2VkVXNlcnN9IHdoaWNoIGRlc3Ryb3kgdGhlIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtVc2VySWR9XG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udXNlcmlkX2Nsb25lKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFVzZXJJZC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5cbmNvbnN0IFZlcmlmaWNhdGlvblJlcXVlc3RGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdmVyaWZpY2F0aW9ucmVxdWVzdF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBbiBvYmplY3QgY29udHJvbGxpbmcga2V5IHZlcmlmaWNhdGlvbiByZXF1ZXN0cy5cbiAqXG4gKiBJbnRlcmFjdGl2ZSB2ZXJpZmljYXRpb24gZmxvd3MgdXN1YWxseSBzdGFydCB3aXRoIGEgdmVyaWZpY2F0aW9uXG4gKiByZXF1ZXN0LCB0aGlzIG9iamVjdCBsZXRzIHlvdSBzZW5kIGFuZCByZXBseSB0byBzdWNoIGFcbiAqIHZlcmlmaWNhdGlvbiByZXF1ZXN0LlxuICpcbiAqIEFmdGVyIHRoZSBpbml0aWFsIGhhbmRzaGFrZSB0aGUgdmVyaWZpY2F0aW9uIGZsb3cgdHJhbnNpdGlvbnMgaW50b1xuICogb25lIG9mIHRoZSB2ZXJpZmljYXRpb24gbWV0aG9kcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFZlcmlmaWNhdGlvblJlcXVlc3Qge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFZlcmlmaWNhdGlvblJlcXVlc3QucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVmVyaWZpY2F0aW9uUmVxdWVzdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBWZXJpZmljYXRpb25SZXF1ZXN0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ192ZXJpZmljYXRpb25yZXF1ZXN0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGV2ZW50IGNvbnRlbnQgdGhhdCBjYW4gYmUgc2VudCBhcyBhIHJvb20gZXZlbnQgdG9cbiAgICAgKiByZXF1ZXN0IHZlcmlmaWNhdGlvbiBmcm9tIHRoZSBvdGhlciBzaWRlLiBUaGlzIHNob3VsZCBiZSB1c2VkXG4gICAgICogb25seSBmb3IgdmVyaWZpY2F0aW9ucyBvZiBvdGhlciB1c2VycyBhbmQgaXQgc2hvdWxkIGJlIHNlbnQgdG9cbiAgICAgKiBhIHJvb20gd2UgY29uc2lkZXIgdG8gYmUgYSBETSB3aXRoIHRoZSBvdGhlciB1c2VyLlxuICAgICAqIEBwYXJhbSB7VXNlcklkfSBvd25fdXNlcl9pZFxuICAgICAqIEBwYXJhbSB7RGV2aWNlSWR9IG93bl9kZXZpY2VfaWRcbiAgICAgKiBAcGFyYW0ge1VzZXJJZH0gb3RoZXJfdXNlcl9pZFxuICAgICAqIEBwYXJhbSB7YW55W10gfCB1bmRlZmluZWR9IFttZXRob2RzXVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHJlcXVlc3Qob3duX3VzZXJfaWQsIG93bl9kZXZpY2VfaWQsIG90aGVyX3VzZXJfaWQsIG1ldGhvZHMpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkM18wO1xuICAgICAgICBsZXQgZGVmZXJyZWQzXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Mob3duX3VzZXJfaWQsIFVzZXJJZCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Mob3duX2RldmljZV9pZCwgRGV2aWNlSWQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKG90aGVyX3VzZXJfaWQsIFVzZXJJZCk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUobWV0aG9kcykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAobWV0aG9kcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZpY2F0aW9ucmVxdWVzdF9yZXF1ZXN0KG93bl91c2VyX2lkLl9fd2JnX3B0ciwgb3duX2RldmljZV9pZC5fX3diZ19wdHIsIG90aGVyX3VzZXJfaWQuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciBwdHIyID0gcmV0WzBdO1xuICAgICAgICAgICAgdmFyIGxlbjIgPSByZXRbMV07XG4gICAgICAgICAgICBpZiAocmV0WzNdKSB7XG4gICAgICAgICAgICAgICAgcHRyMiA9IDA7IGxlbjIgPSAwO1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZDNfMCA9IHB0cjI7XG4gICAgICAgICAgICBkZWZlcnJlZDNfMSA9IGxlbjI7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjIsIGxlbjIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQzXzAsIGRlZmVycmVkM18xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdXIgb3duIHVzZXIgaWQuXG4gICAgICogQHJldHVybnMge1VzZXJJZH1cbiAgICAgKi9cbiAgICBnZXQgb3duVXNlcklkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmaWNhdGlvbnJlcXVlc3Rfb3duVXNlcklkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFVzZXJJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBvdGhlciB1c2VyIHRoYXQgaXMgcGFydGljaXBhdGluZyBpbiB0aGlzXG4gICAgICogdmVyaWZpY2F0aW9uIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1VzZXJJZH1cbiAgICAgKi9cbiAgICBnZXQgb3RoZXJVc2VySWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZpY2F0aW9ucmVxdWVzdF9vdGhlclVzZXJJZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBVc2VySWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBvZiB0aGUgb3RoZXIgZGV2aWNlIHRoYXQgaXMgcGFydGljaXBhdGluZyBpbiB0aGlzXG4gICAgICogdmVyaWZpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtEZXZpY2VJZCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgb3RoZXJEZXZpY2VJZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52ZXJpZmljYXRpb25yZXF1ZXN0X290aGVyRGV2aWNlSWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogRGV2aWNlSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcm9vbSBJRCBpZiB0aGUgdmVyaWZpY2F0aW9uIGlzIGhhcHBlbmluZyBpbnNpZGUgYVxuICAgICAqIHJvb20uXG4gICAgICogQHJldHVybnMge1Jvb21JZCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgcm9vbUlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmaWNhdGlvbnJlcXVlc3Rfcm9vbUlkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFJvb21JZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGluZm8gYWJvdXQgdGhlIGNhbmNlbGxhdGlvbiBpZiB0aGUgdmVyaWZpY2F0aW9uIHJlcXVlc3RcbiAgICAgKiBoYXMgYmVlbiBjYW5jZWxsZWQuXG4gICAgICogQHJldHVybnMge0NhbmNlbEluZm8gfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IGNhbmNlbEluZm8oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZpY2F0aW9ucmVxdWVzdF9jYW5jZWxJbmZvKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IENhbmNlbEluZm8uX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhcyB0aGUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgYmVlbiBhbnN3ZXJlZCBieSBhbm90aGVyIGRldmljZT9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1Bhc3NpdmUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZpY2F0aW9ucmVxdWVzdF9pc1Bhc3NpdmUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgcmVhZHkgdG8gc3RhcnQgYSB2ZXJpZmljYXRpb24gZmxvdz9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1JlYWR5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmaWNhdGlvbnJlcXVlc3RfaXNSZWFkeSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhcyB0aGUgdmVyaWZpY2F0aW9uIGZsb3cgdGltZWQgb3V0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHRpbWVkT3V0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmaWNhdGlvbnJlcXVlc3RfdGltZWRPdXQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyByZW1haW5pbmcgYmVmb3JlIHRoaXMgdmVyaWZpY2F0aW9uIGZsb3cgdGltZXNcbiAgICAgKiBvdXQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHplcm8gaWYgdGhlIHRpbWUgaGFzIGFscmVhZHkgcGFzc2VkLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGltZVJlbWFpbmluZ01pbGxpcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52ZXJpZmljYXRpb25yZXF1ZXN0X3RpbWVSZW1haW5pbmdNaWxsaXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN1cHBvcnRlZCB2ZXJpZmljYXRpb24gbWV0aG9kcyBvZiB0aGUgb3RoZXIgc2lkZS5cbiAgICAgKlxuICAgICAqIFdpbGwgYmUgcHJlc2VudCBvbmx5IGlmIHRoZSBvdGhlciBzaWRlIHJlcXVlc3RlZCB0aGVcbiAgICAgKiB2ZXJpZmljYXRpb24gb3IgaWYgd2XigJlyZSBpbiB0aGUgcmVhZHkgc3RhdGUuXG4gICAgICpcbiAgICAgKiAjIFJldHVybnNcbiAgICAgKlxuICAgICAqIGB1bmRlZmluZWRgIGlmIHdlIGRvIG5vdCB5ZXQga25vdyB0aGUgc3VwcG9ydGVkIG1ldGhvZHM7IG90aGVyd2lzZSwgYW5cbiAgICAgKiBhcnJheSBvZiBgVmVyaWZpY2F0aW9uTWV0aG9kYHMuXG4gICAgICogQHJldHVybnMge2FueVtdIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCB0aGVpclN1cHBvcnRlZE1ldGhvZHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZpY2F0aW9ucmVxdWVzdF90aGVpclN1cHBvcnRlZE1ldGhvZHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICBpZiAocmV0WzNdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKHJldFswXSAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyZXRbMF0sIHJldFsxXSAqIDQsIDQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG91ciBvd24gc3VwcG9ydGVkIHZlcmlmaWNhdGlvbiBtZXRob2RzIHRoYXQgd2UgYWR2ZXJ0aXNlZC5cbiAgICAgKlxuICAgICAqIFdpbGwgYmUgcHJlc2VudCBvbmx5IHdlIHJlcXVlc3RlZCB0aGUgdmVyaWZpY2F0aW9uIG9yIGlmIHdl4oCZcmVcbiAgICAgKiBpbiB0aGUgcmVhZHkgc3RhdGUuXG4gICAgICogQHJldHVybnMge2FueVtdIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBvdXJTdXBwb3J0ZWRNZXRob2RzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmaWNhdGlvbnJlcXVlc3Rfb3VyU3VwcG9ydGVkTWV0aG9kcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIGlmIChyZXRbM10pIHtcbiAgICAgICAgICAgIHRocm93IHRha2VGcm9tRXh0ZXJucmVmVGFibGUwKHJldFsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBpZiAocmV0WzBdICE9PSAwKSB7XG4gICAgICAgICAgICB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyZXRbMF0sIHJldFsxXSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHJldFswXSwgcmV0WzFdICogNCwgNCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVuaXF1ZSBJRCBvZiB0aGlzIHZlcmlmaWNhdGlvbiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGZsb3dJZCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmaWNhdGlvbnJlcXVlc3RfZmxvd0lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcmV0WzBdO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByZXRbMV07XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBhIHZlcmlmaWNhdGlvbiB0aGF0IGlzIHZlcmlmeWluZyBvbmUgb2Ygb3VyIG93blxuICAgICAqIGRldmljZXM/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTZWxmVmVyaWZpY2F0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmaWNhdGlvbnJlcXVlc3RfaXNTZWxmVmVyaWZpY2F0aW9uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlkIHdlIGluaXRpYXRlIHRoZSB2ZXJpZmljYXRpb24gcmVxdWVzdD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB3ZVN0YXJ0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZpY2F0aW9ucmVxdWVzdF93ZVN0YXJ0ZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYXMgdGhlIHZlcmlmaWNhdGlvbiBmbG93IHRoYXQgd2FzIHN0YXJ0ZWQgd2l0aCB0aGlzIHJlcXVlc3RcbiAgICAgKiBmaW5pc2hlZD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0RvbmUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZpY2F0aW9ucmVxdWVzdF9pc0RvbmUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcGhhc2Ugb2YgdGhpcyByZXF1ZXN0LlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIGBWZXJpZmljYXRpb25SZXF1ZXN0UGhhc2VgLlxuICAgICAqIEByZXR1cm5zIHtWZXJpZmljYXRpb25SZXF1ZXN0UGhhc2V9XG4gICAgICovXG4gICAgcGhhc2UoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZpY2F0aW9ucmVxdWVzdF9waGFzZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgcmVxdWVzdCBoYXMgdHJhbnNpdGlvbmVkIGludG8gYSBjb25jcmV0ZSB2ZXJpZmljYXRpb25cbiAgICAgKiBmbG93IChhbmQgbm90IHlldCBiZWVuIGNvbXBsZXRlZCBvciBjYW5jZWxsZWQpLCByZXR1cm5zIGEgYFZlcmlmaWNhdGlvbmBcbiAgICAgKiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zOiBhIGBTYXNgLCBhIGBRcmAsIG9yIGB1bmRlZmluZWRgLlxuICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICovXG4gICAgZ2V0VmVyaWZpY2F0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmaWNhdGlvbnJlcXVlc3RfZ2V0VmVyaWZpY2F0aW9uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGVyZSBpcyBhbiB1cGRhdGUgdG9cbiAgICAgKiB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIFRoZSBgY2FsbGJhY2tgIGlzIGNhbGxlZCB3aXRoIG5vIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICByZWdpc3RlckNoYW5nZXNDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICB3YXNtLnZlcmlmaWNhdGlvbnJlcXVlc3RfcmVnaXN0ZXJDaGFuZ2VzQ2FsbGJhY2sodGhpcy5fX3diZ19wdHIsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFzIHRoZSB2ZXJpZmljYXRpb24gZmxvdyB0aGF0IHdhcyBzdGFydGVkIHdpdGggdGhpcyByZXF1ZXN0XG4gICAgICogYmVlbiBjYW5jZWxsZWQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNDYW5jZWxsZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZpY2F0aW9ucmVxdWVzdF9pc0NhbmNlbGxlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdCB0aGUgdmVyaWZpY2F0aW9uIHJlcXVlc3Qgc2lnbmFsaW5nIHRoYXQgb3VyIGNsaWVudFxuICAgICAqIHN1cHBvcnRzIHRoZSBnaXZlbiB2ZXJpZmljYXRpb24gbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIGBtZXRob2RzYCByZXByZXNlbnRzIHRoZSBtZXRob2RzIHRoYXQgd2Ugc2hvdWxkIGFkdmVydGlzZSBhc1xuICAgICAqIHN1cHBvcnRlZCBieSB1cy5cbiAgICAgKlxuICAgICAqIEl0IHJldHVybnMgZWl0aGVyIGEgYFRvRGV2aWNlUmVxdWVzdGAsIGEgYFJvb21NZXNzYWdlUmVxdWVzdGBcbiAgICAgKiBvciBgdW5kZWZpbmVkYC5cbiAgICAgKiBAcGFyYW0ge2FueVtdfSBtZXRob2RzXG4gICAgICogQHJldHVybnMge2FueX1cbiAgICAgKi9cbiAgICBhY2NlcHRXaXRoTWV0aG9kcyhtZXRob2RzKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChtZXRob2RzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52ZXJpZmljYXRpb25yZXF1ZXN0X2FjY2VwdFdpdGhNZXRob2RzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNjZXB0IHRoZSB2ZXJpZmljYXRpb24gcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYWNjZXB0IHRoZSByZXF1ZXN0IGFuZCBzaWduYWwgdGhhdCBpdFxuICAgICAqIHN1cHBvcnRzIHRoZSBgbS5zYXMudjFgLCB0aGUgYG0ucXJfY29kZS5zaG93LnYxYCwgYW5kXG4gICAgICogYG0ucmVjaXByb2NhdGUudjFgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIGBtLnFyX2NvZGUuc2hvdy52MWAgd2lsbCBvbmx5IGJlIHNpZ25hbGVkIGlmIHRoZSBgcXJjb2RlYFxuICAgICAqIGZlYXR1cmUgaXMgZW5hYmxlZC4gVGhpcyBmZWF0dXJlIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQuIElmXG4gICAgICogaXQncyBlbmFibGVkIGFuZCBRUiBjb2RlIHNjYW5uaW5nIHNob3VsZCBiZSBzdXBwb3J0ZWQgb3IgUVJcbiAgICAgKiBjb2RlIHNob3dpbmcgc2hvdWxkbid0IGJlIHN1cHBvcnRlZCB0aGUgYGFjY2VwdF93aXRoX21ldGhvZHNgXG4gICAgICogbWV0aG9kIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBJdCByZXR1cm5zIGVpdGhlciBhIGBUb0RldmljZVJlcXVlc3RgLCBhIGBSb29tTWVzc2FnZVJlcXVlc3RgXG4gICAgICogb3IgYHVuZGVmaW5lZGAuXG4gICAgICogQHJldHVybnMge2FueX1cbiAgICAgKi9cbiAgICBhY2NlcHQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZpY2F0aW9ucmVxdWVzdF9hY2NlcHQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICBpZiAocmV0WzJdKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWtlRnJvbUV4dGVybnJlZlRhYmxlMChyZXRbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgdGhlIHZlcmlmaWNhdGlvbiByZXF1ZXN0LlxuICAgICAqXG4gICAgICogSXQgcmV0dXJucyBlaXRoZXIgYSBgVG9EZXZpY2VSZXF1ZXN0YCwgYSBgUm9vbU1lc3NhZ2VSZXF1ZXN0YFxuICAgICAqIG9yIGB1bmRlZmluZWRgLlxuICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmaWNhdGlvbnJlcXVlc3RfY2FuY2VsKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgaWYgKHJldFsyXSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFrZUZyb21FeHRlcm5yZWZUYWJsZTAocmV0WzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbiBmcm9tIHRoaXMgdmVyaWZpY2F0aW9uIHJlcXVlc3QgaW50byBhIFNBUyB2ZXJpZmljYXRpb24gZmxvdy5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYFByb21pc2U8W1NhcywgUm9vbU1lc3NhZ2VSZXF1ZXN0fFRvRGV2aWNlUmVxdWVzdF0gfCB1bmRlZmluZWQ+YFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc3RhcnRTYXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZpY2F0aW9ucmVxdWVzdF9zdGFydFNhcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgUVIgY29kZSB0aGF0IGNhbiBiZSB1c2VkIGJ5IGFub3RoZXIgY2xpZW50IHRvIHN0YXJ0XG4gICAgICogYSBRUiBjb2RlIGJhc2VkIHZlcmlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBgUXJgIG9yIGB1bmRlZmluZWRgLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZ2VuZXJhdGVRckNvZGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZpY2F0aW9ucmVxdWVzdF9nZW5lcmF0ZVFyQ29kZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgUVIgY29kZSB2ZXJpZmljYXRpb24gYnkgcHJvdmlkaW5nIGEgc2Nhbm5lZCBRUiBjb2RlXG4gICAgICogZm9yIHRoaXMgdmVyaWZpY2F0aW9uIGZsb3cuXG4gICAgICogQHBhcmFtIHtRckNvZGVTY2FufSBkYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBzY2FuUXJDb2RlKGRhdGEpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGRhdGEsIFFyQ29kZVNjYW4pO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmaWNhdGlvbnJlcXVlc3Rfc2NhblFyQ29kZSh0aGlzLl9fd2JnX3B0ciwgZGF0YS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cblxuY29uc3QgVmVyc2lvbnNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdmVyc2lvbnNfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHZlcnNpb25zIG9mIHRoZSBSdXN0IGxpYnJhcmllcyB3ZSBhcmUgdXNpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBWZXJzaW9ucyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVmVyc2lvbnMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVmVyc2lvbnNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVmVyc2lvbnNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3ZlcnNpb25zX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHZlcnNpb24gb2YgdGhlIHZvZG96ZW1hYyBjcmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB2b2RvemVtYWMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3ZlcnNpb25zX3ZvZG96ZW1hYyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBtYXRyaXgtc2RrLWNyeXB0byBjcmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBtYXRyaXhfc2RrX2NyeXB0bygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfdmVyc2lvbnNfbWF0cml4X3Nka19jcnlwdG8odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgR2l0IGNvbW1pdCBoYXNoIG9mIHRoZSBjcmF0ZSdzIHNvdXJjZSB0cmVlIGF0IGJ1aWxkIHRpbWUuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgZ2l0X3NoYSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfdmVyc2lvbnNfZ2l0X3NoYSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBidWlsZC10aW1lIG91dHB1dCBvZiB0aGUgYGdpdCBkZXNjcmliZWAgY29tbWFuZCBvZiB0aGUgc291cmNlIHRyZWVcbiAgICAgKiBvZiBjcmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBnaXRfZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3ZlcnNpb25zX2dpdF9kZXNjcmlwdGlvbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfU3RyaW5nXzhmMGViMzlhNGE0YzJmNjYoYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IHJldCA9IFN0cmluZyhhcmcxKTtcbiAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDEsIGxlbjEsIHRydWUpO1xuICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMCwgcHRyMSwgdHJ1ZSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfU3RyaW5nX2VlY2M0YTExOTg3MTI3ZDYoYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IHJldCA9IFN0cmluZyhhcmcxKTtcbiAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDEsIGxlbjEsIHRydWUpO1xuICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMCwgcHRyMSwgdHJ1ZSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfV2luZG93X2IwMDQ0YWM3ZGIyNTg1MzUoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuV2luZG93O1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfV29ya2VyR2xvYmFsU2NvcGVfYjc0Y2VmZWZjNjJhMzdkYShhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5Xb3JrZXJHbG9iYWxTY29wZTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2FkZF8wZDllOTlmYjljMmQyY2M1KGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmFkZChhcmcxKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2FkZF9jODM2ZTNkNGIxNGNkMDYyKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmFkZChhcmcxLCBhcmcyKTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfYXRfNDc5ODA3YmZkZGRlM2EzMyhhcmcwLCBhcmcxKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5hdChhcmcxKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2JhY2t1cGtleXNfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBCYWNrdXBLZXlzLl9fd3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2JvdW5kXzE5MThjMDgyNmM1YjkzNjMoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGNvbnN0IHJldCA9IElEQktleVJhbmdlLmJvdW5kKGFyZzAsIGFyZzEsIGFyZzIgIT09IDAsIGFyZzMgIT09IDApO1xuICAgIHJldHVybiByZXQ7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19ib3VuZF8zMjRkZmI4ODk5Yzk3OThjKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBJREJLZXlSYW5nZS5ib3VuZChhcmcwLCBhcmcxKTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfYnVmZmVyXzYxYjdjZTAxMzQxZDdmODgoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuYnVmZmVyO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfY2FsbF8zYjc3MGYwZDZlYjQ3MjBlKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmNhbGwoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2NhbGxfNTAwZGI5NDhlNjljNzMzMCgpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5jYWxsKGFyZzEsIGFyZzIpO1xuICAgIHJldHVybiByZXQ7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19jYWxsXzliZDZmMjY5ZDQ4MzVlMzMoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuY2FsbChhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfY2FsbF9iMGQ4ZTM2OTkyZDk5MDBkKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmNhbGwoYXJnMSk7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2NsZWFyVGltZW91dF81YTU0Zjg4NDFjMzAwNzlhKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBjbGVhclRpbWVvdXQoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19jbGVhcl9kYTgzNzU4ZTBiZWEwZWI2KCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmNsZWFyKCk7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2Nsb3NlX2Y2ZTYxOGVkOGIwMzI2YTMoYXJnMCkge1xuICAgIGFyZzAuY2xvc2UoKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19jb2RlXzcxMTM2Yjg2ZTJhYTdmNDEoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuY29kZTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2NvbnRpbnVlX2JkNDQ1NjFjMDE0Y2FjZWEoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgIGFyZzAuY29udGludWUoKTtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2NvdW50XzI0NGFhNDExOGUwMDViNTkoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuY291bnQoKTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfY291bnRfNGRmNTBlZjZjMWRkZDc3MCgpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5jb3VudCgpO1xuICAgIHJldHVybiByZXQ7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19jcmVhdGVJbmRleF8xNDU3MWIzYzRlZWMxNjI4KCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmNyZWF0ZUluZGV4KGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSwgYXJnMyk7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2NyZWF0ZUluZGV4XzFkNGIyYmJiNmIyMWI4ZjgoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuY3JlYXRlSW5kZXgoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpLCBhcmczLCBhcmc0KTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfY3JlYXRlT2JqZWN0U3RvcmVfYjZmMTRhYTEwZjgzYTMwMCgpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5jcmVhdGVPYmplY3RTdG9yZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgIHJldHVybiByZXQ7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19jcm9zc3NpZ25pbmdib290c3RyYXByZXF1ZXN0c19uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IENyb3NzU2lnbmluZ0Jvb3RzdHJhcFJlcXVlc3RzLl9fd3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2Nyb3Nzc2lnbmluZ2tleWV4cG9ydF9uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IENyb3NzU2lnbmluZ0tleUV4cG9ydC5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19jcm9zc3NpZ25pbmdzdGF0dXNfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBDcm9zc1NpZ25pbmdTdGF0dXMuX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfY3J5cHRvX2VkNThiOGUxMGEyOTI4MzkoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuY3J5cHRvO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfZGVidWdfMTU2Y2E3MjdkYmMzMTUwZihhcmcwKSB7XG4gICAgY29uc29sZS5kZWJ1ZyhhcmcwKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19kZWJ1Z18zYWNkNjY4ZTZlNmM2MDg3KGFyZzAsIGFyZzEpIHtcbiAgICBhcmcwLmRlYnVnKGFyZzEpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2RlY3J5cHRlZHJvb21ldmVudF9uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IERlY3J5cHRlZFJvb21FdmVudC5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19kZWh5ZHJhdGVkZGV2aWNlX25ldyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gRGVoeWRyYXRlZERldmljZS5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19kZWh5ZHJhdGVkZGV2aWNla2V5X25ldyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gRGVoeWRyYXRlZERldmljZUtleS5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19kZWxldGVPYmplY3RTdG9yZV8xZjUwYmEwMjYzODc1ZGViKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICBhcmcwLmRlbGV0ZU9iamVjdFN0b3JlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSk7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19kZWxldGVfNWMzM2U0OTY2ZjU5NjI0ZCgpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5kZWxldGUoYXJnMSk7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2RlbGV0ZV9kOTdiMmI0ZmY3MTZjNTUzKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmRlbGV0ZSgpO1xuICAgIHJldHVybiByZXQ7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19kZXZpY2VfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBEZXZpY2UuX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfZGV2aWNlaWRfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBEZXZpY2VJZC5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19kZXZpY2VrZXlfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBEZXZpY2VLZXkuX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfZGV2aWNla2V5aWRfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBEZXZpY2VLZXlJZC5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19kb25lX2YyMmMxNTYxZmE5MTliYWEoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuZG9uZTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2Vtb2ppX25ldyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gRW1vamkuX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfZW5jcnlwdGlvbmluZm9fbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBFbmNyeXB0aW9uSW5mby5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19lbnRyaWVzXzRmMmJiOWIwZDcwMWMwZjYoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IE9iamVjdC5lbnRyaWVzKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfZW50cmllc184MmJmMGU3NTVlZjU0YTVmKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmVudHJpZXMoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2Vycm9yXzMyZmRhNjc2YWU5NzhmNmUoYXJnMCwgYXJnMSkge1xuICAgIGFyZzAuZXJyb3IoYXJnMSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfZXJyb3JfNzUzNGI4ZTlhMzZmMWFiNChhcmcwLCBhcmcxKSB7XG4gICAgbGV0IGRlZmVycmVkMF8wO1xuICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICB0cnkge1xuICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgY29uc29sZS5lcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2Vycm9yXzc3MjMzYzYyNWVkMGM1MzMoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuZXJyb3I7XG4gICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRUb0V4dGVybnJlZlRhYmxlMChyZXQpO1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfZXJyb3JfZmFiNDFhNDJkMjJiZjJiYyhhcmcwKSB7XG4gICAgY29uc29sZS5lcnJvcihhcmcwKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19mcm9tX2Q2OGVhYTk2ZGJhMjU0NDkoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IEFycmF5LmZyb20oYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19nZXRBbGxLZXlzX2FkOTdkYzI4ODIyYTY4OTEoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuZ2V0QWxsS2V5cygpO1xuICAgIHJldHVybiByZXQ7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19nZXRBbGxfNzJlMmZhYWEwNmQxYThjZigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5nZXRBbGwoKTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfZ2V0QWxsXzhmMzgwMzFlNTk2OWM3ZjUoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuZ2V0QWxsKGFyZzEpO1xuICAgIHJldHVybiByZXQ7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19nZXRBbGxfOGZhODQ1ODlmYWNjYWIzNigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5nZXRBbGwoYXJnMSwgYXJnMiA+Pj4gMCk7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2dldFJhbmRvbVZhbHVlc19iY2I0OTEyZjE2MDAwZGM0KCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICBhcmcwLmdldFJhbmRvbVZhbHVlcyhhcmcxKTtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2dldFRpbWVfYWI4YjcyMDA5OTgzYzUzNyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19nZXRfNmE0Zjg1NGY1Y2NhNzQwMygpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5nZXQoYXJnMSk7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2dldF83MDgxZWRjMDQ0MDk4M2E1KCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmdldChhcmcxKTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfZ2V0XzlhYTNkZmYzZjAyNjYwNTQoYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IHJldCA9IGFyZzBbYXJnMSA+Pj4gMF07XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19nZXRfYmJjY2Y4OTcwNzkzYzA4NygpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgY29uc3QgcmV0ID0gUmVmbGVjdC5nZXQoYXJnMCwgYXJnMSk7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2dldHdpdGhyZWZrZXlfMWRjMzYxYmQxMDA1M2JmZShhcmcwLCBhcmcxKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMFthcmcxXTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2dldHdpdGhyZWZrZXlfNjU1MGIyYzA5M2QyZWIxOChhcmcwLCBhcmcxKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMFthcmcxXTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2dsb2JhbF9iNmY1YzczMzEyZjYyMzEzKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmdsb2JhbDtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2luYm91bmRncm91cHNlc3Npb25fbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBJbmJvdW5kR3JvdXBTZXNzaW9uLl9fd3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2luZGV4Xzg3MWQ4NzQyNTNiYWU3NjAoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuaW5kZXgoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfaW5kZXhlZERCXzYwMWVjMjZjNjNlMzMzZGUoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuaW5kZXhlZERCO1xuICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkVG9FeHRlcm5yZWZUYWJsZTAocmV0KTtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2luZGV4ZWREQl83MmUyY2EwNzEyMjJmZDllKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmluZGV4ZWREQjtcbiAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZFRvRXh0ZXJucmVmVGFibGUwKHJldCk7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19pbmRleGVkREJfZTM0YTVlOWIzZDJmY2ZhMSgpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5pbmRleGVkREI7XG4gICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRUb0V4dGVybnJlZlRhYmxlMChyZXQpO1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfaW5mb19jMzA0NGM4NmFlMjlmYWFiKGFyZzApIHtcbiAgICBjb25zb2xlLmluZm8oYXJnMCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfaW5mb19lZDcxMDU2YmVmMTViOTFhKGFyZzAsIGFyZzEpIHtcbiAgICBhcmcwLmluZm8oYXJnMSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfaW5zdGFuY2VvZl9BcnJheUJ1ZmZlcl82NzBkZGRlNDRjZGIyNjAyKGFyZzApIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGFyZzAgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19pbnN0YW5jZW9mX01hcF85OGVjYjMwYWZlYzVhY2RiKGFyZzApIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGFyZzAgaW5zdGFuY2VvZiBNYXA7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gcmVzdWx0O1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfaW5zdGFuY2VvZl9Qcm9taXNlXzBhYTNhOTBjZmU2NjcyYzkoYXJnMCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXJnMCBpbnN0YW5jZW9mIFByb21pc2U7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gcmVzdWx0O1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfaW5zdGFuY2VvZl9VaW50OEFycmF5XzI4YWY1YmMxOWQ2YWNhZDgoYXJnMCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXJnMCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gcmVzdWx0O1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfaXNBcnJheV8xYmExMWE5MzAxMDhlYzUxKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBBcnJheS5pc0FycmF5KGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfaXNTYWZlSW50ZWdlcl8xMmY1NTQ5YjJmY2EyM2Y0KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBOdW1iZXIuaXNTYWZlSW50ZWdlcihhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2l0ZW1fNzE1NmE4ZmZhNGQ4MTZiYyhhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMS5pdGVtKGFyZzIgPj4+IDApO1xuICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShyZXQpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMSwgbGVuMSwgdHJ1ZSk7XG4gICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAwLCBwdHIxLCB0cnVlKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19pdGVyYXRvcl8yMzYwNGJiOTgzNzkxNTc2KCkge1xuICAgIGNvbnN0IHJldCA9IFN5bWJvbC5pdGVyYXRvcjtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2tleV84N2RiODIyNjc1OWRhNjQyKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmtleTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfa2V5c2JhY2t1cHJlcXVlc3RfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBLZXlzQmFja3VwUmVxdWVzdC5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19rZXlzY2xhaW1yZXF1ZXN0X25ldyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gS2V5c0NsYWltUmVxdWVzdC5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19rZXlzcXVlcnlyZXF1ZXN0X25ldyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gS2V5c1F1ZXJ5UmVxdWVzdC5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19rZXlzdXBsb2FkcmVxdWVzdF9uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IEtleXNVcGxvYWRSZXF1ZXN0Ll9fd3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2xlbmd0aF82NWQxY2QxMTcyOWNlZDExKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2xlbmd0aF9kNjVjZjA3ODZiZmM1NzM5KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2xlbmd0aF9mNGQ3OTQwOWFhMzI0ODExKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2xvd2VyQm91bmRfM2FhNDdjYWEzM2M3ZTFlNigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgY29uc3QgcmV0ID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChhcmcwLCBhcmcxICE9PSAwKTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfbWF5YmVzaWduYXR1cmVfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBNYXliZVNpZ25hdHVyZS5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19tZWdvbG1kZWNyeXB0aW9uZXJyb3JfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBNZWdvbG1EZWNyeXB0aW9uRXJyb3IuX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfbWVzc2FnZV9kMTliZGI2NWYwYTQxY2Y1KGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBhcmcxLm1lc3NhZ2U7XG4gICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAxLCBsZW4xLCB0cnVlKTtcbiAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDAsIHB0cjEsIHRydWUpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX21zQ3J5cHRvXzBhMzZlMmVjM2EzNDNkMjYoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAubXNDcnlwdG87XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19uYW1lXzg4NjJjZDQ5YWQ4MDdjNTkoYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IHJldCA9IGFyZzEubmFtZTtcbiAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDEsIGxlbjEsIHRydWUpO1xuICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMCwgcHRyMSwgdHJ1ZSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfbmV3XzBmMWJkNjU5ZGNkNDcwNjgoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBTZXQoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19uZXdfMjU0ZmE5ZWFjMTE5MzJhZSgpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgQXJyYXkoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX25ld18zZDQ0NmRmOTE1NTEyOGVmKGFyZzAsIGFyZzEpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgc3RhdGUwID0ge2E6IGFyZzAsIGI6IGFyZzF9O1xuICAgICAgICB2YXIgY2IwID0gKGFyZzAsIGFyZzEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBzdGF0ZTAuYTtcbiAgICAgICAgICAgIHN0YXRlMC5hID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fd2JnX2FkYXB0ZXJfNzU4KGEsIHN0YXRlMC5iLCBhcmcwLCBhcmcxKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc3RhdGUwLmEgPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZShjYjApO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHN0YXRlMC5hID0gc3RhdGUwLmIgPSAwO1xuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19uZXdfM2ZmNWIzM2IxY2U3MTJkZihhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19uZXdfNDEyNTc1MzZhZjYwZWQxNChhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IERhdGUoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19uZXdfNjg4ODQ2ZjM3NDM1MWM5MigpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgT2JqZWN0KCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19uZXdfOGE2ZjIzOGE2ZWNlODZlYSgpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgRXJyb3IoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX25ld185NDUxZjNkY2I0MmUwZTM3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19uZXdfYmM5NmM2YTFjMDc4NjY0MygpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19uZXdub2FyZ3NfZmQ5ZTRiZjhiZTJiYzE2ZChhcmcwLCBhcmcxKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IEZ1bmN0aW9uKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9iYTM1ODk2OTY4NzUxZDkxKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShhcmcwLCBhcmcxID4+PiAwLCBhcmcyID4+PiAwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2MwYzkwNjUzZjczYzdkZmIoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OENsYW1wZWRBcnJheShhcmcwLCBhcmcxID4+PiAwLCBhcmcyID4+PiAwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX25ld3dpdGhsZW5ndGhfMmFlZGUwZWY0ZTZlOTdlYyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGFyZzAgPj4+IDApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfbmV3d2l0aGxlbmd0aF8zNGNlOGYxMDUxZTc0NDQ5KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShhcmcwID4+PiAwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX25ld3dpdGhtZXNzYWdlXzgwZTY0MzYwNTg4NjJmZDQoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBET01FeGNlcHRpb24oZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfbmV4dF8wMWRkOTIzNGE1YmY2ZDA1KCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLm5leHQoKTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfbmV4dF8xMzc0MjhkZWI5ODM0MmIwKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLm5leHQ7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19ub2RlXzAyOTk5NTMzYzRlYTAyZTMoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAubm9kZTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX25vd18yYzk1YzlkZTAxMjkzMTczKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLm5vdygpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfbm93XzY0ZDBiYjE1MWU1ZDM4ODkoKSB7XG4gICAgY29uc3QgcmV0ID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX29iamVjdFN0b3JlTmFtZXNfY2IwMGM4MTEzYjNjZjVkZihhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5vYmplY3RTdG9yZU5hbWVzO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfb2JqZWN0U3RvcmVfY2RiYzczZWU2MDBhMmNmYSgpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5vYmplY3RTdG9yZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgIHJldHVybiByZXQ7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19vbGRWZXJzaW9uX2EzMWQ5Zjg1NzcyMzlkZDgoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAub2xkVmVyc2lvbjtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX29sbW1hY2hpbmVfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBPbG1NYWNoaW5lLl9fd3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX29wZW5DdXJzb3JfMzdlMjFkOWFmMWE2MTE1OSgpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5vcGVuQ3Vyc29yKCk7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX29wZW5DdXJzb3JfZGEwOGNjNzQ1NDI3MTFhZCgpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5vcGVuQ3Vyc29yKGFyZzEpO1xuICAgIHJldHVybiByZXQ7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19vcGVuQ3Vyc29yX2U3YTNmNjQ1M2EwZjY3MjUoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAub3BlbkN1cnNvcigpO1xuICAgIHJldHVybiByZXQ7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19vcGVuXzQ1ODhjODVjMGM0MzY3MWQoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IHJldCA9IGFyZzAub3BlbihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgIHJldHVybiByZXQ7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19vcGVuXzVjNTFkNGQ2ZDdhYjZkYTYoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGNvbnN0IHJldCA9IGFyZzAub3BlbihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMiksIGFyZzMgPj4+IDApO1xuICAgIHJldHVybiByZXQ7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19vdGhlcnVzZXJpZGVudGl0eV9uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IE90aGVyVXNlcklkZW50aXR5Ll9fd3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX293bnVzZXJpZGVudGl0eV9uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IE93blVzZXJJZGVudGl0eS5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19wYXJzZV8xNjFjNjgzNzhlMDg2YWUxKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBKU09OLnBhcnNlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3BlcmZvcm1hbmNlXzdhM2ZmZDBiMTdmNjYzYWQoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAucGVyZm9ybWFuY2U7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19waWNrbGVkaW5ib3VuZGdyb3Vwc2Vzc2lvbl91bndyYXAoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IFBpY2tsZWRJbmJvdW5kR3JvdXBTZXNzaW9uLl9fdW53cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfcGlja2xlZHNlc3Npb25fdW53cmFwKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBQaWNrbGVkU2Vzc2lvbi5fX3Vud3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3Byb2Nlc3NfNWMxZDY3MGJjNTM2MTRiOChhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5wcm9jZXNzO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfcHVzaF82ZWRhZDBkZjRiNTQ2YjJjKGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLnB1c2goYXJnMSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19wdXRfNTM5M2U4OGRiZTc0MmU4ZigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5wdXQoYXJnMSwgYXJnMik7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3B1dGRlaHlkcmF0ZWRkZXZpY2VyZXF1ZXN0X25ldyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gUHV0RGVoeWRyYXRlZERldmljZVJlcXVlc3QuX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfcXJfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBRci5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19xdWV1ZU1pY3JvdGFza18yMTgxMDQwZTA2NGMwZGM4KGFyZzApIHtcbiAgICBxdWV1ZU1pY3JvdGFzayhhcmcwKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19xdWV1ZU1pY3JvdGFza19lZjlhYzQzNzY5Y2JjYzRmKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLnF1ZXVlTWljcm90YXNrO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfcmFuZG9tRmlsbFN5bmNfYWIyY2ZlNzllYmJmMjc0MCgpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgYXJnMC5yYW5kb21GaWxsU3luYyhhcmcxKTtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3JlYWR5U3RhdGVfODQyOGZhN2M1ZTA5MzQwMShhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5yZWFkeVN0YXRlO1xuICAgIHJldHVybiAoX193YmluZGdlbl9lbnVtX0lkYlJlcXVlc3RSZWFkeVN0YXRlLmluZGV4T2YocmV0KSArIDEgfHwgMykgLSAxO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3JlaHlkcmF0ZWRkZXZpY2VfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBSZWh5ZHJhdGVkRGV2aWNlLl9fd3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3JlcXVpcmVfNzliMWU5Mjc0Y2RlM2M4NygpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCByZXQgPSBtb2R1bGUucmVxdWlyZTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfcmVzb2x2ZV8wYmY3YzQ0ZDY0MTgwNGY5KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBQcm9taXNlLnJlc29sdmUoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19yZXN1bHRfZTZiYTZhMzQ3ZGNiNzQ3MCgpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5yZXN1bHQ7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3Jvb21pZF91bndyYXAoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IFJvb21JZC5fX3Vud3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3Jvb21rZXljb3VudHNfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBSb29tS2V5Q291bnRzLl9fd3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3Jvb21rZXlpbXBvcnRyZXN1bHRfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBSb29tS2V5SW1wb3J0UmVzdWx0Ll9fd3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3Jvb21rZXlpbmZvX25ldyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gUm9vbUtleUluZm8uX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfcm9vbWtleXdpdGhoZWxkaW5mb19uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IFJvb21LZXlXaXRoaGVsZEluZm8uX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfcm9vbW1lc3NhZ2VyZXF1ZXN0X25ldyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gUm9vbU1lc3NhZ2VSZXF1ZXN0Ll9fd3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3Jvb21zZXR0aW5nc19uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IFJvb21TZXR0aW5ncy5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19zYXNfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBTYXMuX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfc2VjcmV0c2J1bmRsZV9uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IFNlY3JldHNCdW5kbGUuX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfc2V0VGltZW91dF9kYjJkYmFlZWZiNmYzOWM3KCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBzZXRUaW1lb3V0KGFyZzAsIGFyZzEpO1xuICAgIHJldHVybiByZXQ7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19zZXRfMWQ4MDc1MmQwZDVmMGIyMShhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgYXJnMFthcmcxID4+PiAwXSA9IGFyZzI7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfc2V0XzIzZDY5ZGI0ZTVjNjZhNmUoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGFyZzAuc2V0KGFyZzEsIGFyZzIgPj4+IDApO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3NldF8zODA3ZDVmMGJmYzI0YWE3KGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICBhcmcwW2FyZzFdID0gYXJnMjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19zZXRfM2YxZDBiOTg0ZWQyNzJlZChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgYXJnMFthcmcxXSA9IGFyZzI7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfc2V0Xzc2ODE4ZGMzYzU5YTYzZDUoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IHJldCA9IGFyZzAuc2V0KGFyZzEsIGFyZzIpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfc2V0Xzk1OTJmN2Q1Yjc1MmNhZTMoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGFyZzAuc2V0KGFyZzEsIGFyZzIgPj4+IDApO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3NldG9uYWJvcnRfYWRlNmNhYzVjMzVhNTcyZihhcmcwLCBhcmcxKSB7XG4gICAgYXJnMC5vbmFib3J0ID0gYXJnMTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19zZXRvbmJsb2NrZWRfZDEzMDQ4YmU5MzgzZjRkYyhhcmcwLCBhcmcxKSB7XG4gICAgYXJnMC5vbmJsb2NrZWQgPSBhcmcxO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3NldG9uY29tcGxldGVfMjc0N2ZiNzFhZTBhZjRhOChhcmcwLCBhcmcxKSB7XG4gICAgYXJnMC5vbmNvbXBsZXRlID0gYXJnMTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19zZXRvbmVycm9yXzcyYjMzZTMxZjllZGIwNDUoYXJnMCwgYXJnMSkge1xuICAgIGFyZzAub25lcnJvciA9IGFyZzE7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfc2V0b25lcnJvcl9lNGJlYjI2NTJjZjY2NjM1KGFyZzAsIGFyZzEpIHtcbiAgICBhcmcwLm9uZXJyb3IgPSBhcmcxO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3NldG9uc3VjY2Vzc181NzE2N2IxYzI2NTAzNTdjKGFyZzAsIGFyZzEpIHtcbiAgICBhcmcwLm9uc3VjY2VzcyA9IGFyZzE7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfc2V0b251cGdyYWRlbmVlZGVkXzg4N2M3YTVmY2E2NjAxMWUoYXJnMCwgYXJnMSkge1xuICAgIGFyZzAub251cGdyYWRlbmVlZGVkID0gYXJnMTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19zZXRvbnZlcnNpb25jaGFuZ2VfYTZmNjBiZDFkMTEwNzk1ZChhcmcwLCBhcmcxKSB7XG4gICAgYXJnMC5vbnZlcnNpb25jaGFuZ2UgPSBhcmcxO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3NldHVuaXF1ZV9jZmM0NzdkYzU4MjVlMWM0KGFyZzAsIGFyZzEpIHtcbiAgICBhcmcwLnVuaXF1ZSA9IGFyZzEgIT09IDA7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfc2lnbmF0dXJlc19uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IFNpZ25hdHVyZXMuX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfc2lnbmF0dXJldXBsb2FkcmVxdWVzdF9uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IFNpZ25hdHVyZVVwbG9hZFJlcXVlc3QuX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfc2lnbmF0dXJldmVyaWZpY2F0aW9uX25ldyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gU2lnbmF0dXJlVmVyaWZpY2F0aW9uLl9fd3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3N0YWNrXzBlZDc1ZDY4NTc1YjBmM2MoYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IHJldCA9IGFyZzEuc3RhY2s7XG4gICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAxLCBsZW4xLCB0cnVlKTtcbiAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDAsIHB0cjEsIHRydWUpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9HTE9CQUxfMGJlNzQ3MmU0OTJhZDNlMygpIHtcbiAgICBjb25zdCByZXQgPSB0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBnbG9iYWw7XG4gICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRUb0V4dGVybnJlZlRhYmxlMChyZXQpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9HTE9CQUxfVEhJU18xYTZlYjQ4MmQxMmM5YmZiKCkge1xuICAgIGNvbnN0IHJldCA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBnbG9iYWxUaGlzO1xuICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkVG9FeHRlcm5yZWZUYWJsZTAocmV0KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19zdGF0aWNfYWNjZXNzb3JfU0VMRl8xZGMzOThhODk1YzgyMzUxKCkge1xuICAgIGNvbnN0IHJldCA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBzZWxmO1xuICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkVG9FeHRlcm5yZWZUYWJsZTAocmV0KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19zdGF0aWNfYWNjZXNzb3JfV0lORE9XX2FlMWM4MGM3ZWVhOGQ2NGEoKSB7XG4gICAgY29uc3QgcmV0ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93O1xuICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkVG9FeHRlcm5yZWZUYWJsZTAocmV0KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19zdG9yZWhhbmRsZV9uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IFN0b3JlSGFuZGxlLl9fd3JhcChhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3N0cmluZ2lmeV9mNGY3MDFiYzM0Y2VkYTYxKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBKU09OLnN0cmluZ2lmeShhcmcwKTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfc3ViYXJyYXlfNDZhZGViOWI4Njk0OWQxMihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC5zdWJhcnJheShhcmcxID4+PiAwLCBhcmcyID4+PiAwKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3RhcmdldF9hOGZlNTkzZTdlZTc5YzIxKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLnRhcmdldDtcbiAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZFRvRXh0ZXJucmVmVGFibGUwKHJldCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfdGhlbl8wNDM4ZmFkODYwZmUzOGUxKGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLnRoZW4oYXJnMSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ190aGVuXzBmZmFmZWRkZjBlMTgyYTQoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IHJldCA9IGFyZzAudGhlbihhcmcxLCBhcmcyKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3RvZGV2aWNlcmVxdWVzdF9uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IFRvRGV2aWNlUmVxdWVzdC5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ190cmFuc2FjdGlvbl9iYzcxYzJhYWFmNDY3NDIwKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLnRyYW5zYWN0aW9uKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSwgX193YmluZGdlbl9lbnVtX0lkYlRyYW5zYWN0aW9uTW9kZVthcmczXSk7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3RyYW5zYWN0aW9uX2QyYjZkNTIwODM3ZmJlN2YoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAudHJhbnNhY3Rpb247XG4gICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRUb0V4dGVybnJlZlRhYmxlMChyZXQpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3RyYW5zYWN0aW9uX2RiYWI5Y2Q5ZWE4NDk5NTgoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IHJldCA9IGFyZzAudHJhbnNhY3Rpb24oYXJnMSwgX193YmluZGdlbl9lbnVtX0lkYlRyYW5zYWN0aW9uTW9kZVthcmcyXSk7XG4gICAgcmV0dXJuIHJldDtcbn0sIGFyZ3VtZW50cykgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3VwZGF0ZV8yMTFkZGNjYWYyY2VjNmVlKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLnVwZGF0ZShhcmcxKTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfdXNlcmRldmljZXNfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBVc2VyRGV2aWNlcy5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ191c2VyaWRfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBVc2VySWQuX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfdXNlcmlkX3Vud3JhcChhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gVXNlcklkLl9fdW53cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfdmFsdWVfMGFkNmYzNzY3N2M4ZWU3NCgpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC52YWx1ZTtcbiAgICByZXR1cm4gcmV0O1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfdmFsdWVfNGMzMmZkMTM4YTg4ZWVlMihhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMC52YWx1ZTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3ZhbHVlc183YWEwM2RkMDc4OTc4Yzg2KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLnZhbHVlcygpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfdmVyaWZpY2F0aW9ucmVxdWVzdF9uZXcoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IFZlcmlmaWNhdGlvblJlcXVlc3QuX193cmFwKGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfdmVyc2lvbl8yYjY1MGM5ZDRmMGEyNDM4KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLnZlcnNpb247XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ192ZXJzaW9uc19jNzFhYTE2MjZhOTNlMGExKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwLnZlcnNpb25zO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfd2Fybl8xMjNkYjZhYTg5NDgzODJlKGFyZzApIHtcbiAgICBjb25zb2xlLndhcm4oYXJnMCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfd2Fybl85ZDAzOGRmMTU4OWNiMWJkKGFyZzAsIGFyZzEpIHtcbiAgICBhcmcwLndhcm4oYXJnMSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmluZGdlbl9hc19udW1iZXIoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9ICthcmcwO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmluZGdlbl9iaWdpbnRfZnJvbV9pNjQoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGFyZzA7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX2JpZ2ludF9mcm9tX3U2NChhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gQmlnSW50LmFzVWludE4oNjQsIGFyZzApO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmluZGdlbl9iaWdpbnRfZ2V0X2FzX2k2NChhcmcwLCBhcmcxKSB7XG4gICAgY29uc3QgdiA9IGFyZzE7XG4gICAgY29uc3QgcmV0ID0gdHlwZW9mKHYpID09PSAnYmlnaW50JyA/IHYgOiB1bmRlZmluZWQ7XG4gICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0QmlnSW50NjQoYXJnMCArIDggKiAxLCBpc0xpa2VOb25lKHJldCkgPyBCaWdJbnQoMCkgOiByZXQsIHRydWUpO1xuICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMCwgIWlzTGlrZU5vbmUocmV0KSwgdHJ1ZSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmluZGdlbl9ib29sZWFuX2dldChhcmcwKSB7XG4gICAgY29uc3QgdiA9IGFyZzA7XG4gICAgY29uc3QgcmV0ID0gdHlwZW9mKHYpID09PSAnYm9vbGVhbicgPyAodiA/IDEgOiAwKSA6IDI7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX2NiX2Ryb3AoYXJnMCkge1xuICAgIGNvbnN0IG9iaiA9IGFyZzAub3JpZ2luYWw7XG4gICAgaWYgKG9iai5jbnQtLSA9PSAxKSB7XG4gICAgICAgIG9iai5hID0gMDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IGZhbHNlO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXIxMDUwKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCAzMCwgX193YmdfYWRhcHRlcl81OCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjIyMTMoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IHJldCA9IG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIDQxMCwgX193YmdfYWRhcHRlcl82MSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjUzODYoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IHJldCA9IG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIDQxMCwgX193YmdfYWRhcHRlcl82NCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjY4NDMoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IHJldCA9IG1ha2VDbG9zdXJlKGFyZzAsIGFyZzEsIDQxNiwgX193YmdfYWRhcHRlcl82Nyk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX2Nsb3N1cmVfd3JhcHBlcjY4NDgoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IHJldCA9IG1ha2VDbG9zdXJlKGFyZzAsIGFyZzEsIDQxNiwgX193YmdfYWRhcHRlcl83MCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX2RlYnVnX3N0cmluZyhhcmcwLCBhcmcxKSB7XG4gICAgY29uc3QgcmV0ID0gZGVidWdTdHJpbmcoYXJnMSk7XG4gICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAxLCBsZW4xLCB0cnVlKTtcbiAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDAsIHB0cjEsIHRydWUpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5fZXJyb3JfbmV3KGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5faW4oYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IHJldCA9IGFyZzAgaW4gYXJnMTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUoKSB7XG4gICAgY29uc3QgdGFibGUgPSB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGFibGUuZ3Jvdyg0KTtcbiAgICB0YWJsZS5zZXQoMCwgdW5kZWZpbmVkKTtcbiAgICB0YWJsZS5zZXQob2Zmc2V0ICsgMCwgdW5kZWZpbmVkKTtcbiAgICB0YWJsZS5zZXQob2Zmc2V0ICsgMSwgbnVsbCk7XG4gICAgdGFibGUuc2V0KG9mZnNldCArIDIsIHRydWUpO1xuICAgIHRhYmxlLnNldChvZmZzZXQgKyAzLCBmYWxzZSk7XG4gICAgO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5faXNfYXJyYXkoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IEFycmF5LmlzQXJyYXkoYXJnMCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX2lzX2JpZ2ludChhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gdHlwZW9mKGFyZzApID09PSAnYmlnaW50JztcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5faXNfZnVuY3Rpb24oYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IHR5cGVvZihhcmcwKSA9PT0gJ2Z1bmN0aW9uJztcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5faXNfbnVsbChhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMCA9PT0gbnVsbDtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5faXNfb2JqZWN0KGFyZzApIHtcbiAgICBjb25zdCB2YWwgPSBhcmcwO1xuICAgIGNvbnN0IHJldCA9IHR5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGw7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX2lzX3N0cmluZyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gdHlwZW9mKGFyZzApID09PSAnc3RyaW5nJztcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5faXNfdW5kZWZpbmVkKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBhcmcwID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX2pzdmFsX2VxKGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBhcmcwID09PSBhcmcxO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmluZGdlbl9qc3ZhbF9sb29zZV9lcShhcmcwLCBhcmcxKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMCA9PSBhcmcxO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmluZGdlbl9tZW1vcnkoKSB7XG4gICAgY29uc3QgcmV0ID0gd2FzbS5tZW1vcnk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX251bWJlcl9nZXQoYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IG9iaiA9IGFyZzE7XG4gICAgY29uc3QgcmV0ID0gdHlwZW9mKG9iaikgPT09ICdudW1iZXInID8gb2JqIDogdW5kZWZpbmVkO1xuICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEZsb2F0NjQoYXJnMCArIDggKiAxLCBpc0xpa2VOb25lKHJldCkgPyAwIDogcmV0LCB0cnVlKTtcbiAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDAsICFpc0xpa2VOb25lKHJldCksIHRydWUpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5fbnVtYmVyX25ldyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMDtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5fc3RyaW5nX2dldChhcmcwLCBhcmcxKSB7XG4gICAgY29uc3Qgb2JqID0gYXJnMTtcbiAgICBjb25zdCByZXQgPSB0eXBlb2Yob2JqKSA9PT0gJ3N0cmluZycgPyBvYmogOiB1bmRlZmluZWQ7XG4gICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKHJldCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgdmFyIGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAxLCBsZW4xLCB0cnVlKTtcbiAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDAsIHB0cjEsIHRydWUpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5fc3RyaW5nX25ldyhhcmcwLCBhcmcxKSB7XG4gICAgY29uc3QgcmV0ID0gZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmluZGdlbl90aHJvdyhhcmcwLCBhcmcxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmluZGdlbl90cnlfaW50b19udW1iZXIoYXJnMCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHsgcmVzdWx0ID0gK2FyZzAgfSBjYXRjaCAoZSkgeyByZXN1bHQgPSBlIH1cbiAgICBjb25zdCByZXQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@matrix-org/matrix-sdk-crypto-wasm/pkg/matrix_sdk_crypto_wasm_bg.js\n");

/***/ }),

/***/ "./node_modules/@matrix-org/matrix-sdk-crypto-wasm/pkg/matrix_sdk_crypto_wasm_bg.wasm":
/*!********************************************************************************************!*\
  !*** ./node_modules/@matrix-org/matrix-sdk-crypto-wasm/pkg/matrix_sdk_crypto_wasm_bg.wasm ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "7cb3661b763a0eef328b.wasm";

/***/ }),

/***/ "./node_modules/@matrix-org/matrix-sdk-crypto-wasm/index.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@matrix-org/matrix-sdk-crypto-wasm/index.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attachment: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Attachment),\n/* harmony export */   BackupDecryptionKey: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.BackupDecryptionKey),\n/* harmony export */   BackupKeys: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.BackupKeys),\n/* harmony export */   BackupSecretsBundle: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.BackupSecretsBundle),\n/* harmony export */   BaseMigrationData: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.BaseMigrationData),\n/* harmony export */   CancelInfo: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.CancelInfo),\n/* harmony export */   CheckCode: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.CheckCode),\n/* harmony export */   CollectStrategy: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.CollectStrategy),\n/* harmony export */   CrossSigningBootstrapRequests: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.CrossSigningBootstrapRequests),\n/* harmony export */   CrossSigningKeyExport: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.CrossSigningKeyExport),\n/* harmony export */   CrossSigningStatus: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.CrossSigningStatus),\n/* harmony export */   Curve25519PublicKey: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Curve25519PublicKey),\n/* harmony export */   DecryptedRoomEvent: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.DecryptedRoomEvent),\n/* harmony export */   DecryptionErrorCode: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.DecryptionErrorCode),\n/* harmony export */   DecryptionSettings: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.DecryptionSettings),\n/* harmony export */   DehydratedDevice: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.DehydratedDevice),\n/* harmony export */   DehydratedDeviceKey: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.DehydratedDeviceKey),\n/* harmony export */   DehydratedDevices: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.DehydratedDevices),\n/* harmony export */   Device: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Device),\n/* harmony export */   DeviceId: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.DeviceId),\n/* harmony export */   DeviceKey: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.DeviceKey),\n/* harmony export */   DeviceKeyAlgorithm: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.DeviceKeyAlgorithm),\n/* harmony export */   DeviceKeyAlgorithmName: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.DeviceKeyAlgorithmName),\n/* harmony export */   DeviceKeyId: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.DeviceKeyId),\n/* harmony export */   DeviceKeyName: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.DeviceKeyName),\n/* harmony export */   DeviceLists: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.DeviceLists),\n/* harmony export */   Ecies: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Ecies),\n/* harmony export */   Ed25519PublicKey: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Ed25519PublicKey),\n/* harmony export */   Ed25519Signature: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Ed25519Signature),\n/* harmony export */   Emoji: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Emoji),\n/* harmony export */   EncryptedAttachment: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.EncryptedAttachment),\n/* harmony export */   EncryptionAlgorithm: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.EncryptionAlgorithm),\n/* harmony export */   EncryptionInfo: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.EncryptionInfo),\n/* harmony export */   EncryptionSettings: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.EncryptionSettings),\n/* harmony export */   EstablishedEcies: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.EstablishedEcies),\n/* harmony export */   EventId: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.EventId),\n/* harmony export */   HistoryVisibility: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.HistoryVisibility),\n/* harmony export */   IdentityKeys: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.IdentityKeys),\n/* harmony export */   InboundCreationResult: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.InboundCreationResult),\n/* harmony export */   InboundGroupSession: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.InboundGroupSession),\n/* harmony export */   KeysBackupRequest: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.KeysBackupRequest),\n/* harmony export */   KeysClaimRequest: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.KeysClaimRequest),\n/* harmony export */   KeysQueryRequest: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.KeysQueryRequest),\n/* harmony export */   KeysUploadRequest: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.KeysUploadRequest),\n/* harmony export */   LocalTrust: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.LocalTrust),\n/* harmony export */   LoggerLevel: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.LoggerLevel),\n/* harmony export */   MaybeSignature: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.MaybeSignature),\n/* harmony export */   MegolmDecryptionError: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.MegolmDecryptionError),\n/* harmony export */   MegolmV1BackupKey: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.MegolmV1BackupKey),\n/* harmony export */   Migration: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Migration),\n/* harmony export */   OlmMachine: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.OlmMachine),\n/* harmony export */   OtherUserIdentity: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.OtherUserIdentity),\n/* harmony export */   OutboundCreationResult: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.OutboundCreationResult),\n/* harmony export */   OwnUserIdentity: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.OwnUserIdentity),\n/* harmony export */   PickledInboundGroupSession: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.PickledInboundGroupSession),\n/* harmony export */   PickledSession: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.PickledSession),\n/* harmony export */   PutDehydratedDeviceRequest: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.PutDehydratedDeviceRequest),\n/* harmony export */   Qr: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Qr),\n/* harmony export */   QrCode: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.QrCode),\n/* harmony export */   QrCodeData: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.QrCodeData),\n/* harmony export */   QrCodeMode: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.QrCodeMode),\n/* harmony export */   QrCodeScan: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.QrCodeScan),\n/* harmony export */   QrState: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.QrState),\n/* harmony export */   RehydratedDevice: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.RehydratedDevice),\n/* harmony export */   RequestType: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.RequestType),\n/* harmony export */   RoomId: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.RoomId),\n/* harmony export */   RoomKeyCounts: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.RoomKeyCounts),\n/* harmony export */   RoomKeyImportResult: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.RoomKeyImportResult),\n/* harmony export */   RoomKeyInfo: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.RoomKeyInfo),\n/* harmony export */   RoomKeyWithheldInfo: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.RoomKeyWithheldInfo),\n/* harmony export */   RoomMessageRequest: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.RoomMessageRequest),\n/* harmony export */   RoomSettings: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.RoomSettings),\n/* harmony export */   Sas: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Sas),\n/* harmony export */   SecretsBundle: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.SecretsBundle),\n/* harmony export */   ServerName: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.ServerName),\n/* harmony export */   ShieldColor: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.ShieldColor),\n/* harmony export */   ShieldState: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.ShieldState),\n/* harmony export */   ShieldStateCode: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.ShieldStateCode),\n/* harmony export */   Signature: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Signature),\n/* harmony export */   SignatureState: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.SignatureState),\n/* harmony export */   SignatureUploadRequest: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.SignatureUploadRequest),\n/* harmony export */   SignatureVerification: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.SignatureVerification),\n/* harmony export */   Signatures: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Signatures),\n/* harmony export */   StoreHandle: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.StoreHandle),\n/* harmony export */   ToDeviceRequest: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.ToDeviceRequest),\n/* harmony export */   Tracing: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Tracing),\n/* harmony export */   TrustRequirement: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.TrustRequirement),\n/* harmony export */   UploadSigningKeysRequest: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.UploadSigningKeysRequest),\n/* harmony export */   UserDevices: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.UserDevices),\n/* harmony export */   UserId: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.UserId),\n/* harmony export */   VerificationMethod: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.VerificationMethod),\n/* harmony export */   VerificationRequest: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.VerificationRequest),\n/* harmony export */   VerificationRequestPhase: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.VerificationRequestPhase),\n/* harmony export */   Versions: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Versions),\n/* harmony export */   __wbg_String_8f0eb39a4a4c2f66: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_String_8f0eb39a4a4c2f66),\n/* harmony export */   __wbg_String_eecc4a11987127d6: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_String_eecc4a11987127d6),\n/* harmony export */   __wbg_Window_b0044ac7db258535: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_Window_b0044ac7db258535),\n/* harmony export */   __wbg_WorkerGlobalScope_b74cefefc62a37da: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_WorkerGlobalScope_b74cefefc62a37da),\n/* harmony export */   __wbg_add_0d9e99fb9c2d2cc5: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_add_0d9e99fb9c2d2cc5),\n/* harmony export */   __wbg_add_c836e3d4b14cd062: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_add_c836e3d4b14cd062),\n/* harmony export */   __wbg_at_479807bfddde3a33: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_at_479807bfddde3a33),\n/* harmony export */   __wbg_backupkeys_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_backupkeys_new),\n/* harmony export */   __wbg_bound_1918c0826c5b9363: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_bound_1918c0826c5b9363),\n/* harmony export */   __wbg_bound_324dfb8899c9798c: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_bound_324dfb8899c9798c),\n/* harmony export */   __wbg_buffer_61b7ce01341d7f88: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_buffer_61b7ce01341d7f88),\n/* harmony export */   __wbg_call_3b770f0d6eb4720e: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_3b770f0d6eb4720e),\n/* harmony export */   __wbg_call_500db948e69c7330: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_500db948e69c7330),\n/* harmony export */   __wbg_call_9bd6f269d4835e33: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_9bd6f269d4835e33),\n/* harmony export */   __wbg_call_b0d8e36992d9900d: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_b0d8e36992d9900d),\n/* harmony export */   __wbg_clearTimeout_5a54f8841c30079a: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_clearTimeout_5a54f8841c30079a),\n/* harmony export */   __wbg_clear_da83758e0bea0eb6: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_clear_da83758e0bea0eb6),\n/* harmony export */   __wbg_close_f6e618ed8b0326a3: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_close_f6e618ed8b0326a3),\n/* harmony export */   __wbg_code_71136b86e2aa7f41: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_code_71136b86e2aa7f41),\n/* harmony export */   __wbg_continue_bd44561c014cacea: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_continue_bd44561c014cacea),\n/* harmony export */   __wbg_count_244aa4118e005b59: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_count_244aa4118e005b59),\n/* harmony export */   __wbg_count_4df50ef6c1ddd770: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_count_4df50ef6c1ddd770),\n/* harmony export */   __wbg_createIndex_14571b3c4eec1628: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_createIndex_14571b3c4eec1628),\n/* harmony export */   __wbg_createIndex_1d4b2bbb6b21b8f8: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_createIndex_1d4b2bbb6b21b8f8),\n/* harmony export */   __wbg_createObjectStore_b6f14aa10f83a300: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_createObjectStore_b6f14aa10f83a300),\n/* harmony export */   __wbg_crosssigningbootstraprequests_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_crosssigningbootstraprequests_new),\n/* harmony export */   __wbg_crosssigningkeyexport_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_crosssigningkeyexport_new),\n/* harmony export */   __wbg_crosssigningstatus_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_crosssigningstatus_new),\n/* harmony export */   __wbg_crypto_ed58b8e10a292839: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_crypto_ed58b8e10a292839),\n/* harmony export */   __wbg_debug_156ca727dbc3150f: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_debug_156ca727dbc3150f),\n/* harmony export */   __wbg_debug_3acd668e6e6c6087: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_debug_3acd668e6e6c6087),\n/* harmony export */   __wbg_decryptedroomevent_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_decryptedroomevent_new),\n/* harmony export */   __wbg_dehydrateddevice_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_dehydrateddevice_new),\n/* harmony export */   __wbg_dehydrateddevicekey_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_dehydrateddevicekey_new),\n/* harmony export */   __wbg_deleteObjectStore_1f50ba0263875deb: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_deleteObjectStore_1f50ba0263875deb),\n/* harmony export */   __wbg_delete_5c33e4966f59624d: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_delete_5c33e4966f59624d),\n/* harmony export */   __wbg_delete_d97b2b4ff716c553: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_delete_d97b2b4ff716c553),\n/* harmony export */   __wbg_device_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_device_new),\n/* harmony export */   __wbg_deviceid_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_deviceid_new),\n/* harmony export */   __wbg_devicekey_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_devicekey_new),\n/* harmony export */   __wbg_devicekeyid_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_devicekeyid_new),\n/* harmony export */   __wbg_done_f22c1561fa919baa: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_done_f22c1561fa919baa),\n/* harmony export */   __wbg_emoji_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_emoji_new),\n/* harmony export */   __wbg_encryptioninfo_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_encryptioninfo_new),\n/* harmony export */   __wbg_entries_4f2bb9b0d701c0f6: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_entries_4f2bb9b0d701c0f6),\n/* harmony export */   __wbg_entries_82bf0e755ef54a5f: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_entries_82bf0e755ef54a5f),\n/* harmony export */   __wbg_error_32fda676ae978f6e: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_error_32fda676ae978f6e),\n/* harmony export */   __wbg_error_7534b8e9a36f1ab4: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_error_7534b8e9a36f1ab4),\n/* harmony export */   __wbg_error_77233c625ed0c533: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_error_77233c625ed0c533),\n/* harmony export */   __wbg_error_fab41a42d22bf2bc: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_error_fab41a42d22bf2bc),\n/* harmony export */   __wbg_from_d68eaa96dba25449: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_from_d68eaa96dba25449),\n/* harmony export */   __wbg_getAllKeys_ad97dc28822a6891: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_getAllKeys_ad97dc28822a6891),\n/* harmony export */   __wbg_getAll_72e2faaa06d1a8cf: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_getAll_72e2faaa06d1a8cf),\n/* harmony export */   __wbg_getAll_8f38031e5969c7f5: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_getAll_8f38031e5969c7f5),\n/* harmony export */   __wbg_getAll_8fa84589faccab36: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_getAll_8fa84589faccab36),\n/* harmony export */   __wbg_getRandomValues_bcb4912f16000dc4: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_getRandomValues_bcb4912f16000dc4),\n/* harmony export */   __wbg_getTime_ab8b72009983c537: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_getTime_ab8b72009983c537),\n/* harmony export */   __wbg_get_6a4f854f5cca7403: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_get_6a4f854f5cca7403),\n/* harmony export */   __wbg_get_7081edc0440983a5: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_get_7081edc0440983a5),\n/* harmony export */   __wbg_get_9aa3dff3f0266054: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_get_9aa3dff3f0266054),\n/* harmony export */   __wbg_get_bbccf8970793c087: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_get_bbccf8970793c087),\n/* harmony export */   __wbg_getwithrefkey_1dc361bd10053bfe: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_getwithrefkey_1dc361bd10053bfe),\n/* harmony export */   __wbg_getwithrefkey_6550b2c093d2eb18: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_getwithrefkey_6550b2c093d2eb18),\n/* harmony export */   __wbg_global_b6f5c73312f62313: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_global_b6f5c73312f62313),\n/* harmony export */   __wbg_inboundgroupsession_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_inboundgroupsession_new),\n/* harmony export */   __wbg_index_871d874253bae760: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_index_871d874253bae760),\n/* harmony export */   __wbg_indexedDB_601ec26c63e333de: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_indexedDB_601ec26c63e333de),\n/* harmony export */   __wbg_indexedDB_72e2ca071222fd9e: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_indexedDB_72e2ca071222fd9e),\n/* harmony export */   __wbg_indexedDB_e34a5e9b3d2fcfa1: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_indexedDB_e34a5e9b3d2fcfa1),\n/* harmony export */   __wbg_info_c3044c86ae29faab: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_info_c3044c86ae29faab),\n/* harmony export */   __wbg_info_ed71056bef15b91a: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_info_ed71056bef15b91a),\n/* harmony export */   __wbg_instanceof_ArrayBuffer_670ddde44cdb2602: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_instanceof_ArrayBuffer_670ddde44cdb2602),\n/* harmony export */   __wbg_instanceof_Map_98ecb30afec5acdb: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_instanceof_Map_98ecb30afec5acdb),\n/* harmony export */   __wbg_instanceof_Promise_0aa3a90cfe6672c9: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_instanceof_Promise_0aa3a90cfe6672c9),\n/* harmony export */   __wbg_instanceof_Uint8Array_28af5bc19d6acad8: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_instanceof_Uint8Array_28af5bc19d6acad8),\n/* harmony export */   __wbg_isArray_1ba11a930108ec51: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_isArray_1ba11a930108ec51),\n/* harmony export */   __wbg_isSafeInteger_12f5549b2fca23f4: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_isSafeInteger_12f5549b2fca23f4),\n/* harmony export */   __wbg_item_7156a8ffa4d816bc: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_item_7156a8ffa4d816bc),\n/* harmony export */   __wbg_iterator_23604bb983791576: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_iterator_23604bb983791576),\n/* harmony export */   __wbg_key_87db8226759da642: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_key_87db8226759da642),\n/* harmony export */   __wbg_keysbackuprequest_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_keysbackuprequest_new),\n/* harmony export */   __wbg_keysclaimrequest_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_keysclaimrequest_new),\n/* harmony export */   __wbg_keysqueryrequest_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_keysqueryrequest_new),\n/* harmony export */   __wbg_keysuploadrequest_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_keysuploadrequest_new),\n/* harmony export */   __wbg_length_65d1cd11729ced11: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_length_65d1cd11729ced11),\n/* harmony export */   __wbg_length_d65cf0786bfc5739: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_length_d65cf0786bfc5739),\n/* harmony export */   __wbg_length_f4d79409aa324811: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_length_f4d79409aa324811),\n/* harmony export */   __wbg_lowerBound_3aa47caa33c7e1e6: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_lowerBound_3aa47caa33c7e1e6),\n/* harmony export */   __wbg_maybesignature_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_maybesignature_new),\n/* harmony export */   __wbg_megolmdecryptionerror_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_megolmdecryptionerror_new),\n/* harmony export */   __wbg_message_d19bdb65f0a41cf5: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_message_d19bdb65f0a41cf5),\n/* harmony export */   __wbg_msCrypto_0a36e2ec3a343d26: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_msCrypto_0a36e2ec3a343d26),\n/* harmony export */   __wbg_name_8862cd49ad807c59: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_name_8862cd49ad807c59),\n/* harmony export */   __wbg_new_0f1bd659dcd47068: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_0f1bd659dcd47068),\n/* harmony export */   __wbg_new_254fa9eac11932ae: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_254fa9eac11932ae),\n/* harmony export */   __wbg_new_3d446df9155128ef: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_3d446df9155128ef),\n/* harmony export */   __wbg_new_3ff5b33b1ce712df: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_3ff5b33b1ce712df),\n/* harmony export */   __wbg_new_41257536af60ed14: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_41257536af60ed14),\n/* harmony export */   __wbg_new_688846f374351c92: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_688846f374351c92),\n/* harmony export */   __wbg_new_8a6f238a6ece86ea: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_8a6f238a6ece86ea),\n/* harmony export */   __wbg_new_9451f3dcb42e0e37: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_9451f3dcb42e0e37),\n/* harmony export */   __wbg_new_bc96c6a1c0786643: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_bc96c6a1c0786643),\n/* harmony export */   __wbg_newnoargs_fd9e4bf8be2bc16d: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newnoargs_fd9e4bf8be2bc16d),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_ba35896968751d91: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithbyteoffsetandlength_ba35896968751d91),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_c0c90653f73c7dfb: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithbyteoffsetandlength_c0c90653f73c7dfb),\n/* harmony export */   __wbg_newwithlength_2aede0ef4e6e97ec: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithlength_2aede0ef4e6e97ec),\n/* harmony export */   __wbg_newwithlength_34ce8f1051e74449: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithlength_34ce8f1051e74449),\n/* harmony export */   __wbg_newwithmessage_80e6436058862fd4: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithmessage_80e6436058862fd4),\n/* harmony export */   __wbg_next_01dd9234a5bf6d05: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_next_01dd9234a5bf6d05),\n/* harmony export */   __wbg_next_137428deb98342b0: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_next_137428deb98342b0),\n/* harmony export */   __wbg_node_02999533c4ea02e3: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_node_02999533c4ea02e3),\n/* harmony export */   __wbg_now_2c95c9de01293173: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_now_2c95c9de01293173),\n/* harmony export */   __wbg_now_64d0bb151e5d3889: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_now_64d0bb151e5d3889),\n/* harmony export */   __wbg_objectStoreNames_cb00c8113b3cf5df: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_objectStoreNames_cb00c8113b3cf5df),\n/* harmony export */   __wbg_objectStore_cdbc73ee600a2cfa: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_objectStore_cdbc73ee600a2cfa),\n/* harmony export */   __wbg_oldVersion_a31d9f8577239dd8: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_oldVersion_a31d9f8577239dd8),\n/* harmony export */   __wbg_olmmachine_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_olmmachine_new),\n/* harmony export */   __wbg_openCursor_37e21d9af1a61159: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_openCursor_37e21d9af1a61159),\n/* harmony export */   __wbg_openCursor_da08cc74542711ad: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_openCursor_da08cc74542711ad),\n/* harmony export */   __wbg_openCursor_e7a3f6453a0f6725: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_openCursor_e7a3f6453a0f6725),\n/* harmony export */   __wbg_open_4588c85c0c43671d: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_open_4588c85c0c43671d),\n/* harmony export */   __wbg_open_5c51d4d6d7ab6da6: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_open_5c51d4d6d7ab6da6),\n/* harmony export */   __wbg_otheruseridentity_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_otheruseridentity_new),\n/* harmony export */   __wbg_ownuseridentity_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_ownuseridentity_new),\n/* harmony export */   __wbg_parse_161c68378e086ae1: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_parse_161c68378e086ae1),\n/* harmony export */   __wbg_performance_7a3ffd0b17f663ad: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_performance_7a3ffd0b17f663ad),\n/* harmony export */   __wbg_pickledinboundgroupsession_unwrap: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_pickledinboundgroupsession_unwrap),\n/* harmony export */   __wbg_pickledsession_unwrap: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_pickledsession_unwrap),\n/* harmony export */   __wbg_process_5c1d670bc53614b8: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_process_5c1d670bc53614b8),\n/* harmony export */   __wbg_push_6edad0df4b546b2c: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_push_6edad0df4b546b2c),\n/* harmony export */   __wbg_put_5393e88dbe742e8f: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_put_5393e88dbe742e8f),\n/* harmony export */   __wbg_putdehydrateddevicerequest_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_putdehydrateddevicerequest_new),\n/* harmony export */   __wbg_qr_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_qr_new),\n/* harmony export */   __wbg_queueMicrotask_2181040e064c0dc8: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_queueMicrotask_2181040e064c0dc8),\n/* harmony export */   __wbg_queueMicrotask_ef9ac43769cbcc4f: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_queueMicrotask_ef9ac43769cbcc4f),\n/* harmony export */   __wbg_randomFillSync_ab2cfe79ebbf2740: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_randomFillSync_ab2cfe79ebbf2740),\n/* harmony export */   __wbg_readyState_8428fa7c5e093401: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_readyState_8428fa7c5e093401),\n/* harmony export */   __wbg_rehydrateddevice_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_rehydrateddevice_new),\n/* harmony export */   __wbg_require_79b1e9274cde3c87: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_require_79b1e9274cde3c87),\n/* harmony export */   __wbg_resolve_0bf7c44d641804f9: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_resolve_0bf7c44d641804f9),\n/* harmony export */   __wbg_result_e6ba6a347dcb7470: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_result_e6ba6a347dcb7470),\n/* harmony export */   __wbg_roomid_unwrap: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_roomid_unwrap),\n/* harmony export */   __wbg_roomkeycounts_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_roomkeycounts_new),\n/* harmony export */   __wbg_roomkeyimportresult_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_roomkeyimportresult_new),\n/* harmony export */   __wbg_roomkeyinfo_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_roomkeyinfo_new),\n/* harmony export */   __wbg_roomkeywithheldinfo_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_roomkeywithheldinfo_new),\n/* harmony export */   __wbg_roommessagerequest_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_roommessagerequest_new),\n/* harmony export */   __wbg_roomsettings_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_roomsettings_new),\n/* harmony export */   __wbg_sas_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_sas_new),\n/* harmony export */   __wbg_secretsbundle_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_secretsbundle_new),\n/* harmony export */   __wbg_setTimeout_db2dbaeefb6f39c7: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_setTimeout_db2dbaeefb6f39c7),\n/* harmony export */   __wbg_set_1d80752d0d5f0b21: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_1d80752d0d5f0b21),\n/* harmony export */   __wbg_set_23d69db4e5c66a6e: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_23d69db4e5c66a6e),\n/* harmony export */   __wbg_set_3807d5f0bfc24aa7: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_3807d5f0bfc24aa7),\n/* harmony export */   __wbg_set_3f1d0b984ed272ed: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_3f1d0b984ed272ed),\n/* harmony export */   __wbg_set_76818dc3c59a63d5: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_76818dc3c59a63d5),\n/* harmony export */   __wbg_set_9592f7d5b752cae3: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_9592f7d5b752cae3),\n/* harmony export */   __wbg_set_wasm: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm),\n/* harmony export */   __wbg_setonabort_ade6cac5c35a572f: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_setonabort_ade6cac5c35a572f),\n/* harmony export */   __wbg_setonblocked_d13048be9383f4dc: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_setonblocked_d13048be9383f4dc),\n/* harmony export */   __wbg_setoncomplete_2747fb71ae0af4a8: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_setoncomplete_2747fb71ae0af4a8),\n/* harmony export */   __wbg_setonerror_72b33e31f9edb045: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_setonerror_72b33e31f9edb045),\n/* harmony export */   __wbg_setonerror_e4beb2652cf66635: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_setonerror_e4beb2652cf66635),\n/* harmony export */   __wbg_setonsuccess_57167b1c2650357c: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_setonsuccess_57167b1c2650357c),\n/* harmony export */   __wbg_setonupgradeneeded_887c7a5fca66011e: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_setonupgradeneeded_887c7a5fca66011e),\n/* harmony export */   __wbg_setonversionchange_a6f60bd1d110795d: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_setonversionchange_a6f60bd1d110795d),\n/* harmony export */   __wbg_setunique_cfc477dc5825e1c4: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_setunique_cfc477dc5825e1c4),\n/* harmony export */   __wbg_signatures_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_signatures_new),\n/* harmony export */   __wbg_signatureuploadrequest_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_signatureuploadrequest_new),\n/* harmony export */   __wbg_signatureverification_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_signatureverification_new),\n/* harmony export */   __wbg_stack_0ed75d68575b0f3c: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_stack_0ed75d68575b0f3c),\n/* harmony export */   __wbg_static_accessor_GLOBAL_0be7472e492ad3e3: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_static_accessor_GLOBAL_0be7472e492ad3e3),\n/* harmony export */   __wbg_static_accessor_GLOBAL_THIS_1a6eb482d12c9bfb: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_static_accessor_GLOBAL_THIS_1a6eb482d12c9bfb),\n/* harmony export */   __wbg_static_accessor_SELF_1dc398a895c82351: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_static_accessor_SELF_1dc398a895c82351),\n/* harmony export */   __wbg_static_accessor_WINDOW_ae1c80c7eea8d64a: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_static_accessor_WINDOW_ae1c80c7eea8d64a),\n/* harmony export */   __wbg_storehandle_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_storehandle_new),\n/* harmony export */   __wbg_stringify_f4f701bc34ceda61: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_stringify_f4f701bc34ceda61),\n/* harmony export */   __wbg_subarray_46adeb9b86949d12: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_subarray_46adeb9b86949d12),\n/* harmony export */   __wbg_target_a8fe593e7ee79c21: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_target_a8fe593e7ee79c21),\n/* harmony export */   __wbg_then_0438fad860fe38e1: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_then_0438fad860fe38e1),\n/* harmony export */   __wbg_then_0ffafeddf0e182a4: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_then_0ffafeddf0e182a4),\n/* harmony export */   __wbg_todevicerequest_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_todevicerequest_new),\n/* harmony export */   __wbg_transaction_bc71c2aaaf467420: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_transaction_bc71c2aaaf467420),\n/* harmony export */   __wbg_transaction_d2b6d520837fbe7f: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_transaction_d2b6d520837fbe7f),\n/* harmony export */   __wbg_transaction_dbab9cd9ea849958: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_transaction_dbab9cd9ea849958),\n/* harmony export */   __wbg_update_211ddccaf2cec6ee: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_update_211ddccaf2cec6ee),\n/* harmony export */   __wbg_userdevices_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_userdevices_new),\n/* harmony export */   __wbg_userid_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_userid_new),\n/* harmony export */   __wbg_userid_unwrap: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_userid_unwrap),\n/* harmony export */   __wbg_value_0ad6f37677c8ee74: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_value_0ad6f37677c8ee74),\n/* harmony export */   __wbg_value_4c32fd138a88eee2: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_value_4c32fd138a88eee2),\n/* harmony export */   __wbg_values_7aa03dd078978c86: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_values_7aa03dd078978c86),\n/* harmony export */   __wbg_verificationrequest_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_verificationrequest_new),\n/* harmony export */   __wbg_version_2b650c9d4f0a2438: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_version_2b650c9d4f0a2438),\n/* harmony export */   __wbg_versions_c71aa1626a93e0a1: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_versions_c71aa1626a93e0a1),\n/* harmony export */   __wbg_warn_123db6aa8948382e: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_warn_123db6aa8948382e),\n/* harmony export */   __wbg_warn_9d038df1589cb1bd: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_warn_9d038df1589cb1bd),\n/* harmony export */   __wbindgen_as_number: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_as_number),\n/* harmony export */   __wbindgen_bigint_from_i64: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_bigint_from_i64),\n/* harmony export */   __wbindgen_bigint_from_u64: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_bigint_from_u64),\n/* harmony export */   __wbindgen_bigint_get_as_i64: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_bigint_get_as_i64),\n/* harmony export */   __wbindgen_boolean_get: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_boolean_get),\n/* harmony export */   __wbindgen_cb_drop: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_cb_drop),\n/* harmony export */   __wbindgen_closure_wrapper1050: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_closure_wrapper1050),\n/* harmony export */   __wbindgen_closure_wrapper2213: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_closure_wrapper2213),\n/* harmony export */   __wbindgen_closure_wrapper5386: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_closure_wrapper5386),\n/* harmony export */   __wbindgen_closure_wrapper6843: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_closure_wrapper6843),\n/* harmony export */   __wbindgen_closure_wrapper6848: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_closure_wrapper6848),\n/* harmony export */   __wbindgen_debug_string: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_debug_string),\n/* harmony export */   __wbindgen_error_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_error_new),\n/* harmony export */   __wbindgen_in: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_in),\n/* harmony export */   __wbindgen_init_externref_table: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_init_externref_table),\n/* harmony export */   __wbindgen_is_array: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_array),\n/* harmony export */   __wbindgen_is_bigint: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_bigint),\n/* harmony export */   __wbindgen_is_function: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_function),\n/* harmony export */   __wbindgen_is_null: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_null),\n/* harmony export */   __wbindgen_is_object: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_object),\n/* harmony export */   __wbindgen_is_string: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_string),\n/* harmony export */   __wbindgen_is_undefined: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_undefined),\n/* harmony export */   __wbindgen_jsval_eq: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_jsval_eq),\n/* harmony export */   __wbindgen_jsval_loose_eq: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_jsval_loose_eq),\n/* harmony export */   __wbindgen_memory: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_memory),\n/* harmony export */   __wbindgen_number_get: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_number_get),\n/* harmony export */   __wbindgen_number_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_number_new),\n/* harmony export */   __wbindgen_string_get: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_string_get),\n/* harmony export */   __wbindgen_string_new: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_string_new),\n/* harmony export */   __wbindgen_throw: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_throw),\n/* harmony export */   __wbindgen_try_into_number: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_try_into_number),\n/* harmony export */   getVersions: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.getVersions),\n/* harmony export */   initAsync: () => (/* binding */ initAsync),\n/* harmony export */   start: () => (/* reexport safe */ _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.start)\n/* harmony export */ });\n/* harmony import */ var _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pkg/matrix_sdk_crypto_wasm_bg.js */ \"./node_modules/@matrix-org/matrix-sdk-crypto-wasm/pkg/matrix_sdk_crypto_wasm_bg.js\");\n// Copyright 2024 The Matrix.org Foundation C.I.C.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// @ts-check\n\n/**\n * This is the entrypoint on non-node ESM environments.\n * `asyncLoad` will load the WASM module using a `fetch` call.\n */\n\n\n\nconst moduleUrl = new URL(/* asset import */ __webpack_require__(/*! ./pkg/matrix_sdk_crypto_wasm_bg.wasm */ \"./node_modules/@matrix-org/matrix-sdk-crypto-wasm/pkg/matrix_sdk_crypto_wasm_bg.wasm\"), __webpack_require__.b);\n\n// Although we could simply instantiate the WASM at import time with a top-level `await`,\n// we avoid that, to make it easier for callers to delay loading the WASM (and instead\n// wait until `initAsync` is called). (Also, Safari 14 doesn't support top-level `await`.)\n//\n// However, having done so, there is no way to synchronously load the WASM if the user ends\n// up using the bindings before calling `initAsync` (unlike under Node.js), so we just throw\n// an error.\n_pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm(\n    new Proxy(\n        {},\n        {\n            get() {\n                throw new Error(\n                    \"@matrix-org/matrix-sdk-crypto-wasm was used before it was initialized. Call `initAsync` first.\",\n                );\n            },\n        },\n    ),\n);\n\n/**\n * Stores a promise of the `loadModuleAsync` call\n * @type {Promise<void> | null}\n */\nlet modPromise = null;\n\n/**\n * Loads and instantiates the WASM module asynchronously\n *\n * @returns {Promise<void>}\n */\nasync function loadModuleAsync() {\n    const { instance } = await WebAssembly.instantiateStreaming(fetch(moduleUrl), {\n        // @ts-expect-error: The bindings don't exactly match the 'ExportValue' type\n        \"./matrix_sdk_crypto_wasm_bg.js\": _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__,\n    });\n\n    _pkg_matrix_sdk_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm(instance.exports);\n    // @ts-expect-error: Typescript doesn't know what the module exports are\n    instance.exports.__wbindgen_start();\n}\n\n/**\n * Load the WebAssembly module in the background, if it has not already been loaded.\n *\n * Returns a promise which will resolve once the other methods are ready.\n *\n * @returns {Promise<void>}\n */\nasync function initAsync() {\n    if (!modPromise) modPromise = loadModuleAsync();\n    await modPromise;\n}\n\n// Re-export everything from the generated javascript wrappers\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hdHJpeC1vcmcvbWF0cml4LXNkay1jcnlwdG8td2FzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0Q7O0FBRS9ELDBCQUEwQixpTUFBdUQ7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQXVCO0FBQ3ZCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0EsMENBQTBDLDhEQUFRO0FBQ2xELEtBQUs7O0FBRUwsSUFBSSw2RUFBdUI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRCIsInNvdXJjZXMiOlsid2VicGFjazovL2FzdGVyaWNzLWdyaWQvLi9ub2RlX21vZHVsZXMvQG1hdHJpeC1vcmcvbWF0cml4LXNkay1jcnlwdG8td2FzbS9pbmRleC5tanM/ZTUzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyNCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgZW50cnlwb2ludCBvbiBub24tbm9kZSBFU00gZW52aXJvbm1lbnRzLlxuICogYGFzeW5jTG9hZGAgd2lsbCBsb2FkIHRoZSBXQVNNIG1vZHVsZSB1c2luZyBhIGBmZXRjaGAgY2FsbC5cbiAqL1xuXG5pbXBvcnQgKiBhcyBiaW5kaW5ncyBmcm9tIFwiLi9wa2cvbWF0cml4X3Nka19jcnlwdG9fd2FzbV9iZy5qc1wiO1xuXG5jb25zdCBtb2R1bGVVcmwgPSBuZXcgVVJMKFwiLi9wa2cvbWF0cml4X3Nka19jcnlwdG9fd2FzbV9iZy53YXNtXCIsIGltcG9ydC5tZXRhLnVybCk7XG5cbi8vIEFsdGhvdWdoIHdlIGNvdWxkIHNpbXBseSBpbnN0YW50aWF0ZSB0aGUgV0FTTSBhdCBpbXBvcnQgdGltZSB3aXRoIGEgdG9wLWxldmVsIGBhd2FpdGAsXG4vLyB3ZSBhdm9pZCB0aGF0LCB0byBtYWtlIGl0IGVhc2llciBmb3IgY2FsbGVycyB0byBkZWxheSBsb2FkaW5nIHRoZSBXQVNNIChhbmQgaW5zdGVhZFxuLy8gd2FpdCB1bnRpbCBgaW5pdEFzeW5jYCBpcyBjYWxsZWQpLiAoQWxzbywgU2FmYXJpIDE0IGRvZXNuJ3Qgc3VwcG9ydCB0b3AtbGV2ZWwgYGF3YWl0YC4pXG4vL1xuLy8gSG93ZXZlciwgaGF2aW5nIGRvbmUgc28sIHRoZXJlIGlzIG5vIHdheSB0byBzeW5jaHJvbm91c2x5IGxvYWQgdGhlIFdBU00gaWYgdGhlIHVzZXIgZW5kc1xuLy8gdXAgdXNpbmcgdGhlIGJpbmRpbmdzIGJlZm9yZSBjYWxsaW5nIGBpbml0QXN5bmNgICh1bmxpa2UgdW5kZXIgTm9kZS5qcyksIHNvIHdlIGp1c3QgdGhyb3dcbi8vIGFuIGVycm9yLlxuYmluZGluZ3MuX193Ymdfc2V0X3dhc20oXG4gICAgbmV3IFByb3h5KFxuICAgICAgICB7fSxcbiAgICAgICAge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJAbWF0cml4LW9yZy9tYXRyaXgtc2RrLWNyeXB0by13YXNtIHdhcyB1c2VkIGJlZm9yZSBpdCB3YXMgaW5pdGlhbGl6ZWQuIENhbGwgYGluaXRBc3luY2AgZmlyc3QuXCIsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgKSxcbik7XG5cbi8qKlxuICogU3RvcmVzIGEgcHJvbWlzZSBvZiB0aGUgYGxvYWRNb2R1bGVBc3luY2AgY2FsbFxuICogQHR5cGUge1Byb21pc2U8dm9pZD4gfCBudWxsfVxuICovXG5sZXQgbW9kUHJvbWlzZSA9IG51bGw7XG5cbi8qKlxuICogTG9hZHMgYW5kIGluc3RhbnRpYXRlcyB0aGUgV0FTTSBtb2R1bGUgYXN5bmNocm9ub3VzbHlcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZE1vZHVsZUFzeW5jKCkge1xuICAgIGNvbnN0IHsgaW5zdGFuY2UgfSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKGZldGNoKG1vZHVsZVVybCksIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogVGhlIGJpbmRpbmdzIGRvbid0IGV4YWN0bHkgbWF0Y2ggdGhlICdFeHBvcnRWYWx1ZScgdHlwZVxuICAgICAgICBcIi4vbWF0cml4X3Nka19jcnlwdG9fd2FzbV9iZy5qc1wiOiBiaW5kaW5ncyxcbiAgICB9KTtcblxuICAgIGJpbmRpbmdzLl9fd2JnX3NldF93YXNtKGluc3RhbmNlLmV4cG9ydHMpO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFR5cGVzY3JpcHQgZG9lc24ndCBrbm93IHdoYXQgdGhlIG1vZHVsZSBleHBvcnRzIGFyZVxuICAgIGluc3RhbmNlLmV4cG9ydHMuX193YmluZGdlbl9zdGFydCgpO1xufVxuXG4vKipcbiAqIExvYWQgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpbiB0aGUgYmFja2dyb3VuZCwgaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gbG9hZGVkLlxuICpcbiAqIFJldHVybnMgYSBwcm9taXNlIHdoaWNoIHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSBvdGhlciBtZXRob2RzIGFyZSByZWFkeS5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRBc3luYygpIHtcbiAgICBpZiAoIW1vZFByb21pc2UpIG1vZFByb21pc2UgPSBsb2FkTW9kdWxlQXN5bmMoKTtcbiAgICBhd2FpdCBtb2RQcm9taXNlO1xufVxuXG4vLyBSZS1leHBvcnQgZXZlcnl0aGluZyBmcm9tIHRoZSBnZW5lcmF0ZWQgamF2YXNjcmlwdCB3cmFwcGVyc1xuZXhwb3J0ICogZnJvbSBcIi4vcGtnL21hdHJpeF9zZGtfY3J5cHRvX3dhc21fYmcuanNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@matrix-org/matrix-sdk-crypto-wasm/index.mjs\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/CrossSigningIdentity.js":
/*!****************************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/CrossSigningIdentity.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CrossSigningIdentity: () => (/* binding */ CrossSigningIdentity)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logger.js */ \"./node_modules/matrix-js-sdk/lib/logger.js\");\n\n/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n/** Manages the cross-signing keys for our own user.\n *\n * @internal\n */\nclass CrossSigningIdentity {\n  constructor(olmMachine, outgoingRequestProcessor, secretStorage) {\n    this.olmMachine = olmMachine;\n    this.outgoingRequestProcessor = outgoingRequestProcessor;\n    this.secretStorage = secretStorage;\n  }\n\n  /**\n   * Initialise our cross-signing keys by creating new keys if they do not exist, and uploading to the server\n   */\n  bootstrapCrossSigning(opts) {\n    var _this = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      if (opts.setupNewCrossSigning) {\n        yield _this.resetCrossSigning(opts.authUploadDeviceSigningKeys);\n        return;\n      }\n      var olmDeviceStatus = yield _this.olmMachine.crossSigningStatus();\n\n      // Try to fetch cross signing keys from the secret storage\n      var masterKeyFromSecretStorage = yield _this.secretStorage.get(\"m.cross_signing.master\");\n      var selfSigningKeyFromSecretStorage = yield _this.secretStorage.get(\"m.cross_signing.self_signing\");\n      var userSigningKeyFromSecretStorage = yield _this.secretStorage.get(\"m.cross_signing.user_signing\");\n      var privateKeysInSecretStorage = Boolean(masterKeyFromSecretStorage && selfSigningKeyFromSecretStorage && userSigningKeyFromSecretStorage);\n      var olmDeviceHasKeys = olmDeviceStatus.hasMaster && olmDeviceStatus.hasUserSigning && olmDeviceStatus.hasSelfSigning;\n\n      // Log all relevant state for easier parsing of debug logs.\n      _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.log(\"bootstrapCrossSigning: starting\", {\n        setupNewCrossSigning: opts.setupNewCrossSigning,\n        olmDeviceHasMaster: olmDeviceStatus.hasMaster,\n        olmDeviceHasUserSigning: olmDeviceStatus.hasUserSigning,\n        olmDeviceHasSelfSigning: olmDeviceStatus.hasSelfSigning,\n        privateKeysInSecretStorage\n      });\n      if (olmDeviceHasKeys) {\n        if (!(yield _this.secretStorage.hasKey())) {\n          _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.warn(\"bootstrapCrossSigning: Olm device has private keys, but secret storage is not yet set up; doing nothing for now.\");\n          // the keys should get uploaded to 4S once that is set up.\n        } else if (!privateKeysInSecretStorage) {\n          // the device has the keys but they are not in 4S, so update it\n          _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.log(\"bootstrapCrossSigning: Olm device has private keys: exporting to secret storage\");\n          yield _this.exportCrossSigningKeysToStorage();\n        } else {\n          _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.log(\"bootstrapCrossSigning: Olm device has private keys and they are saved in secret storage; doing nothing\");\n        }\n      } /* (!olmDeviceHasKeys) */else {\n        if (privateKeysInSecretStorage) {\n          // they are in 4S, so import from there\n          _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.log(\"bootstrapCrossSigning: Cross-signing private keys not found locally, but they are available \" + \"in secret storage, reading storage and caching locally\");\n          var status = yield _this.olmMachine.importCrossSigningKeys(masterKeyFromSecretStorage, selfSigningKeyFromSecretStorage, userSigningKeyFromSecretStorage);\n\n          // Check that `importCrossSigningKeys` worked correctly (for example, it will fail silently if the\n          // public keys are not available).\n          if (!status.hasMaster || !status.hasSelfSigning || !status.hasUserSigning) {\n            throw new Error(\"importCrossSigningKeys failed to import the keys\");\n          }\n\n          // Get the current device\n          var device = yield _this.olmMachine.getDevice(_this.olmMachine.userId, _this.olmMachine.deviceId);\n          try {\n            // Sign the device with our cross-signing key and upload the signature\n            var request = yield device.verify();\n            yield _this.outgoingRequestProcessor.makeOutgoingRequest(request);\n          } finally {\n            device.free();\n          }\n        } else {\n          _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.log(\"bootstrapCrossSigning: Cross-signing private keys not found locally or in secret storage, creating new keys\");\n          yield _this.resetCrossSigning(opts.authUploadDeviceSigningKeys);\n        }\n      }\n\n      // TODO: we might previously have bootstrapped cross-signing but not completed uploading the keys to the\n      //   server -- in which case we should call OlmDevice.bootstrap_cross_signing. How do we know?\n      _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.log(\"bootstrapCrossSigning: complete\");\n    })();\n  }\n\n  /** Reset our cross-signing keys\n   *\n   * This method will:\n   *   * Tell the OlmMachine to create new keys\n   *   * Upload the new public keys and the device signature to the server\n   *   * Upload the private keys to SSSS, if it is set up\n   */\n  resetCrossSigning(authUploadDeviceSigningKeys) {\n    var _this2 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // XXX: We must find a way to make this atomic, currently if the user does not remember his account password\n      // or 4S passphrase/key the process will fail in a bad state, with keys rotated but not uploaded or saved in 4S.\n      var outgoingRequests = yield _this2.olmMachine.bootstrapCrossSigning(true);\n\n      // If 4S is configured we need to update it.\n      if (!(yield _this2.secretStorage.hasKey())) {\n        _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.warn(\"resetCrossSigning: Secret storage is not yet set up; not exporting keys to secret storage yet.\");\n        // the keys should get uploaded to 4S once that is set up.\n      } else {\n        // Update 4S before uploading cross-signing keys, to stay consistent with legacy that asks\n        // 4S passphrase before asking for account password.\n        // Ultimately should be made atomic and resistant to forgotten password/passphrase.\n        _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.log(\"resetCrossSigning: exporting private keys to secret storage\");\n        yield _this2.exportCrossSigningKeysToStorage();\n      }\n      _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.log(\"resetCrossSigning: publishing public keys to server\");\n      for (var req of [outgoingRequests.uploadKeysRequest, outgoingRequests.uploadSigningKeysRequest, outgoingRequests.uploadSignaturesRequest]) {\n        if (req) {\n          yield _this2.outgoingRequestProcessor.makeOutgoingRequest(req, authUploadDeviceSigningKeys);\n        }\n      }\n    })();\n  }\n\n  /**\n   * Extract the cross-signing keys from the olm machine and save them to secret storage, if it is configured\n   *\n   * (If secret storage is *not* configured, we assume that the export will happen when it is set up)\n   */\n  exportCrossSigningKeysToStorage() {\n    var _this3 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var exported = yield _this3.olmMachine.exportCrossSigningKeys();\n      /* istanbul ignore else (this function is only called when we know the olm machine has keys) */\n      if (exported !== null && exported !== void 0 && exported.masterKey) {\n        yield _this3.secretStorage.store(\"m.cross_signing.master\", exported.masterKey);\n      } else {\n        _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.error(\"Cannot export MSK to secret storage, private key unknown\");\n      }\n      if (exported !== null && exported !== void 0 && exported.self_signing_key) {\n        yield _this3.secretStorage.store(\"m.cross_signing.self_signing\", exported.self_signing_key);\n      } else {\n        _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.error(\"Cannot export SSK to secret storage, private key unknown\");\n      }\n      if (exported !== null && exported !== void 0 && exported.userSigningKey) {\n        yield _this3.secretStorage.store(\"m.cross_signing.user_signing\", exported.userSigningKey);\n      } else {\n        _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.error(\"Cannot export USK to secret storage, private key unknown\");\n      }\n    })();\n  }\n}\n//# sourceMappingURL=CrossSigningIdentity.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vQ3Jvc3NTaWduaW5nSWRlbnRpdHkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdFO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSw4Q0FBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVUsOENBQU0saUdBQWlHO0FBQ2pIO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSw4Q0FBTTtBQUNoQjtBQUNBLFVBQVU7QUFDVixVQUFVLDhDQUFNLCtGQUErRjtBQUMvRztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVSw4Q0FBTTtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWLFVBQVUsOENBQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDhDQUFNO0FBQ1osS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSw4Q0FBTSw0REFBNEQ7QUFDMUU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4Q0FBTTtBQUNkO0FBQ0E7QUFDQSxNQUFNLDhDQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFFBQVEsOENBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsUUFBUSw4Q0FBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRLDhDQUFNO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXN0ZXJpY3MtZ3JpZC8uL25vZGVfbW9kdWxlcy9tYXRyaXgtanMtc2RrL2xpYi9ydXN0LWNyeXB0by9Dcm9zc1NpZ25pbmdJZGVudGl0eS5qcz82NDQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfYXN5bmNUb0dlbmVyYXRvciBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCI7XG4vKlxuQ29weXJpZ2h0IDIwMjMgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2VyLmpzXCI7XG4vKiogTWFuYWdlcyB0aGUgY3Jvc3Mtc2lnbmluZyBrZXlzIGZvciBvdXIgb3duIHVzZXIuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBDcm9zc1NpZ25pbmdJZGVudGl0eSB7XG4gIGNvbnN0cnVjdG9yKG9sbU1hY2hpbmUsIG91dGdvaW5nUmVxdWVzdFByb2Nlc3Nvciwgc2VjcmV0U3RvcmFnZSkge1xuICAgIHRoaXMub2xtTWFjaGluZSA9IG9sbU1hY2hpbmU7XG4gICAgdGhpcy5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IgPSBvdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3I7XG4gICAgdGhpcy5zZWNyZXRTdG9yYWdlID0gc2VjcmV0U3RvcmFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXNlIG91ciBjcm9zcy1zaWduaW5nIGtleXMgYnkgY3JlYXRpbmcgbmV3IGtleXMgaWYgdGhleSBkbyBub3QgZXhpc3QsIGFuZCB1cGxvYWRpbmcgdG8gdGhlIHNlcnZlclxuICAgKi9cbiAgYm9vdHN0cmFwQ3Jvc3NTaWduaW5nKG9wdHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKG9wdHMuc2V0dXBOZXdDcm9zc1NpZ25pbmcpIHtcbiAgICAgICAgeWllbGQgX3RoaXMucmVzZXRDcm9zc1NpZ25pbmcob3B0cy5hdXRoVXBsb2FkRGV2aWNlU2lnbmluZ0tleXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb2xtRGV2aWNlU3RhdHVzID0geWllbGQgX3RoaXMub2xtTWFjaGluZS5jcm9zc1NpZ25pbmdTdGF0dXMoKTtcblxuICAgICAgLy8gVHJ5IHRvIGZldGNoIGNyb3NzIHNpZ25pbmcga2V5cyBmcm9tIHRoZSBzZWNyZXQgc3RvcmFnZVxuICAgICAgdmFyIG1hc3RlcktleUZyb21TZWNyZXRTdG9yYWdlID0geWllbGQgX3RoaXMuc2VjcmV0U3RvcmFnZS5nZXQoXCJtLmNyb3NzX3NpZ25pbmcubWFzdGVyXCIpO1xuICAgICAgdmFyIHNlbGZTaWduaW5nS2V5RnJvbVNlY3JldFN0b3JhZ2UgPSB5aWVsZCBfdGhpcy5zZWNyZXRTdG9yYWdlLmdldChcIm0uY3Jvc3Nfc2lnbmluZy5zZWxmX3NpZ25pbmdcIik7XG4gICAgICB2YXIgdXNlclNpZ25pbmdLZXlGcm9tU2VjcmV0U3RvcmFnZSA9IHlpZWxkIF90aGlzLnNlY3JldFN0b3JhZ2UuZ2V0KFwibS5jcm9zc19zaWduaW5nLnVzZXJfc2lnbmluZ1wiKTtcbiAgICAgIHZhciBwcml2YXRlS2V5c0luU2VjcmV0U3RvcmFnZSA9IEJvb2xlYW4obWFzdGVyS2V5RnJvbVNlY3JldFN0b3JhZ2UgJiYgc2VsZlNpZ25pbmdLZXlGcm9tU2VjcmV0U3RvcmFnZSAmJiB1c2VyU2lnbmluZ0tleUZyb21TZWNyZXRTdG9yYWdlKTtcbiAgICAgIHZhciBvbG1EZXZpY2VIYXNLZXlzID0gb2xtRGV2aWNlU3RhdHVzLmhhc01hc3RlciAmJiBvbG1EZXZpY2VTdGF0dXMuaGFzVXNlclNpZ25pbmcgJiYgb2xtRGV2aWNlU3RhdHVzLmhhc1NlbGZTaWduaW5nO1xuXG4gICAgICAvLyBMb2cgYWxsIHJlbGV2YW50IHN0YXRlIGZvciBlYXNpZXIgcGFyc2luZyBvZiBkZWJ1ZyBsb2dzLlxuICAgICAgbG9nZ2VyLmxvZyhcImJvb3RzdHJhcENyb3NzU2lnbmluZzogc3RhcnRpbmdcIiwge1xuICAgICAgICBzZXR1cE5ld0Nyb3NzU2lnbmluZzogb3B0cy5zZXR1cE5ld0Nyb3NzU2lnbmluZyxcbiAgICAgICAgb2xtRGV2aWNlSGFzTWFzdGVyOiBvbG1EZXZpY2VTdGF0dXMuaGFzTWFzdGVyLFxuICAgICAgICBvbG1EZXZpY2VIYXNVc2VyU2lnbmluZzogb2xtRGV2aWNlU3RhdHVzLmhhc1VzZXJTaWduaW5nLFxuICAgICAgICBvbG1EZXZpY2VIYXNTZWxmU2lnbmluZzogb2xtRGV2aWNlU3RhdHVzLmhhc1NlbGZTaWduaW5nLFxuICAgICAgICBwcml2YXRlS2V5c0luU2VjcmV0U3RvcmFnZVxuICAgICAgfSk7XG4gICAgICBpZiAob2xtRGV2aWNlSGFzS2V5cykge1xuICAgICAgICBpZiAoISh5aWVsZCBfdGhpcy5zZWNyZXRTdG9yYWdlLmhhc0tleSgpKSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFwiYm9vdHN0cmFwQ3Jvc3NTaWduaW5nOiBPbG0gZGV2aWNlIGhhcyBwcml2YXRlIGtleXMsIGJ1dCBzZWNyZXQgc3RvcmFnZSBpcyBub3QgeWV0IHNldCB1cDsgZG9pbmcgbm90aGluZyBmb3Igbm93LlwiKTtcbiAgICAgICAgICAvLyB0aGUga2V5cyBzaG91bGQgZ2V0IHVwbG9hZGVkIHRvIDRTIG9uY2UgdGhhdCBpcyBzZXQgdXAuXG4gICAgICAgIH0gZWxzZSBpZiAoIXByaXZhdGVLZXlzSW5TZWNyZXRTdG9yYWdlKSB7XG4gICAgICAgICAgLy8gdGhlIGRldmljZSBoYXMgdGhlIGtleXMgYnV0IHRoZXkgYXJlIG5vdCBpbiA0Uywgc28gdXBkYXRlIGl0XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcImJvb3RzdHJhcENyb3NzU2lnbmluZzogT2xtIGRldmljZSBoYXMgcHJpdmF0ZSBrZXlzOiBleHBvcnRpbmcgdG8gc2VjcmV0IHN0b3JhZ2VcIik7XG4gICAgICAgICAgeWllbGQgX3RoaXMuZXhwb3J0Q3Jvc3NTaWduaW5nS2V5c1RvU3RvcmFnZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coXCJib290c3RyYXBDcm9zc1NpZ25pbmc6IE9sbSBkZXZpY2UgaGFzIHByaXZhdGUga2V5cyBhbmQgdGhleSBhcmUgc2F2ZWQgaW4gc2VjcmV0IHN0b3JhZ2U7IGRvaW5nIG5vdGhpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH0gLyogKCFvbG1EZXZpY2VIYXNLZXlzKSAqL2Vsc2Uge1xuICAgICAgICBpZiAocHJpdmF0ZUtleXNJblNlY3JldFN0b3JhZ2UpIHtcbiAgICAgICAgICAvLyB0aGV5IGFyZSBpbiA0Uywgc28gaW1wb3J0IGZyb20gdGhlcmVcbiAgICAgICAgICBsb2dnZXIubG9nKFwiYm9vdHN0cmFwQ3Jvc3NTaWduaW5nOiBDcm9zcy1zaWduaW5nIHByaXZhdGUga2V5cyBub3QgZm91bmQgbG9jYWxseSwgYnV0IHRoZXkgYXJlIGF2YWlsYWJsZSBcIiArIFwiaW4gc2VjcmV0IHN0b3JhZ2UsIHJlYWRpbmcgc3RvcmFnZSBhbmQgY2FjaGluZyBsb2NhbGx5XCIpO1xuICAgICAgICAgIHZhciBzdGF0dXMgPSB5aWVsZCBfdGhpcy5vbG1NYWNoaW5lLmltcG9ydENyb3NzU2lnbmluZ0tleXMobWFzdGVyS2V5RnJvbVNlY3JldFN0b3JhZ2UsIHNlbGZTaWduaW5nS2V5RnJvbVNlY3JldFN0b3JhZ2UsIHVzZXJTaWduaW5nS2V5RnJvbVNlY3JldFN0b3JhZ2UpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgdGhhdCBgaW1wb3J0Q3Jvc3NTaWduaW5nS2V5c2Agd29ya2VkIGNvcnJlY3RseSAoZm9yIGV4YW1wbGUsIGl0IHdpbGwgZmFpbCBzaWxlbnRseSBpZiB0aGVcbiAgICAgICAgICAvLyBwdWJsaWMga2V5cyBhcmUgbm90IGF2YWlsYWJsZSkuXG4gICAgICAgICAgaWYgKCFzdGF0dXMuaGFzTWFzdGVyIHx8ICFzdGF0dXMuaGFzU2VsZlNpZ25pbmcgfHwgIXN0YXR1cy5oYXNVc2VyU2lnbmluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW1wb3J0Q3Jvc3NTaWduaW5nS2V5cyBmYWlsZWQgdG8gaW1wb3J0IHRoZSBrZXlzXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBkZXZpY2VcbiAgICAgICAgICB2YXIgZGV2aWNlID0geWllbGQgX3RoaXMub2xtTWFjaGluZS5nZXREZXZpY2UoX3RoaXMub2xtTWFjaGluZS51c2VySWQsIF90aGlzLm9sbU1hY2hpbmUuZGV2aWNlSWQpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTaWduIHRoZSBkZXZpY2Ugd2l0aCBvdXIgY3Jvc3Mtc2lnbmluZyBrZXkgYW5kIHVwbG9hZCB0aGUgc2lnbmF0dXJlXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHlpZWxkIGRldmljZS52ZXJpZnkoKTtcbiAgICAgICAgICAgIHlpZWxkIF90aGlzLm91dGdvaW5nUmVxdWVzdFByb2Nlc3Nvci5tYWtlT3V0Z29pbmdSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkZXZpY2UuZnJlZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIubG9nKFwiYm9vdHN0cmFwQ3Jvc3NTaWduaW5nOiBDcm9zcy1zaWduaW5nIHByaXZhdGUga2V5cyBub3QgZm91bmQgbG9jYWxseSBvciBpbiBzZWNyZXQgc3RvcmFnZSwgY3JlYXRpbmcgbmV3IGtleXNcIik7XG4gICAgICAgICAgeWllbGQgX3RoaXMucmVzZXRDcm9zc1NpZ25pbmcob3B0cy5hdXRoVXBsb2FkRGV2aWNlU2lnbmluZ0tleXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IHdlIG1pZ2h0IHByZXZpb3VzbHkgaGF2ZSBib290c3RyYXBwZWQgY3Jvc3Mtc2lnbmluZyBidXQgbm90IGNvbXBsZXRlZCB1cGxvYWRpbmcgdGhlIGtleXMgdG8gdGhlXG4gICAgICAvLyAgIHNlcnZlciAtLSBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBjYWxsIE9sbURldmljZS5ib290c3RyYXBfY3Jvc3Nfc2lnbmluZy4gSG93IGRvIHdlIGtub3c/XG4gICAgICBsb2dnZXIubG9nKFwiYm9vdHN0cmFwQ3Jvc3NTaWduaW5nOiBjb21wbGV0ZVwiKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqIFJlc2V0IG91ciBjcm9zcy1zaWduaW5nIGtleXNcbiAgICpcbiAgICogVGhpcyBtZXRob2Qgd2lsbDpcbiAgICogICAqIFRlbGwgdGhlIE9sbU1hY2hpbmUgdG8gY3JlYXRlIG5ldyBrZXlzXG4gICAqICAgKiBVcGxvYWQgdGhlIG5ldyBwdWJsaWMga2V5cyBhbmQgdGhlIGRldmljZSBzaWduYXR1cmUgdG8gdGhlIHNlcnZlclxuICAgKiAgICogVXBsb2FkIHRoZSBwcml2YXRlIGtleXMgdG8gU1NTUywgaWYgaXQgaXMgc2V0IHVwXG4gICAqL1xuICByZXNldENyb3NzU2lnbmluZyhhdXRoVXBsb2FkRGV2aWNlU2lnbmluZ0tleXMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIFhYWDogV2UgbXVzdCBmaW5kIGEgd2F5IHRvIG1ha2UgdGhpcyBhdG9taWMsIGN1cnJlbnRseSBpZiB0aGUgdXNlciBkb2VzIG5vdCByZW1lbWJlciBoaXMgYWNjb3VudCBwYXNzd29yZFxuICAgICAgLy8gb3IgNFMgcGFzc3BocmFzZS9rZXkgdGhlIHByb2Nlc3Mgd2lsbCBmYWlsIGluIGEgYmFkIHN0YXRlLCB3aXRoIGtleXMgcm90YXRlZCBidXQgbm90IHVwbG9hZGVkIG9yIHNhdmVkIGluIDRTLlxuICAgICAgdmFyIG91dGdvaW5nUmVxdWVzdHMgPSB5aWVsZCBfdGhpczIub2xtTWFjaGluZS5ib290c3RyYXBDcm9zc1NpZ25pbmcodHJ1ZSk7XG5cbiAgICAgIC8vIElmIDRTIGlzIGNvbmZpZ3VyZWQgd2UgbmVlZCB0byB1cGRhdGUgaXQuXG4gICAgICBpZiAoISh5aWVsZCBfdGhpczIuc2VjcmV0U3RvcmFnZS5oYXNLZXkoKSkpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJyZXNldENyb3NzU2lnbmluZzogU2VjcmV0IHN0b3JhZ2UgaXMgbm90IHlldCBzZXQgdXA7IG5vdCBleHBvcnRpbmcga2V5cyB0byBzZWNyZXQgc3RvcmFnZSB5ZXQuXCIpO1xuICAgICAgICAvLyB0aGUga2V5cyBzaG91bGQgZ2V0IHVwbG9hZGVkIHRvIDRTIG9uY2UgdGhhdCBpcyBzZXQgdXAuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVcGRhdGUgNFMgYmVmb3JlIHVwbG9hZGluZyBjcm9zcy1zaWduaW5nIGtleXMsIHRvIHN0YXkgY29uc2lzdGVudCB3aXRoIGxlZ2FjeSB0aGF0IGFza3NcbiAgICAgICAgLy8gNFMgcGFzc3BocmFzZSBiZWZvcmUgYXNraW5nIGZvciBhY2NvdW50IHBhc3N3b3JkLlxuICAgICAgICAvLyBVbHRpbWF0ZWx5IHNob3VsZCBiZSBtYWRlIGF0b21pYyBhbmQgcmVzaXN0YW50IHRvIGZvcmdvdHRlbiBwYXNzd29yZC9wYXNzcGhyYXNlLlxuICAgICAgICBsb2dnZXIubG9nKFwicmVzZXRDcm9zc1NpZ25pbmc6IGV4cG9ydGluZyBwcml2YXRlIGtleXMgdG8gc2VjcmV0IHN0b3JhZ2VcIik7XG4gICAgICAgIHlpZWxkIF90aGlzMi5leHBvcnRDcm9zc1NpZ25pbmdLZXlzVG9TdG9yYWdlKCk7XG4gICAgICB9XG4gICAgICBsb2dnZXIubG9nKFwicmVzZXRDcm9zc1NpZ25pbmc6IHB1Ymxpc2hpbmcgcHVibGljIGtleXMgdG8gc2VydmVyXCIpO1xuICAgICAgZm9yICh2YXIgcmVxIG9mIFtvdXRnb2luZ1JlcXVlc3RzLnVwbG9hZEtleXNSZXF1ZXN0LCBvdXRnb2luZ1JlcXVlc3RzLnVwbG9hZFNpZ25pbmdLZXlzUmVxdWVzdCwgb3V0Z29pbmdSZXF1ZXN0cy51cGxvYWRTaWduYXR1cmVzUmVxdWVzdF0pIHtcbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgIHlpZWxkIF90aGlzMi5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IubWFrZU91dGdvaW5nUmVxdWVzdChyZXEsIGF1dGhVcGxvYWREZXZpY2VTaWduaW5nS2V5cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIGNyb3NzLXNpZ25pbmcga2V5cyBmcm9tIHRoZSBvbG0gbWFjaGluZSBhbmQgc2F2ZSB0aGVtIHRvIHNlY3JldCBzdG9yYWdlLCBpZiBpdCBpcyBjb25maWd1cmVkXG4gICAqXG4gICAqIChJZiBzZWNyZXQgc3RvcmFnZSBpcyAqbm90KiBjb25maWd1cmVkLCB3ZSBhc3N1bWUgdGhhdCB0aGUgZXhwb3J0IHdpbGwgaGFwcGVuIHdoZW4gaXQgaXMgc2V0IHVwKVxuICAgKi9cbiAgZXhwb3J0Q3Jvc3NTaWduaW5nS2V5c1RvU3RvcmFnZSgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBleHBvcnRlZCA9IHlpZWxkIF90aGlzMy5vbG1NYWNoaW5lLmV4cG9ydENyb3NzU2lnbmluZ0tleXMoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICh0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIHdoZW4gd2Uga25vdyB0aGUgb2xtIG1hY2hpbmUgaGFzIGtleXMpICovXG4gICAgICBpZiAoZXhwb3J0ZWQgIT09IG51bGwgJiYgZXhwb3J0ZWQgIT09IHZvaWQgMCAmJiBleHBvcnRlZC5tYXN0ZXJLZXkpIHtcbiAgICAgICAgeWllbGQgX3RoaXMzLnNlY3JldFN0b3JhZ2Uuc3RvcmUoXCJtLmNyb3NzX3NpZ25pbmcubWFzdGVyXCIsIGV4cG9ydGVkLm1hc3RlcktleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJDYW5ub3QgZXhwb3J0IE1TSyB0byBzZWNyZXQgc3RvcmFnZSwgcHJpdmF0ZSBrZXkgdW5rbm93blwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBvcnRlZCAhPT0gbnVsbCAmJiBleHBvcnRlZCAhPT0gdm9pZCAwICYmIGV4cG9ydGVkLnNlbGZfc2lnbmluZ19rZXkpIHtcbiAgICAgICAgeWllbGQgX3RoaXMzLnNlY3JldFN0b3JhZ2Uuc3RvcmUoXCJtLmNyb3NzX3NpZ25pbmcuc2VsZl9zaWduaW5nXCIsIGV4cG9ydGVkLnNlbGZfc2lnbmluZ19rZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiQ2Fubm90IGV4cG9ydCBTU0sgdG8gc2VjcmV0IHN0b3JhZ2UsIHByaXZhdGUga2V5IHVua25vd25cIik7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3J0ZWQgIT09IG51bGwgJiYgZXhwb3J0ZWQgIT09IHZvaWQgMCAmJiBleHBvcnRlZC51c2VyU2lnbmluZ0tleSkge1xuICAgICAgICB5aWVsZCBfdGhpczMuc2VjcmV0U3RvcmFnZS5zdG9yZShcIm0uY3Jvc3Nfc2lnbmluZy51c2VyX3NpZ25pbmdcIiwgZXhwb3J0ZWQudXNlclNpZ25pbmdLZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiQ2Fubm90IGV4cG9ydCBVU0sgdG8gc2VjcmV0IHN0b3JhZ2UsIHByaXZhdGUga2V5IHVua25vd25cIik7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3Jvc3NTaWduaW5nSWRlbnRpdHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/CrossSigningIdentity.js\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/DehydratedDeviceManager.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/DehydratedDeviceManager.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DehydratedDeviceManager: () => (/* binding */ DehydratedDeviceManager),\n/* harmony export */   UnstablePrefix: () => (/* binding */ UnstablePrefix)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @matrix-org/matrix-sdk-crypto-wasm */ \"./node_modules/@matrix-org/matrix-sdk-crypto-wasm/index.mjs\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/matrix-js-sdk/lib/utils.js\");\n/* harmony import */ var _http_api_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../http-api/index.js */ \"./node_modules/matrix-js-sdk/lib/http-api/index.js\");\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base64.js */ \"./node_modules/matrix-js-sdk/lib/base64.js\");\n/* harmony import */ var _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../crypto-api/index.js */ \"./node_modules/matrix-js-sdk/lib/crypto-api/index.js\");\n/* harmony import */ var _models_typed_event_emitter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../models/typed-event-emitter.js */ \"./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js\");\n\n\n/*\nCopyright 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n\n\n\n\n\n\n/**\n * The response body of `GET /_matrix/client/unstable/org.matrix.msc3814.v1/dehydrated_device`.\n */\n\n/**\n * The response body of `POST /_matrix/client/unstable/org.matrix.msc3814.v1/dehydrated_device/events`.\n */\n\n/**\n * The unstable URL prefix for dehydrated device endpoints\n */\nvar UnstablePrefix = \"/_matrix/client/unstable/org.matrix.msc3814.v1\";\n/**\n * The name used for the dehydration key in Secret Storage\n */\nvar SECRET_STORAGE_NAME = \"org.matrix.msc3814\";\n\n/**\n * The interval between creating dehydrated devices. (one week)\n */\nvar DEHYDRATION_INTERVAL = 7 * 24 * 60 * 60 * 1000;\n\n/**\n * Manages dehydrated devices\n *\n * We have one of these per `RustCrypto`.  It's responsible for\n *\n * * determining server support for dehydrated devices\n * * creating new dehydrated devices when requested, including periodically\n *   replacing the dehydrated device with a new one\n * * rehydrating a device when requested, and when present\n *\n * @internal\n */\nclass DehydratedDeviceManager extends _models_typed_event_emitter_js__WEBPACK_IMPORTED_MODULE_7__.TypedEventEmitter {\n  constructor(logger, olmMachine, http, outgoingRequestProcessor, secretStorage) {\n    super();\n    this.logger = logger;\n    this.olmMachine = olmMachine;\n    this.http = http;\n    this.outgoingRequestProcessor = outgoingRequestProcessor;\n    this.secretStorage = secretStorage;\n    /** the ID of the interval for periodically replacing the dehydrated device */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"intervalId\", void 0);\n  }\n  cacheKey(key) {\n    var _this = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      yield _this.olmMachine.dehydratedDevices().saveDehydratedDeviceKey(key);\n      _this.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_6__.CryptoEvent.DehydrationKeyCached);\n    })();\n  }\n\n  /**\n   * Return whether the server supports dehydrated devices.\n   */\n  isSupported() {\n    var _this2 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // call the endpoint to get a dehydrated device.  If it returns an\n      // M_UNRECOGNIZED error, then dehydration is unsupported.  If it returns\n      // a successful response, or an M_NOT_FOUND, then dehydration is supported.\n      // Any other exceptions are passed through.\n      try {\n        yield _this2.http.authedRequest(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Get, \"/dehydrated_device\", undefined, undefined, {\n          prefix: UnstablePrefix\n        });\n      } catch (error) {\n        var err = error;\n        if (err.errcode === \"M_UNRECOGNIZED\") {\n          return false;\n        } else if (err.errcode === \"M_NOT_FOUND\") {\n          return true;\n        }\n        throw error;\n      }\n      return true;\n    })();\n  }\n\n  /**\n   * Start using device dehydration.\n   *\n   * - Rehydrates a dehydrated device, if one is available and `opts.rehydrate`\n   *   is `true`.\n   * - Creates a new dehydration key, if necessary, and stores it in Secret\n   *   Storage.\n   *   - If `opts.createNewKey` is set to true, always creates a new key.\n   *   - If a dehydration key is not available, creates a new one.\n   * - Creates a new dehydrated device, and schedules periodically creating\n   *   new dehydrated devices.\n   *\n   * @param opts - options for device dehydration. For backwards compatibility\n   *     with old code, a boolean can be given here, which will be treated as\n   *     the `createNewKey` option. However, this is deprecated.\n   */\n  start() {\n    var _arguments = arguments,\n      _this3 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var opts = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {};\n      if (typeof opts === \"boolean\") {\n        opts = {\n          createNewKey: opts\n        };\n      }\n      if (opts.onlyIfKeyCached && !(yield _this3.olmMachine.dehydratedDevices().getDehydratedDeviceKey())) {\n        return;\n      }\n      _this3.stop();\n      if (opts.rehydrate !== false) {\n        try {\n          yield _this3.rehydrateDeviceIfAvailable();\n        } catch (e) {\n          // If rehydration fails, there isn't much we can do about it.  Log\n          // the error, and create a new device.\n          _this3.logger.info(\"dehydration: Error rehydrating device:\", e);\n          _this3.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_6__.CryptoEvent.RehydrationError, e.message);\n        }\n      }\n      if (opts.createNewKey) {\n        yield _this3.resetKey();\n      }\n      yield _this3.scheduleDeviceDehydration();\n    })();\n  }\n\n  /**\n   * Return whether the dehydration key is stored in Secret Storage.\n   */\n  isKeyStored() {\n    var _this4 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return Boolean(yield _this4.secretStorage.isStored(SECRET_STORAGE_NAME));\n    })();\n  }\n\n  /**\n   * Reset the dehydration key.\n   *\n   * Creates a new key and stores it in secret storage.\n   *\n   * @returns The newly-generated key.\n   */\n  resetKey() {\n    var _this5 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var key = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.DehydratedDeviceKey.createRandomKey();\n      yield _this5.secretStorage.store(SECRET_STORAGE_NAME, key.toBase64());\n      // Also cache it in the rust SDK's crypto store.\n      yield _this5.cacheKey(key);\n      return key;\n    })();\n  }\n\n  /**\n   * Get and cache the encryption key from secret storage.\n   *\n   * If `create` is `true`, creates a new key if no existing key is present.\n   *\n   * @returns the key, if available, or `null` if no key is available\n   */\n  getKey(create) {\n    var _this6 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var cachedKey = yield _this6.olmMachine.dehydratedDevices().getDehydratedDeviceKey();\n      if (cachedKey) return cachedKey;\n      var keyB64 = yield _this6.secretStorage.get(SECRET_STORAGE_NAME);\n      if (keyB64 === undefined) {\n        if (!create) {\n          return null;\n        }\n        return yield _this6.resetKey();\n      }\n\n      // We successfully found the key in secret storage: decode it, and cache it in\n      // the rust SDK's crypto store.\n      var bytes = (0,_base64_js__WEBPACK_IMPORTED_MODULE_5__.decodeBase64)(keyB64);\n      try {\n        var key = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.DehydratedDeviceKey.createKeyFromArray(bytes);\n        yield _this6.cacheKey(key);\n        return key;\n      } finally {\n        bytes.fill(0);\n      }\n    })();\n  }\n\n  /**\n   * Rehydrate the dehydrated device stored on the server.\n   *\n   * Checks if there is a dehydrated device on the server.  If so, rehydrates\n   * the device and processes the to-device events.\n   *\n   * Returns whether or not a dehydrated device was found.\n   */\n  rehydrateDeviceIfAvailable() {\n    var _this7 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var key = yield _this7.getKey(false);\n      if (!key) {\n        return false;\n      }\n      var dehydratedDeviceResp;\n      try {\n        dehydratedDeviceResp = yield _this7.http.authedRequest(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Get, \"/dehydrated_device\", undefined, undefined, {\n          prefix: UnstablePrefix\n        });\n      } catch (error) {\n        var err = error;\n        // We ignore M_NOT_FOUND (there is no dehydrated device, so nothing\n        // us to do) and M_UNRECOGNIZED (the server does not understand the\n        // endpoint).  We pass through any other errors.\n        if (err.errcode === \"M_NOT_FOUND\" || err.errcode === \"M_UNRECOGNIZED\") {\n          _this7.logger.info(\"dehydration: No dehydrated device\");\n          return false;\n        }\n        throw err;\n      }\n      _this7.logger.info(\"dehydration: dehydrated device found\");\n      _this7.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_6__.CryptoEvent.RehydrationStarted);\n      var rehydratedDevice = yield _this7.olmMachine.dehydratedDevices().rehydrate(key, new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.DeviceId(dehydratedDeviceResp.device_id), JSON.stringify(dehydratedDeviceResp.device_data));\n      _this7.logger.info(\"dehydration: device rehydrated\");\n      var nextBatch = undefined;\n      var toDeviceCount = 0;\n      var roomKeyCount = 0;\n      var path = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.encodeUri)(\"/dehydrated_device/$device_id/events\", {\n        $device_id: dehydratedDeviceResp.device_id\n      });\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        var eventResp = yield _this7.http.authedRequest(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Post, path, undefined, nextBatch ? {\n          next_batch: nextBatch\n        } : {}, {\n          prefix: UnstablePrefix\n        });\n        if (eventResp.events.length === 0) {\n          break;\n        }\n        toDeviceCount += eventResp.events.length;\n        nextBatch = eventResp.next_batch;\n        var roomKeyInfos = yield rehydratedDevice.receiveEvents(JSON.stringify(eventResp.events));\n        roomKeyCount += roomKeyInfos.length;\n        _this7.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_6__.CryptoEvent.RehydrationProgress, roomKeyCount, toDeviceCount);\n      }\n      _this7.logger.info(\"dehydration: received \".concat(roomKeyCount, \" room keys from \").concat(toDeviceCount, \" to-device events\"));\n      _this7.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_6__.CryptoEvent.RehydrationCompleted);\n      return true;\n    })();\n  }\n\n  /**\n   * Creates and uploads a new dehydrated device.\n   *\n   * Creates and stores a new key in secret storage if none is available.\n   */\n  createAndUploadDehydratedDevice() {\n    var _this8 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var key = yield _this8.getKey(true);\n      var dehydratedDevice = yield _this8.olmMachine.dehydratedDevices().create();\n      _this8.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_6__.CryptoEvent.DehydratedDeviceCreated);\n      var request = yield dehydratedDevice.keysForUpload(\"Dehydrated device\", key);\n      yield _this8.outgoingRequestProcessor.makeOutgoingRequest(request);\n      _this8.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_6__.CryptoEvent.DehydratedDeviceUploaded);\n      _this8.logger.info(\"dehydration: uploaded device\");\n    })();\n  }\n\n  /**\n   * Schedule periodic creation of dehydrated devices.\n   */\n  scheduleDeviceDehydration() {\n    var _this9 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // cancel any previously-scheduled tasks\n      _this9.stop();\n      yield _this9.createAndUploadDehydratedDevice();\n      _this9.intervalId = setInterval(() => {\n        _this9.createAndUploadDehydratedDevice().catch(error => {\n          _this9.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_6__.CryptoEvent.DehydratedDeviceRotationError, error.message);\n          _this9.logger.error(\"Error creating dehydrated device:\", error);\n        });\n      }, DEHYDRATION_INTERVAL);\n    })();\n  }\n\n  /**\n   * Stop the dehydrated device manager.\n   *\n   * Cancels any scheduled dehydration tasks.\n   */\n  stop() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = undefined;\n    }\n  }\n}\n\n/**\n * The events fired by the DehydratedDeviceManager\n * @internal\n */\n\n/**\n * A map of the {@link DehydratedDeviceEvents} fired by the {@link DehydratedDeviceManager} and their payloads.\n * @internal\n */\n//# sourceMappingURL=DehydratedDeviceManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vRGVoeWRyYXRlZERldmljZU1hbmFnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF3RTtBQUNKO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0U7QUFDOUI7QUFDTTtBQUNGO0FBQ1M7QUFDZ0I7O0FBRXJFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0MsNkVBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlGQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0EsaUJBQWlCLDZEQUFXO0FBQzVCLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzREFBTTtBQUM5QztBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QixnQkFBZ0IsbUZBQW1DO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHdEQUFZO0FBQzlCO0FBQ0Esa0JBQWtCLG1GQUFtQztBQUNyRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsc0RBQU07QUFDckU7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkRBQVc7QUFDN0IsNEZBQTRGLHdFQUF3QjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvREFBUztBQUMxQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esd0RBQXdELHNEQUFNO0FBQzlEO0FBQ0EsVUFBVSxJQUFJO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkRBQVc7QUFDL0I7QUFDQTtBQUNBLGtCQUFrQiw2REFBVztBQUM3QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQSxrQkFBa0IsNkRBQVc7QUFDN0I7QUFDQTtBQUNBLGtCQUFrQiw2REFBVztBQUM3QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2REFBVztBQUNqQztBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw4QkFBOEIsY0FBYywrQkFBK0I7QUFDNUY7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXN0ZXJpY3MtZ3JpZC8uL25vZGVfbW9kdWxlcy9tYXRyaXgtanMtc2RrL2xpYi9ydXN0LWNyeXB0by9EZWh5ZHJhdGVkRGV2aWNlTWFuYWdlci5qcz84ZmY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfYXN5bmNUb0dlbmVyYXRvciBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCI7XG4vKlxuQ29weXJpZ2h0IDIwMjQgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgKiBhcyBSdXN0U2RrQ3J5cHRvSnMgZnJvbSBcIkBtYXRyaXgtb3JnL21hdHJpeC1zZGstY3J5cHRvLXdhc21cIjtcbmltcG9ydCB7IGVuY29kZVVyaSB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgTWV0aG9kIH0gZnJvbSBcIi4uL2h0dHAtYXBpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkZWNvZGVCYXNlNjQgfSBmcm9tIFwiLi4vYmFzZTY0LmpzXCI7XG5pbXBvcnQgeyBDcnlwdG9FdmVudCB9IGZyb20gXCIuLi9jcnlwdG8tYXBpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZEV2ZW50RW1pdHRlciB9IGZyb20gXCIuLi9tb2RlbHMvdHlwZWQtZXZlbnQtZW1pdHRlci5qc1wiO1xuXG4vKipcbiAqIFRoZSByZXNwb25zZSBib2R5IG9mIGBHRVQgL19tYXRyaXgvY2xpZW50L3Vuc3RhYmxlL29yZy5tYXRyaXgubXNjMzgxNC52MS9kZWh5ZHJhdGVkX2RldmljZWAuXG4gKi9cblxuLyoqXG4gKiBUaGUgcmVzcG9uc2UgYm9keSBvZiBgUE9TVCAvX21hdHJpeC9jbGllbnQvdW5zdGFibGUvb3JnLm1hdHJpeC5tc2MzODE0LnYxL2RlaHlkcmF0ZWRfZGV2aWNlL2V2ZW50c2AuXG4gKi9cblxuLyoqXG4gKiBUaGUgdW5zdGFibGUgVVJMIHByZWZpeCBmb3IgZGVoeWRyYXRlZCBkZXZpY2UgZW5kcG9pbnRzXG4gKi9cbmV4cG9ydCB2YXIgVW5zdGFibGVQcmVmaXggPSBcIi9fbWF0cml4L2NsaWVudC91bnN0YWJsZS9vcmcubWF0cml4Lm1zYzM4MTQudjFcIjtcbi8qKlxuICogVGhlIG5hbWUgdXNlZCBmb3IgdGhlIGRlaHlkcmF0aW9uIGtleSBpbiBTZWNyZXQgU3RvcmFnZVxuICovXG52YXIgU0VDUkVUX1NUT1JBR0VfTkFNRSA9IFwib3JnLm1hdHJpeC5tc2MzODE0XCI7XG5cbi8qKlxuICogVGhlIGludGVydmFsIGJldHdlZW4gY3JlYXRpbmcgZGVoeWRyYXRlZCBkZXZpY2VzLiAob25lIHdlZWspXG4gKi9cbnZhciBERUhZRFJBVElPTl9JTlRFUlZBTCA9IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuXG4vKipcbiAqIE1hbmFnZXMgZGVoeWRyYXRlZCBkZXZpY2VzXG4gKlxuICogV2UgaGF2ZSBvbmUgb2YgdGhlc2UgcGVyIGBSdXN0Q3J5cHRvYC4gIEl0J3MgcmVzcG9uc2libGUgZm9yXG4gKlxuICogKiBkZXRlcm1pbmluZyBzZXJ2ZXIgc3VwcG9ydCBmb3IgZGVoeWRyYXRlZCBkZXZpY2VzXG4gKiAqIGNyZWF0aW5nIG5ldyBkZWh5ZHJhdGVkIGRldmljZXMgd2hlbiByZXF1ZXN0ZWQsIGluY2x1ZGluZyBwZXJpb2RpY2FsbHlcbiAqICAgcmVwbGFjaW5nIHRoZSBkZWh5ZHJhdGVkIGRldmljZSB3aXRoIGEgbmV3IG9uZVxuICogKiByZWh5ZHJhdGluZyBhIGRldmljZSB3aGVuIHJlcXVlc3RlZCwgYW5kIHdoZW4gcHJlc2VudFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgRGVoeWRyYXRlZERldmljZU1hbmFnZXIgZXh0ZW5kcyBUeXBlZEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGxvZ2dlciwgb2xtTWFjaGluZSwgaHR0cCwgb3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yLCBzZWNyZXRTdG9yYWdlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLm9sbU1hY2hpbmUgPSBvbG1NYWNoaW5lO1xuICAgIHRoaXMuaHR0cCA9IGh0dHA7XG4gICAgdGhpcy5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IgPSBvdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3I7XG4gICAgdGhpcy5zZWNyZXRTdG9yYWdlID0gc2VjcmV0U3RvcmFnZTtcbiAgICAvKiogdGhlIElEIG9mIHRoZSBpbnRlcnZhbCBmb3IgcGVyaW9kaWNhbGx5IHJlcGxhY2luZyB0aGUgZGVoeWRyYXRlZCBkZXZpY2UgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcnZhbElkXCIsIHZvaWQgMCk7XG4gIH1cbiAgY2FjaGVLZXkoa2V5KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF90aGlzLm9sbU1hY2hpbmUuZGVoeWRyYXRlZERldmljZXMoKS5zYXZlRGVoeWRyYXRlZERldmljZUtleShrZXkpO1xuICAgICAgX3RoaXMuZW1pdChDcnlwdG9FdmVudC5EZWh5ZHJhdGlvbktleUNhY2hlZCk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc2VydmVyIHN1cHBvcnRzIGRlaHlkcmF0ZWQgZGV2aWNlcy5cbiAgICovXG4gIGlzU3VwcG9ydGVkKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgLy8gY2FsbCB0aGUgZW5kcG9pbnQgdG8gZ2V0IGEgZGVoeWRyYXRlZCBkZXZpY2UuICBJZiBpdCByZXR1cm5zIGFuXG4gICAgICAvLyBNX1VOUkVDT0dOSVpFRCBlcnJvciwgdGhlbiBkZWh5ZHJhdGlvbiBpcyB1bnN1cHBvcnRlZC4gIElmIGl0IHJldHVybnNcbiAgICAgIC8vIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSwgb3IgYW4gTV9OT1RfRk9VTkQsIHRoZW4gZGVoeWRyYXRpb24gaXMgc3VwcG9ydGVkLlxuICAgICAgLy8gQW55IG90aGVyIGV4Y2VwdGlvbnMgYXJlIHBhc3NlZCB0aHJvdWdoLlxuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgX3RoaXMyLmh0dHAuYXV0aGVkUmVxdWVzdChNZXRob2QuR2V0LCBcIi9kZWh5ZHJhdGVkX2RldmljZVwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgIHByZWZpeDogVW5zdGFibGVQcmVmaXhcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB2YXIgZXJyID0gZXJyb3I7XG4gICAgICAgIGlmIChlcnIuZXJyY29kZSA9PT0gXCJNX1VOUkVDT0dOSVpFRFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGVyci5lcnJjb2RlID09PSBcIk1fTk9UX0ZPVU5EXCIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdXNpbmcgZGV2aWNlIGRlaHlkcmF0aW9uLlxuICAgKlxuICAgKiAtIFJlaHlkcmF0ZXMgYSBkZWh5ZHJhdGVkIGRldmljZSwgaWYgb25lIGlzIGF2YWlsYWJsZSBhbmQgYG9wdHMucmVoeWRyYXRlYFxuICAgKiAgIGlzIGB0cnVlYC5cbiAgICogLSBDcmVhdGVzIGEgbmV3IGRlaHlkcmF0aW9uIGtleSwgaWYgbmVjZXNzYXJ5LCBhbmQgc3RvcmVzIGl0IGluIFNlY3JldFxuICAgKiAgIFN0b3JhZ2UuXG4gICAqICAgLSBJZiBgb3B0cy5jcmVhdGVOZXdLZXlgIGlzIHNldCB0byB0cnVlLCBhbHdheXMgY3JlYXRlcyBhIG5ldyBrZXkuXG4gICAqICAgLSBJZiBhIGRlaHlkcmF0aW9uIGtleSBpcyBub3QgYXZhaWxhYmxlLCBjcmVhdGVzIGEgbmV3IG9uZS5cbiAgICogLSBDcmVhdGVzIGEgbmV3IGRlaHlkcmF0ZWQgZGV2aWNlLCBhbmQgc2NoZWR1bGVzIHBlcmlvZGljYWxseSBjcmVhdGluZ1xuICAgKiAgIG5ldyBkZWh5ZHJhdGVkIGRldmljZXMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBmb3IgZGV2aWNlIGRlaHlkcmF0aW9uLiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICogICAgIHdpdGggb2xkIGNvZGUsIGEgYm9vbGVhbiBjYW4gYmUgZ2l2ZW4gaGVyZSwgd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAqICAgICB0aGUgYGNyZWF0ZU5ld0tleWAgb3B0aW9uLiBIb3dldmVyLCB0aGlzIGlzIGRlcHJlY2F0ZWQuXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cyxcbiAgICAgIF90aGlzMyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgb3B0cyA9IF9hcmd1bWVudHMubGVuZ3RoID4gMCAmJiBfYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBfYXJndW1lbnRzWzBdIDoge307XG4gICAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgY3JlYXRlTmV3S2V5OiBvcHRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAob3B0cy5vbmx5SWZLZXlDYWNoZWQgJiYgISh5aWVsZCBfdGhpczMub2xtTWFjaGluZS5kZWh5ZHJhdGVkRGV2aWNlcygpLmdldERlaHlkcmF0ZWREZXZpY2VLZXkoKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMzLnN0b3AoKTtcbiAgICAgIGlmIChvcHRzLnJlaHlkcmF0ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5aWVsZCBfdGhpczMucmVoeWRyYXRlRGV2aWNlSWZBdmFpbGFibGUoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIElmIHJlaHlkcmF0aW9uIGZhaWxzLCB0aGVyZSBpc24ndCBtdWNoIHdlIGNhbiBkbyBhYm91dCBpdC4gIExvZ1xuICAgICAgICAgIC8vIHRoZSBlcnJvciwgYW5kIGNyZWF0ZSBhIG5ldyBkZXZpY2UuXG4gICAgICAgICAgX3RoaXMzLmxvZ2dlci5pbmZvKFwiZGVoeWRyYXRpb246IEVycm9yIHJlaHlkcmF0aW5nIGRldmljZTpcIiwgZSk7XG4gICAgICAgICAgX3RoaXMzLmVtaXQoQ3J5cHRvRXZlbnQuUmVoeWRyYXRpb25FcnJvciwgZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdHMuY3JlYXRlTmV3S2V5KSB7XG4gICAgICAgIHlpZWxkIF90aGlzMy5yZXNldEtleSgpO1xuICAgICAgfVxuICAgICAgeWllbGQgX3RoaXMzLnNjaGVkdWxlRGV2aWNlRGVoeWRyYXRpb24oKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBkZWh5ZHJhdGlvbiBrZXkgaXMgc3RvcmVkIGluIFNlY3JldCBTdG9yYWdlLlxuICAgKi9cbiAgaXNLZXlTdG9yZWQoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih5aWVsZCBfdGhpczQuc2VjcmV0U3RvcmFnZS5pc1N0b3JlZChTRUNSRVRfU1RPUkFHRV9OQU1FKSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgZGVoeWRyYXRpb24ga2V5LlxuICAgKlxuICAgKiBDcmVhdGVzIGEgbmV3IGtleSBhbmQgc3RvcmVzIGl0IGluIHNlY3JldCBzdG9yYWdlLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgbmV3bHktZ2VuZXJhdGVkIGtleS5cbiAgICovXG4gIHJlc2V0S2V5KCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIGtleSA9IFJ1c3RTZGtDcnlwdG9Kcy5EZWh5ZHJhdGVkRGV2aWNlS2V5LmNyZWF0ZVJhbmRvbUtleSgpO1xuICAgICAgeWllbGQgX3RoaXM1LnNlY3JldFN0b3JhZ2Uuc3RvcmUoU0VDUkVUX1NUT1JBR0VfTkFNRSwga2V5LnRvQmFzZTY0KCkpO1xuICAgICAgLy8gQWxzbyBjYWNoZSBpdCBpbiB0aGUgcnVzdCBTREsncyBjcnlwdG8gc3RvcmUuXG4gICAgICB5aWVsZCBfdGhpczUuY2FjaGVLZXkoa2V5KTtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW5kIGNhY2hlIHRoZSBlbmNyeXB0aW9uIGtleSBmcm9tIHNlY3JldCBzdG9yYWdlLlxuICAgKlxuICAgKiBJZiBgY3JlYXRlYCBpcyBgdHJ1ZWAsIGNyZWF0ZXMgYSBuZXcga2V5IGlmIG5vIGV4aXN0aW5nIGtleSBpcyBwcmVzZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUga2V5LCBpZiBhdmFpbGFibGUsIG9yIGBudWxsYCBpZiBubyBrZXkgaXMgYXZhaWxhYmxlXG4gICAqL1xuICBnZXRLZXkoY3JlYXRlKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgY2FjaGVkS2V5ID0geWllbGQgX3RoaXM2Lm9sbU1hY2hpbmUuZGVoeWRyYXRlZERldmljZXMoKS5nZXREZWh5ZHJhdGVkRGV2aWNlS2V5KCk7XG4gICAgICBpZiAoY2FjaGVkS2V5KSByZXR1cm4gY2FjaGVkS2V5O1xuICAgICAgdmFyIGtleUI2NCA9IHlpZWxkIF90aGlzNi5zZWNyZXRTdG9yYWdlLmdldChTRUNSRVRfU1RPUkFHRV9OQU1FKTtcbiAgICAgIGlmIChrZXlCNjQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWNyZWF0ZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5aWVsZCBfdGhpczYucmVzZXRLZXkoKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2Ugc3VjY2Vzc2Z1bGx5IGZvdW5kIHRoZSBrZXkgaW4gc2VjcmV0IHN0b3JhZ2U6IGRlY29kZSBpdCwgYW5kIGNhY2hlIGl0IGluXG4gICAgICAvLyB0aGUgcnVzdCBTREsncyBjcnlwdG8gc3RvcmUuXG4gICAgICB2YXIgYnl0ZXMgPSBkZWNvZGVCYXNlNjQoa2V5QjY0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBrZXkgPSBSdXN0U2RrQ3J5cHRvSnMuRGVoeWRyYXRlZERldmljZUtleS5jcmVhdGVLZXlGcm9tQXJyYXkoYnl0ZXMpO1xuICAgICAgICB5aWVsZCBfdGhpczYuY2FjaGVLZXkoa2V5KTtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGJ5dGVzLmZpbGwoMCk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWh5ZHJhdGUgdGhlIGRlaHlkcmF0ZWQgZGV2aWNlIHN0b3JlZCBvbiB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBDaGVja3MgaWYgdGhlcmUgaXMgYSBkZWh5ZHJhdGVkIGRldmljZSBvbiB0aGUgc2VydmVyLiAgSWYgc28sIHJlaHlkcmF0ZXNcbiAgICogdGhlIGRldmljZSBhbmQgcHJvY2Vzc2VzIHRoZSB0by1kZXZpY2UgZXZlbnRzLlxuICAgKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEgZGVoeWRyYXRlZCBkZXZpY2Ugd2FzIGZvdW5kLlxuICAgKi9cbiAgcmVoeWRyYXRlRGV2aWNlSWZBdmFpbGFibGUoKSB7XG4gICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIga2V5ID0geWllbGQgX3RoaXM3LmdldEtleShmYWxzZSk7XG4gICAgICBpZiAoIWtleSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgZGVoeWRyYXRlZERldmljZVJlc3A7XG4gICAgICB0cnkge1xuICAgICAgICBkZWh5ZHJhdGVkRGV2aWNlUmVzcCA9IHlpZWxkIF90aGlzNy5odHRwLmF1dGhlZFJlcXVlc3QoTWV0aG9kLkdldCwgXCIvZGVoeWRyYXRlZF9kZXZpY2VcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICBwcmVmaXg6IFVuc3RhYmxlUHJlZml4XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdmFyIGVyciA9IGVycm9yO1xuICAgICAgICAvLyBXZSBpZ25vcmUgTV9OT1RfRk9VTkQgKHRoZXJlIGlzIG5vIGRlaHlkcmF0ZWQgZGV2aWNlLCBzbyBub3RoaW5nXG4gICAgICAgIC8vIHVzIHRvIGRvKSBhbmQgTV9VTlJFQ09HTklaRUQgKHRoZSBzZXJ2ZXIgZG9lcyBub3QgdW5kZXJzdGFuZCB0aGVcbiAgICAgICAgLy8gZW5kcG9pbnQpLiAgV2UgcGFzcyB0aHJvdWdoIGFueSBvdGhlciBlcnJvcnMuXG4gICAgICAgIGlmIChlcnIuZXJyY29kZSA9PT0gXCJNX05PVF9GT1VORFwiIHx8IGVyci5lcnJjb2RlID09PSBcIk1fVU5SRUNPR05JWkVEXCIpIHtcbiAgICAgICAgICBfdGhpczcubG9nZ2VyLmluZm8oXCJkZWh5ZHJhdGlvbjogTm8gZGVoeWRyYXRlZCBkZXZpY2VcIik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIF90aGlzNy5sb2dnZXIuaW5mbyhcImRlaHlkcmF0aW9uOiBkZWh5ZHJhdGVkIGRldmljZSBmb3VuZFwiKTtcbiAgICAgIF90aGlzNy5lbWl0KENyeXB0b0V2ZW50LlJlaHlkcmF0aW9uU3RhcnRlZCk7XG4gICAgICB2YXIgcmVoeWRyYXRlZERldmljZSA9IHlpZWxkIF90aGlzNy5vbG1NYWNoaW5lLmRlaHlkcmF0ZWREZXZpY2VzKCkucmVoeWRyYXRlKGtleSwgbmV3IFJ1c3RTZGtDcnlwdG9Kcy5EZXZpY2VJZChkZWh5ZHJhdGVkRGV2aWNlUmVzcC5kZXZpY2VfaWQpLCBKU09OLnN0cmluZ2lmeShkZWh5ZHJhdGVkRGV2aWNlUmVzcC5kZXZpY2VfZGF0YSkpO1xuICAgICAgX3RoaXM3LmxvZ2dlci5pbmZvKFwiZGVoeWRyYXRpb246IGRldmljZSByZWh5ZHJhdGVkXCIpO1xuICAgICAgdmFyIG5leHRCYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciB0b0RldmljZUNvdW50ID0gMDtcbiAgICAgIHZhciByb29tS2V5Q291bnQgPSAwO1xuICAgICAgdmFyIHBhdGggPSBlbmNvZGVVcmkoXCIvZGVoeWRyYXRlZF9kZXZpY2UvJGRldmljZV9pZC9ldmVudHNcIiwge1xuICAgICAgICAkZGV2aWNlX2lkOiBkZWh5ZHJhdGVkRGV2aWNlUmVzcC5kZXZpY2VfaWRcbiAgICAgIH0pO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGV2ZW50UmVzcCA9IHlpZWxkIF90aGlzNy5odHRwLmF1dGhlZFJlcXVlc3QoTWV0aG9kLlBvc3QsIHBhdGgsIHVuZGVmaW5lZCwgbmV4dEJhdGNoID8ge1xuICAgICAgICAgIG5leHRfYmF0Y2g6IG5leHRCYXRjaFxuICAgICAgICB9IDoge30sIHtcbiAgICAgICAgICBwcmVmaXg6IFVuc3RhYmxlUHJlZml4XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXZlbnRSZXNwLmV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0b0RldmljZUNvdW50ICs9IGV2ZW50UmVzcC5ldmVudHMubGVuZ3RoO1xuICAgICAgICBuZXh0QmF0Y2ggPSBldmVudFJlc3AubmV4dF9iYXRjaDtcbiAgICAgICAgdmFyIHJvb21LZXlJbmZvcyA9IHlpZWxkIHJlaHlkcmF0ZWREZXZpY2UucmVjZWl2ZUV2ZW50cyhKU09OLnN0cmluZ2lmeShldmVudFJlc3AuZXZlbnRzKSk7XG4gICAgICAgIHJvb21LZXlDb3VudCArPSByb29tS2V5SW5mb3MubGVuZ3RoO1xuICAgICAgICBfdGhpczcuZW1pdChDcnlwdG9FdmVudC5SZWh5ZHJhdGlvblByb2dyZXNzLCByb29tS2V5Q291bnQsIHRvRGV2aWNlQ291bnQpO1xuICAgICAgfVxuICAgICAgX3RoaXM3LmxvZ2dlci5pbmZvKFwiZGVoeWRyYXRpb246IHJlY2VpdmVkIFwiLmNvbmNhdChyb29tS2V5Q291bnQsIFwiIHJvb20ga2V5cyBmcm9tIFwiKS5jb25jYXQodG9EZXZpY2VDb3VudCwgXCIgdG8tZGV2aWNlIGV2ZW50c1wiKSk7XG4gICAgICBfdGhpczcuZW1pdChDcnlwdG9FdmVudC5SZWh5ZHJhdGlvbkNvbXBsZXRlZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIHVwbG9hZHMgYSBuZXcgZGVoeWRyYXRlZCBkZXZpY2UuXG4gICAqXG4gICAqIENyZWF0ZXMgYW5kIHN0b3JlcyBhIG5ldyBrZXkgaW4gc2VjcmV0IHN0b3JhZ2UgaWYgbm9uZSBpcyBhdmFpbGFibGUuXG4gICAqL1xuICBjcmVhdGVBbmRVcGxvYWREZWh5ZHJhdGVkRGV2aWNlKCkge1xuICAgIHZhciBfdGhpczggPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIGtleSA9IHlpZWxkIF90aGlzOC5nZXRLZXkodHJ1ZSk7XG4gICAgICB2YXIgZGVoeWRyYXRlZERldmljZSA9IHlpZWxkIF90aGlzOC5vbG1NYWNoaW5lLmRlaHlkcmF0ZWREZXZpY2VzKCkuY3JlYXRlKCk7XG4gICAgICBfdGhpczguZW1pdChDcnlwdG9FdmVudC5EZWh5ZHJhdGVkRGV2aWNlQ3JlYXRlZCk7XG4gICAgICB2YXIgcmVxdWVzdCA9IHlpZWxkIGRlaHlkcmF0ZWREZXZpY2Uua2V5c0ZvclVwbG9hZChcIkRlaHlkcmF0ZWQgZGV2aWNlXCIsIGtleSk7XG4gICAgICB5aWVsZCBfdGhpczgub3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yLm1ha2VPdXRnb2luZ1JlcXVlc3QocmVxdWVzdCk7XG4gICAgICBfdGhpczguZW1pdChDcnlwdG9FdmVudC5EZWh5ZHJhdGVkRGV2aWNlVXBsb2FkZWQpO1xuICAgICAgX3RoaXM4LmxvZ2dlci5pbmZvKFwiZGVoeWRyYXRpb246IHVwbG9hZGVkIGRldmljZVwiKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlIHBlcmlvZGljIGNyZWF0aW9uIG9mIGRlaHlkcmF0ZWQgZGV2aWNlcy5cbiAgICovXG4gIHNjaGVkdWxlRGV2aWNlRGVoeWRyYXRpb24oKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBjYW5jZWwgYW55IHByZXZpb3VzbHktc2NoZWR1bGVkIHRhc2tzXG4gICAgICBfdGhpczkuc3RvcCgpO1xuICAgICAgeWllbGQgX3RoaXM5LmNyZWF0ZUFuZFVwbG9hZERlaHlkcmF0ZWREZXZpY2UoKTtcbiAgICAgIF90aGlzOS5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBfdGhpczkuY3JlYXRlQW5kVXBsb2FkRGVoeWRyYXRlZERldmljZSgpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBfdGhpczkuZW1pdChDcnlwdG9FdmVudC5EZWh5ZHJhdGVkRGV2aWNlUm90YXRpb25FcnJvciwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgX3RoaXM5LmxvZ2dlci5lcnJvcihcIkVycm9yIGNyZWF0aW5nIGRlaHlkcmF0ZWQgZGV2aWNlOlwiLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSwgREVIWURSQVRJT05fSU5URVJWQUwpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgZGVoeWRyYXRlZCBkZXZpY2UgbWFuYWdlci5cbiAgICpcbiAgICogQ2FuY2VscyBhbnkgc2NoZWR1bGVkIGRlaHlkcmF0aW9uIHRhc2tzLlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICB0aGlzLmludGVydmFsSWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhlIGV2ZW50cyBmaXJlZCBieSB0aGUgRGVoeWRyYXRlZERldmljZU1hbmFnZXJcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogQSBtYXAgb2YgdGhlIHtAbGluayBEZWh5ZHJhdGVkRGV2aWNlRXZlbnRzfSBmaXJlZCBieSB0aGUge0BsaW5rIERlaHlkcmF0ZWREZXZpY2VNYW5hZ2VyfSBhbmQgdGhlaXIgcGF5bG9hZHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVoeWRyYXRlZERldmljZU1hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/DehydratedDeviceManager.js\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/KeyClaimManager.js":
/*!***********************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/KeyClaimManager.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyClaimManager: () => (/* binding */ KeyClaimManager)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n\n\n/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * KeyClaimManager: linearises calls to OlmMachine.getMissingSessions to avoid races\n *\n * We have one of these per `RustCrypto` (and hence per `MatrixClient`).\n *\n * @internal\n */\nclass KeyClaimManager {\n  constructor(olmMachine, outgoingRequestProcessor) {\n    this.olmMachine = olmMachine;\n    this.outgoingRequestProcessor = outgoingRequestProcessor;\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"currentClaimPromise\", void 0);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"stopped\", false);\n    this.currentClaimPromise = Promise.resolve();\n  }\n\n  /**\n   * Tell the KeyClaimManager to immediately stop processing requests.\n   *\n   * Any further calls, and any still in the queue, will fail with an error.\n   */\n  stop() {\n    this.stopped = true;\n  }\n\n  /**\n   * Given a list of users, attempt to ensure that we have Olm Sessions active with each of their devices\n   *\n   * If we don't have an active olm session, we will claim a one-time key and start one.\n   * @param logger - logger to use\n   * @param userList - list of userIDs to claim\n   */\n  ensureSessionsForUsers(logger, userList) {\n    // The Rust-SDK requires that we only have one getMissingSessions process in flight at once. This little dance\n    // ensures that, by only having one call to ensureSessionsForUsersInner active at once (and making them\n    // queue up in order).\n    var prom = this.currentClaimPromise.catch(() => {\n      // any errors in the previous claim will have been reported already, so there is nothing to do here.\n      // we just throw away the error and start anew.\n    }).then(() => this.ensureSessionsForUsersInner(logger, userList));\n    this.currentClaimPromise = prom;\n    return prom;\n  }\n  ensureSessionsForUsersInner(logger, userList) {\n    var _this = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // bail out quickly if we've been stopped.\n      if (_this.stopped) {\n        throw new Error(\"Cannot ensure Olm sessions: shutting down\");\n      }\n      logger.info(\"Checking for missing Olm sessions\");\n      // By passing the userId array to rust we transfer ownership of the items to rust, causing\n      // them to be invalidated on the JS side as soon as the method is called.\n      // As we haven't created the `userList` let's clone the users, to not break the caller from re-using it.\n      var claimRequest = yield _this.olmMachine.getMissingSessions(userList.map(u => u.clone()));\n      if (claimRequest) {\n        logger.info(\"Making /keys/claim request\");\n        yield _this.outgoingRequestProcessor.makeOutgoingRequest(claimRequest);\n      }\n      logger.info(\"Olm sessions prepared\");\n    })();\n  }\n}\n//# sourceMappingURL=KeyClaimManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vS2V5Q2xhaW1NYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RTtBQUNKO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQixJQUFJLGlGQUFlO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FzdGVyaWNzLWdyaWQvLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vS2V5Q2xhaW1NYW5hZ2VyLmpzP2Q2YTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9hc3luY1RvR2VuZXJhdG9yIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIjtcbi8qXG5Db3B5cmlnaHQgMjAyMyBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8qKlxuICogS2V5Q2xhaW1NYW5hZ2VyOiBsaW5lYXJpc2VzIGNhbGxzIHRvIE9sbU1hY2hpbmUuZ2V0TWlzc2luZ1Nlc3Npb25zIHRvIGF2b2lkIHJhY2VzXG4gKlxuICogV2UgaGF2ZSBvbmUgb2YgdGhlc2UgcGVyIGBSdXN0Q3J5cHRvYCAoYW5kIGhlbmNlIHBlciBgTWF0cml4Q2xpZW50YCkuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBLZXlDbGFpbU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihvbG1NYWNoaW5lLCBvdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IpIHtcbiAgICB0aGlzLm9sbU1hY2hpbmUgPSBvbG1NYWNoaW5lO1xuICAgIHRoaXMub3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yID0gb3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImN1cnJlbnRDbGFpbVByb21pc2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9wcGVkXCIsIGZhbHNlKTtcbiAgICB0aGlzLmN1cnJlbnRDbGFpbVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWxsIHRoZSBLZXlDbGFpbU1hbmFnZXIgdG8gaW1tZWRpYXRlbHkgc3RvcCBwcm9jZXNzaW5nIHJlcXVlc3RzLlxuICAgKlxuICAgKiBBbnkgZnVydGhlciBjYWxscywgYW5kIGFueSBzdGlsbCBpbiB0aGUgcXVldWUsIHdpbGwgZmFpbCB3aXRoIGFuIGVycm9yLlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgbGlzdCBvZiB1c2VycywgYXR0ZW1wdCB0byBlbnN1cmUgdGhhdCB3ZSBoYXZlIE9sbSBTZXNzaW9ucyBhY3RpdmUgd2l0aCBlYWNoIG9mIHRoZWlyIGRldmljZXNcbiAgICpcbiAgICogSWYgd2UgZG9uJ3QgaGF2ZSBhbiBhY3RpdmUgb2xtIHNlc3Npb24sIHdlIHdpbGwgY2xhaW0gYSBvbmUtdGltZSBrZXkgYW5kIHN0YXJ0IG9uZS5cbiAgICogQHBhcmFtIGxvZ2dlciAtIGxvZ2dlciB0byB1c2VcbiAgICogQHBhcmFtIHVzZXJMaXN0IC0gbGlzdCBvZiB1c2VySURzIHRvIGNsYWltXG4gICAqL1xuICBlbnN1cmVTZXNzaW9uc0ZvclVzZXJzKGxvZ2dlciwgdXNlckxpc3QpIHtcbiAgICAvLyBUaGUgUnVzdC1TREsgcmVxdWlyZXMgdGhhdCB3ZSBvbmx5IGhhdmUgb25lIGdldE1pc3NpbmdTZXNzaW9ucyBwcm9jZXNzIGluIGZsaWdodCBhdCBvbmNlLiBUaGlzIGxpdHRsZSBkYW5jZVxuICAgIC8vIGVuc3VyZXMgdGhhdCwgYnkgb25seSBoYXZpbmcgb25lIGNhbGwgdG8gZW5zdXJlU2Vzc2lvbnNGb3JVc2Vyc0lubmVyIGFjdGl2ZSBhdCBvbmNlIChhbmQgbWFraW5nIHRoZW1cbiAgICAvLyBxdWV1ZSB1cCBpbiBvcmRlcikuXG4gICAgdmFyIHByb20gPSB0aGlzLmN1cnJlbnRDbGFpbVByb21pc2UuY2F0Y2goKCkgPT4ge1xuICAgICAgLy8gYW55IGVycm9ycyBpbiB0aGUgcHJldmlvdXMgY2xhaW0gd2lsbCBoYXZlIGJlZW4gcmVwb3J0ZWQgYWxyZWFkeSwgc28gdGhlcmUgaXMgbm90aGluZyB0byBkbyBoZXJlLlxuICAgICAgLy8gd2UganVzdCB0aHJvdyBhd2F5IHRoZSBlcnJvciBhbmQgc3RhcnQgYW5ldy5cbiAgICB9KS50aGVuKCgpID0+IHRoaXMuZW5zdXJlU2Vzc2lvbnNGb3JVc2Vyc0lubmVyKGxvZ2dlciwgdXNlckxpc3QpKTtcbiAgICB0aGlzLmN1cnJlbnRDbGFpbVByb21pc2UgPSBwcm9tO1xuICAgIHJldHVybiBwcm9tO1xuICB9XG4gIGVuc3VyZVNlc3Npb25zRm9yVXNlcnNJbm5lcihsb2dnZXIsIHVzZXJMaXN0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIGJhaWwgb3V0IHF1aWNrbHkgaWYgd2UndmUgYmVlbiBzdG9wcGVkLlxuICAgICAgaWYgKF90aGlzLnN0b3BwZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGVuc3VyZSBPbG0gc2Vzc2lvbnM6IHNodXR0aW5nIGRvd25cIik7XG4gICAgICB9XG4gICAgICBsb2dnZXIuaW5mbyhcIkNoZWNraW5nIGZvciBtaXNzaW5nIE9sbSBzZXNzaW9uc1wiKTtcbiAgICAgIC8vIEJ5IHBhc3NpbmcgdGhlIHVzZXJJZCBhcnJheSB0byBydXN0IHdlIHRyYW5zZmVyIG93bmVyc2hpcCBvZiB0aGUgaXRlbXMgdG8gcnVzdCwgY2F1c2luZ1xuICAgICAgLy8gdGhlbSB0byBiZSBpbnZhbGlkYXRlZCBvbiB0aGUgSlMgc2lkZSBhcyBzb29uIGFzIHRoZSBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAgLy8gQXMgd2UgaGF2ZW4ndCBjcmVhdGVkIHRoZSBgdXNlckxpc3RgIGxldCdzIGNsb25lIHRoZSB1c2VycywgdG8gbm90IGJyZWFrIHRoZSBjYWxsZXIgZnJvbSByZS11c2luZyBpdC5cbiAgICAgIHZhciBjbGFpbVJlcXVlc3QgPSB5aWVsZCBfdGhpcy5vbG1NYWNoaW5lLmdldE1pc3NpbmdTZXNzaW9ucyh1c2VyTGlzdC5tYXAodSA9PiB1LmNsb25lKCkpKTtcbiAgICAgIGlmIChjbGFpbVJlcXVlc3QpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCJNYWtpbmcgL2tleXMvY2xhaW0gcmVxdWVzdFwiKTtcbiAgICAgICAgeWllbGQgX3RoaXMub3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yLm1ha2VPdXRnb2luZ1JlcXVlc3QoY2xhaW1SZXF1ZXN0KTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5pbmZvKFwiT2xtIHNlc3Npb25zIHByZXBhcmVkXCIpO1xuICAgIH0pKCk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUtleUNsYWltTWFuYWdlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/KeyClaimManager.js\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/OutgoingRequestProcessor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/OutgoingRequestProcessor.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OutgoingRequestProcessor: () => (/* binding */ OutgoingRequestProcessor)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @matrix-org/matrix-sdk-crypto-wasm */ \"./node_modules/@matrix-org/matrix-sdk-crypto-wasm/index.mjs\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger.js */ \"./node_modules/matrix-js-sdk/lib/logger.js\");\n/* harmony import */ var _http_api_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../http-api/index.js */ \"./node_modules/matrix-js-sdk/lib/http-api/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/matrix-js-sdk/lib/utils.js\");\n/* harmony import */ var _types_event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../@types/event.js */ \"./node_modules/matrix-js-sdk/lib/@types/event.js\");\n/* harmony import */ var _DehydratedDeviceManager_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DehydratedDeviceManager.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/DehydratedDeviceManager.js\");\n\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n\n\n\n\n\n\n/**\n * Common interface for all the request types returned by `OlmMachine.outgoingRequests`.\n *\n * @internal\n */\n\n/**\n * OutgoingRequestManager: turns `OutgoingRequest`s from the rust sdk into HTTP requests\n *\n * We have one of these per `RustCrypto` (and hence per `MatrixClient`), not that it does anything terribly complicated.\n * It's responsible for:\n *\n *   * holding the reference to the `MatrixHttpApi`\n *   * turning `OutgoingRequest`s from the rust backend into HTTP requests, and sending them\n *   * sending the results of such requests back to the rust backend.\n *\n * @internal\n */\nclass OutgoingRequestProcessor {\n  constructor(olmMachine, http) {\n    this.olmMachine = olmMachine;\n    this.http = http;\n  }\n  makeOutgoingRequest(msg, uiaCallback) {\n    var _this = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(function* () {\n      var resp;\n\n      /* refer https://docs.rs/matrix-sdk-crypto/0.6.0/matrix_sdk_crypto/requests/enum.OutgoingRequests.html\n       * for the complete list of request types\n       */\n      if (msg instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.KeysUploadRequest) {\n        resp = yield _this.requestWithRetry(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Post, \"/_matrix/client/v3/keys/upload\", {}, msg.body);\n      } else if (msg instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.KeysQueryRequest) {\n        resp = yield _this.requestWithRetry(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Post, \"/_matrix/client/v3/keys/query\", {}, msg.body);\n      } else if (msg instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.KeysClaimRequest) {\n        resp = yield _this.requestWithRetry(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Post, \"/_matrix/client/v3/keys/claim\", {}, msg.body);\n      } else if (msg instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.SignatureUploadRequest) {\n        resp = yield _this.requestWithRetry(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Post, \"/_matrix/client/v3/keys/signatures/upload\", {}, msg.body);\n      } else if (msg instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.KeysBackupRequest) {\n        resp = yield _this.requestWithRetry(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Put, \"/_matrix/client/v3/room_keys/keys\", {\n          version: msg.version\n        }, msg.body);\n      } else if (msg instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.ToDeviceRequest) {\n        resp = yield _this.sendToDeviceRequest(msg);\n      } else if (msg instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.RoomMessageRequest) {\n        var path = \"/_matrix/client/v3/rooms/\".concat(encodeURIComponent(msg.room_id), \"/send/\") + \"\".concat(encodeURIComponent(msg.event_type), \"/\").concat(encodeURIComponent(msg.txn_id));\n        resp = yield _this.requestWithRetry(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Put, path, {}, msg.body);\n      } else if (msg instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.UploadSigningKeysRequest) {\n        yield _this.makeRequestWithUIA(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Post, \"/_matrix/client/v3/keys/device_signing/upload\", {}, msg.body, uiaCallback);\n        // SigningKeysUploadRequest does not implement OutgoingRequest and does not need to be marked as sent.\n        return;\n      } else if (msg instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.PutDehydratedDeviceRequest) {\n        var _path = _DehydratedDeviceManager_js__WEBPACK_IMPORTED_MODULE_7__.UnstablePrefix + \"/dehydrated_device\";\n        yield _this.rawJsonRequest(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Put, _path, {}, msg.body);\n        // PutDehydratedDeviceRequest does not implement OutgoingRequest and does not need to be marked as sent.\n        return;\n      } else {\n        _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"Unsupported outgoing message\", Object.getPrototypeOf(msg));\n        resp = \"\";\n      }\n      if (msg.id) {\n        try {\n          yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logDuration)(_logger_js__WEBPACK_IMPORTED_MODULE_3__.logger, \"Mark Request as sent \".concat(msg.type), /*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(function* () {\n            yield _this.olmMachine.markRequestAsSent(msg.id, msg.type, resp);\n          }));\n        } catch (e) {\n          // Ignore errors which are caused by the olmMachine having been freed. The exact error message depends\n          // on whether we are using a release or develop build of rust-sdk-crypto-wasm.\n          if (e instanceof Error && (e.message === \"Attempt to use a moved value\" || e.message === \"null pointer passed to rust\")) {\n            _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"Ignoring error '\".concat(e.message, \"': client is likely shutting down\"));\n          } else {\n            throw e;\n          }\n        }\n      } else {\n        _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.trace(\"Outgoing request type:\".concat(msg.type, \" does not have an ID\"));\n      }\n    })();\n  }\n\n  /**\n   * Send the HTTP request for a `ToDeviceRequest`\n   *\n   * @param request - request to send\n   * @returns JSON-serialized body of the response, if successful\n   */\n  sendToDeviceRequest(request) {\n    var _this2 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(function* () {\n      // a bit of extra logging, to help trace to-device messages through the system\n      var parsedBody = JSON.parse(request.body);\n      var messageList = [];\n      for (var [userId, perUserMessages] of Object.entries(parsedBody.messages)) {\n        for (var [deviceId, message] of Object.entries(perUserMessages)) {\n          messageList.push(\"\".concat(userId, \"/\").concat(deviceId, \" (msgid \").concat(message[_types_event_js__WEBPACK_IMPORTED_MODULE_6__.ToDeviceMessageId], \")\"));\n        }\n      }\n      _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.info(\"Sending batch of to-device messages. type=\".concat(request.event_type, \" txnid=\").concat(request.txn_id), messageList);\n      var path = \"/_matrix/client/v3/sendToDevice/\".concat(encodeURIComponent(request.event_type), \"/\") + encodeURIComponent(request.txn_id);\n      return yield _this2.requestWithRetry(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Put, path, {}, request.body);\n    })();\n  }\n  makeRequestWithUIA(method, path, queryParams, body, uiaCallback) {\n    var _this3 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(function* () {\n      if (!uiaCallback) {\n        return yield _this3.requestWithRetry(method, path, queryParams, body);\n      }\n      var parsedBody = JSON.parse(body);\n      var makeRequest = /*#__PURE__*/function () {\n        var _ref2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(function* (auth) {\n          var newBody = _objectSpread({}, parsedBody);\n          if (auth !== null) {\n            newBody.auth = auth;\n          }\n          var resp = yield _this3.requestWithRetry(method, path, queryParams, JSON.stringify(newBody));\n          return JSON.parse(resp);\n        });\n        return function makeRequest(_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      var resp = yield uiaCallback(makeRequest);\n      return JSON.stringify(resp);\n    })();\n  }\n  requestWithRetry(method, path, queryParams, body) {\n    var _this4 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(function* () {\n      var currentRetryCount = 0;\n\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        try {\n          return yield _this4.rawJsonRequest(method, path, queryParams, body);\n        } catch (e) {\n          currentRetryCount++;\n          var backoff = (0,_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.calculateRetryBackoff)(e, currentRetryCount, true);\n          if (backoff < 0) {\n            // Max number of retries reached, or error is not retryable. rethrow the error\n            throw e;\n          }\n          // wait for the specified time and then retry the request\n          yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.sleep)(backoff);\n        }\n      }\n    })();\n  }\n  rawJsonRequest(method, path, queryParams, body) {\n    var _this5 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(function* () {\n      var opts = {\n        // inhibit the JSON stringification and parsing within HttpApi.\n        json: false,\n        // nevertheless, we are sending, and accept, JSON.\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"Accept\": \"application/json\"\n        },\n        // we use the full prefix\n        prefix: \"\"\n      };\n      return yield _this5.http.authedRequest(method, path, queryParams, body, opts);\n    })();\n  }\n}\n//# sourceMappingURL=OutgoingRequestProcessor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vT3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFvRTtBQUNJO0FBQ3hFLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsaUZBQWUsZUFBZSxtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpUDtBQUMzTTtBQUMrQjtBQUNwQjtBQUNNO0FBQ29DOztBQUUzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlGQUFpQjtBQUMxQyw0Q0FBNEMsc0RBQU0sMkNBQTJDO0FBQzdGLFFBQVEsd0JBQXdCLGdGQUFnQjtBQUNoRCw0Q0FBNEMsc0RBQU0sMENBQTBDO0FBQzVGLFFBQVEsd0JBQXdCLGdGQUFnQjtBQUNoRCw0Q0FBNEMsc0RBQU0sMENBQTBDO0FBQzVGLFFBQVEsd0JBQXdCLHNGQUFzQjtBQUN0RCw0Q0FBNEMsc0RBQU0sc0RBQXNEO0FBQ3hHLFFBQVEsd0JBQXdCLGlGQUFpQjtBQUNqRCw0Q0FBNEMsc0RBQU07QUFDbEQ7QUFDQSxTQUFTO0FBQ1QsUUFBUSx3QkFBd0IsK0VBQWU7QUFDL0M7QUFDQSxRQUFRLHdCQUF3QixrRkFBa0I7QUFDbEQ7QUFDQSw0Q0FBNEMsc0RBQU0sY0FBYztBQUNoRSxRQUFRLHdCQUF3Qix3RkFBd0I7QUFDeEQsdUNBQXVDLHNEQUFNLDBEQUEwRDtBQUN2RztBQUNBO0FBQ0EsUUFBUSx3QkFBd0IsMEZBQTBCO0FBQzFELG9CQUFvQix1RUFBeUI7QUFDN0MsbUNBQW1DLHNEQUFNLGVBQWU7QUFDeEQ7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRLDhDQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVcsQ0FBQyw4Q0FBTSx5REFBeUQsbUZBQWlCO0FBQzVHO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUFNO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsUUFBUSw4Q0FBTTtBQUNkO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLDhEQUFpQjtBQUMvRztBQUNBO0FBQ0EsTUFBTSw4Q0FBTTtBQUNaO0FBQ0EsMkNBQTJDLHNEQUFNLGNBQWM7QUFDL0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUZBQWlCO0FBQ3JDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esd0JBQXdCLHlFQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFLO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXN0ZXJpY3MtZ3JpZC8uL25vZGVfbW9kdWxlcy9tYXRyaXgtanMtc2RrL2xpYi9ydXN0LWNyeXB0by9PdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IuanM/NGU1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX2FzeW5jVG9HZW5lcmF0b3IgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiO1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vKlxuQ29weXJpZ2h0IDIwMjMgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgeyBLZXlzQmFja3VwUmVxdWVzdCwgS2V5c0NsYWltUmVxdWVzdCwgS2V5c1F1ZXJ5UmVxdWVzdCwgS2V5c1VwbG9hZFJlcXVlc3QsIFB1dERlaHlkcmF0ZWREZXZpY2VSZXF1ZXN0LCBSb29tTWVzc2FnZVJlcXVlc3QsIFNpZ25hdHVyZVVwbG9hZFJlcXVlc3QsIFRvRGV2aWNlUmVxdWVzdCwgVXBsb2FkU2lnbmluZ0tleXNSZXF1ZXN0IH0gZnJvbSBcIkBtYXRyaXgtb3JnL21hdHJpeC1zZGstY3J5cHRvLXdhc21cIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIuanNcIjtcbmltcG9ydCB7IGNhbGN1bGF0ZVJldHJ5QmFja29mZiwgTWV0aG9kIH0gZnJvbSBcIi4uL2h0dHAtYXBpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBsb2dEdXJhdGlvbiwgc2xlZXAgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IFRvRGV2aWNlTWVzc2FnZUlkIH0gZnJvbSBcIi4uL0B0eXBlcy9ldmVudC5qc1wiO1xuaW1wb3J0IHsgVW5zdGFibGVQcmVmaXggYXMgRGVoeWRyYXRpb25VbnN0YWJsZVByZWZpeCB9IGZyb20gXCIuL0RlaHlkcmF0ZWREZXZpY2VNYW5hZ2VyLmpzXCI7XG5cbi8qKlxuICogQ29tbW9uIGludGVyZmFjZSBmb3IgYWxsIHRoZSByZXF1ZXN0IHR5cGVzIHJldHVybmVkIGJ5IGBPbG1NYWNoaW5lLm91dGdvaW5nUmVxdWVzdHNgLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogT3V0Z29pbmdSZXF1ZXN0TWFuYWdlcjogdHVybnMgYE91dGdvaW5nUmVxdWVzdGBzIGZyb20gdGhlIHJ1c3Qgc2RrIGludG8gSFRUUCByZXF1ZXN0c1xuICpcbiAqIFdlIGhhdmUgb25lIG9mIHRoZXNlIHBlciBgUnVzdENyeXB0b2AgKGFuZCBoZW5jZSBwZXIgYE1hdHJpeENsaWVudGApLCBub3QgdGhhdCBpdCBkb2VzIGFueXRoaW5nIHRlcnJpYmx5IGNvbXBsaWNhdGVkLlxuICogSXQncyByZXNwb25zaWJsZSBmb3I6XG4gKlxuICogICAqIGhvbGRpbmcgdGhlIHJlZmVyZW5jZSB0byB0aGUgYE1hdHJpeEh0dHBBcGlgXG4gKiAgICogdHVybmluZyBgT3V0Z29pbmdSZXF1ZXN0YHMgZnJvbSB0aGUgcnVzdCBiYWNrZW5kIGludG8gSFRUUCByZXF1ZXN0cywgYW5kIHNlbmRpbmcgdGhlbVxuICogICAqIHNlbmRpbmcgdGhlIHJlc3VsdHMgb2Ygc3VjaCByZXF1ZXN0cyBiYWNrIHRvIHRoZSBydXN0IGJhY2tlbmQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBPdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3Ige1xuICBjb25zdHJ1Y3RvcihvbG1NYWNoaW5lLCBodHRwKSB7XG4gICAgdGhpcy5vbG1NYWNoaW5lID0gb2xtTWFjaGluZTtcbiAgICB0aGlzLmh0dHAgPSBodHRwO1xuICB9XG4gIG1ha2VPdXRnb2luZ1JlcXVlc3QobXNnLCB1aWFDYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgcmVzcDtcblxuICAgICAgLyogcmVmZXIgaHR0cHM6Ly9kb2NzLnJzL21hdHJpeC1zZGstY3J5cHRvLzAuNi4wL21hdHJpeF9zZGtfY3J5cHRvL3JlcXVlc3RzL2VudW0uT3V0Z29pbmdSZXF1ZXN0cy5odG1sXG4gICAgICAgKiBmb3IgdGhlIGNvbXBsZXRlIGxpc3Qgb2YgcmVxdWVzdCB0eXBlc1xuICAgICAgICovXG4gICAgICBpZiAobXNnIGluc3RhbmNlb2YgS2V5c1VwbG9hZFJlcXVlc3QpIHtcbiAgICAgICAgcmVzcCA9IHlpZWxkIF90aGlzLnJlcXVlc3RXaXRoUmV0cnkoTWV0aG9kLlBvc3QsIFwiL19tYXRyaXgvY2xpZW50L3YzL2tleXMvdXBsb2FkXCIsIHt9LCBtc2cuYm9keSk7XG4gICAgICB9IGVsc2UgaWYgKG1zZyBpbnN0YW5jZW9mIEtleXNRdWVyeVJlcXVlc3QpIHtcbiAgICAgICAgcmVzcCA9IHlpZWxkIF90aGlzLnJlcXVlc3RXaXRoUmV0cnkoTWV0aG9kLlBvc3QsIFwiL19tYXRyaXgvY2xpZW50L3YzL2tleXMvcXVlcnlcIiwge30sIG1zZy5ib2R5KTtcbiAgICAgIH0gZWxzZSBpZiAobXNnIGluc3RhbmNlb2YgS2V5c0NsYWltUmVxdWVzdCkge1xuICAgICAgICByZXNwID0geWllbGQgX3RoaXMucmVxdWVzdFdpdGhSZXRyeShNZXRob2QuUG9zdCwgXCIvX21hdHJpeC9jbGllbnQvdjMva2V5cy9jbGFpbVwiLCB7fSwgbXNnLmJvZHkpO1xuICAgICAgfSBlbHNlIGlmIChtc2cgaW5zdGFuY2VvZiBTaWduYXR1cmVVcGxvYWRSZXF1ZXN0KSB7XG4gICAgICAgIHJlc3AgPSB5aWVsZCBfdGhpcy5yZXF1ZXN0V2l0aFJldHJ5KE1ldGhvZC5Qb3N0LCBcIi9fbWF0cml4L2NsaWVudC92My9rZXlzL3NpZ25hdHVyZXMvdXBsb2FkXCIsIHt9LCBtc2cuYm9keSk7XG4gICAgICB9IGVsc2UgaWYgKG1zZyBpbnN0YW5jZW9mIEtleXNCYWNrdXBSZXF1ZXN0KSB7XG4gICAgICAgIHJlc3AgPSB5aWVsZCBfdGhpcy5yZXF1ZXN0V2l0aFJldHJ5KE1ldGhvZC5QdXQsIFwiL19tYXRyaXgvY2xpZW50L3YzL3Jvb21fa2V5cy9rZXlzXCIsIHtcbiAgICAgICAgICB2ZXJzaW9uOiBtc2cudmVyc2lvblxuICAgICAgICB9LCBtc2cuYm9keSk7XG4gICAgICB9IGVsc2UgaWYgKG1zZyBpbnN0YW5jZW9mIFRvRGV2aWNlUmVxdWVzdCkge1xuICAgICAgICByZXNwID0geWllbGQgX3RoaXMuc2VuZFRvRGV2aWNlUmVxdWVzdChtc2cpO1xuICAgICAgfSBlbHNlIGlmIChtc2cgaW5zdGFuY2VvZiBSb29tTWVzc2FnZVJlcXVlc3QpIHtcbiAgICAgICAgdmFyIHBhdGggPSBcIi9fbWF0cml4L2NsaWVudC92My9yb29tcy9cIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KG1zZy5yb29tX2lkKSwgXCIvc2VuZC9cIikgKyBcIlwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQobXNnLmV2ZW50X3R5cGUpLCBcIi9cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChtc2cudHhuX2lkKSk7XG4gICAgICAgIHJlc3AgPSB5aWVsZCBfdGhpcy5yZXF1ZXN0V2l0aFJldHJ5KE1ldGhvZC5QdXQsIHBhdGgsIHt9LCBtc2cuYm9keSk7XG4gICAgICB9IGVsc2UgaWYgKG1zZyBpbnN0YW5jZW9mIFVwbG9hZFNpZ25pbmdLZXlzUmVxdWVzdCkge1xuICAgICAgICB5aWVsZCBfdGhpcy5tYWtlUmVxdWVzdFdpdGhVSUEoTWV0aG9kLlBvc3QsIFwiL19tYXRyaXgvY2xpZW50L3YzL2tleXMvZGV2aWNlX3NpZ25pbmcvdXBsb2FkXCIsIHt9LCBtc2cuYm9keSwgdWlhQ2FsbGJhY2spO1xuICAgICAgICAvLyBTaWduaW5nS2V5c1VwbG9hZFJlcXVlc3QgZG9lcyBub3QgaW1wbGVtZW50IE91dGdvaW5nUmVxdWVzdCBhbmQgZG9lcyBub3QgbmVlZCB0byBiZSBtYXJrZWQgYXMgc2VudC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChtc2cgaW5zdGFuY2VvZiBQdXREZWh5ZHJhdGVkRGV2aWNlUmVxdWVzdCkge1xuICAgICAgICB2YXIgX3BhdGggPSBEZWh5ZHJhdGlvblVuc3RhYmxlUHJlZml4ICsgXCIvZGVoeWRyYXRlZF9kZXZpY2VcIjtcbiAgICAgICAgeWllbGQgX3RoaXMucmF3SnNvblJlcXVlc3QoTWV0aG9kLlB1dCwgX3BhdGgsIHt9LCBtc2cuYm9keSk7XG4gICAgICAgIC8vIFB1dERlaHlkcmF0ZWREZXZpY2VSZXF1ZXN0IGRvZXMgbm90IGltcGxlbWVudCBPdXRnb2luZ1JlcXVlc3QgYW5kIGRvZXMgbm90IG5lZWQgdG8gYmUgbWFya2VkIGFzIHNlbnQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiVW5zdXBwb3J0ZWQgb3V0Z29pbmcgbWVzc2FnZVwiLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YobXNnKSk7XG4gICAgICAgIHJlc3AgPSBcIlwiO1xuICAgICAgfVxuICAgICAgaWYgKG1zZy5pZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIGxvZ0R1cmF0aW9uKGxvZ2dlciwgXCJNYXJrIFJlcXVlc3QgYXMgc2VudCBcIi5jb25jYXQobXNnLnR5cGUpLCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIF90aGlzLm9sbU1hY2hpbmUubWFya1JlcXVlc3RBc1NlbnQobXNnLmlkLCBtc2cudHlwZSwgcmVzcCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVycm9ycyB3aGljaCBhcmUgY2F1c2VkIGJ5IHRoZSBvbG1NYWNoaW5lIGhhdmluZyBiZWVuIGZyZWVkLiBUaGUgZXhhY3QgZXJyb3IgbWVzc2FnZSBkZXBlbmRzXG4gICAgICAgICAgLy8gb24gd2hldGhlciB3ZSBhcmUgdXNpbmcgYSByZWxlYXNlIG9yIGRldmVsb3AgYnVpbGQgb2YgcnVzdC1zZGstY3J5cHRvLXdhc20uXG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiAoZS5tZXNzYWdlID09PSBcIkF0dGVtcHQgdG8gdXNlIGEgbW92ZWQgdmFsdWVcIiB8fCBlLm1lc3NhZ2UgPT09IFwibnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0XCIpKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiSWdub3JpbmcgZXJyb3IgJ1wiLmNvbmNhdChlLm1lc3NhZ2UsIFwiJzogY2xpZW50IGlzIGxpa2VseSBzaHV0dGluZyBkb3duXCIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci50cmFjZShcIk91dGdvaW5nIHJlcXVlc3QgdHlwZTpcIi5jb25jYXQobXNnLnR5cGUsIFwiIGRvZXMgbm90IGhhdmUgYW4gSURcIikpO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCB0aGUgSFRUUCByZXF1ZXN0IGZvciBhIGBUb0RldmljZVJlcXVlc3RgXG4gICAqXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gcmVxdWVzdCB0byBzZW5kXG4gICAqIEByZXR1cm5zIEpTT04tc2VyaWFsaXplZCBib2R5IG9mIHRoZSByZXNwb25zZSwgaWYgc3VjY2Vzc2Z1bFxuICAgKi9cbiAgc2VuZFRvRGV2aWNlUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBhIGJpdCBvZiBleHRyYSBsb2dnaW5nLCB0byBoZWxwIHRyYWNlIHRvLWRldmljZSBtZXNzYWdlcyB0aHJvdWdoIHRoZSBzeXN0ZW1cbiAgICAgIHZhciBwYXJzZWRCb2R5ID0gSlNPTi5wYXJzZShyZXF1ZXN0LmJvZHkpO1xuICAgICAgdmFyIG1lc3NhZ2VMaXN0ID0gW107XG4gICAgICBmb3IgKHZhciBbdXNlcklkLCBwZXJVc2VyTWVzc2FnZXNdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnNlZEJvZHkubWVzc2FnZXMpKSB7XG4gICAgICAgIGZvciAodmFyIFtkZXZpY2VJZCwgbWVzc2FnZV0gb2YgT2JqZWN0LmVudHJpZXMocGVyVXNlck1lc3NhZ2VzKSkge1xuICAgICAgICAgIG1lc3NhZ2VMaXN0LnB1c2goXCJcIi5jb25jYXQodXNlcklkLCBcIi9cIikuY29uY2F0KGRldmljZUlkLCBcIiAobXNnaWQgXCIpLmNvbmNhdChtZXNzYWdlW1RvRGV2aWNlTWVzc2FnZUlkXSwgXCIpXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9nZ2VyLmluZm8oXCJTZW5kaW5nIGJhdGNoIG9mIHRvLWRldmljZSBtZXNzYWdlcy4gdHlwZT1cIi5jb25jYXQocmVxdWVzdC5ldmVudF90eXBlLCBcIiB0eG5pZD1cIikuY29uY2F0KHJlcXVlc3QudHhuX2lkKSwgbWVzc2FnZUxpc3QpO1xuICAgICAgdmFyIHBhdGggPSBcIi9fbWF0cml4L2NsaWVudC92My9zZW5kVG9EZXZpY2UvXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChyZXF1ZXN0LmV2ZW50X3R5cGUpLCBcIi9cIikgKyBlbmNvZGVVUklDb21wb25lbnQocmVxdWVzdC50eG5faWQpO1xuICAgICAgcmV0dXJuIHlpZWxkIF90aGlzMi5yZXF1ZXN0V2l0aFJldHJ5KE1ldGhvZC5QdXQsIHBhdGgsIHt9LCByZXF1ZXN0LmJvZHkpO1xuICAgIH0pKCk7XG4gIH1cbiAgbWFrZVJlcXVlc3RXaXRoVUlBKG1ldGhvZCwgcGF0aCwgcXVlcnlQYXJhbXMsIGJvZHksIHVpYUNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXVpYUNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCBfdGhpczMucmVxdWVzdFdpdGhSZXRyeShtZXRob2QsIHBhdGgsIHF1ZXJ5UGFyYW1zLCBib2R5KTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJzZWRCb2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgIHZhciBtYWtlUmVxdWVzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoYXV0aCkge1xuICAgICAgICAgIHZhciBuZXdCb2R5ID0gX29iamVjdFNwcmVhZCh7fSwgcGFyc2VkQm9keSk7XG4gICAgICAgICAgaWYgKGF1dGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0JvZHkuYXV0aCA9IGF1dGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXNwID0geWllbGQgX3RoaXMzLnJlcXVlc3RXaXRoUmV0cnkobWV0aG9kLCBwYXRoLCBxdWVyeVBhcmFtcywgSlNPTi5zdHJpbmdpZnkobmV3Qm9keSkpO1xuICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3ApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0KF94KSB7XG4gICAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KCk7XG4gICAgICB2YXIgcmVzcCA9IHlpZWxkIHVpYUNhbGxiYWNrKG1ha2VSZXF1ZXN0KTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXNwKTtcbiAgICB9KSgpO1xuICB9XG4gIHJlcXVlc3RXaXRoUmV0cnkobWV0aG9kLCBwYXRoLCBxdWVyeVBhcmFtcywgYm9keSkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIGN1cnJlbnRSZXRyeUNvdW50ID0gMDtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4geWllbGQgX3RoaXM0LnJhd0pzb25SZXF1ZXN0KG1ldGhvZCwgcGF0aCwgcXVlcnlQYXJhbXMsIGJvZHkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY3VycmVudFJldHJ5Q291bnQrKztcbiAgICAgICAgICB2YXIgYmFja29mZiA9IGNhbGN1bGF0ZVJldHJ5QmFja29mZihlLCBjdXJyZW50UmV0cnlDb3VudCwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKGJhY2tvZmYgPCAwKSB7XG4gICAgICAgICAgICAvLyBNYXggbnVtYmVyIG9mIHJldHJpZXMgcmVhY2hlZCwgb3IgZXJyb3IgaXMgbm90IHJldHJ5YWJsZS4gcmV0aHJvdyB0aGUgZXJyb3JcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdhaXQgZm9yIHRoZSBzcGVjaWZpZWQgdGltZSBhbmQgdGhlbiByZXRyeSB0aGUgcmVxdWVzdFxuICAgICAgICAgIHlpZWxkIHNsZWVwKGJhY2tvZmYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuICByYXdKc29uUmVxdWVzdChtZXRob2QsIHBhdGgsIHF1ZXJ5UGFyYW1zLCBib2R5KSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgLy8gaW5oaWJpdCB0aGUgSlNPTiBzdHJpbmdpZmljYXRpb24gYW5kIHBhcnNpbmcgd2l0aGluIEh0dHBBcGkuXG4gICAgICAgIGpzb246IGZhbHNlLFxuICAgICAgICAvLyBuZXZlcnRoZWxlc3MsIHdlIGFyZSBzZW5kaW5nLCBhbmQgYWNjZXB0LCBKU09OLlxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgXCJBY2NlcHRcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgLy8gd2UgdXNlIHRoZSBmdWxsIHByZWZpeFxuICAgICAgICBwcmVmaXg6IFwiXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4geWllbGQgX3RoaXM1Lmh0dHAuYXV0aGVkUmVxdWVzdChtZXRob2QsIHBhdGgsIHF1ZXJ5UGFyYW1zLCBib2R5LCBvcHRzKTtcbiAgICB9KSgpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/OutgoingRequestProcessor.js\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/OutgoingRequestsManager.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/OutgoingRequestsManager.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OutgoingRequestsManager: () => (/* binding */ OutgoingRequestsManager)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/matrix-js-sdk/lib/utils.js\");\n\n\n/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n\n/**\n * OutgoingRequestsManager: responsible for processing outgoing requests from the OlmMachine.\n * Ensure that only one loop is going on at once, and that the requests are processed in order.\n */\nclass OutgoingRequestsManager {\n  constructor(logger, olmMachine, outgoingRequestProcessor) {\n    this.logger = logger;\n    this.olmMachine = olmMachine;\n    this.outgoingRequestProcessor = outgoingRequestProcessor;\n    /** whether {@link stop} has been called */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"stopped\", false);\n    /** whether {@link outgoingRequestLoop} is currently running */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"outgoingRequestLoopRunning\", false);\n    /**\n     * If there are additional calls to doProcessOutgoingRequests() while there is a current call running\n     * we need to remember in order to call `doProcessOutgoingRequests` again (as there could be new requests).\n     *\n     * If this is defined, it is an indication that we need to do another iteration; in this case the deferred\n     * will resolve once that next iteration completes. If it is undefined, there have been no new calls\n     * to `doProcessOutgoingRequests` since the current iteration started.\n     */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"nextLoopDeferred\", void 0);\n  }\n\n  /**\n   * Shut down as soon as possible the current loop of outgoing requests processing.\n   */\n  stop() {\n    this.stopped = true;\n  }\n\n  /**\n   * Process the OutgoingRequests from the OlmMachine.\n   *\n   * This should be called at the end of each sync, to process any OlmMachine OutgoingRequests created by the rust sdk.\n   * In some cases if OutgoingRequests need to be sent immediately, this can be called directly.\n   *\n   * Calls to doProcessOutgoingRequests() are processed synchronously, one after the other, in order.\n   * If doProcessOutgoingRequests() is called while another call is still being processed, it will be queued.\n   * Multiple calls to doProcessOutgoingRequests() when a call is already processing will be batched together.\n   */\n  doProcessOutgoingRequests() {\n    // Flag that we need at least one more iteration of the loop.\n    //\n    // It is important that we do this even if the loop is currently running. There is potential for a race whereby\n    // a request is added to the queue *after* `OlmMachine.outgoingRequests` checks the queue, but *before* it\n    // returns. In such a case, the item could sit there unnoticed for some time.\n    //\n    // In order to circumvent the race, we set a flag which tells the loop to go round once again even if the\n    // queue appears to be empty.\n    if (!this.nextLoopDeferred) {\n      this.nextLoopDeferred = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.defer)();\n    }\n\n    // ... and wait for it to complete.\n    var result = this.nextLoopDeferred.promise;\n\n    // set the loop going if it is not already.\n    if (!this.outgoingRequestLoopRunning) {\n      this.outgoingRequestLoop().catch(e => {\n        // this should not happen; outgoingRequestLoop should return any errors via `nextLoopDeferred`.\n        /* istanbul ignore next */\n        this.logger.error(\"Uncaught error in outgoing request loop\", e);\n      });\n    }\n    return result;\n  }\n  outgoingRequestLoop() {\n    var _this = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      /* istanbul ignore if */\n      if (_this.outgoingRequestLoopRunning) {\n        throw new Error(\"Cannot run two outgoing request loops\");\n      }\n      _this.outgoingRequestLoopRunning = true;\n      try {\n        while (!_this.stopped && _this.nextLoopDeferred) {\n          var deferred = _this.nextLoopDeferred;\n\n          // reset `nextLoopDeferred` so that any future calls to `doProcessOutgoingRequests` are queued\n          // for another additional iteration.\n          _this.nextLoopDeferred = undefined;\n\n          // make the requests and feed the results back to the `nextLoopDeferred`\n          yield _this.processOutgoingRequests().then(deferred.resolve, deferred.reject);\n        }\n      } finally {\n        _this.outgoingRequestLoopRunning = false;\n      }\n      if (_this.nextLoopDeferred) {\n        // the loop was stopped, but there was a call to `doProcessOutgoingRequests`. Make sure that\n        // we reject the promise in case anything is waiting for it.\n        _this.nextLoopDeferred.reject(new Error(\"OutgoingRequestsManager was stopped\"));\n      }\n    })();\n  }\n\n  /**\n   * Make a single request to `olmMachine.outgoingRequests` and do the corresponding requests.\n   */\n  processOutgoingRequests() {\n    var _this2 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      if (_this2.stopped) return;\n      var outgoingRequests = yield _this2.olmMachine.outgoingRequests();\n      var _loop = function* _loop(request) {\n          if (_this2.stopped) return {\n            v: void 0\n          };\n          try {\n            yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.logDuration)(_this2.logger, \"Make outgoing request \".concat(request.type), /*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n              yield _this2.outgoingRequestProcessor.makeOutgoingRequest(request);\n            }));\n          } catch (e) {\n            // as part of the loop we silently ignore errors, but log them.\n            // The rust sdk will retry the request later as it won't have been marked as sent.\n            _this2.logger.error(\"Failed to process outgoing request \".concat(request.type, \": \").concat(e));\n          }\n        },\n        _ret;\n      for (var request of outgoingRequests) {\n        _ret = yield* _loop(request);\n        if (_ret) return _ret.v;\n      }\n    })();\n  }\n}\n//# sourceMappingURL=OutgoingRequestsManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vT3V0Z29pbmdSZXF1ZXN0c01hbmFnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3RTtBQUNKO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCLElBQUksaUZBQWU7QUFDbkIsaUJBQWlCLDJCQUEyQjtBQUM1QyxJQUFJLGlGQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLElBQUksaUZBQWU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0RBQUs7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBVyw0RUFBNEUsbUZBQWlCO0FBQzFIO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FzdGVyaWNzLWdyaWQvLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vT3V0Z29pbmdSZXF1ZXN0c01hbmFnZXIuanM/ZmZmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2FzeW5jVG9HZW5lcmF0b3IgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiO1xuLypcbkNvcHlyaWdodCAyMDIzIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHsgZGVmZXIsIGxvZ0R1cmF0aW9uIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5cbi8qKlxuICogT3V0Z29pbmdSZXF1ZXN0c01hbmFnZXI6IHJlc3BvbnNpYmxlIGZvciBwcm9jZXNzaW5nIG91dGdvaW5nIHJlcXVlc3RzIGZyb20gdGhlIE9sbU1hY2hpbmUuXG4gKiBFbnN1cmUgdGhhdCBvbmx5IG9uZSBsb29wIGlzIGdvaW5nIG9uIGF0IG9uY2UsIGFuZCB0aGF0IHRoZSByZXF1ZXN0cyBhcmUgcHJvY2Vzc2VkIGluIG9yZGVyLlxuICovXG5leHBvcnQgY2xhc3MgT3V0Z29pbmdSZXF1ZXN0c01hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIsIG9sbU1hY2hpbmUsIG91dGdvaW5nUmVxdWVzdFByb2Nlc3Nvcikge1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMub2xtTWFjaGluZSA9IG9sbU1hY2hpbmU7XG4gICAgdGhpcy5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IgPSBvdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3I7XG4gICAgLyoqIHdoZXRoZXIge0BsaW5rIHN0b3B9IGhhcyBiZWVuIGNhbGxlZCAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3BwZWRcIiwgZmFsc2UpO1xuICAgIC8qKiB3aGV0aGVyIHtAbGluayBvdXRnb2luZ1JlcXVlc3RMb29wfSBpcyBjdXJyZW50bHkgcnVubmluZyAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm91dGdvaW5nUmVxdWVzdExvb3BSdW5uaW5nXCIsIGZhbHNlKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSBhcmUgYWRkaXRpb25hbCBjYWxscyB0byBkb1Byb2Nlc3NPdXRnb2luZ1JlcXVlc3RzKCkgd2hpbGUgdGhlcmUgaXMgYSBjdXJyZW50IGNhbGwgcnVubmluZ1xuICAgICAqIHdlIG5lZWQgdG8gcmVtZW1iZXIgaW4gb3JkZXIgdG8gY2FsbCBgZG9Qcm9jZXNzT3V0Z29pbmdSZXF1ZXN0c2AgYWdhaW4gKGFzIHRoZXJlIGNvdWxkIGJlIG5ldyByZXF1ZXN0cykuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGlzIGRlZmluZWQsIGl0IGlzIGFuIGluZGljYXRpb24gdGhhdCB3ZSBuZWVkIHRvIGRvIGFub3RoZXIgaXRlcmF0aW9uOyBpbiB0aGlzIGNhc2UgdGhlIGRlZmVycmVkXG4gICAgICogd2lsbCByZXNvbHZlIG9uY2UgdGhhdCBuZXh0IGl0ZXJhdGlvbiBjb21wbGV0ZXMuIElmIGl0IGlzIHVuZGVmaW5lZCwgdGhlcmUgaGF2ZSBiZWVuIG5vIG5ldyBjYWxsc1xuICAgICAqIHRvIGBkb1Byb2Nlc3NPdXRnb2luZ1JlcXVlc3RzYCBzaW5jZSB0aGUgY3VycmVudCBpdGVyYXRpb24gc3RhcnRlZC5cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJuZXh0TG9vcERlZmVycmVkXCIsIHZvaWQgMCk7XG4gIH1cblxuICAvKipcbiAgICogU2h1dCBkb3duIGFzIHNvb24gYXMgcG9zc2libGUgdGhlIGN1cnJlbnQgbG9vcCBvZiBvdXRnb2luZyByZXF1ZXN0cyBwcm9jZXNzaW5nLlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIE91dGdvaW5nUmVxdWVzdHMgZnJvbSB0aGUgT2xtTWFjaGluZS5cbiAgICpcbiAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgZWFjaCBzeW5jLCB0byBwcm9jZXNzIGFueSBPbG1NYWNoaW5lIE91dGdvaW5nUmVxdWVzdHMgY3JlYXRlZCBieSB0aGUgcnVzdCBzZGsuXG4gICAqIEluIHNvbWUgY2FzZXMgaWYgT3V0Z29pbmdSZXF1ZXN0cyBuZWVkIHRvIGJlIHNlbnQgaW1tZWRpYXRlbHksIHRoaXMgY2FuIGJlIGNhbGxlZCBkaXJlY3RseS5cbiAgICpcbiAgICogQ2FsbHMgdG8gZG9Qcm9jZXNzT3V0Z29pbmdSZXF1ZXN0cygpIGFyZSBwcm9jZXNzZWQgc3luY2hyb25vdXNseSwgb25lIGFmdGVyIHRoZSBvdGhlciwgaW4gb3JkZXIuXG4gICAqIElmIGRvUHJvY2Vzc091dGdvaW5nUmVxdWVzdHMoKSBpcyBjYWxsZWQgd2hpbGUgYW5vdGhlciBjYWxsIGlzIHN0aWxsIGJlaW5nIHByb2Nlc3NlZCwgaXQgd2lsbCBiZSBxdWV1ZWQuXG4gICAqIE11bHRpcGxlIGNhbGxzIHRvIGRvUHJvY2Vzc091dGdvaW5nUmVxdWVzdHMoKSB3aGVuIGEgY2FsbCBpcyBhbHJlYWR5IHByb2Nlc3Npbmcgd2lsbCBiZSBiYXRjaGVkIHRvZ2V0aGVyLlxuICAgKi9cbiAgZG9Qcm9jZXNzT3V0Z29pbmdSZXF1ZXN0cygpIHtcbiAgICAvLyBGbGFnIHRoYXQgd2UgbmVlZCBhdCBsZWFzdCBvbmUgbW9yZSBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgLy9cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdGhhdCB3ZSBkbyB0aGlzIGV2ZW4gaWYgdGhlIGxvb3AgaXMgY3VycmVudGx5IHJ1bm5pbmcuIFRoZXJlIGlzIHBvdGVudGlhbCBmb3IgYSByYWNlIHdoZXJlYnlcbiAgICAvLyBhIHJlcXVlc3QgaXMgYWRkZWQgdG8gdGhlIHF1ZXVlICphZnRlciogYE9sbU1hY2hpbmUub3V0Z29pbmdSZXF1ZXN0c2AgY2hlY2tzIHRoZSBxdWV1ZSwgYnV0ICpiZWZvcmUqIGl0XG4gICAgLy8gcmV0dXJucy4gSW4gc3VjaCBhIGNhc2UsIHRoZSBpdGVtIGNvdWxkIHNpdCB0aGVyZSB1bm5vdGljZWQgZm9yIHNvbWUgdGltZS5cbiAgICAvL1xuICAgIC8vIEluIG9yZGVyIHRvIGNpcmN1bXZlbnQgdGhlIHJhY2UsIHdlIHNldCBhIGZsYWcgd2hpY2ggdGVsbHMgdGhlIGxvb3AgdG8gZ28gcm91bmQgb25jZSBhZ2FpbiBldmVuIGlmIHRoZVxuICAgIC8vIHF1ZXVlIGFwcGVhcnMgdG8gYmUgZW1wdHkuXG4gICAgaWYgKCF0aGlzLm5leHRMb29wRGVmZXJyZWQpIHtcbiAgICAgIHRoaXMubmV4dExvb3BEZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgfVxuXG4gICAgLy8gLi4uIGFuZCB3YWl0IGZvciBpdCB0byBjb21wbGV0ZS5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5uZXh0TG9vcERlZmVycmVkLnByb21pc2U7XG5cbiAgICAvLyBzZXQgdGhlIGxvb3AgZ29pbmcgaWYgaXQgaXMgbm90IGFscmVhZHkuXG4gICAgaWYgKCF0aGlzLm91dGdvaW5nUmVxdWVzdExvb3BSdW5uaW5nKSB7XG4gICAgICB0aGlzLm91dGdvaW5nUmVxdWVzdExvb3AoKS5jYXRjaChlID0+IHtcbiAgICAgICAgLy8gdGhpcyBzaG91bGQgbm90IGhhcHBlbjsgb3V0Z29pbmdSZXF1ZXN0TG9vcCBzaG91bGQgcmV0dXJuIGFueSBlcnJvcnMgdmlhIGBuZXh0TG9vcERlZmVycmVkYC5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJVbmNhdWdodCBlcnJvciBpbiBvdXRnb2luZyByZXF1ZXN0IGxvb3BcIiwgZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBvdXRnb2luZ1JlcXVlc3RMb29wKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChfdGhpcy5vdXRnb2luZ1JlcXVlc3RMb29wUnVubmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcnVuIHR3byBvdXRnb2luZyByZXF1ZXN0IGxvb3BzXCIpO1xuICAgICAgfVxuICAgICAgX3RoaXMub3V0Z29pbmdSZXF1ZXN0TG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKCFfdGhpcy5zdG9wcGVkICYmIF90aGlzLm5leHRMb29wRGVmZXJyZWQpIHtcbiAgICAgICAgICB2YXIgZGVmZXJyZWQgPSBfdGhpcy5uZXh0TG9vcERlZmVycmVkO1xuXG4gICAgICAgICAgLy8gcmVzZXQgYG5leHRMb29wRGVmZXJyZWRgIHNvIHRoYXQgYW55IGZ1dHVyZSBjYWxscyB0byBgZG9Qcm9jZXNzT3V0Z29pbmdSZXF1ZXN0c2AgYXJlIHF1ZXVlZFxuICAgICAgICAgIC8vIGZvciBhbm90aGVyIGFkZGl0aW9uYWwgaXRlcmF0aW9uLlxuICAgICAgICAgIF90aGlzLm5leHRMb29wRGVmZXJyZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAvLyBtYWtlIHRoZSByZXF1ZXN0cyBhbmQgZmVlZCB0aGUgcmVzdWx0cyBiYWNrIHRvIHRoZSBgbmV4dExvb3BEZWZlcnJlZGBcbiAgICAgICAgICB5aWVsZCBfdGhpcy5wcm9jZXNzT3V0Z29pbmdSZXF1ZXN0cygpLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX3RoaXMub3V0Z29pbmdSZXF1ZXN0TG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5uZXh0TG9vcERlZmVycmVkKSB7XG4gICAgICAgIC8vIHRoZSBsb29wIHdhcyBzdG9wcGVkLCBidXQgdGhlcmUgd2FzIGEgY2FsbCB0byBgZG9Qcm9jZXNzT3V0Z29pbmdSZXF1ZXN0c2AuIE1ha2Ugc3VyZSB0aGF0XG4gICAgICAgIC8vIHdlIHJlamVjdCB0aGUgcHJvbWlzZSBpbiBjYXNlIGFueXRoaW5nIGlzIHdhaXRpbmcgZm9yIGl0LlxuICAgICAgICBfdGhpcy5uZXh0TG9vcERlZmVycmVkLnJlamVjdChuZXcgRXJyb3IoXCJPdXRnb2luZ1JlcXVlc3RzTWFuYWdlciB3YXMgc3RvcHBlZFwiKSk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgc2luZ2xlIHJlcXVlc3QgdG8gYG9sbU1hY2hpbmUub3V0Z29pbmdSZXF1ZXN0c2AgYW5kIGRvIHRoZSBjb3JyZXNwb25kaW5nIHJlcXVlc3RzLlxuICAgKi9cbiAgcHJvY2Vzc091dGdvaW5nUmVxdWVzdHMoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoX3RoaXMyLnN0b3BwZWQpIHJldHVybjtcbiAgICAgIHZhciBvdXRnb2luZ1JlcXVlc3RzID0geWllbGQgX3RoaXMyLm9sbU1hY2hpbmUub3V0Z29pbmdSZXF1ZXN0cygpO1xuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24qIF9sb29wKHJlcXVlc3QpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLnN0b3BwZWQpIHJldHVybiB7XG4gICAgICAgICAgICB2OiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB5aWVsZCBsb2dEdXJhdGlvbihfdGhpczIubG9nZ2VyLCBcIk1ha2Ugb3V0Z29pbmcgcmVxdWVzdCBcIi5jb25jYXQocmVxdWVzdC50eXBlKSwgLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgIHlpZWxkIF90aGlzMi5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IubWFrZU91dGdvaW5nUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBhcyBwYXJ0IG9mIHRoZSBsb29wIHdlIHNpbGVudGx5IGlnbm9yZSBlcnJvcnMsIGJ1dCBsb2cgdGhlbS5cbiAgICAgICAgICAgIC8vIFRoZSBydXN0IHNkayB3aWxsIHJldHJ5IHRoZSByZXF1ZXN0IGxhdGVyIGFzIGl0IHdvbid0IGhhdmUgYmVlbiBtYXJrZWQgYXMgc2VudC5cbiAgICAgICAgICAgIF90aGlzMi5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gcHJvY2VzcyBvdXRnb2luZyByZXF1ZXN0IFwiLmNvbmNhdChyZXF1ZXN0LnR5cGUsIFwiOiBcIikuY29uY2F0KGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9yZXQ7XG4gICAgICBmb3IgKHZhciByZXF1ZXN0IG9mIG91dGdvaW5nUmVxdWVzdHMpIHtcbiAgICAgICAgX3JldCA9IHlpZWxkKiBfbG9vcChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKF9yZXQpIHJldHVybiBfcmV0LnY7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3V0Z29pbmdSZXF1ZXN0c01hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/OutgoingRequestsManager.js\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/PerSessionKeyBackupDownloader.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/PerSessionKeyBackupDownloader.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PerSessionKeyBackupDownloader: () => (/* binding */ PerSessionKeyBackupDownloader)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto-api/index.js */ \"./node_modules/matrix-js-sdk/lib/crypto-api/index.js\");\n/* harmony import */ var _http_api_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../http-api/index.js */ \"./node_modules/matrix-js-sdk/lib/http-api/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/matrix-js-sdk/lib/utils.js\");\n\n\n/*\nCopyright 2023 - 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n\n\n// The minimum time to wait between two retries in case of errors. To avoid hammering the server.\nvar KEY_BACKUP_BACKOFF = 5000; // ms\n\n/**\n * Enumerates the different kind of errors that can occurs when downloading and importing a key from backup.\n */\nvar KeyDownloadErrorCode = /*#__PURE__*/function (KeyDownloadErrorCode) {\n  KeyDownloadErrorCode[\"MISSING_DECRYPTION_KEY\"] = \"MISSING_DECRYPTION_KEY\";\n  KeyDownloadErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n  KeyDownloadErrorCode[\"STOPPED\"] = \"STOPPED\";\n  return KeyDownloadErrorCode;\n}(KeyDownloadErrorCode || {});\nclass KeyDownloadError extends Error {\n  constructor(code) {\n    super(\"Failed to get key from backup: \".concat(code));\n    this.code = code;\n    this.name = \"KeyDownloadError\";\n  }\n}\nclass KeyDownloadRateLimitError extends Error {\n  constructor(retryMillis) {\n    super(\"Failed to get key from backup: rate limited\");\n    this.retryMillis = retryMillis;\n    this.name = \"KeyDownloadRateLimitError\";\n  }\n}\n\n/** Details of a megolm session whose key we are trying to fetch. */\n\n/** Holds the current backup decryptor and version that should be used.\n *\n * This is intended to be used as an immutable object (a new instance should be created if the configuration changes),\n * and some of the logic relies on that, so the properties are marked as `readonly`.\n */\n\n/**\n * Used when an 'unable to decrypt' error occurs. It attempts to download the key from the backup.\n *\n * The current backup API lacks pagination, which can lead to lengthy key retrieval times for large histories (several 10s of minutes).\n * To mitigate this, keys are downloaded on demand as decryption errors occurs.\n * While this approach may result in numerous requests, it improves user experience by reducing wait times for message decryption.\n *\n * The PerSessionKeyBackupDownloader is resistant to backup configuration changes: it will automatically resume querying when\n * the backup is configured correctly.\n */\nclass PerSessionKeyBackupDownloader {\n  /**\n   * Creates a new instance of PerSessionKeyBackupDownloader.\n   *\n   * @param backupManager - The backup manager to use.\n   * @param olmMachine - The olm machine to use.\n   * @param http - The http instance to use.\n   * @param logger - The logger to use.\n   */\n  constructor(logger, olmMachine, http, backupManager) {\n    this.olmMachine = olmMachine;\n    this.http = http;\n    this.backupManager = backupManager;\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"stopped\", false);\n    /**\n     * The version and decryption key to use with current backup if all set up correctly.\n     *\n     * Will not be set unless `hasConfigurationProblem` is `false`.\n     */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"configuration\", null);\n    /** We remember when a session was requested and not found in backup to avoid query again too soon.\n     * Map of session_id to timestamp */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"sessionLastCheckAttemptedTime\", new Map());\n    /** The logger to use */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"logger\", void 0);\n    /** Whether the download loop is running. */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"downloadLoopRunning\", false);\n    /** The list of requests that are queued. */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"queuedRequests\", []);\n    /** Remembers if we have a configuration problem. */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"hasConfigurationProblem\", false);\n    /** The current server backup version check promise. To avoid doing a server call if one is in flight. */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"currentBackupVersionCheck\", null);\n    /**\n     * Called when the backup status changes (CryptoEvents)\n     * This will trigger a check of the backup configuration.\n     */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"onBackupStatusChanged\", () => {\n      // we want to force check configuration, so we clear the current one.\n      this.hasConfigurationProblem = false;\n      this.configuration = null;\n      this.getOrCreateBackupConfiguration().then(configuration => {\n        if (configuration) {\n          // restart the download loop if it was stopped\n          this.downloadKeysLoop();\n        }\n      });\n    });\n    this.logger = logger.getChild(\"[PerSessionKeyBackupDownloader]\");\n    backupManager.on(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_2__.CryptoEvent.KeyBackupStatus, this.onBackupStatusChanged);\n    backupManager.on(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_2__.CryptoEvent.KeyBackupFailed, this.onBackupStatusChanged);\n    backupManager.on(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_2__.CryptoEvent.KeyBackupDecryptionKeyCached, this.onBackupStatusChanged);\n  }\n\n  /**\n   * Check if key download is successfully configured and active.\n   *\n   * @return `true` if key download is correctly configured and active; otherwise `false`.\n   */\n  isKeyBackupDownloadConfigured() {\n    return this.configuration !== null;\n  }\n\n  /**\n   * Return the details of the latest backup on the server, when we last checked.\n   *\n   * This is just a convenience method to expose {@link RustBackupManager.getServerBackupInfo}.\n   */\n  getServerBackupInfo() {\n    var _this = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return yield _this.backupManager.getServerBackupInfo();\n    })();\n  }\n\n  /**\n   * Called when a MissingRoomKey or UnknownMessageIndex decryption error is encountered.\n   *\n   * This will try to download the key from the backup if there is a trusted active backup.\n   * In case of success the key will be imported and the onRoomKeysUpdated callback will be called\n   * internally by the rust-sdk and decryption will be retried.\n   *\n   * @param roomId - The room ID of the room where the error occurred.\n   * @param megolmSessionId - The megolm session ID that is missing.\n   */\n  onDecryptionKeyMissingError(roomId, megolmSessionId) {\n    // Several messages encrypted with the same session may be decrypted at the same time,\n    // so we need to be resistant and not query several time the same session.\n    if (this.isAlreadyInQueue(roomId, megolmSessionId)) {\n      // There is already a request queued for this session, no need to queue another one.\n      this.logger.trace(\"Not checking key backup for session \".concat(megolmSessionId, \" as it is already queued\"));\n      return;\n    }\n    if (this.wasRequestedRecently(megolmSessionId)) {\n      // We already tried to download this session recently and it was not in backup, no need to try again.\n      this.logger.trace(\"Not checking key backup for session \".concat(megolmSessionId, \" as it was already requested recently\"));\n      return;\n    }\n\n    // We always add the request to the queue, even if we have a configuration problem (can't access backup).\n    // This is to make sure that if the configuration problem is resolved, we will try to download the key.\n    // This will happen after an initial sync, at this point the backup will not yet be trusted and the decryption\n    // key will not be available, but it will be just after the verification.\n    // We don't need to persist it because currently on refresh the sdk will retry to decrypt the messages in error.\n    this.queuedRequests.push({\n      roomId,\n      megolmSessionId\n    });\n\n    // Start the download loop if it's not already running.\n    this.downloadKeysLoop();\n  }\n  stop() {\n    this.stopped = true;\n    this.backupManager.off(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_2__.CryptoEvent.KeyBackupStatus, this.onBackupStatusChanged);\n    this.backupManager.off(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_2__.CryptoEvent.KeyBackupFailed, this.onBackupStatusChanged);\n    this.backupManager.off(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_2__.CryptoEvent.KeyBackupDecryptionKeyCached, this.onBackupStatusChanged);\n  }\n  /** Returns true if the megolm session is already queued for download. */\n  isAlreadyInQueue(roomId, megolmSessionId) {\n    return this.queuedRequests.some(info => {\n      return info.roomId == roomId && info.megolmSessionId == megolmSessionId;\n    });\n  }\n\n  /**\n   * Marks the session as not found in backup, to avoid retrying to soon for a key not in backup\n   *\n   * @param megolmSessionId - The megolm session ID that is missing.\n   */\n  markAsNotFoundInBackup(megolmSessionId) {\n    var now = Date.now();\n    this.sessionLastCheckAttemptedTime.set(megolmSessionId, now);\n    // if too big make some cleaning to keep under control\n    if (this.sessionLastCheckAttemptedTime.size > 100) {\n      this.sessionLastCheckAttemptedTime = new Map(Array.from(this.sessionLastCheckAttemptedTime).filter((sid, ts) => {\n        return Math.max(now - ts, 0) < KEY_BACKUP_BACKOFF;\n      }));\n    }\n  }\n\n  /** Returns true if the session was requested recently. */\n  wasRequestedRecently(megolmSessionId) {\n    var lastCheck = this.sessionLastCheckAttemptedTime.get(megolmSessionId);\n    if (!lastCheck) return false;\n    return Math.max(Date.now() - lastCheck, 0) < KEY_BACKUP_BACKOFF;\n  }\n  getBackupDecryptionKey() {\n    var _this2 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      try {\n        return yield _this2.olmMachine.getBackupKeys();\n      } catch (_unused) {\n        return null;\n      }\n    })();\n  }\n\n  /**\n   * Requests a key from the server side backup.\n   *\n   * @param version - The backup version to use.\n   * @param roomId - The room ID of the room where the error occurred.\n   * @param sessionId - The megolm session ID that is missing.\n   */\n  requestRoomKeyFromBackup(version, roomId, sessionId) {\n    var _this3 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var path = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.encodeUri)(\"/room_keys/keys/$roomId/$sessionId\", {\n        $roomId: roomId,\n        $sessionId: sessionId\n      });\n      return yield _this3.http.authedRequest(_http_api_index_js__WEBPACK_IMPORTED_MODULE_3__.Method.Get, path, {\n        version\n      }, undefined, {\n        prefix: _http_api_index_js__WEBPACK_IMPORTED_MODULE_3__.ClientPrefix.V3\n      });\n    })();\n  }\n  downloadKeysLoop() {\n    var _this4 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      if (_this4.downloadLoopRunning) return;\n\n      // If we have a configuration problem, we don't want to try to download.\n      // If any configuration change is detected, we will retry and restart the loop.\n      if (_this4.hasConfigurationProblem) return;\n      _this4.downloadLoopRunning = true;\n      try {\n        while (_this4.queuedRequests.length > 0) {\n          // we just peek the first one without removing it, so if a new request for same key comes in while we're\n          // processing this one, it won't queue another request.\n          var request = _this4.queuedRequests[0];\n          try {\n            // The backup could have changed between the time we queued the request and now, so we need to check\n            var configuration = yield _this4.getOrCreateBackupConfiguration();\n            if (!configuration) {\n              // Backup is not configured correctly, so stop the loop.\n              _this4.downloadLoopRunning = false;\n              return;\n            }\n            var result = yield _this4.queryKeyBackup(request.roomId, request.megolmSessionId, configuration);\n            if (_this4.stopped) {\n              return;\n            }\n            // We got the encrypted key from backup, let's try to decrypt and import it.\n            try {\n              yield _this4.decryptAndImport(request, result, configuration);\n            } catch (e) {\n              _this4.logger.error(\"Error while decrypting and importing key backup for session \".concat(request.megolmSessionId), e);\n            }\n            // now remove the request from the queue as we've processed it.\n            _this4.queuedRequests.shift();\n          } catch (err) {\n            if (err instanceof KeyDownloadError) {\n              switch (err.code) {\n                case KeyDownloadErrorCode.MISSING_DECRYPTION_KEY:\n                  _this4.markAsNotFoundInBackup(request.megolmSessionId);\n                  // continue for next one\n                  _this4.queuedRequests.shift();\n                  break;\n                case KeyDownloadErrorCode.NETWORK_ERROR:\n                  // We don't want to hammer if there is a problem, so wait a bit.\n                  yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.sleep)(KEY_BACKUP_BACKOFF);\n                  break;\n                case KeyDownloadErrorCode.STOPPED:\n                  // If the downloader was stopped, we don't want to retry.\n                  _this4.downloadLoopRunning = false;\n                  return;\n              }\n            } else if (err instanceof KeyDownloadRateLimitError) {\n              // we want to retry after the backoff time\n              yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.sleep)(err.retryMillis);\n            }\n          }\n        }\n      } finally {\n        // all pending request have been processed, we can stop the loop.\n        _this4.downloadLoopRunning = false;\n      }\n    })();\n  }\n\n  /**\n   * Query the backup for a key.\n   *\n   * @param targetRoomId - ID of the room that the session is used in.\n   * @param targetSessionId - ID of the session for which to check backup.\n   * @param configuration - The backup configuration to use.\n   */\n  queryKeyBackup(targetRoomId, targetSessionId, configuration) {\n    var _this5 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      _this5.logger.debug(\"Checking key backup for session \".concat(targetSessionId));\n      if (_this5.stopped) throw new KeyDownloadError(KeyDownloadErrorCode.STOPPED);\n      try {\n        var res = yield _this5.requestRoomKeyFromBackup(configuration.backupVersion, targetRoomId, targetSessionId);\n        _this5.logger.debug(\"Got key from backup for sessionId:\".concat(targetSessionId));\n        return res;\n      } catch (e) {\n        if (_this5.stopped) throw new KeyDownloadError(KeyDownloadErrorCode.STOPPED);\n        _this5.logger.info(\"No luck requesting key backup for session \".concat(targetSessionId, \": \").concat(e));\n        if (e instanceof _http_api_index_js__WEBPACK_IMPORTED_MODULE_3__.MatrixError) {\n          var errCode = e.data.errcode;\n          if (errCode == \"M_NOT_FOUND\") {\n            // Unfortunately the spec doesn't give us a way to differentiate between a missing key and a wrong version.\n            // Synapse will return:\n            //     - \"error\": \"Unknown backup version\" if the version is wrong.\n            //     - \"error\": \"No room_keys found\" if the key is missing.\n            // It's useful to know if the key is missing or if the version is wrong.\n            // As it's not spec'ed, we fall back on considering the key is not in backup.\n            // Notice that this request will be lost if instead the backup got out of sync (updated from other session).\n            throw new KeyDownloadError(KeyDownloadErrorCode.MISSING_DECRYPTION_KEY);\n          }\n          if (e.isRateLimitError()) {\n            var _waitTime;\n            var waitTime;\n            try {\n              var _e$getRetryAfterMs;\n              waitTime = (_e$getRetryAfterMs = e.getRetryAfterMs()) !== null && _e$getRetryAfterMs !== void 0 ? _e$getRetryAfterMs : undefined;\n            } catch (error) {\n              _this5.logger.warn(\"Error while retrieving a rate-limit retry delay\", error);\n            }\n            if (waitTime && waitTime > 0) {\n              _this5.logger.info(\"Rate limited by server, waiting \".concat(waitTime, \"ms\"));\n            }\n            throw new KeyDownloadRateLimitError((_waitTime = waitTime) !== null && _waitTime !== void 0 ? _waitTime : KEY_BACKUP_BACKOFF);\n          }\n        }\n        throw new KeyDownloadError(KeyDownloadErrorCode.NETWORK_ERROR);\n      }\n    })();\n  }\n  decryptAndImport(sessionInfo, data, configuration) {\n    var _this6 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var sessionsToImport = {\n        [sessionInfo.megolmSessionId]: data\n      };\n      var keys = yield configuration.decryptor.decryptSessions(sessionsToImport);\n      for (var k of keys) {\n        k.room_id = sessionInfo.roomId;\n      }\n      yield _this6.backupManager.importBackedUpRoomKeys(keys, configuration.backupVersion);\n    })();\n  }\n\n  /**\n   * Gets the current backup configuration or create one if it doesn't exist.\n   *\n   * When a valid configuration is found it is cached and returned for subsequent calls.\n   * Otherwise, if a check is forced or a check has not yet been done, a new check is done.\n   *\n   * @returns The backup configuration to use or null if there is a configuration problem.\n   */\n  getOrCreateBackupConfiguration() {\n    var _this7 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      if (_this7.configuration) {\n        return _this7.configuration;\n      }\n\n      // We already tried to check the configuration and it failed.\n      // We don't want to try again immediately, we will retry if a configuration change is detected.\n      if (_this7.hasConfigurationProblem) {\n        return null;\n      }\n\n      // This method can be called rapidly by several emitted CryptoEvent, so we need to make sure that we don't\n      // query the server several times.\n      if (_this7.currentBackupVersionCheck != null) {\n        _this7.logger.debug(\"Already checking server version, use current promise\");\n        return yield _this7.currentBackupVersionCheck;\n      }\n      _this7.currentBackupVersionCheck = _this7.internalCheckFromServer();\n      try {\n        return yield _this7.currentBackupVersionCheck;\n      } finally {\n        _this7.currentBackupVersionCheck = null;\n      }\n    })();\n  }\n  internalCheckFromServer() {\n    var _this8 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var _currentServerVersion, _currentServerVersion2, _currentServerVersion4;\n      var currentServerVersion = null;\n      try {\n        currentServerVersion = yield _this8.backupManager.getServerBackupInfo();\n      } catch (e) {\n        _this8.logger.debug(\"Backup: error while checking server version: \".concat(e));\n        _this8.hasConfigurationProblem = true;\n        return null;\n      }\n      _this8.logger.debug(\"Got current backup version from server: \".concat((_currentServerVersion = currentServerVersion) === null || _currentServerVersion === void 0 ? void 0 : _currentServerVersion.version));\n      if (((_currentServerVersion2 = currentServerVersion) === null || _currentServerVersion2 === void 0 ? void 0 : _currentServerVersion2.algorithm) != \"m.megolm_backup.v1.curve25519-aes-sha2\") {\n        var _currentServerVersion3;\n        _this8.logger.info(\"Unsupported algorithm \".concat((_currentServerVersion3 = currentServerVersion) === null || _currentServerVersion3 === void 0 ? void 0 : _currentServerVersion3.algorithm));\n        _this8.hasConfigurationProblem = true;\n        return null;\n      }\n      if (!((_currentServerVersion4 = currentServerVersion) !== null && _currentServerVersion4 !== void 0 && _currentServerVersion4.version)) {\n        _this8.logger.info(\"No current key backup\");\n        _this8.hasConfigurationProblem = true;\n        return null;\n      }\n      var activeVersion = yield _this8.backupManager.getActiveBackupVersion();\n      if (activeVersion == null || currentServerVersion.version != activeVersion) {\n        // Either the current backup version on server side is not trusted, or it is out of sync with the active version on the client side.\n        _this8.logger.info(\"The current backup version on the server (\".concat(currentServerVersion.version, \") is not trusted. Version we are currently backing up to: \").concat(activeVersion));\n        _this8.hasConfigurationProblem = true;\n        return null;\n      }\n      var backupKeys = yield _this8.getBackupDecryptionKey();\n      if (!(backupKeys !== null && backupKeys !== void 0 && backupKeys.decryptionKey)) {\n        _this8.logger.debug(\"Not checking key backup for session (no decryption key)\");\n        _this8.hasConfigurationProblem = true;\n        return null;\n      }\n      if (activeVersion != backupKeys.backupVersion) {\n        _this8.logger.debug(\"Version for which we have a decryption key (\".concat(backupKeys.backupVersion, \") doesn't match the version we are backing up to (\").concat(activeVersion, \")\"));\n        _this8.hasConfigurationProblem = true;\n        return null;\n      }\n      var authData = currentServerVersion.auth_data;\n      if (authData.public_key != backupKeys.decryptionKey.megolmV1PublicKey.publicKeyBase64) {\n        _this8.logger.debug(\"Key backup on server does not match our decryption key\");\n        _this8.hasConfigurationProblem = true;\n        return null;\n      }\n      var backupDecryptor = _this8.backupManager.createBackupDecryptor(backupKeys.decryptionKey);\n      _this8.hasConfigurationProblem = false;\n      _this8.configuration = {\n        decryptor: backupDecryptor,\n        backupVersion: activeVersion\n      };\n      return _this8.configuration;\n    })();\n  }\n}\n//# sourceMappingURL=PerSessionKeyBackupDownloader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vUGVyU2Vzc2lvbktleUJhY2t1cERvd25sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXdFO0FBQ0o7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRDtBQUNvQjtBQUMxQjtBQUMvQztBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBLElBQUksaUZBQWU7QUFDbkI7QUFDQSxJQUFJLGlGQUFlO0FBQ25CO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBLElBQUksaUZBQWU7QUFDbkI7QUFDQSxJQUFJLGlGQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLHFCQUFxQiw2REFBVztBQUNoQyxxQkFBcUIsNkRBQVc7QUFDaEMscUJBQXFCLDZEQUFXO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FzdGVyaWNzLWdyaWQvLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vUGVyU2Vzc2lvbktleUJhY2t1cERvd25sb2FkZXIuanM/OTNjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2FzeW5jVG9HZW5lcmF0b3IgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiO1xuLypcbkNvcHlyaWdodCAyMDIzIC0gMjAyNCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7IENyeXB0b0V2ZW50IH0gZnJvbSBcIi4uL2NyeXB0by1hcGkvaW5kZXguanNcIjtcbmltcG9ydCB7IENsaWVudFByZWZpeCwgTWF0cml4RXJyb3IsIE1ldGhvZCB9IGZyb20gXCIuLi9odHRwLWFwaS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZW5jb2RlVXJpLCBzbGVlcCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuLy8gVGhlIG1pbmltdW0gdGltZSB0byB3YWl0IGJldHdlZW4gdHdvIHJldHJpZXMgaW4gY2FzZSBvZiBlcnJvcnMuIFRvIGF2b2lkIGhhbW1lcmluZyB0aGUgc2VydmVyLlxudmFyIEtFWV9CQUNLVVBfQkFDS09GRiA9IDUwMDA7IC8vIG1zXG5cbi8qKlxuICogRW51bWVyYXRlcyB0aGUgZGlmZmVyZW50IGtpbmQgb2YgZXJyb3JzIHRoYXQgY2FuIG9jY3VycyB3aGVuIGRvd25sb2FkaW5nIGFuZCBpbXBvcnRpbmcgYSBrZXkgZnJvbSBiYWNrdXAuXG4gKi9cbnZhciBLZXlEb3dubG9hZEVycm9yQ29kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoS2V5RG93bmxvYWRFcnJvckNvZGUpIHtcbiAgS2V5RG93bmxvYWRFcnJvckNvZGVbXCJNSVNTSU5HX0RFQ1JZUFRJT05fS0VZXCJdID0gXCJNSVNTSU5HX0RFQ1JZUFRJT05fS0VZXCI7XG4gIEtleURvd25sb2FkRXJyb3JDb2RlW1wiTkVUV09SS19FUlJPUlwiXSA9IFwiTkVUV09SS19FUlJPUlwiO1xuICBLZXlEb3dubG9hZEVycm9yQ29kZVtcIlNUT1BQRURcIl0gPSBcIlNUT1BQRURcIjtcbiAgcmV0dXJuIEtleURvd25sb2FkRXJyb3JDb2RlO1xufShLZXlEb3dubG9hZEVycm9yQ29kZSB8fCB7fSk7XG5jbGFzcyBLZXlEb3dubG9hZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgc3VwZXIoXCJGYWlsZWQgdG8gZ2V0IGtleSBmcm9tIGJhY2t1cDogXCIuY29uY2F0KGNvZGUpKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMubmFtZSA9IFwiS2V5RG93bmxvYWRFcnJvclwiO1xuICB9XG59XG5jbGFzcyBLZXlEb3dubG9hZFJhdGVMaW1pdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZXRyeU1pbGxpcykge1xuICAgIHN1cGVyKFwiRmFpbGVkIHRvIGdldCBrZXkgZnJvbSBiYWNrdXA6IHJhdGUgbGltaXRlZFwiKTtcbiAgICB0aGlzLnJldHJ5TWlsbGlzID0gcmV0cnlNaWxsaXM7XG4gICAgdGhpcy5uYW1lID0gXCJLZXlEb3dubG9hZFJhdGVMaW1pdEVycm9yXCI7XG4gIH1cbn1cblxuLyoqIERldGFpbHMgb2YgYSBtZWdvbG0gc2Vzc2lvbiB3aG9zZSBrZXkgd2UgYXJlIHRyeWluZyB0byBmZXRjaC4gKi9cblxuLyoqIEhvbGRzIHRoZSBjdXJyZW50IGJhY2t1cCBkZWNyeXB0b3IgYW5kIHZlcnNpb24gdGhhdCBzaG91bGQgYmUgdXNlZC5cbiAqXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgYW4gaW1tdXRhYmxlIG9iamVjdCAoYSBuZXcgaW5zdGFuY2Ugc2hvdWxkIGJlIGNyZWF0ZWQgaWYgdGhlIGNvbmZpZ3VyYXRpb24gY2hhbmdlcyksXG4gKiBhbmQgc29tZSBvZiB0aGUgbG9naWMgcmVsaWVzIG9uIHRoYXQsIHNvIHRoZSBwcm9wZXJ0aWVzIGFyZSBtYXJrZWQgYXMgYHJlYWRvbmx5YC5cbiAqL1xuXG4vKipcbiAqIFVzZWQgd2hlbiBhbiAndW5hYmxlIHRvIGRlY3J5cHQnIGVycm9yIG9jY3Vycy4gSXQgYXR0ZW1wdHMgdG8gZG93bmxvYWQgdGhlIGtleSBmcm9tIHRoZSBiYWNrdXAuXG4gKlxuICogVGhlIGN1cnJlbnQgYmFja3VwIEFQSSBsYWNrcyBwYWdpbmF0aW9uLCB3aGljaCBjYW4gbGVhZCB0byBsZW5ndGh5IGtleSByZXRyaWV2YWwgdGltZXMgZm9yIGxhcmdlIGhpc3RvcmllcyAoc2V2ZXJhbCAxMHMgb2YgbWludXRlcykuXG4gKiBUbyBtaXRpZ2F0ZSB0aGlzLCBrZXlzIGFyZSBkb3dubG9hZGVkIG9uIGRlbWFuZCBhcyBkZWNyeXB0aW9uIGVycm9ycyBvY2N1cnMuXG4gKiBXaGlsZSB0aGlzIGFwcHJvYWNoIG1heSByZXN1bHQgaW4gbnVtZXJvdXMgcmVxdWVzdHMsIGl0IGltcHJvdmVzIHVzZXIgZXhwZXJpZW5jZSBieSByZWR1Y2luZyB3YWl0IHRpbWVzIGZvciBtZXNzYWdlIGRlY3J5cHRpb24uXG4gKlxuICogVGhlIFBlclNlc3Npb25LZXlCYWNrdXBEb3dubG9hZGVyIGlzIHJlc2lzdGFudCB0byBiYWNrdXAgY29uZmlndXJhdGlvbiBjaGFuZ2VzOiBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgcmVzdW1lIHF1ZXJ5aW5nIHdoZW5cbiAqIHRoZSBiYWNrdXAgaXMgY29uZmlndXJlZCBjb3JyZWN0bHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBQZXJTZXNzaW9uS2V5QmFja3VwRG93bmxvYWRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFBlclNlc3Npb25LZXlCYWNrdXBEb3dubG9hZGVyLlxuICAgKlxuICAgKiBAcGFyYW0gYmFja3VwTWFuYWdlciAtIFRoZSBiYWNrdXAgbWFuYWdlciB0byB1c2UuXG4gICAqIEBwYXJhbSBvbG1NYWNoaW5lIC0gVGhlIG9sbSBtYWNoaW5lIHRvIHVzZS5cbiAgICogQHBhcmFtIGh0dHAgLSBUaGUgaHR0cCBpbnN0YW5jZSB0byB1c2UuXG4gICAqIEBwYXJhbSBsb2dnZXIgLSBUaGUgbG9nZ2VyIHRvIHVzZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxvZ2dlciwgb2xtTWFjaGluZSwgaHR0cCwgYmFja3VwTWFuYWdlcikge1xuICAgIHRoaXMub2xtTWFjaGluZSA9IG9sbU1hY2hpbmU7XG4gICAgdGhpcy5odHRwID0gaHR0cDtcbiAgICB0aGlzLmJhY2t1cE1hbmFnZXIgPSBiYWNrdXBNYW5hZ2VyO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3BwZWRcIiwgZmFsc2UpO1xuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIGFuZCBkZWNyeXB0aW9uIGtleSB0byB1c2Ugd2l0aCBjdXJyZW50IGJhY2t1cCBpZiBhbGwgc2V0IHVwIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIFdpbGwgbm90IGJlIHNldCB1bmxlc3MgYGhhc0NvbmZpZ3VyYXRpb25Qcm9ibGVtYCBpcyBgZmFsc2VgLlxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ3VyYXRpb25cIiwgbnVsbCk7XG4gICAgLyoqIFdlIHJlbWVtYmVyIHdoZW4gYSBzZXNzaW9uIHdhcyByZXF1ZXN0ZWQgYW5kIG5vdCBmb3VuZCBpbiBiYWNrdXAgdG8gYXZvaWQgcXVlcnkgYWdhaW4gdG9vIHNvb24uXG4gICAgICogTWFwIG9mIHNlc3Npb25faWQgdG8gdGltZXN0YW1wICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2Vzc2lvbkxhc3RDaGVja0F0dGVtcHRlZFRpbWVcIiwgbmV3IE1hcCgpKTtcbiAgICAvKiogVGhlIGxvZ2dlciB0byB1c2UgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsb2dnZXJcIiwgdm9pZCAwKTtcbiAgICAvKiogV2hldGhlciB0aGUgZG93bmxvYWQgbG9vcCBpcyBydW5uaW5nLiAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvd25sb2FkTG9vcFJ1bm5pbmdcIiwgZmFsc2UpO1xuICAgIC8qKiBUaGUgbGlzdCBvZiByZXF1ZXN0cyB0aGF0IGFyZSBxdWV1ZWQuICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicXVldWVkUmVxdWVzdHNcIiwgW10pO1xuICAgIC8qKiBSZW1lbWJlcnMgaWYgd2UgaGF2ZSBhIGNvbmZpZ3VyYXRpb24gcHJvYmxlbS4gKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYXNDb25maWd1cmF0aW9uUHJvYmxlbVwiLCBmYWxzZSk7XG4gICAgLyoqIFRoZSBjdXJyZW50IHNlcnZlciBiYWNrdXAgdmVyc2lvbiBjaGVjayBwcm9taXNlLiBUbyBhdm9pZCBkb2luZyBhIHNlcnZlciBjYWxsIGlmIG9uZSBpcyBpbiBmbGlnaHQuICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY3VycmVudEJhY2t1cFZlcnNpb25DaGVja1wiLCBudWxsKTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgYmFja3VwIHN0YXR1cyBjaGFuZ2VzIChDcnlwdG9FdmVudHMpXG4gICAgICogVGhpcyB3aWxsIHRyaWdnZXIgYSBjaGVjayBvZiB0aGUgYmFja3VwIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25CYWNrdXBTdGF0dXNDaGFuZ2VkXCIsICgpID0+IHtcbiAgICAgIC8vIHdlIHdhbnQgdG8gZm9yY2UgY2hlY2sgY29uZmlndXJhdGlvbiwgc28gd2UgY2xlYXIgdGhlIGN1cnJlbnQgb25lLlxuICAgICAgdGhpcy5oYXNDb25maWd1cmF0aW9uUHJvYmxlbSA9IGZhbHNlO1xuICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gbnVsbDtcbiAgICAgIHRoaXMuZ2V0T3JDcmVhdGVCYWNrdXBDb25maWd1cmF0aW9uKCkudGhlbihjb25maWd1cmF0aW9uID0+IHtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAvLyByZXN0YXJ0IHRoZSBkb3dubG9hZCBsb29wIGlmIGl0IHdhcyBzdG9wcGVkXG4gICAgICAgICAgdGhpcy5kb3dubG9hZEtleXNMb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyLmdldENoaWxkKFwiW1BlclNlc3Npb25LZXlCYWNrdXBEb3dubG9hZGVyXVwiKTtcbiAgICBiYWNrdXBNYW5hZ2VyLm9uKENyeXB0b0V2ZW50LktleUJhY2t1cFN0YXR1cywgdGhpcy5vbkJhY2t1cFN0YXR1c0NoYW5nZWQpO1xuICAgIGJhY2t1cE1hbmFnZXIub24oQ3J5cHRvRXZlbnQuS2V5QmFja3VwRmFpbGVkLCB0aGlzLm9uQmFja3VwU3RhdHVzQ2hhbmdlZCk7XG4gICAgYmFja3VwTWFuYWdlci5vbihDcnlwdG9FdmVudC5LZXlCYWNrdXBEZWNyeXB0aW9uS2V5Q2FjaGVkLCB0aGlzLm9uQmFja3VwU3RhdHVzQ2hhbmdlZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYga2V5IGRvd25sb2FkIGlzIHN1Y2Nlc3NmdWxseSBjb25maWd1cmVkIGFuZCBhY3RpdmUuXG4gICAqXG4gICAqIEByZXR1cm4gYHRydWVgIGlmIGtleSBkb3dubG9hZCBpcyBjb3JyZWN0bHkgY29uZmlndXJlZCBhbmQgYWN0aXZlOyBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICovXG4gIGlzS2V5QmFja3VwRG93bmxvYWRDb25maWd1cmVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24gIT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkZXRhaWxzIG9mIHRoZSBsYXRlc3QgYmFja3VwIG9uIHRoZSBzZXJ2ZXIsIHdoZW4gd2UgbGFzdCBjaGVja2VkLlxuICAgKlxuICAgKiBUaGlzIGlzIGp1c3QgYSBjb252ZW5pZW5jZSBtZXRob2QgdG8gZXhwb3NlIHtAbGluayBSdXN0QmFja3VwTWFuYWdlci5nZXRTZXJ2ZXJCYWNrdXBJbmZvfS5cbiAgICovXG4gIGdldFNlcnZlckJhY2t1cEluZm8oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB5aWVsZCBfdGhpcy5iYWNrdXBNYW5hZ2VyLmdldFNlcnZlckJhY2t1cEluZm8oKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgTWlzc2luZ1Jvb21LZXkgb3IgVW5rbm93bk1lc3NhZ2VJbmRleCBkZWNyeXB0aW9uIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgdHJ5IHRvIGRvd25sb2FkIHRoZSBrZXkgZnJvbSB0aGUgYmFja3VwIGlmIHRoZXJlIGlzIGEgdHJ1c3RlZCBhY3RpdmUgYmFja3VwLlxuICAgKiBJbiBjYXNlIG9mIHN1Y2Nlc3MgdGhlIGtleSB3aWxsIGJlIGltcG9ydGVkIGFuZCB0aGUgb25Sb29tS2V5c1VwZGF0ZWQgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAgICogaW50ZXJuYWxseSBieSB0aGUgcnVzdC1zZGsgYW5kIGRlY3J5cHRpb24gd2lsbCBiZSByZXRyaWVkLlxuICAgKlxuICAgKiBAcGFyYW0gcm9vbUlkIC0gVGhlIHJvb20gSUQgb2YgdGhlIHJvb20gd2hlcmUgdGhlIGVycm9yIG9jY3VycmVkLlxuICAgKiBAcGFyYW0gbWVnb2xtU2Vzc2lvbklkIC0gVGhlIG1lZ29sbSBzZXNzaW9uIElEIHRoYXQgaXMgbWlzc2luZy5cbiAgICovXG4gIG9uRGVjcnlwdGlvbktleU1pc3NpbmdFcnJvcihyb29tSWQsIG1lZ29sbVNlc3Npb25JZCkge1xuICAgIC8vIFNldmVyYWwgbWVzc2FnZXMgZW5jcnlwdGVkIHdpdGggdGhlIHNhbWUgc2Vzc2lvbiBtYXkgYmUgZGVjcnlwdGVkIGF0IHRoZSBzYW1lIHRpbWUsXG4gICAgLy8gc28gd2UgbmVlZCB0byBiZSByZXNpc3RhbnQgYW5kIG5vdCBxdWVyeSBzZXZlcmFsIHRpbWUgdGhlIHNhbWUgc2Vzc2lvbi5cbiAgICBpZiAodGhpcy5pc0FscmVhZHlJblF1ZXVlKHJvb21JZCwgbWVnb2xtU2Vzc2lvbklkKSkge1xuICAgICAgLy8gVGhlcmUgaXMgYWxyZWFkeSBhIHJlcXVlc3QgcXVldWVkIGZvciB0aGlzIHNlc3Npb24sIG5vIG5lZWQgdG8gcXVldWUgYW5vdGhlciBvbmUuXG4gICAgICB0aGlzLmxvZ2dlci50cmFjZShcIk5vdCBjaGVja2luZyBrZXkgYmFja3VwIGZvciBzZXNzaW9uIFwiLmNvbmNhdChtZWdvbG1TZXNzaW9uSWQsIFwiIGFzIGl0IGlzIGFscmVhZHkgcXVldWVkXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMud2FzUmVxdWVzdGVkUmVjZW50bHkobWVnb2xtU2Vzc2lvbklkKSkge1xuICAgICAgLy8gV2UgYWxyZWFkeSB0cmllZCB0byBkb3dubG9hZCB0aGlzIHNlc3Npb24gcmVjZW50bHkgYW5kIGl0IHdhcyBub3QgaW4gYmFja3VwLCBubyBuZWVkIHRvIHRyeSBhZ2Fpbi5cbiAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiTm90IGNoZWNraW5nIGtleSBiYWNrdXAgZm9yIHNlc3Npb24gXCIuY29uY2F0KG1lZ29sbVNlc3Npb25JZCwgXCIgYXMgaXQgd2FzIGFscmVhZHkgcmVxdWVzdGVkIHJlY2VudGx5XCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZSBhbHdheXMgYWRkIHRoZSByZXF1ZXN0IHRvIHRoZSBxdWV1ZSwgZXZlbiBpZiB3ZSBoYXZlIGEgY29uZmlndXJhdGlvbiBwcm9ibGVtIChjYW4ndCBhY2Nlc3MgYmFja3VwKS5cbiAgICAvLyBUaGlzIGlzIHRvIG1ha2Ugc3VyZSB0aGF0IGlmIHRoZSBjb25maWd1cmF0aW9uIHByb2JsZW0gaXMgcmVzb2x2ZWQsIHdlIHdpbGwgdHJ5IHRvIGRvd25sb2FkIHRoZSBrZXkuXG4gICAgLy8gVGhpcyB3aWxsIGhhcHBlbiBhZnRlciBhbiBpbml0aWFsIHN5bmMsIGF0IHRoaXMgcG9pbnQgdGhlIGJhY2t1cCB3aWxsIG5vdCB5ZXQgYmUgdHJ1c3RlZCBhbmQgdGhlIGRlY3J5cHRpb25cbiAgICAvLyBrZXkgd2lsbCBub3QgYmUgYXZhaWxhYmxlLCBidXQgaXQgd2lsbCBiZSBqdXN0IGFmdGVyIHRoZSB2ZXJpZmljYXRpb24uXG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBwZXJzaXN0IGl0IGJlY2F1c2UgY3VycmVudGx5IG9uIHJlZnJlc2ggdGhlIHNkayB3aWxsIHJldHJ5IHRvIGRlY3J5cHQgdGhlIG1lc3NhZ2VzIGluIGVycm9yLlxuICAgIHRoaXMucXVldWVkUmVxdWVzdHMucHVzaCh7XG4gICAgICByb29tSWQsXG4gICAgICBtZWdvbG1TZXNzaW9uSWRcbiAgICB9KTtcblxuICAgIC8vIFN0YXJ0IHRoZSBkb3dubG9hZCBsb29wIGlmIGl0J3Mgbm90IGFscmVhZHkgcnVubmluZy5cbiAgICB0aGlzLmRvd25sb2FkS2V5c0xvb3AoKTtcbiAgfVxuICBzdG9wKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgdGhpcy5iYWNrdXBNYW5hZ2VyLm9mZihDcnlwdG9FdmVudC5LZXlCYWNrdXBTdGF0dXMsIHRoaXMub25CYWNrdXBTdGF0dXNDaGFuZ2VkKTtcbiAgICB0aGlzLmJhY2t1cE1hbmFnZXIub2ZmKENyeXB0b0V2ZW50LktleUJhY2t1cEZhaWxlZCwgdGhpcy5vbkJhY2t1cFN0YXR1c0NoYW5nZWQpO1xuICAgIHRoaXMuYmFja3VwTWFuYWdlci5vZmYoQ3J5cHRvRXZlbnQuS2V5QmFja3VwRGVjcnlwdGlvbktleUNhY2hlZCwgdGhpcy5vbkJhY2t1cFN0YXR1c0NoYW5nZWQpO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1lZ29sbSBzZXNzaW9uIGlzIGFscmVhZHkgcXVldWVkIGZvciBkb3dubG9hZC4gKi9cbiAgaXNBbHJlYWR5SW5RdWV1ZShyb29tSWQsIG1lZ29sbVNlc3Npb25JZCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlZFJlcXVlc3RzLnNvbWUoaW5mbyA9PiB7XG4gICAgICByZXR1cm4gaW5mby5yb29tSWQgPT0gcm9vbUlkICYmIGluZm8ubWVnb2xtU2Vzc2lvbklkID09IG1lZ29sbVNlc3Npb25JZDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrcyB0aGUgc2Vzc2lvbiBhcyBub3QgZm91bmQgaW4gYmFja3VwLCB0byBhdm9pZCByZXRyeWluZyB0byBzb29uIGZvciBhIGtleSBub3QgaW4gYmFja3VwXG4gICAqXG4gICAqIEBwYXJhbSBtZWdvbG1TZXNzaW9uSWQgLSBUaGUgbWVnb2xtIHNlc3Npb24gSUQgdGhhdCBpcyBtaXNzaW5nLlxuICAgKi9cbiAgbWFya0FzTm90Rm91bmRJbkJhY2t1cChtZWdvbG1TZXNzaW9uSWQpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLnNlc3Npb25MYXN0Q2hlY2tBdHRlbXB0ZWRUaW1lLnNldChtZWdvbG1TZXNzaW9uSWQsIG5vdyk7XG4gICAgLy8gaWYgdG9vIGJpZyBtYWtlIHNvbWUgY2xlYW5pbmcgdG8ga2VlcCB1bmRlciBjb250cm9sXG4gICAgaWYgKHRoaXMuc2Vzc2lvbkxhc3RDaGVja0F0dGVtcHRlZFRpbWUuc2l6ZSA+IDEwMCkge1xuICAgICAgdGhpcy5zZXNzaW9uTGFzdENoZWNrQXR0ZW1wdGVkVGltZSA9IG5ldyBNYXAoQXJyYXkuZnJvbSh0aGlzLnNlc3Npb25MYXN0Q2hlY2tBdHRlbXB0ZWRUaW1lKS5maWx0ZXIoKHNpZCwgdHMpID0+IHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KG5vdyAtIHRzLCAwKSA8IEtFWV9CQUNLVVBfQkFDS09GRjtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBzZXNzaW9uIHdhcyByZXF1ZXN0ZWQgcmVjZW50bHkuICovXG4gIHdhc1JlcXVlc3RlZFJlY2VudGx5KG1lZ29sbVNlc3Npb25JZCkge1xuICAgIHZhciBsYXN0Q2hlY2sgPSB0aGlzLnNlc3Npb25MYXN0Q2hlY2tBdHRlbXB0ZWRUaW1lLmdldChtZWdvbG1TZXNzaW9uSWQpO1xuICAgIGlmICghbGFzdENoZWNrKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIE1hdGgubWF4KERhdGUubm93KCkgLSBsYXN0Q2hlY2ssIDApIDwgS0VZX0JBQ0tVUF9CQUNLT0ZGO1xuICB9XG4gIGdldEJhY2t1cERlY3J5cHRpb25LZXkoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4geWllbGQgX3RoaXMyLm9sbU1hY2hpbmUuZ2V0QmFja3VwS2V5cygpO1xuICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGEga2V5IGZyb20gdGhlIHNlcnZlciBzaWRlIGJhY2t1cC5cbiAgICpcbiAgICogQHBhcmFtIHZlcnNpb24gLSBUaGUgYmFja3VwIHZlcnNpb24gdG8gdXNlLlxuICAgKiBAcGFyYW0gcm9vbUlkIC0gVGhlIHJvb20gSUQgb2YgdGhlIHJvb20gd2hlcmUgdGhlIGVycm9yIG9jY3VycmVkLlxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIC0gVGhlIG1lZ29sbSBzZXNzaW9uIElEIHRoYXQgaXMgbWlzc2luZy5cbiAgICovXG4gIHJlcXVlc3RSb29tS2V5RnJvbUJhY2t1cCh2ZXJzaW9uLCByb29tSWQsIHNlc3Npb25JZCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHBhdGggPSBlbmNvZGVVcmkoXCIvcm9vbV9rZXlzL2tleXMvJHJvb21JZC8kc2Vzc2lvbklkXCIsIHtcbiAgICAgICAgJHJvb21JZDogcm9vbUlkLFxuICAgICAgICAkc2Vzc2lvbklkOiBzZXNzaW9uSWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHlpZWxkIF90aGlzMy5odHRwLmF1dGhlZFJlcXVlc3QoTWV0aG9kLkdldCwgcGF0aCwge1xuICAgICAgICB2ZXJzaW9uXG4gICAgICB9LCB1bmRlZmluZWQsIHtcbiAgICAgICAgcHJlZml4OiBDbGllbnRQcmVmaXguVjNcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH1cbiAgZG93bmxvYWRLZXlzTG9vcCgpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChfdGhpczQuZG93bmxvYWRMb29wUnVubmluZykgcmV0dXJuO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgY29uZmlndXJhdGlvbiBwcm9ibGVtLCB3ZSBkb24ndCB3YW50IHRvIHRyeSB0byBkb3dubG9hZC5cbiAgICAgIC8vIElmIGFueSBjb25maWd1cmF0aW9uIGNoYW5nZSBpcyBkZXRlY3RlZCwgd2Ugd2lsbCByZXRyeSBhbmQgcmVzdGFydCB0aGUgbG9vcC5cbiAgICAgIGlmIChfdGhpczQuaGFzQ29uZmlndXJhdGlvblByb2JsZW0pIHJldHVybjtcbiAgICAgIF90aGlzNC5kb3dubG9hZExvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlIChfdGhpczQucXVldWVkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIHdlIGp1c3QgcGVlayB0aGUgZmlyc3Qgb25lIHdpdGhvdXQgcmVtb3ZpbmcgaXQsIHNvIGlmIGEgbmV3IHJlcXVlc3QgZm9yIHNhbWUga2V5IGNvbWVzIGluIHdoaWxlIHdlJ3JlXG4gICAgICAgICAgLy8gcHJvY2Vzc2luZyB0aGlzIG9uZSwgaXQgd29uJ3QgcXVldWUgYW5vdGhlciByZXF1ZXN0LlxuICAgICAgICAgIHZhciByZXF1ZXN0ID0gX3RoaXM0LnF1ZXVlZFJlcXVlc3RzWzBdO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUaGUgYmFja3VwIGNvdWxkIGhhdmUgY2hhbmdlZCBiZXR3ZWVuIHRoZSB0aW1lIHdlIHF1ZXVlZCB0aGUgcmVxdWVzdCBhbmQgbm93LCBzbyB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgICAgICAgICB2YXIgY29uZmlndXJhdGlvbiA9IHlpZWxkIF90aGlzNC5nZXRPckNyZWF0ZUJhY2t1cENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgICAgIGlmICghY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAvLyBCYWNrdXAgaXMgbm90IGNvbmZpZ3VyZWQgY29ycmVjdGx5LCBzbyBzdG9wIHRoZSBsb29wLlxuICAgICAgICAgICAgICBfdGhpczQuZG93bmxvYWRMb29wUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0geWllbGQgX3RoaXM0LnF1ZXJ5S2V5QmFja3VwKHJlcXVlc3Qucm9vbUlkLCByZXF1ZXN0Lm1lZ29sbVNlc3Npb25JZCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoX3RoaXM0LnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgZ290IHRoZSBlbmNyeXB0ZWQga2V5IGZyb20gYmFja3VwLCBsZXQncyB0cnkgdG8gZGVjcnlwdCBhbmQgaW1wb3J0IGl0LlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgeWllbGQgX3RoaXM0LmRlY3J5cHRBbmRJbXBvcnQocmVxdWVzdCwgcmVzdWx0LCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgX3RoaXM0LmxvZ2dlci5lcnJvcihcIkVycm9yIHdoaWxlIGRlY3J5cHRpbmcgYW5kIGltcG9ydGluZyBrZXkgYmFja3VwIGZvciBzZXNzaW9uIFwiLmNvbmNhdChyZXF1ZXN0Lm1lZ29sbVNlc3Npb25JZCksIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm93IHJlbW92ZSB0aGUgcmVxdWVzdCBmcm9tIHRoZSBxdWV1ZSBhcyB3ZSd2ZSBwcm9jZXNzZWQgaXQuXG4gICAgICAgICAgICBfdGhpczQucXVldWVkUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBLZXlEb3dubG9hZEVycm9yKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEtleURvd25sb2FkRXJyb3JDb2RlLk1JU1NJTkdfREVDUllQVElPTl9LRVk6XG4gICAgICAgICAgICAgICAgICBfdGhpczQubWFya0FzTm90Rm91bmRJbkJhY2t1cChyZXF1ZXN0Lm1lZ29sbVNlc3Npb25JZCk7XG4gICAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBmb3IgbmV4dCBvbmVcbiAgICAgICAgICAgICAgICAgIF90aGlzNC5xdWV1ZWRSZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlEb3dubG9hZEVycm9yQ29kZS5ORVRXT1JLX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBoYW1tZXIgaWYgdGhlcmUgaXMgYSBwcm9ibGVtLCBzbyB3YWl0IGEgYml0LlxuICAgICAgICAgICAgICAgICAgeWllbGQgc2xlZXAoS0VZX0JBQ0tVUF9CQUNLT0ZGKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgS2V5RG93bmxvYWRFcnJvckNvZGUuU1RPUFBFRDpcbiAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkb3dubG9hZGVyIHdhcyBzdG9wcGVkLCB3ZSBkb24ndCB3YW50IHRvIHJldHJ5LlxuICAgICAgICAgICAgICAgICAgX3RoaXM0LmRvd25sb2FkTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIgaW5zdGFuY2VvZiBLZXlEb3dubG9hZFJhdGVMaW1pdEVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gcmV0cnkgYWZ0ZXIgdGhlIGJhY2tvZmYgdGltZVxuICAgICAgICAgICAgICB5aWVsZCBzbGVlcChlcnIucmV0cnlNaWxsaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gYWxsIHBlbmRpbmcgcmVxdWVzdCBoYXZlIGJlZW4gcHJvY2Vzc2VkLCB3ZSBjYW4gc3RvcCB0aGUgbG9vcC5cbiAgICAgICAgX3RoaXM0LmRvd25sb2FkTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJ5IHRoZSBiYWNrdXAgZm9yIGEga2V5LlxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0Um9vbUlkIC0gSUQgb2YgdGhlIHJvb20gdGhhdCB0aGUgc2Vzc2lvbiBpcyB1c2VkIGluLlxuICAgKiBAcGFyYW0gdGFyZ2V0U2Vzc2lvbklkIC0gSUQgb2YgdGhlIHNlc3Npb24gZm9yIHdoaWNoIHRvIGNoZWNrIGJhY2t1cC5cbiAgICogQHBhcmFtIGNvbmZpZ3VyYXRpb24gLSBUaGUgYmFja3VwIGNvbmZpZ3VyYXRpb24gdG8gdXNlLlxuICAgKi9cbiAgcXVlcnlLZXlCYWNrdXAodGFyZ2V0Um9vbUlkLCB0YXJnZXRTZXNzaW9uSWQsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIF90aGlzNS5sb2dnZXIuZGVidWcoXCJDaGVja2luZyBrZXkgYmFja3VwIGZvciBzZXNzaW9uIFwiLmNvbmNhdCh0YXJnZXRTZXNzaW9uSWQpKTtcbiAgICAgIGlmIChfdGhpczUuc3RvcHBlZCkgdGhyb3cgbmV3IEtleURvd25sb2FkRXJyb3IoS2V5RG93bmxvYWRFcnJvckNvZGUuU1RPUFBFRCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzID0geWllbGQgX3RoaXM1LnJlcXVlc3RSb29tS2V5RnJvbUJhY2t1cChjb25maWd1cmF0aW9uLmJhY2t1cFZlcnNpb24sIHRhcmdldFJvb21JZCwgdGFyZ2V0U2Vzc2lvbklkKTtcbiAgICAgICAgX3RoaXM1LmxvZ2dlci5kZWJ1ZyhcIkdvdCBrZXkgZnJvbSBiYWNrdXAgZm9yIHNlc3Npb25JZDpcIi5jb25jYXQodGFyZ2V0U2Vzc2lvbklkKSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChfdGhpczUuc3RvcHBlZCkgdGhyb3cgbmV3IEtleURvd25sb2FkRXJyb3IoS2V5RG93bmxvYWRFcnJvckNvZGUuU1RPUFBFRCk7XG4gICAgICAgIF90aGlzNS5sb2dnZXIuaW5mbyhcIk5vIGx1Y2sgcmVxdWVzdGluZyBrZXkgYmFja3VwIGZvciBzZXNzaW9uIFwiLmNvbmNhdCh0YXJnZXRTZXNzaW9uSWQsIFwiOiBcIikuY29uY2F0KGUpKTtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBNYXRyaXhFcnJvcikge1xuICAgICAgICAgIHZhciBlcnJDb2RlID0gZS5kYXRhLmVycmNvZGU7XG4gICAgICAgICAgaWYgKGVyckNvZGUgPT0gXCJNX05PVF9GT1VORFwiKSB7XG4gICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5IHRoZSBzcGVjIGRvZXNuJ3QgZ2l2ZSB1cyBhIHdheSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gYSBtaXNzaW5nIGtleSBhbmQgYSB3cm9uZyB2ZXJzaW9uLlxuICAgICAgICAgICAgLy8gU3luYXBzZSB3aWxsIHJldHVybjpcbiAgICAgICAgICAgIC8vICAgICAtIFwiZXJyb3JcIjogXCJVbmtub3duIGJhY2t1cCB2ZXJzaW9uXCIgaWYgdGhlIHZlcnNpb24gaXMgd3JvbmcuXG4gICAgICAgICAgICAvLyAgICAgLSBcImVycm9yXCI6IFwiTm8gcm9vbV9rZXlzIGZvdW5kXCIgaWYgdGhlIGtleSBpcyBtaXNzaW5nLlxuICAgICAgICAgICAgLy8gSXQncyB1c2VmdWwgdG8ga25vdyBpZiB0aGUga2V5IGlzIG1pc3Npbmcgb3IgaWYgdGhlIHZlcnNpb24gaXMgd3JvbmcuXG4gICAgICAgICAgICAvLyBBcyBpdCdzIG5vdCBzcGVjJ2VkLCB3ZSBmYWxsIGJhY2sgb24gY29uc2lkZXJpbmcgdGhlIGtleSBpcyBub3QgaW4gYmFja3VwLlxuICAgICAgICAgICAgLy8gTm90aWNlIHRoYXQgdGhpcyByZXF1ZXN0IHdpbGwgYmUgbG9zdCBpZiBpbnN0ZWFkIHRoZSBiYWNrdXAgZ290IG91dCBvZiBzeW5jICh1cGRhdGVkIGZyb20gb3RoZXIgc2Vzc2lvbikuXG4gICAgICAgICAgICB0aHJvdyBuZXcgS2V5RG93bmxvYWRFcnJvcihLZXlEb3dubG9hZEVycm9yQ29kZS5NSVNTSU5HX0RFQ1JZUFRJT05fS0VZKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGUuaXNSYXRlTGltaXRFcnJvcigpKSB7XG4gICAgICAgICAgICB2YXIgX3dhaXRUaW1lO1xuICAgICAgICAgICAgdmFyIHdhaXRUaW1lO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIF9lJGdldFJldHJ5QWZ0ZXJNcztcbiAgICAgICAgICAgICAgd2FpdFRpbWUgPSAoX2UkZ2V0UmV0cnlBZnRlck1zID0gZS5nZXRSZXRyeUFmdGVyTXMoKSkgIT09IG51bGwgJiYgX2UkZ2V0UmV0cnlBZnRlck1zICE9PSB2b2lkIDAgPyBfZSRnZXRSZXRyeUFmdGVyTXMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBfdGhpczUubG9nZ2VyLndhcm4oXCJFcnJvciB3aGlsZSByZXRyaWV2aW5nIGEgcmF0ZS1saW1pdCByZXRyeSBkZWxheVwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FpdFRpbWUgJiYgd2FpdFRpbWUgPiAwKSB7XG4gICAgICAgICAgICAgIF90aGlzNS5sb2dnZXIuaW5mbyhcIlJhdGUgbGltaXRlZCBieSBzZXJ2ZXIsIHdhaXRpbmcgXCIuY29uY2F0KHdhaXRUaW1lLCBcIm1zXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlEb3dubG9hZFJhdGVMaW1pdEVycm9yKChfd2FpdFRpbWUgPSB3YWl0VGltZSkgIT09IG51bGwgJiYgX3dhaXRUaW1lICE9PSB2b2lkIDAgPyBfd2FpdFRpbWUgOiBLRVlfQkFDS1VQX0JBQ0tPRkYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgS2V5RG93bmxvYWRFcnJvcihLZXlEb3dubG9hZEVycm9yQ29kZS5ORVRXT1JLX0VSUk9SKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG4gIGRlY3J5cHRBbmRJbXBvcnQoc2Vzc2lvbkluZm8sIGRhdGEsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBzZXNzaW9uc1RvSW1wb3J0ID0ge1xuICAgICAgICBbc2Vzc2lvbkluZm8ubWVnb2xtU2Vzc2lvbklkXTogZGF0YVxuICAgICAgfTtcbiAgICAgIHZhciBrZXlzID0geWllbGQgY29uZmlndXJhdGlvbi5kZWNyeXB0b3IuZGVjcnlwdFNlc3Npb25zKHNlc3Npb25zVG9JbXBvcnQpO1xuICAgICAgZm9yICh2YXIgayBvZiBrZXlzKSB7XG4gICAgICAgIGsucm9vbV9pZCA9IHNlc3Npb25JbmZvLnJvb21JZDtcbiAgICAgIH1cbiAgICAgIHlpZWxkIF90aGlzNi5iYWNrdXBNYW5hZ2VyLmltcG9ydEJhY2tlZFVwUm9vbUtleXMoa2V5cywgY29uZmlndXJhdGlvbi5iYWNrdXBWZXJzaW9uKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgYmFja3VwIGNvbmZpZ3VyYXRpb24gb3IgY3JlYXRlIG9uZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgKlxuICAgKiBXaGVuIGEgdmFsaWQgY29uZmlndXJhdGlvbiBpcyBmb3VuZCBpdCBpcyBjYWNoZWQgYW5kIHJldHVybmVkIGZvciBzdWJzZXF1ZW50IGNhbGxzLlxuICAgKiBPdGhlcndpc2UsIGlmIGEgY2hlY2sgaXMgZm9yY2VkIG9yIGEgY2hlY2sgaGFzIG5vdCB5ZXQgYmVlbiBkb25lLCBhIG5ldyBjaGVjayBpcyBkb25lLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgYmFja3VwIGNvbmZpZ3VyYXRpb24gdG8gdXNlIG9yIG51bGwgaWYgdGhlcmUgaXMgYSBjb25maWd1cmF0aW9uIHByb2JsZW0uXG4gICAqL1xuICBnZXRPckNyZWF0ZUJhY2t1cENvbmZpZ3VyYXRpb24oKSB7XG4gICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoX3RoaXM3LmNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNy5jb25maWd1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBhbHJlYWR5IHRyaWVkIHRvIGNoZWNrIHRoZSBjb25maWd1cmF0aW9uIGFuZCBpdCBmYWlsZWQuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHRyeSBhZ2FpbiBpbW1lZGlhdGVseSwgd2Ugd2lsbCByZXRyeSBpZiBhIGNvbmZpZ3VyYXRpb24gY2hhbmdlIGlzIGRldGVjdGVkLlxuICAgICAgaWYgKF90aGlzNy5oYXNDb25maWd1cmF0aW9uUHJvYmxlbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCByYXBpZGx5IGJ5IHNldmVyYWwgZW1pdHRlZCBDcnlwdG9FdmVudCwgc28gd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndFxuICAgICAgLy8gcXVlcnkgdGhlIHNlcnZlciBzZXZlcmFsIHRpbWVzLlxuICAgICAgaWYgKF90aGlzNy5jdXJyZW50QmFja3VwVmVyc2lvbkNoZWNrICE9IG51bGwpIHtcbiAgICAgICAgX3RoaXM3LmxvZ2dlci5kZWJ1ZyhcIkFscmVhZHkgY2hlY2tpbmcgc2VydmVyIHZlcnNpb24sIHVzZSBjdXJyZW50IHByb21pc2VcIik7XG4gICAgICAgIHJldHVybiB5aWVsZCBfdGhpczcuY3VycmVudEJhY2t1cFZlcnNpb25DaGVjaztcbiAgICAgIH1cbiAgICAgIF90aGlzNy5jdXJyZW50QmFja3VwVmVyc2lvbkNoZWNrID0gX3RoaXM3LmludGVybmFsQ2hlY2tGcm9tU2VydmVyKCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4geWllbGQgX3RoaXM3LmN1cnJlbnRCYWNrdXBWZXJzaW9uQ2hlY2s7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfdGhpczcuY3VycmVudEJhY2t1cFZlcnNpb25DaGVjayA9IG51bGw7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuICBpbnRlcm5hbENoZWNrRnJvbVNlcnZlcigpIHtcbiAgICB2YXIgX3RoaXM4ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfY3VycmVudFNlcnZlclZlcnNpb24sIF9jdXJyZW50U2VydmVyVmVyc2lvbjIsIF9jdXJyZW50U2VydmVyVmVyc2lvbjQ7XG4gICAgICB2YXIgY3VycmVudFNlcnZlclZlcnNpb24gPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY3VycmVudFNlcnZlclZlcnNpb24gPSB5aWVsZCBfdGhpczguYmFja3VwTWFuYWdlci5nZXRTZXJ2ZXJCYWNrdXBJbmZvKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIF90aGlzOC5sb2dnZXIuZGVidWcoXCJCYWNrdXA6IGVycm9yIHdoaWxlIGNoZWNraW5nIHNlcnZlciB2ZXJzaW9uOiBcIi5jb25jYXQoZSkpO1xuICAgICAgICBfdGhpczguaGFzQ29uZmlndXJhdGlvblByb2JsZW0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIF90aGlzOC5sb2dnZXIuZGVidWcoXCJHb3QgY3VycmVudCBiYWNrdXAgdmVyc2lvbiBmcm9tIHNlcnZlcjogXCIuY29uY2F0KChfY3VycmVudFNlcnZlclZlcnNpb24gPSBjdXJyZW50U2VydmVyVmVyc2lvbikgPT09IG51bGwgfHwgX2N1cnJlbnRTZXJ2ZXJWZXJzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY3VycmVudFNlcnZlclZlcnNpb24udmVyc2lvbikpO1xuICAgICAgaWYgKCgoX2N1cnJlbnRTZXJ2ZXJWZXJzaW9uMiA9IGN1cnJlbnRTZXJ2ZXJWZXJzaW9uKSA9PT0gbnVsbCB8fCBfY3VycmVudFNlcnZlclZlcnNpb24yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY3VycmVudFNlcnZlclZlcnNpb24yLmFsZ29yaXRobSkgIT0gXCJtLm1lZ29sbV9iYWNrdXAudjEuY3VydmUyNTUxOS1hZXMtc2hhMlwiKSB7XG4gICAgICAgIHZhciBfY3VycmVudFNlcnZlclZlcnNpb24zO1xuICAgICAgICBfdGhpczgubG9nZ2VyLmluZm8oXCJVbnN1cHBvcnRlZCBhbGdvcml0aG0gXCIuY29uY2F0KChfY3VycmVudFNlcnZlclZlcnNpb24zID0gY3VycmVudFNlcnZlclZlcnNpb24pID09PSBudWxsIHx8IF9jdXJyZW50U2VydmVyVmVyc2lvbjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jdXJyZW50U2VydmVyVmVyc2lvbjMuYWxnb3JpdGhtKSk7XG4gICAgICAgIF90aGlzOC5oYXNDb25maWd1cmF0aW9uUHJvYmxlbSA9IHRydWU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCEoKF9jdXJyZW50U2VydmVyVmVyc2lvbjQgPSBjdXJyZW50U2VydmVyVmVyc2lvbikgIT09IG51bGwgJiYgX2N1cnJlbnRTZXJ2ZXJWZXJzaW9uNCAhPT0gdm9pZCAwICYmIF9jdXJyZW50U2VydmVyVmVyc2lvbjQudmVyc2lvbikpIHtcbiAgICAgICAgX3RoaXM4LmxvZ2dlci5pbmZvKFwiTm8gY3VycmVudCBrZXkgYmFja3VwXCIpO1xuICAgICAgICBfdGhpczguaGFzQ29uZmlndXJhdGlvblByb2JsZW0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVWZXJzaW9uID0geWllbGQgX3RoaXM4LmJhY2t1cE1hbmFnZXIuZ2V0QWN0aXZlQmFja3VwVmVyc2lvbigpO1xuICAgICAgaWYgKGFjdGl2ZVZlcnNpb24gPT0gbnVsbCB8fCBjdXJyZW50U2VydmVyVmVyc2lvbi52ZXJzaW9uICE9IGFjdGl2ZVZlcnNpb24pIHtcbiAgICAgICAgLy8gRWl0aGVyIHRoZSBjdXJyZW50IGJhY2t1cCB2ZXJzaW9uIG9uIHNlcnZlciBzaWRlIGlzIG5vdCB0cnVzdGVkLCBvciBpdCBpcyBvdXQgb2Ygc3luYyB3aXRoIHRoZSBhY3RpdmUgdmVyc2lvbiBvbiB0aGUgY2xpZW50IHNpZGUuXG4gICAgICAgIF90aGlzOC5sb2dnZXIuaW5mbyhcIlRoZSBjdXJyZW50IGJhY2t1cCB2ZXJzaW9uIG9uIHRoZSBzZXJ2ZXIgKFwiLmNvbmNhdChjdXJyZW50U2VydmVyVmVyc2lvbi52ZXJzaW9uLCBcIikgaXMgbm90IHRydXN0ZWQuIFZlcnNpb24gd2UgYXJlIGN1cnJlbnRseSBiYWNraW5nIHVwIHRvOiBcIikuY29uY2F0KGFjdGl2ZVZlcnNpb24pKTtcbiAgICAgICAgX3RoaXM4Lmhhc0NvbmZpZ3VyYXRpb25Qcm9ibGVtID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgYmFja3VwS2V5cyA9IHlpZWxkIF90aGlzOC5nZXRCYWNrdXBEZWNyeXB0aW9uS2V5KCk7XG4gICAgICBpZiAoIShiYWNrdXBLZXlzICE9PSBudWxsICYmIGJhY2t1cEtleXMgIT09IHZvaWQgMCAmJiBiYWNrdXBLZXlzLmRlY3J5cHRpb25LZXkpKSB7XG4gICAgICAgIF90aGlzOC5sb2dnZXIuZGVidWcoXCJOb3QgY2hlY2tpbmcga2V5IGJhY2t1cCBmb3Igc2Vzc2lvbiAobm8gZGVjcnlwdGlvbiBrZXkpXCIpO1xuICAgICAgICBfdGhpczguaGFzQ29uZmlndXJhdGlvblByb2JsZW0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVWZXJzaW9uICE9IGJhY2t1cEtleXMuYmFja3VwVmVyc2lvbikge1xuICAgICAgICBfdGhpczgubG9nZ2VyLmRlYnVnKFwiVmVyc2lvbiBmb3Igd2hpY2ggd2UgaGF2ZSBhIGRlY3J5cHRpb24ga2V5IChcIi5jb25jYXQoYmFja3VwS2V5cy5iYWNrdXBWZXJzaW9uLCBcIikgZG9lc24ndCBtYXRjaCB0aGUgdmVyc2lvbiB3ZSBhcmUgYmFja2luZyB1cCB0byAoXCIpLmNvbmNhdChhY3RpdmVWZXJzaW9uLCBcIilcIikpO1xuICAgICAgICBfdGhpczguaGFzQ29uZmlndXJhdGlvblByb2JsZW0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBhdXRoRGF0YSA9IGN1cnJlbnRTZXJ2ZXJWZXJzaW9uLmF1dGhfZGF0YTtcbiAgICAgIGlmIChhdXRoRGF0YS5wdWJsaWNfa2V5ICE9IGJhY2t1cEtleXMuZGVjcnlwdGlvbktleS5tZWdvbG1WMVB1YmxpY0tleS5wdWJsaWNLZXlCYXNlNjQpIHtcbiAgICAgICAgX3RoaXM4LmxvZ2dlci5kZWJ1ZyhcIktleSBiYWNrdXAgb24gc2VydmVyIGRvZXMgbm90IG1hdGNoIG91ciBkZWNyeXB0aW9uIGtleVwiKTtcbiAgICAgICAgX3RoaXM4Lmhhc0NvbmZpZ3VyYXRpb25Qcm9ibGVtID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgYmFja3VwRGVjcnlwdG9yID0gX3RoaXM4LmJhY2t1cE1hbmFnZXIuY3JlYXRlQmFja3VwRGVjcnlwdG9yKGJhY2t1cEtleXMuZGVjcnlwdGlvbktleSk7XG4gICAgICBfdGhpczguaGFzQ29uZmlndXJhdGlvblByb2JsZW0gPSBmYWxzZTtcbiAgICAgIF90aGlzOC5jb25maWd1cmF0aW9uID0ge1xuICAgICAgICBkZWNyeXB0b3I6IGJhY2t1cERlY3J5cHRvcixcbiAgICAgICAgYmFja3VwVmVyc2lvbjogYWN0aXZlVmVyc2lvblxuICAgICAgfTtcbiAgICAgIHJldHVybiBfdGhpczguY29uZmlndXJhdGlvbjtcbiAgICB9KSgpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QZXJTZXNzaW9uS2V5QmFja3VwRG93bmxvYWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/PerSessionKeyBackupDownloader.js\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/RoomEncryptor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/RoomEncryptor.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RoomEncryptor: () => (/* binding */ RoomEncryptor),\n/* harmony export */   toRustHistoryVisibility: () => (/* binding */ toRustHistoryVisibility)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @matrix-org/matrix-sdk-crypto-wasm */ \"./node_modules/@matrix-org/matrix-sdk-crypto-wasm/index.mjs\");\n/* harmony import */ var _types_event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../@types/event.js */ \"./node_modules/matrix-js-sdk/lib/@types/event.js\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../logger.js */ \"./node_modules/matrix-js-sdk/lib/logger.js\");\n/* harmony import */ var _types_partials_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../@types/partials.js */ \"./node_modules/matrix-js-sdk/lib/@types/partials.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/matrix-js-sdk/lib/utils.js\");\n/* harmony import */ var _types_membership_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../@types/membership.js */ \"./node_modules/matrix-js-sdk/lib/@types/membership.js\");\n/* harmony import */ var _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../crypto-api/index.js */ \"./node_modules/matrix-js-sdk/lib/crypto-api/index.js\");\n\n\n/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n\n\n\n\n\n\n\n\n/**\n * RoomEncryptor: responsible for encrypting messages to a given room\n *\n * @internal\n */\nclass RoomEncryptor {\n  /**\n   * @param olmMachine - The rust-sdk's OlmMachine\n   * @param keyClaimManager - Our KeyClaimManager, which manages the queue of one-time-key claim requests\n   * @param outgoingRequestManager - The OutgoingRequestManager, which manages the queue of outgoing requests.\n   * @param room - The room we want to encrypt for\n   * @param encryptionSettings - body of the m.room.encryption event currently in force in this room\n   */\n  constructor(olmMachine, keyClaimManager, outgoingRequestManager, room, encryptionSettings) {\n    this.olmMachine = olmMachine;\n    this.keyClaimManager = keyClaimManager;\n    this.outgoingRequestManager = outgoingRequestManager;\n    this.room = room;\n    this.encryptionSettings = encryptionSettings;\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"prefixedLogger\", void 0);\n    /** whether the room members have been loaded and tracked for the first time */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"lazyLoadedMembersResolved\", false);\n    /**\n     * Ensures that there is only one encryption operation at a time for that room.\n     *\n     * An encryption operation is either a {@link prepareForEncryption} or an {@link encryptEvent} call.\n     */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"currentEncryptionPromise\", Promise.resolve());\n    this.prefixedLogger = _logger_js__WEBPACK_IMPORTED_MODULE_4__.logger.getChild(\"[\".concat(room.roomId, \" encryption]\"));\n\n    // start tracking devices for any users already known to be in this room.\n    // Do not load members here, would defeat lazy loading.\n    var members = room.getJoinedMembers();\n\n    // At this point just mark the known members as tracked, it might not be the full list of members\n    // because of lazy loading. This is fine, because we will get a member list update when sending a message for\n    // the first time, see `RoomEncryptor#ensureEncryptionSession`\n    this.olmMachine.updateTrackedUsers(members.map(u => new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.UserId(u.userId))).catch(e => this.prefixedLogger.error(\"Error initializing tracked users\", e));\n  }\n\n  /**\n   * Handle a new `m.room.encryption` event in this room\n   *\n   * @param config - The content of the encryption event\n   */\n  onCryptoEvent(config) {\n    if (JSON.stringify(this.encryptionSettings) != JSON.stringify(config)) {\n      // This should currently be unreachable, since the Rust SDK will reject any attempts to change config.\n      throw new Error(\"Cannot reconfigure an active RoomEncryptor\");\n    }\n  }\n\n  /**\n   * Handle a new `m.room.member` event in this room\n   *\n   * @param member - new membership state\n   */\n  onRoomMembership(member) {\n    if (member.membership == _types_membership_js__WEBPACK_IMPORTED_MODULE_7__.KnownMembership.Join || member.membership == _types_membership_js__WEBPACK_IMPORTED_MODULE_7__.KnownMembership.Invite && this.room.shouldEncryptForInvitedMembers()) {\n      // make sure we are tracking the deviceList for this user\n      this.olmMachine.updateTrackedUsers([new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.UserId(member.userId)]).catch(e => {\n        this.prefixedLogger.error(\"Unable to update tracked users\", e);\n      });\n    }\n\n    // TODO: handle leaves (including our own)\n  }\n\n  /**\n   * Prepare to encrypt events in this room.\n   *\n   * This ensures that we have a megolm session ready to use and that we have shared its key with all the devices\n   * in the room.\n   * @param globalBlacklistUnverifiedDevices - When `true`, and `deviceIsolationMode` is `AllDevicesIsolationMode`,\n   * will not send encrypted messages to unverified devices.\n   * Ignored when `deviceIsolationMode` is `OnlySignedDevicesIsolationMode`.\n   * @param deviceIsolationMode - The device isolation mode. See {@link DeviceIsolationMode}.\n   */\n  prepareForEncryption(globalBlacklistUnverifiedDevices, deviceIsolationMode) {\n    var _this = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // We consider a prepareForEncryption as an encryption promise as it will potentially share keys\n      // even if it doesn't send an event.\n      // Usually this is called when the user starts typing, so we want to make sure we have keys ready when the\n      // message is finally sent.\n      // If `encryptEvent` is invoked before `prepareForEncryption` has completed, the `encryptEvent` call will wait for\n      // `prepareForEncryption` to complete before executing.\n      // The part where `encryptEvent` shares the room key will then usually be a no-op as it was already performed by `prepareForEncryption`.\n      yield _this.encryptEvent(null, globalBlacklistUnverifiedDevices, deviceIsolationMode);\n    })();\n  }\n\n  /**\n   * Encrypt an event for this room, or prepare for encryption.\n   *\n   * This will ensure that we have a megolm session for this room, share it with the devices in the room, and\n   * then, if an event is provided, encrypt it using the session.\n   *\n   * @param event - Event to be encrypted, or null if only preparing for encryption (in which case we will pre-share the room key).\n   * @param globalBlacklistUnverifiedDevices - When `true`, and `deviceIsolationMode` is `AllDevicesIsolationMode`,\n   * will not send encrypted messages to unverified devices.\n   * Ignored when `deviceIsolationMode` is `OnlySignedDevicesIsolationMode`.\n   * @param deviceIsolationMode - The device isolation mode. See {@link DeviceIsolationMode}.\n   */\n  encryptEvent(event, globalBlacklistUnverifiedDevices, deviceIsolationMode) {\n    var _event$getTxnId,\n      _this2 = this;\n    var logger = new _logger_js__WEBPACK_IMPORTED_MODULE_4__.LogSpan(this.prefixedLogger, event ? (_event$getTxnId = event.getTxnId()) !== null && _event$getTxnId !== void 0 ? _event$getTxnId : \"\" : \"prepareForEncryption\");\n    // Ensure order of encryption to avoid message ordering issues, as the scheduler only ensures\n    // events order after they have been encrypted.\n    var prom = this.currentEncryptionPromise.catch(() => {\n      // Any errors in the previous call will have been reported already, so there is nothing to do here.\n      // we just throw away the error and start anew.\n    }).then(/*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.logDuration)(logger, \"ensureEncryptionSession\", /*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n        yield _this2.ensureEncryptionSession(logger, globalBlacklistUnverifiedDevices, deviceIsolationMode);\n      }));\n      if (event) {\n        yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.logDuration)(logger, \"encryptEventInner\", /*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n          yield _this2.encryptEventInner(logger, event);\n        }));\n      }\n    }));\n    this.currentEncryptionPromise = prom;\n    return prom;\n  }\n\n  /**\n   * Prepare to encrypt events in this room.\n   *\n   * This ensures that we have a megolm session ready to use and that we have shared its key with all the devices\n   * in the room.\n   *\n   * @param logger - a place to write diagnostics to\n   * @param globalBlacklistUnverifiedDevices - When `true`, and `deviceIsolationMode` is `AllDevicesIsolationMode`,\n   * will not send encrypted messages to unverified devices.\n   * Ignored when `deviceIsolationMode` is `OnlySignedDevicesIsolationMode`.\n   * @param deviceIsolationMode - The device isolation mode. See {@link DeviceIsolationMode}.\n   */\n  ensureEncryptionSession(logger, globalBlacklistUnverifiedDevices, deviceIsolationMode) {\n    var _this3 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      if (_this3.encryptionSettings.algorithm !== \"m.megolm.v1.aes-sha2\") {\n        throw new Error(\"Cannot encrypt in \".concat(_this3.room.roomId, \" for unsupported algorithm '\").concat(_this3.encryptionSettings.algorithm, \"'\"));\n      }\n      logger.debug(\"Starting encryption\");\n      var members = yield _this3.room.getEncryptionTargetMembers();\n\n      // If this is the first time we are sending a message to the room, we may not yet have seen all the members\n      // (so the Crypto SDK might not have a device list for them). So, if this is the first time we are encrypting\n      // for this room, give the SDK the full list of members, to be on the safe side.\n      //\n      // This could end up being racy (if two calls to ensureEncryptionSession happen at the same time), but that's\n      // not a particular problem, since `OlmMachine.updateTrackedUsers` just adds any users that weren't already tracked.\n      if (!_this3.lazyLoadedMembersResolved) {\n        yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.logDuration)(_this3.prefixedLogger, \"loadMembersIfNeeded: updateTrackedUsers\", /*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n          yield _this3.olmMachine.updateTrackedUsers(members.map(u => new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.UserId(u.userId)));\n        }));\n        logger.debug(\"Updated tracked users\");\n        _this3.lazyLoadedMembersResolved = true;\n\n        // Query keys in case we don't have them for newly tracked members.\n        // It's important after loading members for the first time, as likely most of them won't be\n        // known yet and will be unable to decrypt messages despite being in the room for long.\n        // This must be done before ensuring sessions. If not the devices of these users are not\n        // known yet and will not get the room key.\n        // We don't have API to only get the keys queries related to this member list, so we just\n        // process the pending requests from the olmMachine. (usually these are processed\n        // at the end of the sync, but we can't wait for that).\n        // XXX future improvement process only KeysQueryRequests for the users that have never been queried.\n        logger.debug(\"Processing outgoing requests\");\n        yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.logDuration)(_this3.prefixedLogger, \"doProcessOutgoingRequests\", /*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n          yield _this3.outgoingRequestManager.doProcessOutgoingRequests();\n        }));\n      } else {\n        // If members are already loaded it's less critical to await on key queries.\n        // We might still want to trigger a processOutgoingRequests here.\n        // The call to `ensureSessionsForUsers` below will wait a bit on in-flight key queries we are\n        // interested in. If a sync handling happens in the meantime, and some new members are added to the room\n        // or have new devices it would give us a chance to query them before sending.\n        // It's less critical due to the racy nature of this process.\n        logger.debug(\"Processing outgoing requests in background\");\n        _this3.outgoingRequestManager.doProcessOutgoingRequests();\n      }\n      logger.debug(\"Encrypting for users (shouldEncryptForInvitedMembers: \".concat(_this3.room.shouldEncryptForInvitedMembers(), \"):\"), members.map(u => \"\".concat(u.userId, \" (\").concat(u.membership, \")\")));\n      var userList = members.map(u => new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.UserId(u.userId));\n      yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.logDuration)(_this3.prefixedLogger, \"ensureSessionsForUsers\", /*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n        yield _this3.keyClaimManager.ensureSessionsForUsers(logger, userList);\n      }));\n      var rustEncryptionSettings = new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.EncryptionSettings();\n      rustEncryptionSettings.historyVisibility = toRustHistoryVisibility(_this3.room.getHistoryVisibility());\n\n      // We only support megolm\n      rustEncryptionSettings.algorithm = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.EncryptionAlgorithm.MegolmV1AesSha2;\n\n      // We need to convert the rotation period from milliseconds to microseconds\n      // See https://spec.matrix.org/v1.8/client-server-api/#mroomencryption and\n      // https://matrix-org.github.io/matrix-rust-sdk-crypto-wasm/classes/EncryptionSettings.html#rotationPeriod\n      if (typeof _this3.encryptionSettings.rotation_period_ms === \"number\") {\n        rustEncryptionSettings.rotationPeriod = BigInt(_this3.encryptionSettings.rotation_period_ms * 1000);\n      }\n      if (typeof _this3.encryptionSettings.rotation_period_msgs === \"number\") {\n        rustEncryptionSettings.rotationPeriodMessages = BigInt(_this3.encryptionSettings.rotation_period_msgs);\n      }\n      switch (deviceIsolationMode.kind) {\n        case _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_8__.DeviceIsolationModeKind.AllDevicesIsolationMode:\n          {\n            var _this3$room$getBlackl;\n            // When this.room.getBlacklistUnverifiedDevices() === null, the global settings should be used\n            // See Room#getBlacklistUnverifiedDevices\n            var onlyAllowTrustedDevices = (_this3$room$getBlackl = _this3.room.getBlacklistUnverifiedDevices()) !== null && _this3$room$getBlackl !== void 0 ? _this3$room$getBlackl : globalBlacklistUnverifiedDevices;\n            rustEncryptionSettings.sharingStrategy = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.CollectStrategy.deviceBasedStrategy(onlyAllowTrustedDevices, deviceIsolationMode.errorOnVerifiedUserProblems);\n          }\n          break;\n        case _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_8__.DeviceIsolationModeKind.OnlySignedDevicesIsolationMode:\n          rustEncryptionSettings.sharingStrategy = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.CollectStrategy.identityBasedStrategy();\n          break;\n      }\n      yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.logDuration)(_this3.prefixedLogger, \"shareRoomKey\", /*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n        var shareMessages = yield _this3.olmMachine.shareRoomKey(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.RoomId(_this3.room.roomId),\n        // safe to pass without cloning, as it's not reused here (before or after)\n        userList, rustEncryptionSettings);\n        if (shareMessages) {\n          for (var m of shareMessages) {\n            yield _this3.outgoingRequestManager.outgoingRequestProcessor.makeOutgoingRequest(m);\n          }\n        }\n      }));\n    })();\n  }\n\n  /**\n   * Discard any existing group session for this room\n   */\n  forceDiscardSession() {\n    var _this4 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var r = yield _this4.olmMachine.invalidateGroupSession(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.RoomId(_this4.room.roomId));\n      if (r) {\n        _this4.prefixedLogger.info(\"Discarded existing group session\");\n      }\n    })();\n  }\n  encryptEventInner(logger, event) {\n    var _this5 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      logger.debug(\"Encrypting actual message content\");\n      var encryptedContent = yield _this5.olmMachine.encryptRoomEvent(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.RoomId(_this5.room.roomId), event.getType(), JSON.stringify(event.getContent()));\n      event.makeEncrypted(_types_event_js__WEBPACK_IMPORTED_MODULE_3__.EventType.RoomMessageEncrypted, JSON.parse(encryptedContent), _this5.olmMachine.identityKeys.curve25519.toBase64(), _this5.olmMachine.identityKeys.ed25519.toBase64());\n      logger.debug(\"Encrypted event successfully\");\n    })();\n  }\n}\n\n/**\n * Convert a HistoryVisibility to a RustHistoryVisibility\n * @param visibility - HistoryVisibility enum\n * @returns a RustHistoryVisibility enum\n */\nfunction toRustHistoryVisibility(visibility) {\n  switch (visibility) {\n    case _types_partials_js__WEBPACK_IMPORTED_MODULE_5__.HistoryVisibility.Invited:\n      return _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.HistoryVisibility.Invited;\n    case _types_partials_js__WEBPACK_IMPORTED_MODULE_5__.HistoryVisibility.Joined:\n      return _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.HistoryVisibility.Joined;\n    case _types_partials_js__WEBPACK_IMPORTED_MODULE_5__.HistoryVisibility.Shared:\n      return _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.HistoryVisibility.Shared;\n    case _types_partials_js__WEBPACK_IMPORTED_MODULE_5__.HistoryVisibility.WorldReadable:\n      return _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.HistoryVisibility.WorldReadable;\n  }\n}\n//# sourceMappingURL=RoomEncryptor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vUm9vbUVuY3J5cHRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF3RTtBQUNKO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0U7QUFDb0c7QUFDM0g7QUFDQTtBQUNXO0FBQ2hCO0FBQ2dCO0FBQ087O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBLElBQUksaUZBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDRCQUE0QixPQUFPLG9CQUFvQjtBQUNuRztBQUNBLElBQUksaUZBQWU7QUFDbkIsMEJBQTBCLDhDQUFNOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHNFQUFzQjtBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRUFBZSw4QkFBOEIsaUVBQWU7QUFDekY7QUFDQSw4Q0FBOEMsc0VBQU07QUFDcEQ7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDBCQUEwQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDBCQUEwQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQ0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0IsbUZBQWlCO0FBQzFDLFlBQVksc0RBQVcsaURBQWlELG1GQUFpQjtBQUN6RjtBQUNBLE9BQU87QUFDUDtBQUNBLGNBQWMsc0RBQVcsMkNBQTJDLG1GQUFpQjtBQUNyRjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsMEJBQTBCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFXLGdGQUFnRixtRkFBaUI7QUFDMUgsMEVBQTBFLHNFQUFzQjtBQUNoRyxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0RBQVcsa0VBQWtFLG1GQUFpQjtBQUM1RztBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0VBQU07QUFDaEQsWUFBWSxzREFBVywrREFBK0QsbUZBQWlCO0FBQ3ZHO0FBQ0EsT0FBTztBQUNQLHVDQUF1QyxrRkFBa0I7QUFDekQ7O0FBRUE7QUFDQSx5Q0FBeUMsbUZBQW1COztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUVBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsK0VBQWU7QUFDcEU7QUFDQTtBQUNBLGFBQWEseUVBQXVCO0FBQ3BDLG1EQUFtRCwrRUFBZTtBQUNsRTtBQUNBO0FBQ0EsWUFBWSxzREFBVyxxREFBcUQsbUZBQWlCO0FBQzdGLHFFQUFxRSxzRUFBTTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCLGlFQUFpRSxzRUFBTTtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQSwwRUFBMEUsc0VBQU07QUFDaEYsMEJBQTBCLHNEQUFTO0FBQ25DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxTQUFTLGlFQUFpQjtBQUMxQixhQUFhLGlGQUFxQjtBQUNsQyxTQUFTLGlFQUFpQjtBQUMxQixhQUFhLGlGQUFxQjtBQUNsQyxTQUFTLGlFQUFpQjtBQUMxQixhQUFhLGlGQUFxQjtBQUNsQyxTQUFTLGlFQUFpQjtBQUMxQixhQUFhLGlGQUFxQjtBQUNsQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc3Rlcmljcy1ncmlkLy4vbm9kZV9tb2R1bGVzL21hdHJpeC1qcy1zZGsvbGliL3J1c3QtY3J5cHRvL1Jvb21FbmNyeXB0b3IuanM/OTdhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2FzeW5jVG9HZW5lcmF0b3IgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiO1xuLypcbkNvcHlyaWdodCAyMDIzIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0ICogYXMgUnVzdFNka0NyeXB0b0pzIGZyb20gXCJAbWF0cml4LW9yZy9tYXRyaXgtc2RrLWNyeXB0by13YXNtXCI7XG5pbXBvcnQgeyBDb2xsZWN0U3RyYXRlZ3ksIEVuY3J5cHRpb25BbGdvcml0aG0sIEVuY3J5cHRpb25TZXR0aW5ncywgSGlzdG9yeVZpc2liaWxpdHkgYXMgUnVzdEhpc3RvcnlWaXNpYmlsaXR5LCBSb29tSWQsIFVzZXJJZCB9IGZyb20gXCJAbWF0cml4LW9yZy9tYXRyaXgtc2RrLWNyeXB0by13YXNtXCI7XG5pbXBvcnQgeyBFdmVudFR5cGUgfSBmcm9tIFwiLi4vQHR5cGVzL2V2ZW50LmpzXCI7XG5pbXBvcnQgeyBsb2dnZXIsIExvZ1NwYW4gfSBmcm9tIFwiLi4vbG9nZ2VyLmpzXCI7XG5pbXBvcnQgeyBIaXN0b3J5VmlzaWJpbGl0eSB9IGZyb20gXCIuLi9AdHlwZXMvcGFydGlhbHMuanNcIjtcbmltcG9ydCB7IGxvZ0R1cmF0aW9uIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBLbm93bk1lbWJlcnNoaXAgfSBmcm9tIFwiLi4vQHR5cGVzL21lbWJlcnNoaXAuanNcIjtcbmltcG9ydCB7IERldmljZUlzb2xhdGlvbk1vZGVLaW5kIH0gZnJvbSBcIi4uL2NyeXB0by1hcGkvaW5kZXguanNcIjtcblxuLyoqXG4gKiBSb29tRW5jcnlwdG9yOiByZXNwb25zaWJsZSBmb3IgZW5jcnlwdGluZyBtZXNzYWdlcyB0byBhIGdpdmVuIHJvb21cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIFJvb21FbmNyeXB0b3Ige1xuICAvKipcbiAgICogQHBhcmFtIG9sbU1hY2hpbmUgLSBUaGUgcnVzdC1zZGsncyBPbG1NYWNoaW5lXG4gICAqIEBwYXJhbSBrZXlDbGFpbU1hbmFnZXIgLSBPdXIgS2V5Q2xhaW1NYW5hZ2VyLCB3aGljaCBtYW5hZ2VzIHRoZSBxdWV1ZSBvZiBvbmUtdGltZS1rZXkgY2xhaW0gcmVxdWVzdHNcbiAgICogQHBhcmFtIG91dGdvaW5nUmVxdWVzdE1hbmFnZXIgLSBUaGUgT3V0Z29pbmdSZXF1ZXN0TWFuYWdlciwgd2hpY2ggbWFuYWdlcyB0aGUgcXVldWUgb2Ygb3V0Z29pbmcgcmVxdWVzdHMuXG4gICAqIEBwYXJhbSByb29tIC0gVGhlIHJvb20gd2Ugd2FudCB0byBlbmNyeXB0IGZvclxuICAgKiBAcGFyYW0gZW5jcnlwdGlvblNldHRpbmdzIC0gYm9keSBvZiB0aGUgbS5yb29tLmVuY3J5cHRpb24gZXZlbnQgY3VycmVudGx5IGluIGZvcmNlIGluIHRoaXMgcm9vbVxuICAgKi9cbiAgY29uc3RydWN0b3Iob2xtTWFjaGluZSwga2V5Q2xhaW1NYW5hZ2VyLCBvdXRnb2luZ1JlcXVlc3RNYW5hZ2VyLCByb29tLCBlbmNyeXB0aW9uU2V0dGluZ3MpIHtcbiAgICB0aGlzLm9sbU1hY2hpbmUgPSBvbG1NYWNoaW5lO1xuICAgIHRoaXMua2V5Q2xhaW1NYW5hZ2VyID0ga2V5Q2xhaW1NYW5hZ2VyO1xuICAgIHRoaXMub3V0Z29pbmdSZXF1ZXN0TWFuYWdlciA9IG91dGdvaW5nUmVxdWVzdE1hbmFnZXI7XG4gICAgdGhpcy5yb29tID0gcm9vbTtcbiAgICB0aGlzLmVuY3J5cHRpb25TZXR0aW5ncyA9IGVuY3J5cHRpb25TZXR0aW5ncztcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcmVmaXhlZExvZ2dlclwiLCB2b2lkIDApO1xuICAgIC8qKiB3aGV0aGVyIHRoZSByb29tIG1lbWJlcnMgaGF2ZSBiZWVuIGxvYWRlZCBhbmQgdHJhY2tlZCBmb3IgdGhlIGZpcnN0IHRpbWUgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYXp5TG9hZGVkTWVtYmVyc1Jlc29sdmVkXCIsIGZhbHNlKTtcbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgZW5jcnlwdGlvbiBvcGVyYXRpb24gYXQgYSB0aW1lIGZvciB0aGF0IHJvb20uXG4gICAgICpcbiAgICAgKiBBbiBlbmNyeXB0aW9uIG9wZXJhdGlvbiBpcyBlaXRoZXIgYSB7QGxpbmsgcHJlcGFyZUZvckVuY3J5cHRpb259IG9yIGFuIHtAbGluayBlbmNyeXB0RXZlbnR9IGNhbGwuXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY3VycmVudEVuY3J5cHRpb25Qcm9taXNlXCIsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICB0aGlzLnByZWZpeGVkTG9nZ2VyID0gbG9nZ2VyLmdldENoaWxkKFwiW1wiLmNvbmNhdChyb29tLnJvb21JZCwgXCIgZW5jcnlwdGlvbl1cIikpO1xuXG4gICAgLy8gc3RhcnQgdHJhY2tpbmcgZGV2aWNlcyBmb3IgYW55IHVzZXJzIGFscmVhZHkga25vd24gdG8gYmUgaW4gdGhpcyByb29tLlxuICAgIC8vIERvIG5vdCBsb2FkIG1lbWJlcnMgaGVyZSwgd291bGQgZGVmZWF0IGxhenkgbG9hZGluZy5cbiAgICB2YXIgbWVtYmVycyA9IHJvb20uZ2V0Sm9pbmVkTWVtYmVycygpO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCBqdXN0IG1hcmsgdGhlIGtub3duIG1lbWJlcnMgYXMgdHJhY2tlZCwgaXQgbWlnaHQgbm90IGJlIHRoZSBmdWxsIGxpc3Qgb2YgbWVtYmVyc1xuICAgIC8vIGJlY2F1c2Ugb2YgbGF6eSBsb2FkaW5nLiBUaGlzIGlzIGZpbmUsIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSBtZW1iZXIgbGlzdCB1cGRhdGUgd2hlbiBzZW5kaW5nIGEgbWVzc2FnZSBmb3JcbiAgICAvLyB0aGUgZmlyc3QgdGltZSwgc2VlIGBSb29tRW5jcnlwdG9yI2Vuc3VyZUVuY3J5cHRpb25TZXNzaW9uYFxuICAgIHRoaXMub2xtTWFjaGluZS51cGRhdGVUcmFja2VkVXNlcnMobWVtYmVycy5tYXAodSA9PiBuZXcgUnVzdFNka0NyeXB0b0pzLlVzZXJJZCh1LnVzZXJJZCkpKS5jYXRjaChlID0+IHRoaXMucHJlZml4ZWRMb2dnZXIuZXJyb3IoXCJFcnJvciBpbml0aWFsaXppbmcgdHJhY2tlZCB1c2Vyc1wiLCBlKSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgbmV3IGBtLnJvb20uZW5jcnlwdGlvbmAgZXZlbnQgaW4gdGhpcyByb29tXG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29udGVudCBvZiB0aGUgZW5jcnlwdGlvbiBldmVudFxuICAgKi9cbiAgb25DcnlwdG9FdmVudChjb25maWcpIHtcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkodGhpcy5lbmNyeXB0aW9uU2V0dGluZ3MpICE9IEpTT04uc3RyaW5naWZ5KGNvbmZpZykpIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIGN1cnJlbnRseSBiZSB1bnJlYWNoYWJsZSwgc2luY2UgdGhlIFJ1c3QgU0RLIHdpbGwgcmVqZWN0IGFueSBhdHRlbXB0cyB0byBjaGFuZ2UgY29uZmlnLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlY29uZmlndXJlIGFuIGFjdGl2ZSBSb29tRW5jcnlwdG9yXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBuZXcgYG0ucm9vbS5tZW1iZXJgIGV2ZW50IGluIHRoaXMgcm9vbVxuICAgKlxuICAgKiBAcGFyYW0gbWVtYmVyIC0gbmV3IG1lbWJlcnNoaXAgc3RhdGVcbiAgICovXG4gIG9uUm9vbU1lbWJlcnNoaXAobWVtYmVyKSB7XG4gICAgaWYgKG1lbWJlci5tZW1iZXJzaGlwID09IEtub3duTWVtYmVyc2hpcC5Kb2luIHx8IG1lbWJlci5tZW1iZXJzaGlwID09IEtub3duTWVtYmVyc2hpcC5JbnZpdGUgJiYgdGhpcy5yb29tLnNob3VsZEVuY3J5cHRGb3JJbnZpdGVkTWVtYmVycygpKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgYXJlIHRyYWNraW5nIHRoZSBkZXZpY2VMaXN0IGZvciB0aGlzIHVzZXJcbiAgICAgIHRoaXMub2xtTWFjaGluZS51cGRhdGVUcmFja2VkVXNlcnMoW25ldyBVc2VySWQobWVtYmVyLnVzZXJJZCldKS5jYXRjaChlID0+IHtcbiAgICAgICAgdGhpcy5wcmVmaXhlZExvZ2dlci5lcnJvcihcIlVuYWJsZSB0byB1cGRhdGUgdHJhY2tlZCB1c2Vyc1wiLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGhhbmRsZSBsZWF2ZXMgKGluY2x1ZGluZyBvdXIgb3duKVxuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmUgdG8gZW5jcnlwdCBldmVudHMgaW4gdGhpcyByb29tLlxuICAgKlxuICAgKiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBoYXZlIGEgbWVnb2xtIHNlc3Npb24gcmVhZHkgdG8gdXNlIGFuZCB0aGF0IHdlIGhhdmUgc2hhcmVkIGl0cyBrZXkgd2l0aCBhbGwgdGhlIGRldmljZXNcbiAgICogaW4gdGhlIHJvb20uXG4gICAqIEBwYXJhbSBnbG9iYWxCbGFja2xpc3RVbnZlcmlmaWVkRGV2aWNlcyAtIFdoZW4gYHRydWVgLCBhbmQgYGRldmljZUlzb2xhdGlvbk1vZGVgIGlzIGBBbGxEZXZpY2VzSXNvbGF0aW9uTW9kZWAsXG4gICAqIHdpbGwgbm90IHNlbmQgZW5jcnlwdGVkIG1lc3NhZ2VzIHRvIHVudmVyaWZpZWQgZGV2aWNlcy5cbiAgICogSWdub3JlZCB3aGVuIGBkZXZpY2VJc29sYXRpb25Nb2RlYCBpcyBgT25seVNpZ25lZERldmljZXNJc29sYXRpb25Nb2RlYC5cbiAgICogQHBhcmFtIGRldmljZUlzb2xhdGlvbk1vZGUgLSBUaGUgZGV2aWNlIGlzb2xhdGlvbiBtb2RlLiBTZWUge0BsaW5rIERldmljZUlzb2xhdGlvbk1vZGV9LlxuICAgKi9cbiAgcHJlcGFyZUZvckVuY3J5cHRpb24oZ2xvYmFsQmxhY2tsaXN0VW52ZXJpZmllZERldmljZXMsIGRldmljZUlzb2xhdGlvbk1vZGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgLy8gV2UgY29uc2lkZXIgYSBwcmVwYXJlRm9yRW5jcnlwdGlvbiBhcyBhbiBlbmNyeXB0aW9uIHByb21pc2UgYXMgaXQgd2lsbCBwb3RlbnRpYWxseSBzaGFyZSBrZXlzXG4gICAgICAvLyBldmVuIGlmIGl0IGRvZXNuJ3Qgc2VuZCBhbiBldmVudC5cbiAgICAgIC8vIFVzdWFsbHkgdGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgdHlwaW5nLCBzbyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBoYXZlIGtleXMgcmVhZHkgd2hlbiB0aGVcbiAgICAgIC8vIG1lc3NhZ2UgaXMgZmluYWxseSBzZW50LlxuICAgICAgLy8gSWYgYGVuY3J5cHRFdmVudGAgaXMgaW52b2tlZCBiZWZvcmUgYHByZXBhcmVGb3JFbmNyeXB0aW9uYCBoYXMgY29tcGxldGVkLCB0aGUgYGVuY3J5cHRFdmVudGAgY2FsbCB3aWxsIHdhaXQgZm9yXG4gICAgICAvLyBgcHJlcGFyZUZvckVuY3J5cHRpb25gIHRvIGNvbXBsZXRlIGJlZm9yZSBleGVjdXRpbmcuXG4gICAgICAvLyBUaGUgcGFydCB3aGVyZSBgZW5jcnlwdEV2ZW50YCBzaGFyZXMgdGhlIHJvb20ga2V5IHdpbGwgdGhlbiB1c3VhbGx5IGJlIGEgbm8tb3AgYXMgaXQgd2FzIGFscmVhZHkgcGVyZm9ybWVkIGJ5IGBwcmVwYXJlRm9yRW5jcnlwdGlvbmAuXG4gICAgICB5aWVsZCBfdGhpcy5lbmNyeXB0RXZlbnQobnVsbCwgZ2xvYmFsQmxhY2tsaXN0VW52ZXJpZmllZERldmljZXMsIGRldmljZUlzb2xhdGlvbk1vZGUpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogRW5jcnlwdCBhbiBldmVudCBmb3IgdGhpcyByb29tLCBvciBwcmVwYXJlIGZvciBlbmNyeXB0aW9uLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgd2UgaGF2ZSBhIG1lZ29sbSBzZXNzaW9uIGZvciB0aGlzIHJvb20sIHNoYXJlIGl0IHdpdGggdGhlIGRldmljZXMgaW4gdGhlIHJvb20sIGFuZFxuICAgKiB0aGVuLCBpZiBhbiBldmVudCBpcyBwcm92aWRlZCwgZW5jcnlwdCBpdCB1c2luZyB0aGUgc2Vzc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gRXZlbnQgdG8gYmUgZW5jcnlwdGVkLCBvciBudWxsIGlmIG9ubHkgcHJlcGFyaW5nIGZvciBlbmNyeXB0aW9uIChpbiB3aGljaCBjYXNlIHdlIHdpbGwgcHJlLXNoYXJlIHRoZSByb29tIGtleSkuXG4gICAqIEBwYXJhbSBnbG9iYWxCbGFja2xpc3RVbnZlcmlmaWVkRGV2aWNlcyAtIFdoZW4gYHRydWVgLCBhbmQgYGRldmljZUlzb2xhdGlvbk1vZGVgIGlzIGBBbGxEZXZpY2VzSXNvbGF0aW9uTW9kZWAsXG4gICAqIHdpbGwgbm90IHNlbmQgZW5jcnlwdGVkIG1lc3NhZ2VzIHRvIHVudmVyaWZpZWQgZGV2aWNlcy5cbiAgICogSWdub3JlZCB3aGVuIGBkZXZpY2VJc29sYXRpb25Nb2RlYCBpcyBgT25seVNpZ25lZERldmljZXNJc29sYXRpb25Nb2RlYC5cbiAgICogQHBhcmFtIGRldmljZUlzb2xhdGlvbk1vZGUgLSBUaGUgZGV2aWNlIGlzb2xhdGlvbiBtb2RlLiBTZWUge0BsaW5rIERldmljZUlzb2xhdGlvbk1vZGV9LlxuICAgKi9cbiAgZW5jcnlwdEV2ZW50KGV2ZW50LCBnbG9iYWxCbGFja2xpc3RVbnZlcmlmaWVkRGV2aWNlcywgZGV2aWNlSXNvbGF0aW9uTW9kZSkge1xuICAgIHZhciBfZXZlbnQkZ2V0VHhuSWQsXG4gICAgICBfdGhpczIgPSB0aGlzO1xuICAgIHZhciBsb2dnZXIgPSBuZXcgTG9nU3Bhbih0aGlzLnByZWZpeGVkTG9nZ2VyLCBldmVudCA/IChfZXZlbnQkZ2V0VHhuSWQgPSBldmVudC5nZXRUeG5JZCgpKSAhPT0gbnVsbCAmJiBfZXZlbnQkZ2V0VHhuSWQgIT09IHZvaWQgMCA/IF9ldmVudCRnZXRUeG5JZCA6IFwiXCIgOiBcInByZXBhcmVGb3JFbmNyeXB0aW9uXCIpO1xuICAgIC8vIEVuc3VyZSBvcmRlciBvZiBlbmNyeXB0aW9uIHRvIGF2b2lkIG1lc3NhZ2Ugb3JkZXJpbmcgaXNzdWVzLCBhcyB0aGUgc2NoZWR1bGVyIG9ubHkgZW5zdXJlc1xuICAgIC8vIGV2ZW50cyBvcmRlciBhZnRlciB0aGV5IGhhdmUgYmVlbiBlbmNyeXB0ZWQuXG4gICAgdmFyIHByb20gPSB0aGlzLmN1cnJlbnRFbmNyeXB0aW9uUHJvbWlzZS5jYXRjaCgoKSA9PiB7XG4gICAgICAvLyBBbnkgZXJyb3JzIGluIHRoZSBwcmV2aW91cyBjYWxsIHdpbGwgaGF2ZSBiZWVuIHJlcG9ydGVkIGFscmVhZHksIHNvIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8gaGVyZS5cbiAgICAgIC8vIHdlIGp1c3QgdGhyb3cgYXdheSB0aGUgZXJyb3IgYW5kIHN0YXJ0IGFuZXcuXG4gICAgfSkudGhlbigvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIGxvZ0R1cmF0aW9uKGxvZ2dlciwgXCJlbnN1cmVFbmNyeXB0aW9uU2Vzc2lvblwiLCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgeWllbGQgX3RoaXMyLmVuc3VyZUVuY3J5cHRpb25TZXNzaW9uKGxvZ2dlciwgZ2xvYmFsQmxhY2tsaXN0VW52ZXJpZmllZERldmljZXMsIGRldmljZUlzb2xhdGlvbk1vZGUpO1xuICAgICAgfSkpO1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIHlpZWxkIGxvZ0R1cmF0aW9uKGxvZ2dlciwgXCJlbmNyeXB0RXZlbnRJbm5lclwiLCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB5aWVsZCBfdGhpczIuZW5jcnlwdEV2ZW50SW5uZXIobG9nZ2VyLCBldmVudCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgdGhpcy5jdXJyZW50RW5jcnlwdGlvblByb21pc2UgPSBwcm9tO1xuICAgIHJldHVybiBwcm9tO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmUgdG8gZW5jcnlwdCBldmVudHMgaW4gdGhpcyByb29tLlxuICAgKlxuICAgKiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBoYXZlIGEgbWVnb2xtIHNlc3Npb24gcmVhZHkgdG8gdXNlIGFuZCB0aGF0IHdlIGhhdmUgc2hhcmVkIGl0cyBrZXkgd2l0aCBhbGwgdGhlIGRldmljZXNcbiAgICogaW4gdGhlIHJvb20uXG4gICAqXG4gICAqIEBwYXJhbSBsb2dnZXIgLSBhIHBsYWNlIHRvIHdyaXRlIGRpYWdub3N0aWNzIHRvXG4gICAqIEBwYXJhbSBnbG9iYWxCbGFja2xpc3RVbnZlcmlmaWVkRGV2aWNlcyAtIFdoZW4gYHRydWVgLCBhbmQgYGRldmljZUlzb2xhdGlvbk1vZGVgIGlzIGBBbGxEZXZpY2VzSXNvbGF0aW9uTW9kZWAsXG4gICAqIHdpbGwgbm90IHNlbmQgZW5jcnlwdGVkIG1lc3NhZ2VzIHRvIHVudmVyaWZpZWQgZGV2aWNlcy5cbiAgICogSWdub3JlZCB3aGVuIGBkZXZpY2VJc29sYXRpb25Nb2RlYCBpcyBgT25seVNpZ25lZERldmljZXNJc29sYXRpb25Nb2RlYC5cbiAgICogQHBhcmFtIGRldmljZUlzb2xhdGlvbk1vZGUgLSBUaGUgZGV2aWNlIGlzb2xhdGlvbiBtb2RlLiBTZWUge0BsaW5rIERldmljZUlzb2xhdGlvbk1vZGV9LlxuICAgKi9cbiAgZW5zdXJlRW5jcnlwdGlvblNlc3Npb24obG9nZ2VyLCBnbG9iYWxCbGFja2xpc3RVbnZlcmlmaWVkRGV2aWNlcywgZGV2aWNlSXNvbGF0aW9uTW9kZSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKF90aGlzMy5lbmNyeXB0aW9uU2V0dGluZ3MuYWxnb3JpdGhtICE9PSBcIm0ubWVnb2xtLnYxLmFlcy1zaGEyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGVuY3J5cHQgaW4gXCIuY29uY2F0KF90aGlzMy5yb29tLnJvb21JZCwgXCIgZm9yIHVuc3VwcG9ydGVkIGFsZ29yaXRobSAnXCIpLmNvbmNhdChfdGhpczMuZW5jcnlwdGlvblNldHRpbmdzLmFsZ29yaXRobSwgXCInXCIpKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIlN0YXJ0aW5nIGVuY3J5cHRpb25cIik7XG4gICAgICB2YXIgbWVtYmVycyA9IHlpZWxkIF90aGlzMy5yb29tLmdldEVuY3J5cHRpb25UYXJnZXRNZW1iZXJzKCk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2UgYXJlIHNlbmRpbmcgYSBtZXNzYWdlIHRvIHRoZSByb29tLCB3ZSBtYXkgbm90IHlldCBoYXZlIHNlZW4gYWxsIHRoZSBtZW1iZXJzXG4gICAgICAvLyAoc28gdGhlIENyeXB0byBTREsgbWlnaHQgbm90IGhhdmUgYSBkZXZpY2UgbGlzdCBmb3IgdGhlbSkuIFNvLCBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlIGFyZSBlbmNyeXB0aW5nXG4gICAgICAvLyBmb3IgdGhpcyByb29tLCBnaXZlIHRoZSBTREsgdGhlIGZ1bGwgbGlzdCBvZiBtZW1iZXJzLCB0byBiZSBvbiB0aGUgc2FmZSBzaWRlLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgY291bGQgZW5kIHVwIGJlaW5nIHJhY3kgKGlmIHR3byBjYWxscyB0byBlbnN1cmVFbmNyeXB0aW9uU2Vzc2lvbiBoYXBwZW4gYXQgdGhlIHNhbWUgdGltZSksIGJ1dCB0aGF0J3NcbiAgICAgIC8vIG5vdCBhIHBhcnRpY3VsYXIgcHJvYmxlbSwgc2luY2UgYE9sbU1hY2hpbmUudXBkYXRlVHJhY2tlZFVzZXJzYCBqdXN0IGFkZHMgYW55IHVzZXJzIHRoYXQgd2VyZW4ndCBhbHJlYWR5IHRyYWNrZWQuXG4gICAgICBpZiAoIV90aGlzMy5sYXp5TG9hZGVkTWVtYmVyc1Jlc29sdmVkKSB7XG4gICAgICAgIHlpZWxkIGxvZ0R1cmF0aW9uKF90aGlzMy5wcmVmaXhlZExvZ2dlciwgXCJsb2FkTWVtYmVyc0lmTmVlZGVkOiB1cGRhdGVUcmFja2VkVXNlcnNcIiwgLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgeWllbGQgX3RoaXMzLm9sbU1hY2hpbmUudXBkYXRlVHJhY2tlZFVzZXJzKG1lbWJlcnMubWFwKHUgPT4gbmV3IFJ1c3RTZGtDcnlwdG9Kcy5Vc2VySWQodS51c2VySWQpKSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiVXBkYXRlZCB0cmFja2VkIHVzZXJzXCIpO1xuICAgICAgICBfdGhpczMubGF6eUxvYWRlZE1lbWJlcnNSZXNvbHZlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gUXVlcnkga2V5cyBpbiBjYXNlIHdlIGRvbid0IGhhdmUgdGhlbSBmb3IgbmV3bHkgdHJhY2tlZCBtZW1iZXJzLlxuICAgICAgICAvLyBJdCdzIGltcG9ydGFudCBhZnRlciBsb2FkaW5nIG1lbWJlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLCBhcyBsaWtlbHkgbW9zdCBvZiB0aGVtIHdvbid0IGJlXG4gICAgICAgIC8vIGtub3duIHlldCBhbmQgd2lsbCBiZSB1bmFibGUgdG8gZGVjcnlwdCBtZXNzYWdlcyBkZXNwaXRlIGJlaW5nIGluIHRoZSByb29tIGZvciBsb25nLlxuICAgICAgICAvLyBUaGlzIG11c3QgYmUgZG9uZSBiZWZvcmUgZW5zdXJpbmcgc2Vzc2lvbnMuIElmIG5vdCB0aGUgZGV2aWNlcyBvZiB0aGVzZSB1c2VycyBhcmUgbm90XG4gICAgICAgIC8vIGtub3duIHlldCBhbmQgd2lsbCBub3QgZ2V0IHRoZSByb29tIGtleS5cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBBUEkgdG8gb25seSBnZXQgdGhlIGtleXMgcXVlcmllcyByZWxhdGVkIHRvIHRoaXMgbWVtYmVyIGxpc3QsIHNvIHdlIGp1c3RcbiAgICAgICAgLy8gcHJvY2VzcyB0aGUgcGVuZGluZyByZXF1ZXN0cyBmcm9tIHRoZSBvbG1NYWNoaW5lLiAodXN1YWxseSB0aGVzZSBhcmUgcHJvY2Vzc2VkXG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHN5bmMsIGJ1dCB3ZSBjYW4ndCB3YWl0IGZvciB0aGF0KS5cbiAgICAgICAgLy8gWFhYIGZ1dHVyZSBpbXByb3ZlbWVudCBwcm9jZXNzIG9ubHkgS2V5c1F1ZXJ5UmVxdWVzdHMgZm9yIHRoZSB1c2VycyB0aGF0IGhhdmUgbmV2ZXIgYmVlbiBxdWVyaWVkLlxuICAgICAgICBsb2dnZXIuZGVidWcoXCJQcm9jZXNzaW5nIG91dGdvaW5nIHJlcXVlc3RzXCIpO1xuICAgICAgICB5aWVsZCBsb2dEdXJhdGlvbihfdGhpczMucHJlZml4ZWRMb2dnZXIsIFwiZG9Qcm9jZXNzT3V0Z29pbmdSZXF1ZXN0c1wiLCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB5aWVsZCBfdGhpczMub3V0Z29pbmdSZXF1ZXN0TWFuYWdlci5kb1Byb2Nlc3NPdXRnb2luZ1JlcXVlc3RzKCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG1lbWJlcnMgYXJlIGFscmVhZHkgbG9hZGVkIGl0J3MgbGVzcyBjcml0aWNhbCB0byBhd2FpdCBvbiBrZXkgcXVlcmllcy5cbiAgICAgICAgLy8gV2UgbWlnaHQgc3RpbGwgd2FudCB0byB0cmlnZ2VyIGEgcHJvY2Vzc091dGdvaW5nUmVxdWVzdHMgaGVyZS5cbiAgICAgICAgLy8gVGhlIGNhbGwgdG8gYGVuc3VyZVNlc3Npb25zRm9yVXNlcnNgIGJlbG93IHdpbGwgd2FpdCBhIGJpdCBvbiBpbi1mbGlnaHQga2V5IHF1ZXJpZXMgd2UgYXJlXG4gICAgICAgIC8vIGludGVyZXN0ZWQgaW4uIElmIGEgc3luYyBoYW5kbGluZyBoYXBwZW5zIGluIHRoZSBtZWFudGltZSwgYW5kIHNvbWUgbmV3IG1lbWJlcnMgYXJlIGFkZGVkIHRvIHRoZSByb29tXG4gICAgICAgIC8vIG9yIGhhdmUgbmV3IGRldmljZXMgaXQgd291bGQgZ2l2ZSB1cyBhIGNoYW5jZSB0byBxdWVyeSB0aGVtIGJlZm9yZSBzZW5kaW5nLlxuICAgICAgICAvLyBJdCdzIGxlc3MgY3JpdGljYWwgZHVlIHRvIHRoZSByYWN5IG5hdHVyZSBvZiB0aGlzIHByb2Nlc3MuXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlByb2Nlc3Npbmcgb3V0Z29pbmcgcmVxdWVzdHMgaW4gYmFja2dyb3VuZFwiKTtcbiAgICAgICAgX3RoaXMzLm91dGdvaW5nUmVxdWVzdE1hbmFnZXIuZG9Qcm9jZXNzT3V0Z29pbmdSZXF1ZXN0cygpO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmRlYnVnKFwiRW5jcnlwdGluZyBmb3IgdXNlcnMgKHNob3VsZEVuY3J5cHRGb3JJbnZpdGVkTWVtYmVyczogXCIuY29uY2F0KF90aGlzMy5yb29tLnNob3VsZEVuY3J5cHRGb3JJbnZpdGVkTWVtYmVycygpLCBcIik6XCIpLCBtZW1iZXJzLm1hcCh1ID0+IFwiXCIuY29uY2F0KHUudXNlcklkLCBcIiAoXCIpLmNvbmNhdCh1Lm1lbWJlcnNoaXAsIFwiKVwiKSkpO1xuICAgICAgdmFyIHVzZXJMaXN0ID0gbWVtYmVycy5tYXAodSA9PiBuZXcgVXNlcklkKHUudXNlcklkKSk7XG4gICAgICB5aWVsZCBsb2dEdXJhdGlvbihfdGhpczMucHJlZml4ZWRMb2dnZXIsIFwiZW5zdXJlU2Vzc2lvbnNGb3JVc2Vyc1wiLCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgeWllbGQgX3RoaXMzLmtleUNsYWltTWFuYWdlci5lbnN1cmVTZXNzaW9uc0ZvclVzZXJzKGxvZ2dlciwgdXNlckxpc3QpO1xuICAgICAgfSkpO1xuICAgICAgdmFyIHJ1c3RFbmNyeXB0aW9uU2V0dGluZ3MgPSBuZXcgRW5jcnlwdGlvblNldHRpbmdzKCk7XG4gICAgICBydXN0RW5jcnlwdGlvblNldHRpbmdzLmhpc3RvcnlWaXNpYmlsaXR5ID0gdG9SdXN0SGlzdG9yeVZpc2liaWxpdHkoX3RoaXMzLnJvb20uZ2V0SGlzdG9yeVZpc2liaWxpdHkoKSk7XG5cbiAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCBtZWdvbG1cbiAgICAgIHJ1c3RFbmNyeXB0aW9uU2V0dGluZ3MuYWxnb3JpdGhtID0gRW5jcnlwdGlvbkFsZ29yaXRobS5NZWdvbG1WMUFlc1NoYTI7XG5cbiAgICAgIC8vIFdlIG5lZWQgdG8gY29udmVydCB0aGUgcm90YXRpb24gcGVyaW9kIGZyb20gbWlsbGlzZWNvbmRzIHRvIG1pY3Jvc2Vjb25kc1xuICAgICAgLy8gU2VlIGh0dHBzOi8vc3BlYy5tYXRyaXgub3JnL3YxLjgvY2xpZW50LXNlcnZlci1hcGkvI21yb29tZW5jcnlwdGlvbiBhbmRcbiAgICAgIC8vIGh0dHBzOi8vbWF0cml4LW9yZy5naXRodWIuaW8vbWF0cml4LXJ1c3Qtc2RrLWNyeXB0by13YXNtL2NsYXNzZXMvRW5jcnlwdGlvblNldHRpbmdzLmh0bWwjcm90YXRpb25QZXJpb2RcbiAgICAgIGlmICh0eXBlb2YgX3RoaXMzLmVuY3J5cHRpb25TZXR0aW5ncy5yb3RhdGlvbl9wZXJpb2RfbXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcnVzdEVuY3J5cHRpb25TZXR0aW5ncy5yb3RhdGlvblBlcmlvZCA9IEJpZ0ludChfdGhpczMuZW5jcnlwdGlvblNldHRpbmdzLnJvdGF0aW9uX3BlcmlvZF9tcyAqIDEwMDApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBfdGhpczMuZW5jcnlwdGlvblNldHRpbmdzLnJvdGF0aW9uX3BlcmlvZF9tc2dzID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJ1c3RFbmNyeXB0aW9uU2V0dGluZ3Mucm90YXRpb25QZXJpb2RNZXNzYWdlcyA9IEJpZ0ludChfdGhpczMuZW5jcnlwdGlvblNldHRpbmdzLnJvdGF0aW9uX3BlcmlvZF9tc2dzKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGV2aWNlSXNvbGF0aW9uTW9kZS5raW5kKSB7XG4gICAgICAgIGNhc2UgRGV2aWNlSXNvbGF0aW9uTW9kZUtpbmQuQWxsRGV2aWNlc0lzb2xhdGlvbk1vZGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF90aGlzMyRyb29tJGdldEJsYWNrbDtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhpcy5yb29tLmdldEJsYWNrbGlzdFVudmVyaWZpZWREZXZpY2VzKCkgPT09IG51bGwsIHRoZSBnbG9iYWwgc2V0dGluZ3Mgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgIC8vIFNlZSBSb29tI2dldEJsYWNrbGlzdFVudmVyaWZpZWREZXZpY2VzXG4gICAgICAgICAgICB2YXIgb25seUFsbG93VHJ1c3RlZERldmljZXMgPSAoX3RoaXMzJHJvb20kZ2V0QmxhY2tsID0gX3RoaXMzLnJvb20uZ2V0QmxhY2tsaXN0VW52ZXJpZmllZERldmljZXMoKSkgIT09IG51bGwgJiYgX3RoaXMzJHJvb20kZ2V0QmxhY2tsICE9PSB2b2lkIDAgPyBfdGhpczMkcm9vbSRnZXRCbGFja2wgOiBnbG9iYWxCbGFja2xpc3RVbnZlcmlmaWVkRGV2aWNlcztcbiAgICAgICAgICAgIHJ1c3RFbmNyeXB0aW9uU2V0dGluZ3Muc2hhcmluZ1N0cmF0ZWd5ID0gQ29sbGVjdFN0cmF0ZWd5LmRldmljZUJhc2VkU3RyYXRlZ3kob25seUFsbG93VHJ1c3RlZERldmljZXMsIGRldmljZUlzb2xhdGlvbk1vZGUuZXJyb3JPblZlcmlmaWVkVXNlclByb2JsZW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRGV2aWNlSXNvbGF0aW9uTW9kZUtpbmQuT25seVNpZ25lZERldmljZXNJc29sYXRpb25Nb2RlOlxuICAgICAgICAgIHJ1c3RFbmNyeXB0aW9uU2V0dGluZ3Muc2hhcmluZ1N0cmF0ZWd5ID0gQ29sbGVjdFN0cmF0ZWd5LmlkZW50aXR5QmFzZWRTdHJhdGVneSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgeWllbGQgbG9nRHVyYXRpb24oX3RoaXMzLnByZWZpeGVkTG9nZ2VyLCBcInNoYXJlUm9vbUtleVwiLCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIHNoYXJlTWVzc2FnZXMgPSB5aWVsZCBfdGhpczMub2xtTWFjaGluZS5zaGFyZVJvb21LZXkobmV3IFJvb21JZChfdGhpczMucm9vbS5yb29tSWQpLFxuICAgICAgICAvLyBzYWZlIHRvIHBhc3Mgd2l0aG91dCBjbG9uaW5nLCBhcyBpdCdzIG5vdCByZXVzZWQgaGVyZSAoYmVmb3JlIG9yIGFmdGVyKVxuICAgICAgICB1c2VyTGlzdCwgcnVzdEVuY3J5cHRpb25TZXR0aW5ncyk7XG4gICAgICAgIGlmIChzaGFyZU1lc3NhZ2VzKSB7XG4gICAgICAgICAgZm9yICh2YXIgbSBvZiBzaGFyZU1lc3NhZ2VzKSB7XG4gICAgICAgICAgICB5aWVsZCBfdGhpczMub3V0Z29pbmdSZXF1ZXN0TWFuYWdlci5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IubWFrZU91dGdvaW5nUmVxdWVzdChtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2NhcmQgYW55IGV4aXN0aW5nIGdyb3VwIHNlc3Npb24gZm9yIHRoaXMgcm9vbVxuICAgKi9cbiAgZm9yY2VEaXNjYXJkU2Vzc2lvbigpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciByID0geWllbGQgX3RoaXM0Lm9sbU1hY2hpbmUuaW52YWxpZGF0ZUdyb3VwU2Vzc2lvbihuZXcgUm9vbUlkKF90aGlzNC5yb29tLnJvb21JZCkpO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgX3RoaXM0LnByZWZpeGVkTG9nZ2VyLmluZm8oXCJEaXNjYXJkZWQgZXhpc3RpbmcgZ3JvdXAgc2Vzc2lvblwiKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG4gIGVuY3J5cHRFdmVudElubmVyKGxvZ2dlciwgZXZlbnQpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIkVuY3J5cHRpbmcgYWN0dWFsIG1lc3NhZ2UgY29udGVudFwiKTtcbiAgICAgIHZhciBlbmNyeXB0ZWRDb250ZW50ID0geWllbGQgX3RoaXM1Lm9sbU1hY2hpbmUuZW5jcnlwdFJvb21FdmVudChuZXcgUm9vbUlkKF90aGlzNS5yb29tLnJvb21JZCksIGV2ZW50LmdldFR5cGUoKSwgSlNPTi5zdHJpbmdpZnkoZXZlbnQuZ2V0Q29udGVudCgpKSk7XG4gICAgICBldmVudC5tYWtlRW5jcnlwdGVkKEV2ZW50VHlwZS5Sb29tTWVzc2FnZUVuY3J5cHRlZCwgSlNPTi5wYXJzZShlbmNyeXB0ZWRDb250ZW50KSwgX3RoaXM1Lm9sbU1hY2hpbmUuaWRlbnRpdHlLZXlzLmN1cnZlMjU1MTkudG9CYXNlNjQoKSwgX3RoaXM1Lm9sbU1hY2hpbmUuaWRlbnRpdHlLZXlzLmVkMjU1MTkudG9CYXNlNjQoKSk7XG4gICAgICBsb2dnZXIuZGVidWcoXCJFbmNyeXB0ZWQgZXZlbnQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgIH0pKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgSGlzdG9yeVZpc2liaWxpdHkgdG8gYSBSdXN0SGlzdG9yeVZpc2liaWxpdHlcbiAqIEBwYXJhbSB2aXNpYmlsaXR5IC0gSGlzdG9yeVZpc2liaWxpdHkgZW51bVxuICogQHJldHVybnMgYSBSdXN0SGlzdG9yeVZpc2liaWxpdHkgZW51bVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9SdXN0SGlzdG9yeVZpc2liaWxpdHkodmlzaWJpbGl0eSkge1xuICBzd2l0Y2ggKHZpc2liaWxpdHkpIHtcbiAgICBjYXNlIEhpc3RvcnlWaXNpYmlsaXR5Lkludml0ZWQ6XG4gICAgICByZXR1cm4gUnVzdEhpc3RvcnlWaXNpYmlsaXR5Lkludml0ZWQ7XG4gICAgY2FzZSBIaXN0b3J5VmlzaWJpbGl0eS5Kb2luZWQ6XG4gICAgICByZXR1cm4gUnVzdEhpc3RvcnlWaXNpYmlsaXR5LkpvaW5lZDtcbiAgICBjYXNlIEhpc3RvcnlWaXNpYmlsaXR5LlNoYXJlZDpcbiAgICAgIHJldHVybiBSdXN0SGlzdG9yeVZpc2liaWxpdHkuU2hhcmVkO1xuICAgIGNhc2UgSGlzdG9yeVZpc2liaWxpdHkuV29ybGRSZWFkYWJsZTpcbiAgICAgIHJldHVybiBSdXN0SGlzdG9yeVZpc2liaWxpdHkuV29ybGRSZWFkYWJsZTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um9vbUVuY3J5cHRvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/RoomEncryptor.js\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/backup.js":
/*!**************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/backup.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RustBackupDecryptor: () => (/* binding */ RustBackupDecryptor),\n/* harmony export */   RustBackupManager: () => (/* binding */ RustBackupManager),\n/* harmony export */   decryptionKeyMatchesKeyBackupInfo: () => (/* binding */ decryptionKeyMatchesKeyBackupInfo),\n/* harmony export */   requestKeyBackupVersion: () => (/* binding */ requestKeyBackupVersion)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @matrix-org/matrix-sdk-crypto-wasm */ \"./node_modules/@matrix-org/matrix-sdk-crypto-wasm/index.mjs\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger.js */ \"./node_modules/matrix-js-sdk/lib/logger.js\");\n/* harmony import */ var _http_api_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../http-api/index.js */ \"./node_modules/matrix-js-sdk/lib/http-api/index.js\");\n/* harmony import */ var _models_typed_event_emitter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../models/typed-event-emitter.js */ \"./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/matrix-js-sdk/lib/utils.js\");\n/* harmony import */ var _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../crypto-api/index.js */ \"./node_modules/matrix-js-sdk/lib/crypto-api/index.js\");\n\n\n/*\nCopyright 2023 - 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n\n\n\n\n\n\n\n/** Authentification of the backup info, depends on algorithm */\n\n/**\n * Holds information of a created keybackup.\n * Useful to get the generated private key material and save it securely somewhere.\n */\n\n/**\n * @internal\n */\nclass RustBackupManager extends _models_typed_event_emitter_js__WEBPACK_IMPORTED_MODULE_5__.TypedEventEmitter {\n  constructor(olmMachine, http, outgoingRequestProcessor) {\n    super();\n    this.olmMachine = olmMachine;\n    this.http = http;\n    this.outgoingRequestProcessor = outgoingRequestProcessor;\n    /** Have we checked if there is a backup on the server which we can use */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"checkedForBackup\", false);\n    /**\n     * The latest backup version on the server, when we last checked.\n     *\n     * If there was no backup on the server, `null`. If our attempt to check resulted in an error, `undefined`.\n     *\n     * Note that the backup was not necessarily verified.\n     */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"serverBackupInfo\", undefined);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"activeBackupVersion\", null);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"stopped\", false);\n    /** whether {@link backupKeysLoop} is currently running */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"backupKeysLoopRunning\", false);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"keyBackupCheckInProgress\", null);\n  }\n\n  /**\n   * Tells the RustBackupManager to stop.\n   * The RustBackupManager is scheduling background uploads of keys to the backup, this\n   * call allows to cancel the process when the client is stoppped.\n   */\n  stop() {\n    this.stopped = true;\n  }\n\n  /**\n   * Get the backup version we are currently backing up to, if any\n   */\n  getActiveBackupVersion() {\n    var _this = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      if (!(yield _this.olmMachine.isBackupEnabled())) return null;\n      return _this.activeBackupVersion;\n    })();\n  }\n\n  /**\n   * Return the details of the latest backup on the server, when we last checked.\n   *\n   * This normally returns a cached value, but if we haven't yet made a request to the server, it will fire one off.\n   * It will always return the details of the active backup if key backup is enabled.\n   *\n   * If there was no backup on the server, `null`. If our attempt to check resulted in an error, `undefined`.\n   */\n  getServerBackupInfo() {\n    var _this2 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // Do a validity check if we haven't already done one. The check is likely to fail if we don't yet have the\n      // backup keys -- but as a side-effect, it will populate `serverBackupInfo`.\n      yield _this2.checkKeyBackupAndEnable(false);\n      return _this2.serverBackupInfo;\n    })();\n  }\n\n  /**\n   * Determine if a key backup can be trusted.\n   *\n   * @param info - key backup info dict from {@link MatrixClient#getKeyBackupVersion}.\n   */\n  isKeyBackupTrusted(info) {\n    var _this3 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var signatureVerification = yield _this3.olmMachine.verifyBackup(info);\n      var backupKeys = yield _this3.olmMachine.getBackupKeys();\n      var decryptionKey = backupKeys === null || backupKeys === void 0 ? void 0 : backupKeys.decryptionKey;\n      var backupMatchesSavedPrivateKey = !!decryptionKey && backupInfoMatchesBackupDecryptionKey(info, decryptionKey);\n      return {\n        matchesDecryptionKey: backupMatchesSavedPrivateKey,\n        trusted: signatureVerification.trusted()\n      };\n    })();\n  }\n\n  /**\n   * Re-check the key backup and enable/disable it as appropriate.\n   *\n   * @param force - whether we should force a re-check even if one has already happened.\n   */\n  checkKeyBackupAndEnable(force) {\n    if (!force && this.checkedForBackup) {\n      return Promise.resolve(null);\n    }\n\n    // make sure there is only one check going on at a time\n    if (!this.keyBackupCheckInProgress) {\n      this.keyBackupCheckInProgress = this.doCheckKeyBackup().finally(() => {\n        this.keyBackupCheckInProgress = null;\n      });\n    }\n    return this.keyBackupCheckInProgress;\n  }\n\n  /**\n   * Handles a backup secret received event and store it if it matches the current backup version.\n   *\n   * @param secret - The secret as received from a `m.secret.send` event for secret `m.megolm_backup.v1`.\n   * @returns true if the secret is valid and has been stored, false otherwise.\n   */\n  handleBackupSecretReceived(secret) {\n    var _this4 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var _backupCheck$backupIn;\n      // Currently we only receive the decryption key without any key backup version. It is important to\n      // check that the secret is valid for the current version before storing it.\n      // We force a check to ensure to have the latest version. We also want to check that the backup is trusted\n      // as we don't want to store the secret if the backup is not trusted, and eventually import megolm keys later from an untrusted backup.\n      var backupCheck = yield _this4.checkKeyBackupAndEnable(true);\n      if (!(backupCheck !== null && backupCheck !== void 0 && (_backupCheck$backupIn = backupCheck.backupInfo) !== null && _backupCheck$backupIn !== void 0 && _backupCheck$backupIn.version) || !backupCheck.trustInfo.trusted) {\n        // There is no server-side key backup, or the backup is not signed by a trusted cross-signing key or trusted own device.\n        // This decryption key is useless to us.\n        _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"handleBackupSecretReceived: Received a backup decryption key, but there is no trusted server-side key backup\");\n        return false;\n      }\n      try {\n        var backupDecryptionKey = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.BackupDecryptionKey.fromBase64(secret);\n        var privateKeyMatches = backupInfoMatchesBackupDecryptionKey(backupCheck.backupInfo, backupDecryptionKey);\n        if (!privateKeyMatches) {\n          _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"handleBackupSecretReceived: Private decryption key does not match the public key of the current remote backup.\");\n          // just ignore the secret\n          return false;\n        }\n        _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.info(\"handleBackupSecretReceived: A valid backup decryption key has been received and stored in cache.\");\n        yield _this4.saveBackupDecryptionKey(backupDecryptionKey, backupCheck.backupInfo.version);\n        return true;\n      } catch (e) {\n        _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"handleBackupSecretReceived: Invalid backup decryption key\", e);\n      }\n      return false;\n    })();\n  }\n  saveBackupDecryptionKey(backupDecryptionKey, version) {\n    var _this5 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      yield _this5.olmMachine.saveBackupDecryptionKey(backupDecryptionKey, version);\n      // Emit an event that we have a new backup decryption key, so that the sdk can start\n      // importing keys from backup if needed.\n      _this5.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_7__.CryptoEvent.KeyBackupDecryptionKeyCached, version);\n    })();\n  }\n\n  /**\n   * Import a list of room keys previously exported by exportRoomKeys\n   *\n   * @param keys - a list of session export objects\n   * @param opts - options object\n   * @returns a promise which resolves once the keys have been imported\n   */\n  importRoomKeys(keys, opts) {\n    var _this6 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      yield _this6.importRoomKeysAsJson(JSON.stringify(keys), opts);\n    })();\n  }\n\n  /**\n   * Import a list of room keys previously exported by exportRoomKeysAsJson\n   *\n   * @param jsonKeys - a JSON string encoding a list of session export objects,\n   *    each of which is an IMegolmSessionData\n   * @param opts - options object\n   * @returns a promise which resolves once the keys have been imported\n   */\n  importRoomKeysAsJson(jsonKeys, opts) {\n    var _this7 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      yield _this7.olmMachine.importExportedRoomKeys(jsonKeys, (progress, total) => {\n        var _opts$progressCallbac;\n        var importOpt = {\n          total: Number(total),\n          successes: Number(progress),\n          stage: \"load_keys\",\n          failures: 0\n        };\n        opts === null || opts === void 0 || (_opts$progressCallbac = opts.progressCallback) === null || _opts$progressCallbac === void 0 || _opts$progressCallbac.call(opts, importOpt);\n      });\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoBackend#importBackedUpRoomKeys}.\n   */\n  importBackedUpRoomKeys(keys, backupVersion, opts) {\n    var _this8 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var keysByRoom = new Map();\n      for (var key of keys) {\n        var roomId = new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.RoomId(key.room_id);\n        if (!keysByRoom.has(roomId)) {\n          keysByRoom.set(roomId, new Map());\n        }\n        keysByRoom.get(roomId).set(key.session_id, key);\n      }\n      yield _this8.olmMachine.importBackedUpRoomKeys(keysByRoom, (progress, total, failures) => {\n        var _opts$progressCallbac2;\n        var importOpt = {\n          total: Number(total),\n          successes: Number(progress),\n          stage: \"load_keys\",\n          failures: Number(failures)\n        };\n        opts === null || opts === void 0 || (_opts$progressCallbac2 = opts.progressCallback) === null || _opts$progressCallbac2 === void 0 || _opts$progressCallbac2.call(opts, importOpt);\n      }, backupVersion);\n    })();\n  }\n  /** Helper for `checkKeyBackup` */\n  doCheckKeyBackup() {\n    var _this9 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"Checking key backup status...\");\n      var backupInfo;\n      try {\n        backupInfo = yield _this9.requestKeyBackupVersion();\n      } catch (e) {\n        _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"Error checking for active key backup\", e);\n        _this9.serverBackupInfo = undefined;\n        return null;\n      }\n      _this9.checkedForBackup = true;\n      if (backupInfo && !backupInfo.version) {\n        _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"active backup lacks a useful 'version'; ignoring it\");\n        backupInfo = undefined;\n      }\n      _this9.serverBackupInfo = backupInfo;\n      var activeVersion = yield _this9.getActiveBackupVersion();\n      if (!backupInfo) {\n        if (activeVersion !== null) {\n          _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"No key backup present on server: disabling key backup\");\n          yield _this9.disableKeyBackup();\n        } else {\n          _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"No key backup present on server: not enabling key backup\");\n        }\n        return null;\n      }\n      var trustInfo = yield _this9.isKeyBackupTrusted(backupInfo);\n      if (!trustInfo.trusted) {\n        if (activeVersion !== null) {\n          _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"Key backup present on server but not trusted: disabling key backup\");\n          yield _this9.disableKeyBackup();\n        } else {\n          _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"Key backup present on server but not trusted: not enabling key backup\");\n        }\n      } else {\n        if (activeVersion === null) {\n          _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"Found usable key backup v\".concat(backupInfo.version, \": enabling key backups\"));\n          yield _this9.enableKeyBackup(backupInfo);\n        } else if (activeVersion !== backupInfo.version) {\n          _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"On backup version \".concat(activeVersion, \" but found version \").concat(backupInfo.version, \": switching.\"));\n          // This will remove any pending backup request, remove the backup key and reset the backup state of each room key we have.\n          yield _this9.disableKeyBackup();\n          // Enabling will now trigger re-upload of all the keys\n          yield _this9.enableKeyBackup(backupInfo);\n        } else {\n          _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"Backup version \".concat(backupInfo.version, \" still current\"));\n        }\n      }\n      return {\n        backupInfo,\n        trustInfo\n      };\n    })();\n  }\n  enableKeyBackup(backupInfo) {\n    var _this10 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // we know for certain it must be a Curve25519 key, because we have verified it and only Curve25519\n      // keys can be verified.\n      //\n      // we also checked it has a valid `version`.\n      yield _this10.olmMachine.enableBackupV1(backupInfo.auth_data.public_key, backupInfo.version);\n      _this10.activeBackupVersion = backupInfo.version;\n      _this10.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_7__.CryptoEvent.KeyBackupStatus, true);\n      _this10.backupKeysLoop();\n    })();\n  }\n\n  /**\n   * Restart the backup key loop if there is an active trusted backup.\n   * Doesn't try to check the backup server side. To be called when a new\n   * megolm key is known locally.\n   */\n  maybeUploadKey() {\n    var _this11 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      if (_this11.activeBackupVersion != null) {\n        _this11.backupKeysLoop();\n      }\n    })();\n  }\n  disableKeyBackup() {\n    var _this12 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      yield _this12.olmMachine.disableBackup();\n      _this12.activeBackupVersion = null;\n      _this12.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_7__.CryptoEvent.KeyBackupStatus, false);\n    })();\n  }\n  backupKeysLoop() {\n    var _arguments = arguments,\n      _this13 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var maxDelay = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : 10000;\n      if (_this13.backupKeysLoopRunning) {\n        _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"Backup loop already running\");\n        return;\n      }\n      _this13.backupKeysLoopRunning = true;\n      _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"Backup: Starting keys upload loop for backup version:\".concat(_this13.activeBackupVersion, \".\"));\n\n      // wait between 0 and `maxDelay` seconds, to avoid backup\n      // requests from different clients hitting the server all at\n      // the same time when a new key is sent\n      var delay = Math.random() * maxDelay;\n      yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.sleep)(delay);\n      try {\n        // number of consecutive network failures for exponential backoff\n        var numFailures = 0;\n        // The number of keys left to back up. (Populated lazily: see more comments below.)\n        var remainingToUploadCount = null;\n        // To avoid computing the key when only a few keys were added (after a sync for example),\n        // we compute the count only when at least two iterations are needed.\n        var isFirstIteration = true;\n        while (!_this13.stopped) {\n          // Get a batch of room keys to upload\n          var request = null;\n          try {\n            request = yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.logDuration)(_logger_js__WEBPACK_IMPORTED_MODULE_3__.logger, \"BackupRoomKeys: Get keys to backup from rust crypto-sdk\", /*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n              return yield _this13.olmMachine.backupRoomKeys();\n            }));\n          } catch (err) {\n            _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.error(\"Backup: Failed to get keys to backup from rust crypto-sdk\", err);\n          }\n          if (!request || _this13.stopped || !_this13.activeBackupVersion) {\n            _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"Backup: Ending loop for version \".concat(_this13.activeBackupVersion, \".\"));\n            if (!request) {\n              // nothing more to upload\n              _this13.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_7__.CryptoEvent.KeyBackupSessionsRemaining, 0);\n            }\n            return;\n          }\n          try {\n            yield _this13.outgoingRequestProcessor.makeOutgoingRequest(request);\n            numFailures = 0;\n            if (_this13.stopped) break;\n\n            // Key count performance (`olmMachine.roomKeyCounts()`) can be pretty bad on some configurations.\n            // In particular, we detected on some M1 macs that when the object store reaches a threshold, the count\n            // performance stops growing in O(n) and suddenly becomes very slow (40s, 60s or more).\n            // For reference, the performance drop occurs around 300-400k keys on the platforms where this issue is observed.\n            // Even on other configurations, the count can take several seconds.\n            // This will block other operations on the database, like sending messages.\n            //\n            // This is a workaround to avoid calling `olmMachine.roomKeyCounts()` too often, and only when necessary.\n            // We don't call it on the first loop because there could be only a few keys to upload, and we don't want to wait for the count.\n            if (!isFirstIteration && remainingToUploadCount === null) {\n              try {\n                var keyCount = yield _this13.olmMachine.roomKeyCounts();\n                remainingToUploadCount = keyCount.total - keyCount.backedUp;\n              } catch (err) {\n                _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.error(\"Backup: Failed to get key counts from rust crypto-sdk\", err);\n              }\n            }\n            if (remainingToUploadCount !== null) {\n              _this13.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_7__.CryptoEvent.KeyBackupSessionsRemaining, remainingToUploadCount);\n              var keysCountInBatch = _this13.keysCountInBatch(request);\n              // `OlmMachine.roomKeyCounts` is called only once for the current backupKeysLoop. But new\n              // keys could be added during the current loop (after a sync for example).\n              // So the count can get out of sync with the real number of remaining keys to upload.\n              // Depending on the number of new keys imported and the time to complete the loop,\n              // this could result in multiple events being emitted with a remaining key count of 0.\n              remainingToUploadCount = Math.max(remainingToUploadCount - keysCountInBatch, 0);\n            }\n          } catch (err) {\n            numFailures++;\n            _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.error(\"Backup: Error processing backup request for rust crypto-sdk\", err);\n            if (err instanceof _http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.MatrixError) {\n              var errCode = err.data.errcode;\n              if (errCode == \"M_NOT_FOUND\" || errCode == \"M_WRONG_ROOM_KEYS_VERSION\") {\n                _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"Backup: Failed to upload keys to current vesion: \".concat(errCode, \".\"));\n                try {\n                  yield _this13.disableKeyBackup();\n                } catch (error) {\n                  _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.error(\"Backup: An error occurred while disabling key backup:\", error);\n                }\n                _this13.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_7__.CryptoEvent.KeyBackupFailed, err.data.errcode);\n                // There was an active backup and we are out of sync with the server\n                // force a check server side\n                _this13.backupKeysLoopRunning = false;\n                _this13.checkKeyBackupAndEnable(true);\n                return;\n              } else if (err.isRateLimitError()) {\n                // wait for that and then continue?\n                try {\n                  var waitTime = err.getRetryAfterMs();\n                  if (waitTime && waitTime > 0) {\n                    yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.sleep)(waitTime);\n                    continue;\n                  }\n                } catch (error) {\n                  _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"Backup: An error occurred while retrieving a rate-limit retry delay\", error);\n                } // else go to the normal backoff\n              }\n            }\n\n            // Some other errors (mx, network, or CORS or invalid urls?) anyhow backoff\n            // exponential backoff if we have failures\n            yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.sleep)(1000 * Math.pow(2, Math.min(numFailures - 1, 4)));\n          }\n          isFirstIteration = false;\n        }\n      } finally {\n        _this13.backupKeysLoopRunning = false;\n      }\n    })();\n  }\n\n  /**\n   * Utility method to count the number of keys in a backup request, in order to update the remaining keys count.\n   * This should be the chunk size of the backup request for all requests but the last, but we don't have access to it\n   * (it's static in the Rust SDK).\n   * @param batch - The backup request to count the keys from.\n   *\n   * @returns The number of keys in the backup request.\n   */\n  keysCountInBatch(batch) {\n    var parsedBody = JSON.parse(batch.body);\n    return countKeysInBackup(parsedBody);\n  }\n\n  /**\n   * Get information about a key backup from the server\n   * - If version is provided, get information about that backup version.\n   * - If no version is provided, get information about the latest backup.\n   *\n   * @param version - The version of the backup to get information about.\n   * @returns Information object from API or null if there is no active backup.\n   */\n  requestKeyBackupVersion(version) {\n    var _this14 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return yield requestKeyBackupVersion(_this14.http, version);\n    })();\n  }\n\n  /**\n   * Creates a new key backup by generating a new random private key.\n   *\n   * If there is an existing backup server side it will be deleted and replaced\n   * by the new one.\n   *\n   * @param signObject - Method that should sign the backup with existing device and\n   * existing identity.\n   * @returns a KeyBackupCreationInfo - All information related to the backup.\n   */\n  setupKeyBackup(signObject) {\n    var _this15 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // Clean up any existing backup\n      yield _this15.deleteAllKeyBackupVersions();\n      var randomKey = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.BackupDecryptionKey.createRandomKey();\n      var pubKey = randomKey.megolmV1PublicKey;\n      var authData = {\n        public_key: pubKey.publicKeyBase64\n      };\n      yield signObject(authData);\n      var res = yield _this15.http.authedRequest(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Post, \"/room_keys/version\", undefined, {\n        algorithm: pubKey.algorithm,\n        auth_data: authData\n      }, {\n        prefix: _http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.ClientPrefix.V3\n      });\n      yield _this15.saveBackupDecryptionKey(randomKey, res.version);\n      return {\n        version: res.version,\n        algorithm: pubKey.algorithm,\n        authData: authData,\n        decryptionKey: randomKey\n      };\n    })();\n  }\n\n  /**\n   * Deletes all key backups.\n   *\n   * Will call the API to delete active backup until there is no more present.\n   */\n  deleteAllKeyBackupVersions() {\n    var _this16 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var _yield$_this16$reques, _yield$_this16$reques2;\n      // there could be several backup versions. Delete all to be safe.\n      var current = (_yield$_this16$reques = (_yield$_this16$reques2 = yield _this16.requestKeyBackupVersion()) === null || _yield$_this16$reques2 === void 0 ? void 0 : _yield$_this16$reques2.version) !== null && _yield$_this16$reques !== void 0 ? _yield$_this16$reques : null;\n      while (current != null) {\n        var _yield$_this16$reques3, _yield$_this16$reques4;\n        yield _this16.deleteKeyBackupVersion(current);\n        current = (_yield$_this16$reques3 = (_yield$_this16$reques4 = yield _this16.requestKeyBackupVersion()) === null || _yield$_this16$reques4 === void 0 ? void 0 : _yield$_this16$reques4.version) !== null && _yield$_this16$reques3 !== void 0 ? _yield$_this16$reques3 : null;\n      }\n\n      // XXX: Should this also update Secret Storage and delete any existing keys?\n    })();\n  }\n\n  /**\n   * Deletes the given key backup.\n   *\n   * @param version - The backup version to delete.\n   */\n  deleteKeyBackupVersion(version) {\n    var _this17 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.debug(\"deleteKeyBackupVersion v:\".concat(version));\n      var path = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.encodeUri)(\"/room_keys/version/$version\", {\n        $version: version\n      });\n      yield _this17.http.authedRequest(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Delete, path, undefined, undefined, {\n        prefix: _http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.ClientPrefix.V3\n      });\n      // If the backup we are deleting is the active one, we need to disable the key backup and to have the local properties reset\n      if (_this17.activeBackupVersion === version) {\n        _this17.serverBackupInfo = null;\n        yield _this17.disableKeyBackup();\n      }\n    })();\n  }\n\n  /**\n   * Creates a new backup decryptor for the given private key.\n   * @param decryptionKey - The private key to use for decryption.\n   */\n  createBackupDecryptor(decryptionKey) {\n    return new RustBackupDecryptor(decryptionKey);\n  }\n\n  /**\n   * Restore a key backup.\n   *\n   * @param backupVersion - The version of the backup to restore.\n   * @param backupDecryptor - The backup decryptor to use to decrypt the keys.\n   * @param opts - Options for the restore.\n   * @returns The total number of keys and the total imported.\n   */\n  restoreKeyBackup(backupVersion, backupDecryptor, opts) {\n    var _this18 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var _opts$progressCallbac3;\n      var keyBackup = yield _this18.downloadKeyBackup(backupVersion);\n      opts === null || opts === void 0 || (_opts$progressCallbac3 = opts.progressCallback) === null || _opts$progressCallbac3 === void 0 || _opts$progressCallbac3.call(opts, {\n        stage: \"load_keys\"\n      });\n      return _this18.importKeyBackup(keyBackup, backupVersion, backupDecryptor, opts);\n    })();\n  }\n\n  /**\n   * Call `/room_keys/keys` to download the key backup (room keys) for the given backup version.\n   * https://spec.matrix.org/v1.12/client-server-api/#get_matrixclientv3room_keyskeys\n   *\n   * @param backupVersion\n   * @returns The key backup response.\n   */\n  downloadKeyBackup(backupVersion) {\n    return this.http.authedRequest(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Get, \"/room_keys/keys\", {\n      version: backupVersion\n    }, undefined, {\n      prefix: _http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.ClientPrefix.V3\n    });\n  }\n\n  /**\n   * Import the room keys from a `/room_keys/keys` call.\n   * Calls `opts.progressCallback` with the progress of the import.\n   *\n   * @param keyBackup - The response from the server containing the keys to import.\n   * @param backupVersion - The version of the backup info.\n   * @param backupDecryptor - The backup decryptor to use to decrypt the keys.\n   * @param opts - Options for the import.\n   *\n   * @returns The total number of keys and the total imported.\n   *\n   * @private\n   */\n  importKeyBackup(keyBackup, backupVersion, backupDecryptor, opts) {\n    var _this19 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // We have a full backup here, it can get quite big, so we need to decrypt and import it in chunks.\n\n      var CHUNK_SIZE = 200;\n      // Get the total count as a first pass\n      var totalKeyCount = countKeysInBackup(keyBackup);\n      var totalImported = 0;\n      var totalFailures = 0;\n\n      /**\n       * This method is called when we have enough chunks to decrypt.\n       * It will decrypt the chunks and try to import the room keys.\n       * @param roomChunks\n       */\n      var handleChunkCallback = /*#__PURE__*/function () {\n        var _ref2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (roomChunks) {\n          var _opts$progressCallbac4;\n          var currentChunk = [];\n          var _loop = function* _loop(roomId) {\n            // Decrypt the sessions for the given room\n            var decryptedSessions = yield backupDecryptor.decryptSessions(roomChunks.get(roomId));\n            // Add the decrypted sessions to the current chunk\n            decryptedSessions.forEach(session => {\n              // We set the room_id for each session\n              session.room_id = roomId;\n              currentChunk.push(session);\n            });\n          };\n          for (var roomId of roomChunks.keys()) {\n            yield* _loop(roomId);\n          }\n\n          // We have a chunk of decrypted keys: import them\n          try {\n            yield _this19.importBackedUpRoomKeys(currentChunk, backupVersion);\n            totalImported += currentChunk.length;\n          } catch (e) {\n            totalFailures += currentChunk.length;\n            // We failed to import some keys, but we should still try to import the rest?\n            // Log the error and continue\n            _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.error(\"Error importing keys from backup\", e);\n          }\n          opts === null || opts === void 0 || (_opts$progressCallbac4 = opts.progressCallback) === null || _opts$progressCallbac4 === void 0 || _opts$progressCallbac4.call(opts, {\n            total: totalKeyCount,\n            successes: totalImported,\n            stage: \"load_keys\",\n            failures: totalFailures\n          });\n        });\n        return function handleChunkCallback(_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      var groupChunkCount = 0;\n      var chunkGroupByRoom = new Map();\n\n      // Iterate over the rooms and sessions to group them in chunks\n      // And we call the handleChunkCallback when we have enough chunks to decrypt\n      for (var [roomId, roomData] of Object.entries(keyBackup.rooms)) {\n        // If there are no sessions for the room, skip it\n        if (!roomData.sessions) continue;\n\n        // Initialize a new chunk group for the current room\n        chunkGroupByRoom.set(roomId, {});\n        for (var [sessionId, session] of Object.entries(roomData.sessions)) {\n          // We set previously the chunk group for the current room, so we can safely get it\n          var sessionsForRoom = chunkGroupByRoom.get(roomId);\n          sessionsForRoom[sessionId] = session;\n          groupChunkCount += 1;\n          // If we have enough chunks to decrypt, call the block callback\n          if (groupChunkCount >= CHUNK_SIZE) {\n            // We have enough chunks to decrypt\n            yield handleChunkCallback(chunkGroupByRoom);\n            // Reset the chunk group\n            chunkGroupByRoom = new Map();\n            // There might be remaining keys for that room, so add back an entry for the current room.\n            chunkGroupByRoom.set(roomId, {});\n            groupChunkCount = 0;\n          }\n        }\n      }\n\n      // Handle remaining chunk if needed\n      if (groupChunkCount > 0) {\n        yield handleChunkCallback(chunkGroupByRoom);\n      }\n      return {\n        total: totalKeyCount,\n        imported: totalImported\n      };\n    })();\n  }\n}\n\n/**\n * Checks if the provided backup info matches the given private key.\n *\n * @param info - The backup info to check.\n * @param backupDecryptionKey - The `BackupDecryptionKey` private key to check against.\n * @returns `true` if the private key can decrypt the backup, `false` otherwise.\n */\nfunction backupInfoMatchesBackupDecryptionKey(info, backupDecryptionKey) {\n  var _info$auth_data;\n  if (info.algorithm !== \"m.megolm_backup.v1.curve25519-aes-sha2\") {\n    _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"backupMatchesPrivateKey: Unsupported backup algorithm\", info.algorithm);\n    return false;\n  }\n  return ((_info$auth_data = info.auth_data) === null || _info$auth_data === void 0 ? void 0 : _info$auth_data.public_key) === backupDecryptionKey.megolmV1PublicKey.publicKeyBase64;\n}\n\n/**\n * Implementation of {@link BackupDecryptor} for the rust crypto backend.\n */\nclass RustBackupDecryptor {\n  constructor(decryptionKey) {\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"decryptionKey\", void 0);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"sourceTrusted\", void 0);\n    this.decryptionKey = decryptionKey;\n    this.sourceTrusted = false;\n  }\n\n  /**\n   * Implements {@link BackupDecryptor#decryptSessions}\n   */\n  decryptSessions(ciphertexts) {\n    var _this20 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var keys = [];\n      for (var [sessionId, sessionData] of Object.entries(ciphertexts)) {\n        try {\n          var decrypted = JSON.parse(_this20.decryptionKey.decryptV1(sessionData.session_data.ephemeral, sessionData.session_data.mac, sessionData.session_data.ciphertext));\n          decrypted.session_id = sessionId;\n          keys.push(decrypted);\n        } catch (e) {\n          _logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.log(\"Failed to decrypt megolm session from backup\", e, sessionData);\n        }\n      }\n      return keys;\n    })();\n  }\n\n  /**\n   * Implements {@link BackupDecryptor#free}\n   */\n  free() {\n    this.decryptionKey.free();\n  }\n}\n\n/**\n * Fetch a key backup info from the server.\n *\n * If `version` is provided, calls `GET /room_keys/version/$version` and gets the backup info for that version.\n * See https://spec.matrix.org/v1.12/client-server-api/#get_matrixclientv3room_keysversionversion.\n *\n * If not, calls `GET /room_keys/version` and gets the latest backup info.\n * See https://spec.matrix.org/v1.12/client-server-api/#get_matrixclientv3room_keysversion\n *\n * @param http\n * @param version - the specific version of the backup info to fetch\n * @returns The key backup info or null if there is no backup.\n */\nfunction requestKeyBackupVersion(_x2, _x3) {\n  return _requestKeyBackupVersion.apply(this, arguments);\n}\n\n/**\n * Checks if the provided decryption key matches the public key of the key backup info.\n *\n * @param decryptionKey - The decryption key to check.\n * @param keyBackupInfo - The key backup info to check against.\n * @returns `true` if the decryption key matches the key backup info, `false` otherwise.\n */\nfunction _requestKeyBackupVersion() {\n  _requestKeyBackupVersion = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (http, version) {\n    try {\n      var path = version ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.encodeUri)(\"/room_keys/version/$version\", {\n        $version: version\n      }) : \"/room_keys/version\";\n      return yield http.authedRequest(_http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.Method.Get, path, undefined, undefined, {\n        prefix: _http_api_index_js__WEBPACK_IMPORTED_MODULE_4__.ClientPrefix.V3\n      });\n    } catch (e) {\n      if (e.errcode === \"M_NOT_FOUND\") {\n        return null;\n      } else {\n        throw e;\n      }\n    }\n  });\n  return _requestKeyBackupVersion.apply(this, arguments);\n}\nfunction decryptionKeyMatchesKeyBackupInfo(decryptionKey, keyBackupInfo) {\n  var authData = keyBackupInfo.auth_data;\n  return authData.public_key === decryptionKey.megolmV1PublicKey.publicKeyBase64;\n}\n\n/**\n * Counts the total number of keys present in a key backup.\n * @param keyBackup - The key backup to count the keys from.\n * @returns The total number of keys in the backup.\n */\nfunction countKeysInBackup(keyBackup) {\n  var count = 0;\n  for (var {\n    sessions\n  } of Object.values(keyBackup.rooms)) {\n    count += Object.keys(sessions).length;\n  }\n  return count;\n}\n\n/**\n * Response from GET `/room_keys/keys` endpoint.\n * See https://spec.matrix.org/latest/client-server-api/#get_matrixclientv3room_keyskeys\n */\n//# sourceMappingURL=backup.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vYmFja3VwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUF3RTtBQUNKO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0U7QUFDaEM7QUFDbUM7QUFDSjtBQUNoQjtBQUNqQjtBQUNpQjs7QUFFckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLDZFQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlGQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQixJQUFJLGlGQUFlO0FBQ25CLElBQUksaUZBQWU7QUFDbkIsaUJBQWlCLHNCQUFzQjtBQUN2QyxJQUFJLGlGQUFlO0FBQ25CLElBQUksaUZBQWU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFD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LHNDQUFzQyxzREFBTTtBQUM1QyxnQkFBZ0IsNERBQVk7QUFDNUIsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc3Rlcmljcy1ncmlkLy4vbm9kZV9tb2R1bGVzL21hdHJpeC1qcy1zZGsvbGliL3J1c3QtY3J5cHRvL2JhY2t1cC5qcz9lZDFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfYXN5bmNUb0dlbmVyYXRvciBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCI7XG4vKlxuQ29weXJpZ2h0IDIwMjMgLSAyMDI0IFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0ICogYXMgUnVzdFNka0NyeXB0b0pzIGZyb20gXCJAbWF0cml4LW9yZy9tYXRyaXgtc2RrLWNyeXB0by13YXNtXCI7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2VyLmpzXCI7XG5pbXBvcnQgeyBDbGllbnRQcmVmaXgsIE1hdHJpeEVycm9yLCBNZXRob2QgfSBmcm9tIFwiLi4vaHR0cC1hcGkvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkRXZlbnRFbWl0dGVyIH0gZnJvbSBcIi4uL21vZGVscy90eXBlZC1ldmVudC1lbWl0dGVyLmpzXCI7XG5pbXBvcnQgeyBlbmNvZGVVcmksIGxvZ0R1cmF0aW9uIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgQ3J5cHRvRXZlbnQgfSBmcm9tIFwiLi4vY3J5cHRvLWFwaS9pbmRleC5qc1wiO1xuXG4vKiogQXV0aGVudGlmaWNhdGlvbiBvZiB0aGUgYmFja3VwIGluZm8sIGRlcGVuZHMgb24gYWxnb3JpdGhtICovXG5cbi8qKlxuICogSG9sZHMgaW5mb3JtYXRpb24gb2YgYSBjcmVhdGVkIGtleWJhY2t1cC5cbiAqIFVzZWZ1bCB0byBnZXQgdGhlIGdlbmVyYXRlZCBwcml2YXRlIGtleSBtYXRlcmlhbCBhbmQgc2F2ZSBpdCBzZWN1cmVseSBzb21ld2hlcmUuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1c3RCYWNrdXBNYW5hZ2VyIGV4dGVuZHMgVHlwZWRFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvbG1NYWNoaW5lLCBodHRwLCBvdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub2xtTWFjaGluZSA9IG9sbU1hY2hpbmU7XG4gICAgdGhpcy5odHRwID0gaHR0cDtcbiAgICB0aGlzLm91dGdvaW5nUmVxdWVzdFByb2Nlc3NvciA9IG91dGdvaW5nUmVxdWVzdFByb2Nlc3NvcjtcbiAgICAvKiogSGF2ZSB3ZSBjaGVja2VkIGlmIHRoZXJlIGlzIGEgYmFja3VwIG9uIHRoZSBzZXJ2ZXIgd2hpY2ggd2UgY2FuIHVzZSAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoZWNrZWRGb3JCYWNrdXBcIiwgZmFsc2UpO1xuICAgIC8qKlxuICAgICAqIFRoZSBsYXRlc3QgYmFja3VwIHZlcnNpb24gb24gdGhlIHNlcnZlciwgd2hlbiB3ZSBsYXN0IGNoZWNrZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSB3YXMgbm8gYmFja3VwIG9uIHRoZSBzZXJ2ZXIsIGBudWxsYC4gSWYgb3VyIGF0dGVtcHQgdG8gY2hlY2sgcmVzdWx0ZWQgaW4gYW4gZXJyb3IsIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBiYWNrdXAgd2FzIG5vdCBuZWNlc3NhcmlseSB2ZXJpZmllZC5cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXJ2ZXJCYWNrdXBJbmZvXCIsIHVuZGVmaW5lZCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYWN0aXZlQmFja3VwVmVyc2lvblwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9wcGVkXCIsIGZhbHNlKTtcbiAgICAvKiogd2hldGhlciB7QGxpbmsgYmFja3VwS2V5c0xvb3B9IGlzIGN1cnJlbnRseSBydW5uaW5nICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYmFja3VwS2V5c0xvb3BSdW5uaW5nXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlCYWNrdXBDaGVja0luUHJvZ3Jlc3NcIiwgbnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogVGVsbHMgdGhlIFJ1c3RCYWNrdXBNYW5hZ2VyIHRvIHN0b3AuXG4gICAqIFRoZSBSdXN0QmFja3VwTWFuYWdlciBpcyBzY2hlZHVsaW5nIGJhY2tncm91bmQgdXBsb2FkcyBvZiBrZXlzIHRvIHRoZSBiYWNrdXAsIHRoaXNcbiAgICogY2FsbCBhbGxvd3MgdG8gY2FuY2VsIHRoZSBwcm9jZXNzIHdoZW4gdGhlIGNsaWVudCBpcyBzdG9wcHBlZC5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJhY2t1cCB2ZXJzaW9uIHdlIGFyZSBjdXJyZW50bHkgYmFja2luZyB1cCB0bywgaWYgYW55XG4gICAqL1xuICBnZXRBY3RpdmVCYWNrdXBWZXJzaW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoISh5aWVsZCBfdGhpcy5vbG1NYWNoaW5lLmlzQmFja3VwRW5hYmxlZCgpKSkgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gX3RoaXMuYWN0aXZlQmFja3VwVmVyc2lvbjtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGV0YWlscyBvZiB0aGUgbGF0ZXN0IGJhY2t1cCBvbiB0aGUgc2VydmVyLCB3aGVuIHdlIGxhc3QgY2hlY2tlZC5cbiAgICpcbiAgICogVGhpcyBub3JtYWxseSByZXR1cm5zIGEgY2FjaGVkIHZhbHVlLCBidXQgaWYgd2UgaGF2ZW4ndCB5ZXQgbWFkZSBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciwgaXQgd2lsbCBmaXJlIG9uZSBvZmYuXG4gICAqIEl0IHdpbGwgYWx3YXlzIHJldHVybiB0aGUgZGV0YWlscyBvZiB0aGUgYWN0aXZlIGJhY2t1cCBpZiBrZXkgYmFja3VwIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIElmIHRoZXJlIHdhcyBubyBiYWNrdXAgb24gdGhlIHNlcnZlciwgYG51bGxgLiBJZiBvdXIgYXR0ZW1wdCB0byBjaGVjayByZXN1bHRlZCBpbiBhbiBlcnJvciwgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBnZXRTZXJ2ZXJCYWNrdXBJbmZvKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgLy8gRG8gYSB2YWxpZGl0eSBjaGVjayBpZiB3ZSBoYXZlbid0IGFscmVhZHkgZG9uZSBvbmUuIFRoZSBjaGVjayBpcyBsaWtlbHkgdG8gZmFpbCBpZiB3ZSBkb24ndCB5ZXQgaGF2ZSB0aGVcbiAgICAgIC8vIGJhY2t1cCBrZXlzIC0tIGJ1dCBhcyBhIHNpZGUtZWZmZWN0LCBpdCB3aWxsIHBvcHVsYXRlIGBzZXJ2ZXJCYWNrdXBJbmZvYC5cbiAgICAgIHlpZWxkIF90aGlzMi5jaGVja0tleUJhY2t1cEFuZEVuYWJsZShmYWxzZSk7XG4gICAgICByZXR1cm4gX3RoaXMyLnNlcnZlckJhY2t1cEluZm87XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYSBrZXkgYmFja3VwIGNhbiBiZSB0cnVzdGVkLlxuICAgKlxuICAgKiBAcGFyYW0gaW5mbyAtIGtleSBiYWNrdXAgaW5mbyBkaWN0IGZyb20ge0BsaW5rIE1hdHJpeENsaWVudCNnZXRLZXlCYWNrdXBWZXJzaW9ufS5cbiAgICovXG4gIGlzS2V5QmFja3VwVHJ1c3RlZChpbmZvKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgc2lnbmF0dXJlVmVyaWZpY2F0aW9uID0geWllbGQgX3RoaXMzLm9sbU1hY2hpbmUudmVyaWZ5QmFja3VwKGluZm8pO1xuICAgICAgdmFyIGJhY2t1cEtleXMgPSB5aWVsZCBfdGhpczMub2xtTWFjaGluZS5nZXRCYWNrdXBLZXlzKCk7XG4gICAgICB2YXIgZGVjcnlwdGlvbktleSA9IGJhY2t1cEtleXMgPT09IG51bGwgfHwgYmFja3VwS2V5cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFja3VwS2V5cy5kZWNyeXB0aW9uS2V5O1xuICAgICAgdmFyIGJhY2t1cE1hdGNoZXNTYXZlZFByaXZhdGVLZXkgPSAhIWRlY3J5cHRpb25LZXkgJiYgYmFja3VwSW5mb01hdGNoZXNCYWNrdXBEZWNyeXB0aW9uS2V5KGluZm8sIGRlY3J5cHRpb25LZXkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlc0RlY3J5cHRpb25LZXk6IGJhY2t1cE1hdGNoZXNTYXZlZFByaXZhdGVLZXksXG4gICAgICAgIHRydXN0ZWQ6IHNpZ25hdHVyZVZlcmlmaWNhdGlvbi50cnVzdGVkKClcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZS1jaGVjayB0aGUga2V5IGJhY2t1cCBhbmQgZW5hYmxlL2Rpc2FibGUgaXQgYXMgYXBwcm9wcmlhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBmb3JjZSAtIHdoZXRoZXIgd2Ugc2hvdWxkIGZvcmNlIGEgcmUtY2hlY2sgZXZlbiBpZiBvbmUgaGFzIGFscmVhZHkgaGFwcGVuZWQuXG4gICAqL1xuICBjaGVja0tleUJhY2t1cEFuZEVuYWJsZShmb3JjZSkge1xuICAgIGlmICghZm9yY2UgJiYgdGhpcy5jaGVja2VkRm9yQmFja3VwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBvbmx5IG9uZSBjaGVjayBnb2luZyBvbiBhdCBhIHRpbWVcbiAgICBpZiAoIXRoaXMua2V5QmFja3VwQ2hlY2tJblByb2dyZXNzKSB7XG4gICAgICB0aGlzLmtleUJhY2t1cENoZWNrSW5Qcm9ncmVzcyA9IHRoaXMuZG9DaGVja0tleUJhY2t1cCgpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLmtleUJhY2t1cENoZWNrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMua2V5QmFja3VwQ2hlY2tJblByb2dyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBiYWNrdXAgc2VjcmV0IHJlY2VpdmVkIGV2ZW50IGFuZCBzdG9yZSBpdCBpZiBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGJhY2t1cCB2ZXJzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gc2VjcmV0IC0gVGhlIHNlY3JldCBhcyByZWNlaXZlZCBmcm9tIGEgYG0uc2VjcmV0LnNlbmRgIGV2ZW50IGZvciBzZWNyZXQgYG0ubWVnb2xtX2JhY2t1cC52MWAuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHNlY3JldCBpcyB2YWxpZCBhbmQgaGFzIGJlZW4gc3RvcmVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBoYW5kbGVCYWNrdXBTZWNyZXRSZWNlaXZlZChzZWNyZXQpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYmFja3VwQ2hlY2skYmFja3VwSW47XG4gICAgICAvLyBDdXJyZW50bHkgd2Ugb25seSByZWNlaXZlIHRoZSBkZWNyeXB0aW9uIGtleSB3aXRob3V0IGFueSBrZXkgYmFja3VwIHZlcnNpb24uIEl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgLy8gY2hlY2sgdGhhdCB0aGUgc2VjcmV0IGlzIHZhbGlkIGZvciB0aGUgY3VycmVudCB2ZXJzaW9uIGJlZm9yZSBzdG9yaW5nIGl0LlxuICAgICAgLy8gV2UgZm9yY2UgYSBjaGVjayB0byBlbnN1cmUgdG8gaGF2ZSB0aGUgbGF0ZXN0IHZlcnNpb24uIFdlIGFsc28gd2FudCB0byBjaGVjayB0aGF0IHRoZSBiYWNrdXAgaXMgdHJ1c3RlZFxuICAgICAgLy8gYXMgd2UgZG9uJ3Qgd2FudCB0byBzdG9yZSB0aGUgc2VjcmV0IGlmIHRoZSBiYWNrdXAgaXMgbm90IHRydXN0ZWQsIGFuZCBldmVudHVhbGx5IGltcG9ydCBtZWdvbG0ga2V5cyBsYXRlciBmcm9tIGFuIHVudHJ1c3RlZCBiYWNrdXAuXG4gICAgICB2YXIgYmFja3VwQ2hlY2sgPSB5aWVsZCBfdGhpczQuY2hlY2tLZXlCYWNrdXBBbmRFbmFibGUodHJ1ZSk7XG4gICAgICBpZiAoIShiYWNrdXBDaGVjayAhPT0gbnVsbCAmJiBiYWNrdXBDaGVjayAhPT0gdm9pZCAwICYmIChfYmFja3VwQ2hlY2skYmFja3VwSW4gPSBiYWNrdXBDaGVjay5iYWNrdXBJbmZvKSAhPT0gbnVsbCAmJiBfYmFja3VwQ2hlY2skYmFja3VwSW4gIT09IHZvaWQgMCAmJiBfYmFja3VwQ2hlY2skYmFja3VwSW4udmVyc2lvbikgfHwgIWJhY2t1cENoZWNrLnRydXN0SW5mby50cnVzdGVkKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIHNlcnZlci1zaWRlIGtleSBiYWNrdXAsIG9yIHRoZSBiYWNrdXAgaXMgbm90IHNpZ25lZCBieSBhIHRydXN0ZWQgY3Jvc3Mtc2lnbmluZyBrZXkgb3IgdHJ1c3RlZCBvd24gZGV2aWNlLlxuICAgICAgICAvLyBUaGlzIGRlY3J5cHRpb24ga2V5IGlzIHVzZWxlc3MgdG8gdXMuXG4gICAgICAgIGxvZ2dlci53YXJuKFwiaGFuZGxlQmFja3VwU2VjcmV0UmVjZWl2ZWQ6IFJlY2VpdmVkIGEgYmFja3VwIGRlY3J5cHRpb24ga2V5LCBidXQgdGhlcmUgaXMgbm8gdHJ1c3RlZCBzZXJ2ZXItc2lkZSBrZXkgYmFja3VwXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgYmFja3VwRGVjcnlwdGlvbktleSA9IFJ1c3RTZGtDcnlwdG9Kcy5CYWNrdXBEZWNyeXB0aW9uS2V5LmZyb21CYXNlNjQoc2VjcmV0KTtcbiAgICAgICAgdmFyIHByaXZhdGVLZXlNYXRjaGVzID0gYmFja3VwSW5mb01hdGNoZXNCYWNrdXBEZWNyeXB0aW9uS2V5KGJhY2t1cENoZWNrLmJhY2t1cEluZm8sIGJhY2t1cERlY3J5cHRpb25LZXkpO1xuICAgICAgICBpZiAoIXByaXZhdGVLZXlNYXRjaGVzKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXCJoYW5kbGVCYWNrdXBTZWNyZXRSZWNlaXZlZDogUHJpdmF0ZSBkZWNyeXB0aW9uIGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgcHVibGljIGtleSBvZiB0aGUgY3VycmVudCByZW1vdGUgYmFja3VwLlwiKTtcbiAgICAgICAgICAvLyBqdXN0IGlnbm9yZSB0aGUgc2VjcmV0XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiaGFuZGxlQmFja3VwU2VjcmV0UmVjZWl2ZWQ6IEEgdmFsaWQgYmFja3VwIGRlY3J5cHRpb24ga2V5IGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBzdG9yZWQgaW4gY2FjaGUuXCIpO1xuICAgICAgICB5aWVsZCBfdGhpczQuc2F2ZUJhY2t1cERlY3J5cHRpb25LZXkoYmFja3VwRGVjcnlwdGlvbktleSwgYmFja3VwQ2hlY2suYmFja3VwSW5mby52ZXJzaW9uKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiaGFuZGxlQmFja3VwU2VjcmV0UmVjZWl2ZWQ6IEludmFsaWQgYmFja3VwIGRlY3J5cHRpb24ga2V5XCIsIGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pKCk7XG4gIH1cbiAgc2F2ZUJhY2t1cERlY3J5cHRpb25LZXkoYmFja3VwRGVjcnlwdGlvbktleSwgdmVyc2lvbikge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgX3RoaXM1Lm9sbU1hY2hpbmUuc2F2ZUJhY2t1cERlY3J5cHRpb25LZXkoYmFja3VwRGVjcnlwdGlvbktleSwgdmVyc2lvbik7XG4gICAgICAvLyBFbWl0IGFuIGV2ZW50IHRoYXQgd2UgaGF2ZSBhIG5ldyBiYWNrdXAgZGVjcnlwdGlvbiBrZXksIHNvIHRoYXQgdGhlIHNkayBjYW4gc3RhcnRcbiAgICAgIC8vIGltcG9ydGluZyBrZXlzIGZyb20gYmFja3VwIGlmIG5lZWRlZC5cbiAgICAgIF90aGlzNS5lbWl0KENyeXB0b0V2ZW50LktleUJhY2t1cERlY3J5cHRpb25LZXlDYWNoZWQsIHZlcnNpb24pO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wb3J0IGEgbGlzdCBvZiByb29tIGtleXMgcHJldmlvdXNseSBleHBvcnRlZCBieSBleHBvcnRSb29tS2V5c1xuICAgKlxuICAgKiBAcGFyYW0ga2V5cyAtIGEgbGlzdCBvZiBzZXNzaW9uIGV4cG9ydCBvYmplY3RzXG4gICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIG9uY2UgdGhlIGtleXMgaGF2ZSBiZWVuIGltcG9ydGVkXG4gICAqL1xuICBpbXBvcnRSb29tS2V5cyhrZXlzLCBvcHRzKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfdGhpczYuaW1wb3J0Um9vbUtleXNBc0pzb24oSlNPTi5zdHJpbmdpZnkoa2V5cyksIG9wdHMpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wb3J0IGEgbGlzdCBvZiByb29tIGtleXMgcHJldmlvdXNseSBleHBvcnRlZCBieSBleHBvcnRSb29tS2V5c0FzSnNvblxuICAgKlxuICAgKiBAcGFyYW0ganNvbktleXMgLSBhIEpTT04gc3RyaW5nIGVuY29kaW5nIGEgbGlzdCBvZiBzZXNzaW9uIGV4cG9ydCBvYmplY3RzLFxuICAgKiAgICBlYWNoIG9mIHdoaWNoIGlzIGFuIElNZWdvbG1TZXNzaW9uRGF0YVxuICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyBvbmNlIHRoZSBrZXlzIGhhdmUgYmVlbiBpbXBvcnRlZFxuICAgKi9cbiAgaW1wb3J0Um9vbUtleXNBc0pzb24oanNvbktleXMsIG9wdHMpIHtcbiAgICB2YXIgX3RoaXM3ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF90aGlzNy5vbG1NYWNoaW5lLmltcG9ydEV4cG9ydGVkUm9vbUtleXMoanNvbktleXMsIChwcm9ncmVzcywgdG90YWwpID0+IHtcbiAgICAgICAgdmFyIF9vcHRzJHByb2dyZXNzQ2FsbGJhYztcbiAgICAgICAgdmFyIGltcG9ydE9wdCA9IHtcbiAgICAgICAgICB0b3RhbDogTnVtYmVyKHRvdGFsKSxcbiAgICAgICAgICBzdWNjZXNzZXM6IE51bWJlcihwcm9ncmVzcyksXG4gICAgICAgICAgc3RhZ2U6IFwibG9hZF9rZXlzXCIsXG4gICAgICAgICAgZmFpbHVyZXM6IDBcbiAgICAgICAgfTtcbiAgICAgICAgb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgfHwgKF9vcHRzJHByb2dyZXNzQ2FsbGJhYyA9IG9wdHMucHJvZ3Jlc3NDYWxsYmFjaykgPT09IG51bGwgfHwgX29wdHMkcHJvZ3Jlc3NDYWxsYmFjID09PSB2b2lkIDAgfHwgX29wdHMkcHJvZ3Jlc3NDYWxsYmFjLmNhbGwob3B0cywgaW1wb3J0T3B0KTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0JhY2tlbmQjaW1wb3J0QmFja2VkVXBSb29tS2V5c30uXG4gICAqL1xuICBpbXBvcnRCYWNrZWRVcFJvb21LZXlzKGtleXMsIGJhY2t1cFZlcnNpb24sIG9wdHMpIHtcbiAgICB2YXIgX3RoaXM4ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBrZXlzQnlSb29tID0gbmV3IE1hcCgpO1xuICAgICAgZm9yICh2YXIga2V5IG9mIGtleXMpIHtcbiAgICAgICAgdmFyIHJvb21JZCA9IG5ldyBSdXN0U2RrQ3J5cHRvSnMuUm9vbUlkKGtleS5yb29tX2lkKTtcbiAgICAgICAgaWYgKCFrZXlzQnlSb29tLmhhcyhyb29tSWQpKSB7XG4gICAgICAgICAga2V5c0J5Um9vbS5zZXQocm9vbUlkLCBuZXcgTWFwKCkpO1xuICAgICAgICB9XG4gICAgICAgIGtleXNCeVJvb20uZ2V0KHJvb21JZCkuc2V0KGtleS5zZXNzaW9uX2lkLCBrZXkpO1xuICAgICAgfVxuICAgICAgeWllbGQgX3RoaXM4Lm9sbU1hY2hpbmUuaW1wb3J0QmFja2VkVXBSb29tS2V5cyhrZXlzQnlSb29tLCAocHJvZ3Jlc3MsIHRvdGFsLCBmYWlsdXJlcykgPT4ge1xuICAgICAgICB2YXIgX29wdHMkcHJvZ3Jlc3NDYWxsYmFjMjtcbiAgICAgICAgdmFyIGltcG9ydE9wdCA9IHtcbiAgICAgICAgICB0b3RhbDogTnVtYmVyKHRvdGFsKSxcbiAgICAgICAgICBzdWNjZXNzZXM6IE51bWJlcihwcm9ncmVzcyksXG4gICAgICAgICAgc3RhZ2U6IFwibG9hZF9rZXlzXCIsXG4gICAgICAgICAgZmFpbHVyZXM6IE51bWJlcihmYWlsdXJlcylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgfHwgKF9vcHRzJHByb2dyZXNzQ2FsbGJhYzIgPSBvcHRzLnByb2dyZXNzQ2FsbGJhY2spID09PSBudWxsIHx8IF9vcHRzJHByb2dyZXNzQ2FsbGJhYzIgPT09IHZvaWQgMCB8fCBfb3B0cyRwcm9ncmVzc0NhbGxiYWMyLmNhbGwob3B0cywgaW1wb3J0T3B0KTtcbiAgICAgIH0sIGJhY2t1cFZlcnNpb24pO1xuICAgIH0pKCk7XG4gIH1cbiAgLyoqIEhlbHBlciBmb3IgYGNoZWNrS2V5QmFja3VwYCAqL1xuICBkb0NoZWNrS2V5QmFja3VwKCkge1xuICAgIHZhciBfdGhpczkgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgbG9nZ2VyLmxvZyhcIkNoZWNraW5nIGtleSBiYWNrdXAgc3RhdHVzLi4uXCIpO1xuICAgICAgdmFyIGJhY2t1cEluZm87XG4gICAgICB0cnkge1xuICAgICAgICBiYWNrdXBJbmZvID0geWllbGQgX3RoaXM5LnJlcXVlc3RLZXlCYWNrdXBWZXJzaW9uKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiRXJyb3IgY2hlY2tpbmcgZm9yIGFjdGl2ZSBrZXkgYmFja3VwXCIsIGUpO1xuICAgICAgICBfdGhpczkuc2VydmVyQmFja3VwSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBfdGhpczkuY2hlY2tlZEZvckJhY2t1cCA9IHRydWU7XG4gICAgICBpZiAoYmFja3VwSW5mbyAmJiAhYmFja3VwSW5mby52ZXJzaW9uKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiYWN0aXZlIGJhY2t1cCBsYWNrcyBhIHVzZWZ1bCAndmVyc2lvbic7IGlnbm9yaW5nIGl0XCIpO1xuICAgICAgICBiYWNrdXBJbmZvID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgX3RoaXM5LnNlcnZlckJhY2t1cEluZm8gPSBiYWNrdXBJbmZvO1xuICAgICAgdmFyIGFjdGl2ZVZlcnNpb24gPSB5aWVsZCBfdGhpczkuZ2V0QWN0aXZlQmFja3VwVmVyc2lvbigpO1xuICAgICAgaWYgKCFiYWNrdXBJbmZvKSB7XG4gICAgICAgIGlmIChhY3RpdmVWZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcIk5vIGtleSBiYWNrdXAgcHJlc2VudCBvbiBzZXJ2ZXI6IGRpc2FibGluZyBrZXkgYmFja3VwXCIpO1xuICAgICAgICAgIHlpZWxkIF90aGlzOS5kaXNhYmxlS2V5QmFja3VwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcIk5vIGtleSBiYWNrdXAgcHJlc2VudCBvbiBzZXJ2ZXI6IG5vdCBlbmFibGluZyBrZXkgYmFja3VwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHRydXN0SW5mbyA9IHlpZWxkIF90aGlzOS5pc0tleUJhY2t1cFRydXN0ZWQoYmFja3VwSW5mbyk7XG4gICAgICBpZiAoIXRydXN0SW5mby50cnVzdGVkKSB7XG4gICAgICAgIGlmIChhY3RpdmVWZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcIktleSBiYWNrdXAgcHJlc2VudCBvbiBzZXJ2ZXIgYnV0IG5vdCB0cnVzdGVkOiBkaXNhYmxpbmcga2V5IGJhY2t1cFwiKTtcbiAgICAgICAgICB5aWVsZCBfdGhpczkuZGlzYWJsZUtleUJhY2t1cCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coXCJLZXkgYmFja3VwIHByZXNlbnQgb24gc2VydmVyIGJ1dCBub3QgdHJ1c3RlZDogbm90IGVuYWJsaW5nIGtleSBiYWNrdXBcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhY3RpdmVWZXJzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcIkZvdW5kIHVzYWJsZSBrZXkgYmFja3VwIHZcIi5jb25jYXQoYmFja3VwSW5mby52ZXJzaW9uLCBcIjogZW5hYmxpbmcga2V5IGJhY2t1cHNcIikpO1xuICAgICAgICAgIHlpZWxkIF90aGlzOS5lbmFibGVLZXlCYWNrdXAoYmFja3VwSW5mbyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aXZlVmVyc2lvbiAhPT0gYmFja3VwSW5mby52ZXJzaW9uKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcIk9uIGJhY2t1cCB2ZXJzaW9uIFwiLmNvbmNhdChhY3RpdmVWZXJzaW9uLCBcIiBidXQgZm91bmQgdmVyc2lvbiBcIikuY29uY2F0KGJhY2t1cEluZm8udmVyc2lvbiwgXCI6IHN3aXRjaGluZy5cIikpO1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCByZW1vdmUgYW55IHBlbmRpbmcgYmFja3VwIHJlcXVlc3QsIHJlbW92ZSB0aGUgYmFja3VwIGtleSBhbmQgcmVzZXQgdGhlIGJhY2t1cCBzdGF0ZSBvZiBlYWNoIHJvb20ga2V5IHdlIGhhdmUuXG4gICAgICAgICAgeWllbGQgX3RoaXM5LmRpc2FibGVLZXlCYWNrdXAoKTtcbiAgICAgICAgICAvLyBFbmFibGluZyB3aWxsIG5vdyB0cmlnZ2VyIHJlLXVwbG9hZCBvZiBhbGwgdGhlIGtleXNcbiAgICAgICAgICB5aWVsZCBfdGhpczkuZW5hYmxlS2V5QmFja3VwKGJhY2t1cEluZm8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coXCJCYWNrdXAgdmVyc2lvbiBcIi5jb25jYXQoYmFja3VwSW5mby52ZXJzaW9uLCBcIiBzdGlsbCBjdXJyZW50XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFja3VwSW5mbyxcbiAgICAgICAgdHJ1c3RJbmZvXG4gICAgICB9O1xuICAgIH0pKCk7XG4gIH1cbiAgZW5hYmxlS2V5QmFja3VwKGJhY2t1cEluZm8pIHtcbiAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyB3ZSBrbm93IGZvciBjZXJ0YWluIGl0IG11c3QgYmUgYSBDdXJ2ZTI1NTE5IGtleSwgYmVjYXVzZSB3ZSBoYXZlIHZlcmlmaWVkIGl0IGFuZCBvbmx5IEN1cnZlMjU1MTlcbiAgICAgIC8vIGtleXMgY2FuIGJlIHZlcmlmaWVkLlxuICAgICAgLy9cbiAgICAgIC8vIHdlIGFsc28gY2hlY2tlZCBpdCBoYXMgYSB2YWxpZCBgdmVyc2lvbmAuXG4gICAgICB5aWVsZCBfdGhpczEwLm9sbU1hY2hpbmUuZW5hYmxlQmFja3VwVjEoYmFja3VwSW5mby5hdXRoX2RhdGEucHVibGljX2tleSwgYmFja3VwSW5mby52ZXJzaW9uKTtcbiAgICAgIF90aGlzMTAuYWN0aXZlQmFja3VwVmVyc2lvbiA9IGJhY2t1cEluZm8udmVyc2lvbjtcbiAgICAgIF90aGlzMTAuZW1pdChDcnlwdG9FdmVudC5LZXlCYWNrdXBTdGF0dXMsIHRydWUpO1xuICAgICAgX3RoaXMxMC5iYWNrdXBLZXlzTG9vcCgpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzdGFydCB0aGUgYmFja3VwIGtleSBsb29wIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSB0cnVzdGVkIGJhY2t1cC5cbiAgICogRG9lc24ndCB0cnkgdG8gY2hlY2sgdGhlIGJhY2t1cCBzZXJ2ZXIgc2lkZS4gVG8gYmUgY2FsbGVkIHdoZW4gYSBuZXdcbiAgICogbWVnb2xtIGtleSBpcyBrbm93biBsb2NhbGx5LlxuICAgKi9cbiAgbWF5YmVVcGxvYWRLZXkoKSB7XG4gICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKF90aGlzMTEuYWN0aXZlQmFja3VwVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIF90aGlzMTEuYmFja3VwS2V5c0xvb3AoKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG4gIGRpc2FibGVLZXlCYWNrdXAoKSB7XG4gICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgX3RoaXMxMi5vbG1NYWNoaW5lLmRpc2FibGVCYWNrdXAoKTtcbiAgICAgIF90aGlzMTIuYWN0aXZlQmFja3VwVmVyc2lvbiA9IG51bGw7XG4gICAgICBfdGhpczEyLmVtaXQoQ3J5cHRvRXZlbnQuS2V5QmFja3VwU3RhdHVzLCBmYWxzZSk7XG4gICAgfSkoKTtcbiAgfVxuICBiYWNrdXBLZXlzTG9vcCgpIHtcbiAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cyxcbiAgICAgIF90aGlzMTMgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIG1heERlbGF5ID0gX2FyZ3VtZW50cy5sZW5ndGggPiAwICYmIF9hcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmd1bWVudHNbMF0gOiAxMDAwMDtcbiAgICAgIGlmIChfdGhpczEzLmJhY2t1cEtleXNMb29wUnVubmluZykge1xuICAgICAgICBsb2dnZXIubG9nKFwiQmFja3VwIGxvb3AgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfdGhpczEzLmJhY2t1cEtleXNMb29wUnVubmluZyA9IHRydWU7XG4gICAgICBsb2dnZXIubG9nKFwiQmFja3VwOiBTdGFydGluZyBrZXlzIHVwbG9hZCBsb29wIGZvciBiYWNrdXAgdmVyc2lvbjpcIi5jb25jYXQoX3RoaXMxMy5hY3RpdmVCYWNrdXBWZXJzaW9uLCBcIi5cIikpO1xuXG4gICAgICAvLyB3YWl0IGJldHdlZW4gMCBhbmQgYG1heERlbGF5YCBzZWNvbmRzLCB0byBhdm9pZCBiYWNrdXBcbiAgICAgIC8vIHJlcXVlc3RzIGZyb20gZGlmZmVyZW50IGNsaWVudHMgaGl0dGluZyB0aGUgc2VydmVyIGFsbCBhdFxuICAgICAgLy8gdGhlIHNhbWUgdGltZSB3aGVuIGEgbmV3IGtleSBpcyBzZW50XG4gICAgICB2YXIgZGVsYXkgPSBNYXRoLnJhbmRvbSgpICogbWF4RGVsYXk7XG4gICAgICB5aWVsZCBzbGVlcChkZWxheSk7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBudW1iZXIgb2YgY29uc2VjdXRpdmUgbmV0d29yayBmYWlsdXJlcyBmb3IgZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSAwO1xuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGtleXMgbGVmdCB0byBiYWNrIHVwLiAoUG9wdWxhdGVkIGxhemlseTogc2VlIG1vcmUgY29tbWVudHMgYmVsb3cuKVxuICAgICAgICB2YXIgcmVtYWluaW5nVG9VcGxvYWRDb3VudCA9IG51bGw7XG4gICAgICAgIC8vIFRvIGF2b2lkIGNvbXB1dGluZyB0aGUga2V5IHdoZW4gb25seSBhIGZldyBrZXlzIHdlcmUgYWRkZWQgKGFmdGVyIGEgc3luYyBmb3IgZXhhbXBsZSksXG4gICAgICAgIC8vIHdlIGNvbXB1dGUgdGhlIGNvdW50IG9ubHkgd2hlbiBhdCBsZWFzdCB0d28gaXRlcmF0aW9ucyBhcmUgbmVlZGVkLlxuICAgICAgICB2YXIgaXNGaXJzdEl0ZXJhdGlvbiA9IHRydWU7XG4gICAgICAgIHdoaWxlICghX3RoaXMxMy5zdG9wcGVkKSB7XG4gICAgICAgICAgLy8gR2V0IGEgYmF0Y2ggb2Ygcm9vbSBrZXlzIHRvIHVwbG9hZFxuICAgICAgICAgIHZhciByZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVxdWVzdCA9IHlpZWxkIGxvZ0R1cmF0aW9uKGxvZ2dlciwgXCJCYWNrdXBSb29tS2V5czogR2V0IGtleXMgdG8gYmFja3VwIGZyb20gcnVzdCBjcnlwdG8tc2RrXCIsIC8qI19fUFVSRV9fKi9fYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICByZXR1cm4geWllbGQgX3RoaXMxMy5vbG1NYWNoaW5lLmJhY2t1cFJvb21LZXlzKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJCYWNrdXA6IEZhaWxlZCB0byBnZXQga2V5cyB0byBiYWNrdXAgZnJvbSBydXN0IGNyeXB0by1zZGtcIiwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IF90aGlzMTMuc3RvcHBlZCB8fCAhX3RoaXMxMy5hY3RpdmVCYWNrdXBWZXJzaW9uKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiQmFja3VwOiBFbmRpbmcgbG9vcCBmb3IgdmVyc2lvbiBcIi5jb25jYXQoX3RoaXMxMy5hY3RpdmVCYWNrdXBWZXJzaW9uLCBcIi5cIikpO1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgIC8vIG5vdGhpbmcgbW9yZSB0byB1cGxvYWRcbiAgICAgICAgICAgICAgX3RoaXMxMy5lbWl0KENyeXB0b0V2ZW50LktleUJhY2t1cFNlc3Npb25zUmVtYWluaW5nLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHlpZWxkIF90aGlzMTMub3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yLm1ha2VPdXRnb2luZ1JlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgICAgICBudW1GYWlsdXJlcyA9IDA7XG4gICAgICAgICAgICBpZiAoX3RoaXMxMy5zdG9wcGVkKSBicmVhaztcblxuICAgICAgICAgICAgLy8gS2V5IGNvdW50IHBlcmZvcm1hbmNlIChgb2xtTWFjaGluZS5yb29tS2V5Q291bnRzKClgKSBjYW4gYmUgcHJldHR5IGJhZCBvbiBzb21lIGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICAgICAgLy8gSW4gcGFydGljdWxhciwgd2UgZGV0ZWN0ZWQgb24gc29tZSBNMSBtYWNzIHRoYXQgd2hlbiB0aGUgb2JqZWN0IHN0b3JlIHJlYWNoZXMgYSB0aHJlc2hvbGQsIHRoZSBjb3VudFxuICAgICAgICAgICAgLy8gcGVyZm9ybWFuY2Ugc3RvcHMgZ3Jvd2luZyBpbiBPKG4pIGFuZCBzdWRkZW5seSBiZWNvbWVzIHZlcnkgc2xvdyAoNDBzLCA2MHMgb3IgbW9yZSkuXG4gICAgICAgICAgICAvLyBGb3IgcmVmZXJlbmNlLCB0aGUgcGVyZm9ybWFuY2UgZHJvcCBvY2N1cnMgYXJvdW5kIDMwMC00MDBrIGtleXMgb24gdGhlIHBsYXRmb3JtcyB3aGVyZSB0aGlzIGlzc3VlIGlzIG9ic2VydmVkLlxuICAgICAgICAgICAgLy8gRXZlbiBvbiBvdGhlciBjb25maWd1cmF0aW9ucywgdGhlIGNvdW50IGNhbiB0YWtlIHNldmVyYWwgc2Vjb25kcy5cbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBibG9jayBvdGhlciBvcGVyYXRpb25zIG9uIHRoZSBkYXRhYmFzZSwgbGlrZSBzZW5kaW5nIG1lc3NhZ2VzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIHRvIGF2b2lkIGNhbGxpbmcgYG9sbU1hY2hpbmUucm9vbUtleUNvdW50cygpYCB0b28gb2Z0ZW4sIGFuZCBvbmx5IHdoZW4gbmVjZXNzYXJ5LlxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgY2FsbCBpdCBvbiB0aGUgZmlyc3QgbG9vcCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgYSBmZXcga2V5cyB0byB1cGxvYWQsIGFuZCB3ZSBkb24ndCB3YW50IHRvIHdhaXQgZm9yIHRoZSBjb3VudC5cbiAgICAgICAgICAgIGlmICghaXNGaXJzdEl0ZXJhdGlvbiAmJiByZW1haW5pbmdUb1VwbG9hZENvdW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleUNvdW50ID0geWllbGQgX3RoaXMxMy5vbG1NYWNoaW5lLnJvb21LZXlDb3VudHMoKTtcbiAgICAgICAgICAgICAgICByZW1haW5pbmdUb1VwbG9hZENvdW50ID0ga2V5Q291bnQudG90YWwgLSBrZXlDb3VudC5iYWNrZWRVcDtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiQmFja3VwOiBGYWlsZWQgdG8gZ2V0IGtleSBjb3VudHMgZnJvbSBydXN0IGNyeXB0by1zZGtcIiwgZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ1RvVXBsb2FkQ291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgX3RoaXMxMy5lbWl0KENyeXB0b0V2ZW50LktleUJhY2t1cFNlc3Npb25zUmVtYWluaW5nLCByZW1haW5pbmdUb1VwbG9hZENvdW50KTtcbiAgICAgICAgICAgICAgdmFyIGtleXNDb3VudEluQmF0Y2ggPSBfdGhpczEzLmtleXNDb3VudEluQmF0Y2gocmVxdWVzdCk7XG4gICAgICAgICAgICAgIC8vIGBPbG1NYWNoaW5lLnJvb21LZXlDb3VudHNgIGlzIGNhbGxlZCBvbmx5IG9uY2UgZm9yIHRoZSBjdXJyZW50IGJhY2t1cEtleXNMb29wLiBCdXQgbmV3XG4gICAgICAgICAgICAgIC8vIGtleXMgY291bGQgYmUgYWRkZWQgZHVyaW5nIHRoZSBjdXJyZW50IGxvb3AgKGFmdGVyIGEgc3luYyBmb3IgZXhhbXBsZSkuXG4gICAgICAgICAgICAgIC8vIFNvIHRoZSBjb3VudCBjYW4gZ2V0IG91dCBvZiBzeW5jIHdpdGggdGhlIHJlYWwgbnVtYmVyIG9mIHJlbWFpbmluZyBrZXlzIHRvIHVwbG9hZC5cbiAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBudW1iZXIgb2YgbmV3IGtleXMgaW1wb3J0ZWQgYW5kIHRoZSB0aW1lIHRvIGNvbXBsZXRlIHRoZSBsb29wLFxuICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBldmVudHMgYmVpbmcgZW1pdHRlZCB3aXRoIGEgcmVtYWluaW5nIGtleSBjb3VudCBvZiAwLlxuICAgICAgICAgICAgICByZW1haW5pbmdUb1VwbG9hZENvdW50ID0gTWF0aC5tYXgocmVtYWluaW5nVG9VcGxvYWRDb3VudCAtIGtleXNDb3VudEluQmF0Y2gsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbnVtRmFpbHVyZXMrKztcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkJhY2t1cDogRXJyb3IgcHJvY2Vzc2luZyBiYWNrdXAgcmVxdWVzdCBmb3IgcnVzdCBjcnlwdG8tc2RrXCIsIGVycik7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgTWF0cml4RXJyb3IpIHtcbiAgICAgICAgICAgICAgdmFyIGVyckNvZGUgPSBlcnIuZGF0YS5lcnJjb2RlO1xuICAgICAgICAgICAgICBpZiAoZXJyQ29kZSA9PSBcIk1fTk9UX0ZPVU5EXCIgfHwgZXJyQ29kZSA9PSBcIk1fV1JPTkdfUk9PTV9LRVlTX1ZFUlNJT05cIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJCYWNrdXA6IEZhaWxlZCB0byB1cGxvYWQga2V5cyB0byBjdXJyZW50IHZlc2lvbjogXCIuY29uY2F0KGVyckNvZGUsIFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzMTMuZGlzYWJsZUtleUJhY2t1cCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJCYWNrdXA6IEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGRpc2FibGluZyBrZXkgYmFja3VwOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzMTMuZW1pdChDcnlwdG9FdmVudC5LZXlCYWNrdXBGYWlsZWQsIGVyci5kYXRhLmVycmNvZGUpO1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIHdhcyBhbiBhY3RpdmUgYmFja3VwIGFuZCB3ZSBhcmUgb3V0IG9mIHN5bmMgd2l0aCB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgYSBjaGVjayBzZXJ2ZXIgc2lkZVxuICAgICAgICAgICAgICAgIF90aGlzMTMuYmFja3VwS2V5c0xvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMxMy5jaGVja0tleUJhY2t1cEFuZEVuYWJsZSh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyLmlzUmF0ZUxpbWl0RXJyb3IoKSkge1xuICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRoYXQgYW5kIHRoZW4gY29udGludWU/XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciB3YWl0VGltZSA9IGVyci5nZXRSZXRyeUFmdGVyTXMoKTtcbiAgICAgICAgICAgICAgICAgIGlmICh3YWl0VGltZSAmJiB3YWl0VGltZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgc2xlZXAod2FpdFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJCYWNrdXA6IEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJldHJpZXZpbmcgYSByYXRlLWxpbWl0IHJldHJ5IGRlbGF5XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IC8vIGVsc2UgZ28gdG8gdGhlIG5vcm1hbCBiYWNrb2ZmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU29tZSBvdGhlciBlcnJvcnMgKG14LCBuZXR3b3JrLCBvciBDT1JTIG9yIGludmFsaWQgdXJscz8pIGFueWhvdyBiYWNrb2ZmXG4gICAgICAgICAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGlmIHdlIGhhdmUgZmFpbHVyZXNcbiAgICAgICAgICAgIHlpZWxkIHNsZWVwKDEwMDAgKiBNYXRoLnBvdygyLCBNYXRoLm1pbihudW1GYWlsdXJlcyAtIDEsIDQpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzRmlyc3RJdGVyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX3RoaXMxMy5iYWNrdXBLZXlzTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIHRvIGNvdW50IHRoZSBudW1iZXIgb2Yga2V5cyBpbiBhIGJhY2t1cCByZXF1ZXN0LCBpbiBvcmRlciB0byB1cGRhdGUgdGhlIHJlbWFpbmluZyBrZXlzIGNvdW50LlxuICAgKiBUaGlzIHNob3VsZCBiZSB0aGUgY2h1bmsgc2l6ZSBvZiB0aGUgYmFja3VwIHJlcXVlc3QgZm9yIGFsbCByZXF1ZXN0cyBidXQgdGhlIGxhc3QsIGJ1dCB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byBpdFxuICAgKiAoaXQncyBzdGF0aWMgaW4gdGhlIFJ1c3QgU0RLKS5cbiAgICogQHBhcmFtIGJhdGNoIC0gVGhlIGJhY2t1cCByZXF1ZXN0IHRvIGNvdW50IHRoZSBrZXlzIGZyb20uXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2Yga2V5cyBpbiB0aGUgYmFja3VwIHJlcXVlc3QuXG4gICAqL1xuICBrZXlzQ291bnRJbkJhdGNoKGJhdGNoKSB7XG4gICAgdmFyIHBhcnNlZEJvZHkgPSBKU09OLnBhcnNlKGJhdGNoLmJvZHkpO1xuICAgIHJldHVybiBjb3VudEtleXNJbkJhY2t1cChwYXJzZWRCb2R5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgYSBrZXkgYmFja3VwIGZyb20gdGhlIHNlcnZlclxuICAgKiAtIElmIHZlcnNpb24gaXMgcHJvdmlkZWQsIGdldCBpbmZvcm1hdGlvbiBhYm91dCB0aGF0IGJhY2t1cCB2ZXJzaW9uLlxuICAgKiAtIElmIG5vIHZlcnNpb24gaXMgcHJvdmlkZWQsIGdldCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGF0ZXN0IGJhY2t1cC5cbiAgICpcbiAgICogQHBhcmFtIHZlcnNpb24gLSBUaGUgdmVyc2lvbiBvZiB0aGUgYmFja3VwIHRvIGdldCBpbmZvcm1hdGlvbiBhYm91dC5cbiAgICogQHJldHVybnMgSW5mb3JtYXRpb24gb2JqZWN0IGZyb20gQVBJIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGJhY2t1cC5cbiAgICovXG4gIHJlcXVlc3RLZXlCYWNrdXBWZXJzaW9uKHZlcnNpb24pIHtcbiAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4geWllbGQgcmVxdWVzdEtleUJhY2t1cFZlcnNpb24oX3RoaXMxNC5odHRwLCB2ZXJzaW9uKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcga2V5IGJhY2t1cCBieSBnZW5lcmF0aW5nIGEgbmV3IHJhbmRvbSBwcml2YXRlIGtleS5cbiAgICpcbiAgICogSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgYmFja3VwIHNlcnZlciBzaWRlIGl0IHdpbGwgYmUgZGVsZXRlZCBhbmQgcmVwbGFjZWRcbiAgICogYnkgdGhlIG5ldyBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSBzaWduT2JqZWN0IC0gTWV0aG9kIHRoYXQgc2hvdWxkIHNpZ24gdGhlIGJhY2t1cCB3aXRoIGV4aXN0aW5nIGRldmljZSBhbmRcbiAgICogZXhpc3RpbmcgaWRlbnRpdHkuXG4gICAqIEByZXR1cm5zIGEgS2V5QmFja3VwQ3JlYXRpb25JbmZvIC0gQWxsIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhlIGJhY2t1cC5cbiAgICovXG4gIHNldHVwS2V5QmFja3VwKHNpZ25PYmplY3QpIHtcbiAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBDbGVhbiB1cCBhbnkgZXhpc3RpbmcgYmFja3VwXG4gICAgICB5aWVsZCBfdGhpczE1LmRlbGV0ZUFsbEtleUJhY2t1cFZlcnNpb25zKCk7XG4gICAgICB2YXIgcmFuZG9tS2V5ID0gUnVzdFNka0NyeXB0b0pzLkJhY2t1cERlY3J5cHRpb25LZXkuY3JlYXRlUmFuZG9tS2V5KCk7XG4gICAgICB2YXIgcHViS2V5ID0gcmFuZG9tS2V5Lm1lZ29sbVYxUHVibGljS2V5O1xuICAgICAgdmFyIGF1dGhEYXRhID0ge1xuICAgICAgICBwdWJsaWNfa2V5OiBwdWJLZXkucHVibGljS2V5QmFzZTY0XG4gICAgICB9O1xuICAgICAgeWllbGQgc2lnbk9iamVjdChhdXRoRGF0YSk7XG4gICAgICB2YXIgcmVzID0geWllbGQgX3RoaXMxNS5odHRwLmF1dGhlZFJlcXVlc3QoTWV0aG9kLlBvc3QsIFwiL3Jvb21fa2V5cy92ZXJzaW9uXCIsIHVuZGVmaW5lZCwge1xuICAgICAgICBhbGdvcml0aG06IHB1YktleS5hbGdvcml0aG0sXG4gICAgICAgIGF1dGhfZGF0YTogYXV0aERhdGFcbiAgICAgIH0sIHtcbiAgICAgICAgcHJlZml4OiBDbGllbnRQcmVmaXguVjNcbiAgICAgIH0pO1xuICAgICAgeWllbGQgX3RoaXMxNS5zYXZlQmFja3VwRGVjcnlwdGlvbktleShyYW5kb21LZXksIHJlcy52ZXJzaW9uKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IHJlcy52ZXJzaW9uLFxuICAgICAgICBhbGdvcml0aG06IHB1YktleS5hbGdvcml0aG0sXG4gICAgICAgIGF1dGhEYXRhOiBhdXRoRGF0YSxcbiAgICAgICAgZGVjcnlwdGlvbktleTogcmFuZG9tS2V5XG4gICAgICB9O1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwga2V5IGJhY2t1cHMuXG4gICAqXG4gICAqIFdpbGwgY2FsbCB0aGUgQVBJIHRvIGRlbGV0ZSBhY3RpdmUgYmFja3VwIHVudGlsIHRoZXJlIGlzIG5vIG1vcmUgcHJlc2VudC5cbiAgICovXG4gIGRlbGV0ZUFsbEtleUJhY2t1cFZlcnNpb25zKCkge1xuICAgIHZhciBfdGhpczE2ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfeWllbGQkX3RoaXMxNiRyZXF1ZXMsIF95aWVsZCRfdGhpczE2JHJlcXVlczI7XG4gICAgICAvLyB0aGVyZSBjb3VsZCBiZSBzZXZlcmFsIGJhY2t1cCB2ZXJzaW9ucy4gRGVsZXRlIGFsbCB0byBiZSBzYWZlLlxuICAgICAgdmFyIGN1cnJlbnQgPSAoX3lpZWxkJF90aGlzMTYkcmVxdWVzID0gKF95aWVsZCRfdGhpczE2JHJlcXVlczIgPSB5aWVsZCBfdGhpczE2LnJlcXVlc3RLZXlCYWNrdXBWZXJzaW9uKCkpID09PSBudWxsIHx8IF95aWVsZCRfdGhpczE2JHJlcXVlczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF95aWVsZCRfdGhpczE2JHJlcXVlczIudmVyc2lvbikgIT09IG51bGwgJiYgX3lpZWxkJF90aGlzMTYkcmVxdWVzICE9PSB2b2lkIDAgPyBfeWllbGQkX3RoaXMxNiRyZXF1ZXMgOiBudWxsO1xuICAgICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgX3lpZWxkJF90aGlzMTYkcmVxdWVzMywgX3lpZWxkJF90aGlzMTYkcmVxdWVzNDtcbiAgICAgICAgeWllbGQgX3RoaXMxNi5kZWxldGVLZXlCYWNrdXBWZXJzaW9uKGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gKF95aWVsZCRfdGhpczE2JHJlcXVlczMgPSAoX3lpZWxkJF90aGlzMTYkcmVxdWVzNCA9IHlpZWxkIF90aGlzMTYucmVxdWVzdEtleUJhY2t1cFZlcnNpb24oKSkgPT09IG51bGwgfHwgX3lpZWxkJF90aGlzMTYkcmVxdWVzNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3lpZWxkJF90aGlzMTYkcmVxdWVzNC52ZXJzaW9uKSAhPT0gbnVsbCAmJiBfeWllbGQkX3RoaXMxNiRyZXF1ZXMzICE9PSB2b2lkIDAgPyBfeWllbGQkX3RoaXMxNiRyZXF1ZXMzIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gWFhYOiBTaG91bGQgdGhpcyBhbHNvIHVwZGF0ZSBTZWNyZXQgU3RvcmFnZSBhbmQgZGVsZXRlIGFueSBleGlzdGluZyBrZXlzP1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgZ2l2ZW4ga2V5IGJhY2t1cC5cbiAgICpcbiAgICogQHBhcmFtIHZlcnNpb24gLSBUaGUgYmFja3VwIHZlcnNpb24gdG8gZGVsZXRlLlxuICAgKi9cbiAgZGVsZXRlS2V5QmFja3VwVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgdmFyIF90aGlzMTcgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiZGVsZXRlS2V5QmFja3VwVmVyc2lvbiB2OlwiLmNvbmNhdCh2ZXJzaW9uKSk7XG4gICAgICB2YXIgcGF0aCA9IGVuY29kZVVyaShcIi9yb29tX2tleXMvdmVyc2lvbi8kdmVyc2lvblwiLCB7XG4gICAgICAgICR2ZXJzaW9uOiB2ZXJzaW9uXG4gICAgICB9KTtcbiAgICAgIHlpZWxkIF90aGlzMTcuaHR0cC5hdXRoZWRSZXF1ZXN0KE1ldGhvZC5EZWxldGUsIHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgIHByZWZpeDogQ2xpZW50UHJlZml4LlYzXG4gICAgICB9KTtcbiAgICAgIC8vIElmIHRoZSBiYWNrdXAgd2UgYXJlIGRlbGV0aW5nIGlzIHRoZSBhY3RpdmUgb25lLCB3ZSBuZWVkIHRvIGRpc2FibGUgdGhlIGtleSBiYWNrdXAgYW5kIHRvIGhhdmUgdGhlIGxvY2FsIHByb3BlcnRpZXMgcmVzZXRcbiAgICAgIGlmIChfdGhpczE3LmFjdGl2ZUJhY2t1cFZlcnNpb24gPT09IHZlcnNpb24pIHtcbiAgICAgICAgX3RoaXMxNy5zZXJ2ZXJCYWNrdXBJbmZvID0gbnVsbDtcbiAgICAgICAgeWllbGQgX3RoaXMxNy5kaXNhYmxlS2V5QmFja3VwKCk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGJhY2t1cCBkZWNyeXB0b3IgZm9yIHRoZSBnaXZlbiBwcml2YXRlIGtleS5cbiAgICogQHBhcmFtIGRlY3J5cHRpb25LZXkgLSBUaGUgcHJpdmF0ZSBrZXkgdG8gdXNlIGZvciBkZWNyeXB0aW9uLlxuICAgKi9cbiAgY3JlYXRlQmFja3VwRGVjcnlwdG9yKGRlY3J5cHRpb25LZXkpIHtcbiAgICByZXR1cm4gbmV3IFJ1c3RCYWNrdXBEZWNyeXB0b3IoZGVjcnlwdGlvbktleSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSBhIGtleSBiYWNrdXAuXG4gICAqXG4gICAqIEBwYXJhbSBiYWNrdXBWZXJzaW9uIC0gVGhlIHZlcnNpb24gb2YgdGhlIGJhY2t1cCB0byByZXN0b3JlLlxuICAgKiBAcGFyYW0gYmFja3VwRGVjcnlwdG9yIC0gVGhlIGJhY2t1cCBkZWNyeXB0b3IgdG8gdXNlIHRvIGRlY3J5cHQgdGhlIGtleXMuXG4gICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBmb3IgdGhlIHJlc3RvcmUuXG4gICAqIEByZXR1cm5zIFRoZSB0b3RhbCBudW1iZXIgb2Yga2V5cyBhbmQgdGhlIHRvdGFsIGltcG9ydGVkLlxuICAgKi9cbiAgcmVzdG9yZUtleUJhY2t1cChiYWNrdXBWZXJzaW9uLCBiYWNrdXBEZWNyeXB0b3IsIG9wdHMpIHtcbiAgICB2YXIgX3RoaXMxOCA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX29wdHMkcHJvZ3Jlc3NDYWxsYmFjMztcbiAgICAgIHZhciBrZXlCYWNrdXAgPSB5aWVsZCBfdGhpczE4LmRvd25sb2FkS2V5QmFja3VwKGJhY2t1cFZlcnNpb24pO1xuICAgICAgb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgfHwgKF9vcHRzJHByb2dyZXNzQ2FsbGJhYzMgPSBvcHRzLnByb2dyZXNzQ2FsbGJhY2spID09PSBudWxsIHx8IF9vcHRzJHByb2dyZXNzQ2FsbGJhYzMgPT09IHZvaWQgMCB8fCBfb3B0cyRwcm9ncmVzc0NhbGxiYWMzLmNhbGwob3B0cywge1xuICAgICAgICBzdGFnZTogXCJsb2FkX2tleXNcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gX3RoaXMxOC5pbXBvcnRLZXlCYWNrdXAoa2V5QmFja3VwLCBiYWNrdXBWZXJzaW9uLCBiYWNrdXBEZWNyeXB0b3IsIG9wdHMpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBgL3Jvb21fa2V5cy9rZXlzYCB0byBkb3dubG9hZCB0aGUga2V5IGJhY2t1cCAocm9vbSBrZXlzKSBmb3IgdGhlIGdpdmVuIGJhY2t1cCB2ZXJzaW9uLlxuICAgKiBodHRwczovL3NwZWMubWF0cml4Lm9yZy92MS4xMi9jbGllbnQtc2VydmVyLWFwaS8jZ2V0X21hdHJpeGNsaWVudHYzcm9vbV9rZXlza2V5c1xuICAgKlxuICAgKiBAcGFyYW0gYmFja3VwVmVyc2lvblxuICAgKiBAcmV0dXJucyBUaGUga2V5IGJhY2t1cCByZXNwb25zZS5cbiAgICovXG4gIGRvd25sb2FkS2V5QmFja3VwKGJhY2t1cFZlcnNpb24pIHtcbiAgICByZXR1cm4gdGhpcy5odHRwLmF1dGhlZFJlcXVlc3QoTWV0aG9kLkdldCwgXCIvcm9vbV9rZXlzL2tleXNcIiwge1xuICAgICAgdmVyc2lvbjogYmFja3VwVmVyc2lvblxuICAgIH0sIHVuZGVmaW5lZCwge1xuICAgICAgcHJlZml4OiBDbGllbnRQcmVmaXguVjNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBvcnQgdGhlIHJvb20ga2V5cyBmcm9tIGEgYC9yb29tX2tleXMva2V5c2AgY2FsbC5cbiAgICogQ2FsbHMgYG9wdHMucHJvZ3Jlc3NDYWxsYmFja2Agd2l0aCB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIGltcG9ydC5cbiAgICpcbiAgICogQHBhcmFtIGtleUJhY2t1cCAtIFRoZSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIgY29udGFpbmluZyB0aGUga2V5cyB0byBpbXBvcnQuXG4gICAqIEBwYXJhbSBiYWNrdXBWZXJzaW9uIC0gVGhlIHZlcnNpb24gb2YgdGhlIGJhY2t1cCBpbmZvLlxuICAgKiBAcGFyYW0gYmFja3VwRGVjcnlwdG9yIC0gVGhlIGJhY2t1cCBkZWNyeXB0b3IgdG8gdXNlIHRvIGRlY3J5cHQgdGhlIGtleXMuXG4gICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBmb3IgdGhlIGltcG9ydC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHRvdGFsIG51bWJlciBvZiBrZXlzIGFuZCB0aGUgdG90YWwgaW1wb3J0ZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbXBvcnRLZXlCYWNrdXAoa2V5QmFja3VwLCBiYWNrdXBWZXJzaW9uLCBiYWNrdXBEZWNyeXB0b3IsIG9wdHMpIHtcbiAgICB2YXIgX3RoaXMxOSA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBXZSBoYXZlIGEgZnVsbCBiYWNrdXAgaGVyZSwgaXQgY2FuIGdldCBxdWl0ZSBiaWcsIHNvIHdlIG5lZWQgdG8gZGVjcnlwdCBhbmQgaW1wb3J0IGl0IGluIGNodW5rcy5cblxuICAgICAgdmFyIENIVU5LX1NJWkUgPSAyMDA7XG4gICAgICAvLyBHZXQgdGhlIHRvdGFsIGNvdW50IGFzIGEgZmlyc3QgcGFzc1xuICAgICAgdmFyIHRvdGFsS2V5Q291bnQgPSBjb3VudEtleXNJbkJhY2t1cChrZXlCYWNrdXApO1xuICAgICAgdmFyIHRvdGFsSW1wb3J0ZWQgPSAwO1xuICAgICAgdmFyIHRvdGFsRmFpbHVyZXMgPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHdlIGhhdmUgZW5vdWdoIGNodW5rcyB0byBkZWNyeXB0LlxuICAgICAgICogSXQgd2lsbCBkZWNyeXB0IHRoZSBjaHVua3MgYW5kIHRyeSB0byBpbXBvcnQgdGhlIHJvb20ga2V5cy5cbiAgICAgICAqIEBwYXJhbSByb29tQ2h1bmtzXG4gICAgICAgKi9cbiAgICAgIHZhciBoYW5kbGVDaHVua0NhbGxiYWNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qIChyb29tQ2h1bmtzKSB7XG4gICAgICAgICAgdmFyIF9vcHRzJHByb2dyZXNzQ2FsbGJhYzQ7XG4gICAgICAgICAgdmFyIGN1cnJlbnRDaHVuayA9IFtdO1xuICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uKiBfbG9vcChyb29tSWQpIHtcbiAgICAgICAgICAgIC8vIERlY3J5cHQgdGhlIHNlc3Npb25zIGZvciB0aGUgZ2l2ZW4gcm9vbVxuICAgICAgICAgICAgdmFyIGRlY3J5cHRlZFNlc3Npb25zID0geWllbGQgYmFja3VwRGVjcnlwdG9yLmRlY3J5cHRTZXNzaW9ucyhyb29tQ2h1bmtzLmdldChyb29tSWQpKTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgZGVjcnlwdGVkIHNlc3Npb25zIHRvIHRoZSBjdXJyZW50IGNodW5rXG4gICAgICAgICAgICBkZWNyeXB0ZWRTZXNzaW9ucy5mb3JFYWNoKHNlc3Npb24gPT4ge1xuICAgICAgICAgICAgICAvLyBXZSBzZXQgdGhlIHJvb21faWQgZm9yIGVhY2ggc2Vzc2lvblxuICAgICAgICAgICAgICBzZXNzaW9uLnJvb21faWQgPSByb29tSWQ7XG4gICAgICAgICAgICAgIGN1cnJlbnRDaHVuay5wdXNoKHNlc3Npb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKHZhciByb29tSWQgb2Ygcm9vbUNodW5rcy5rZXlzKCkpIHtcbiAgICAgICAgICAgIHlpZWxkKiBfbG9vcChyb29tSWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdlIGhhdmUgYSBjaHVuayBvZiBkZWNyeXB0ZWQga2V5czogaW1wb3J0IHRoZW1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgeWllbGQgX3RoaXMxOS5pbXBvcnRCYWNrZWRVcFJvb21LZXlzKGN1cnJlbnRDaHVuaywgYmFja3VwVmVyc2lvbik7XG4gICAgICAgICAgICB0b3RhbEltcG9ydGVkICs9IGN1cnJlbnRDaHVuay5sZW5ndGg7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdG90YWxGYWlsdXJlcyArPSBjdXJyZW50Q2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgLy8gV2UgZmFpbGVkIHRvIGltcG9ydCBzb21lIGtleXMsIGJ1dCB3ZSBzaG91bGQgc3RpbGwgdHJ5IHRvIGltcG9ydCB0aGUgcmVzdD9cbiAgICAgICAgICAgIC8vIExvZyB0aGUgZXJyb3IgYW5kIGNvbnRpbnVlXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBpbXBvcnRpbmcga2V5cyBmcm9tIGJhY2t1cFwiLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgfHwgKF9vcHRzJHByb2dyZXNzQ2FsbGJhYzQgPSBvcHRzLnByb2dyZXNzQ2FsbGJhY2spID09PSBudWxsIHx8IF9vcHRzJHByb2dyZXNzQ2FsbGJhYzQgPT09IHZvaWQgMCB8fCBfb3B0cyRwcm9ncmVzc0NhbGxiYWM0LmNhbGwob3B0cywge1xuICAgICAgICAgICAgdG90YWw6IHRvdGFsS2V5Q291bnQsXG4gICAgICAgICAgICBzdWNjZXNzZXM6IHRvdGFsSW1wb3J0ZWQsXG4gICAgICAgICAgICBzdGFnZTogXCJsb2FkX2tleXNcIixcbiAgICAgICAgICAgIGZhaWx1cmVzOiB0b3RhbEZhaWx1cmVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlQ2h1bmtDYWxsYmFjayhfeCkge1xuICAgICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfSgpO1xuICAgICAgdmFyIGdyb3VwQ2h1bmtDb3VudCA9IDA7XG4gICAgICB2YXIgY2h1bmtHcm91cEJ5Um9vbSA9IG5ldyBNYXAoKTtcblxuICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSByb29tcyBhbmQgc2Vzc2lvbnMgdG8gZ3JvdXAgdGhlbSBpbiBjaHVua3NcbiAgICAgIC8vIEFuZCB3ZSBjYWxsIHRoZSBoYW5kbGVDaHVua0NhbGxiYWNrIHdoZW4gd2UgaGF2ZSBlbm91Z2ggY2h1bmtzIHRvIGRlY3J5cHRcbiAgICAgIGZvciAodmFyIFtyb29tSWQsIHJvb21EYXRhXSBvZiBPYmplY3QuZW50cmllcyhrZXlCYWNrdXAucm9vbXMpKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBzZXNzaW9ucyBmb3IgdGhlIHJvb20sIHNraXAgaXRcbiAgICAgICAgaWYgKCFyb29tRGF0YS5zZXNzaW9ucykgY29udGludWU7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhIG5ldyBjaHVuayBncm91cCBmb3IgdGhlIGN1cnJlbnQgcm9vbVxuICAgICAgICBjaHVua0dyb3VwQnlSb29tLnNldChyb29tSWQsIHt9KTtcbiAgICAgICAgZm9yICh2YXIgW3Nlc3Npb25JZCwgc2Vzc2lvbl0gb2YgT2JqZWN0LmVudHJpZXMocm9vbURhdGEuc2Vzc2lvbnMpKSB7XG4gICAgICAgICAgLy8gV2Ugc2V0IHByZXZpb3VzbHkgdGhlIGNodW5rIGdyb3VwIGZvciB0aGUgY3VycmVudCByb29tLCBzbyB3ZSBjYW4gc2FmZWx5IGdldCBpdFxuICAgICAgICAgIHZhciBzZXNzaW9uc0ZvclJvb20gPSBjaHVua0dyb3VwQnlSb29tLmdldChyb29tSWQpO1xuICAgICAgICAgIHNlc3Npb25zRm9yUm9vbVtzZXNzaW9uSWRdID0gc2Vzc2lvbjtcbiAgICAgICAgICBncm91cENodW5rQ291bnQgKz0gMTtcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGVub3VnaCBjaHVua3MgdG8gZGVjcnlwdCwgY2FsbCB0aGUgYmxvY2sgY2FsbGJhY2tcbiAgICAgICAgICBpZiAoZ3JvdXBDaHVua0NvdW50ID49IENIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgZW5vdWdoIGNodW5rcyB0byBkZWNyeXB0XG4gICAgICAgICAgICB5aWVsZCBoYW5kbGVDaHVua0NhbGxiYWNrKGNodW5rR3JvdXBCeVJvb20pO1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNodW5rIGdyb3VwXG4gICAgICAgICAgICBjaHVua0dyb3VwQnlSb29tID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgcmVtYWluaW5nIGtleXMgZm9yIHRoYXQgcm9vbSwgc28gYWRkIGJhY2sgYW4gZW50cnkgZm9yIHRoZSBjdXJyZW50IHJvb20uXG4gICAgICAgICAgICBjaHVua0dyb3VwQnlSb29tLnNldChyb29tSWQsIHt9KTtcbiAgICAgICAgICAgIGdyb3VwQ2h1bmtDb3VudCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSByZW1haW5pbmcgY2h1bmsgaWYgbmVlZGVkXG4gICAgICBpZiAoZ3JvdXBDaHVua0NvdW50ID4gMCkge1xuICAgICAgICB5aWVsZCBoYW5kbGVDaHVua0NhbGxiYWNrKGNodW5rR3JvdXBCeVJvb20pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG90YWw6IHRvdGFsS2V5Q291bnQsXG4gICAgICAgIGltcG9ydGVkOiB0b3RhbEltcG9ydGVkXG4gICAgICB9O1xuICAgIH0pKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGJhY2t1cCBpbmZvIG1hdGNoZXMgdGhlIGdpdmVuIHByaXZhdGUga2V5LlxuICpcbiAqIEBwYXJhbSBpbmZvIC0gVGhlIGJhY2t1cCBpbmZvIHRvIGNoZWNrLlxuICogQHBhcmFtIGJhY2t1cERlY3J5cHRpb25LZXkgLSBUaGUgYEJhY2t1cERlY3J5cHRpb25LZXlgIHByaXZhdGUga2V5IHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByaXZhdGUga2V5IGNhbiBkZWNyeXB0IHRoZSBiYWNrdXAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBiYWNrdXBJbmZvTWF0Y2hlc0JhY2t1cERlY3J5cHRpb25LZXkoaW5mbywgYmFja3VwRGVjcnlwdGlvbktleSkge1xuICB2YXIgX2luZm8kYXV0aF9kYXRhO1xuICBpZiAoaW5mby5hbGdvcml0aG0gIT09IFwibS5tZWdvbG1fYmFja3VwLnYxLmN1cnZlMjU1MTktYWVzLXNoYTJcIikge1xuICAgIGxvZ2dlci53YXJuKFwiYmFja3VwTWF0Y2hlc1ByaXZhdGVLZXk6IFVuc3VwcG9ydGVkIGJhY2t1cCBhbGdvcml0aG1cIiwgaW5mby5hbGdvcml0aG0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKChfaW5mbyRhdXRoX2RhdGEgPSBpbmZvLmF1dGhfZGF0YSkgPT09IG51bGwgfHwgX2luZm8kYXV0aF9kYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW5mbyRhdXRoX2RhdGEucHVibGljX2tleSkgPT09IGJhY2t1cERlY3J5cHRpb25LZXkubWVnb2xtVjFQdWJsaWNLZXkucHVibGljS2V5QmFzZTY0O1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBCYWNrdXBEZWNyeXB0b3J9IGZvciB0aGUgcnVzdCBjcnlwdG8gYmFja2VuZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1c3RCYWNrdXBEZWNyeXB0b3Ige1xuICBjb25zdHJ1Y3RvcihkZWNyeXB0aW9uS2V5KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVjcnlwdGlvbktleVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNvdXJjZVRydXN0ZWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmRlY3J5cHRpb25LZXkgPSBkZWNyeXB0aW9uS2V5O1xuICAgIHRoaXMuc291cmNlVHJ1c3RlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMge0BsaW5rIEJhY2t1cERlY3J5cHRvciNkZWNyeXB0U2Vzc2lvbnN9XG4gICAqL1xuICBkZWNyeXB0U2Vzc2lvbnMoY2lwaGVydGV4dHMpIHtcbiAgICB2YXIgX3RoaXMyMCA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgZm9yICh2YXIgW3Nlc3Npb25JZCwgc2Vzc2lvbkRhdGFdIG9mIE9iamVjdC5lbnRyaWVzKGNpcGhlcnRleHRzKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBkZWNyeXB0ZWQgPSBKU09OLnBhcnNlKF90aGlzMjAuZGVjcnlwdGlvbktleS5kZWNyeXB0VjEoc2Vzc2lvbkRhdGEuc2Vzc2lvbl9kYXRhLmVwaGVtZXJhbCwgc2Vzc2lvbkRhdGEuc2Vzc2lvbl9kYXRhLm1hYywgc2Vzc2lvbkRhdGEuc2Vzc2lvbl9kYXRhLmNpcGhlcnRleHQpKTtcbiAgICAgICAgICBkZWNyeXB0ZWQuc2Vzc2lvbl9pZCA9IHNlc3Npb25JZDtcbiAgICAgICAgICBrZXlzLnB1c2goZGVjcnlwdGVkKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coXCJGYWlsZWQgdG8gZGVjcnlwdCBtZWdvbG0gc2Vzc2lvbiBmcm9tIGJhY2t1cFwiLCBlLCBzZXNzaW9uRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyB7QGxpbmsgQmFja3VwRGVjcnlwdG9yI2ZyZWV9XG4gICAqL1xuICBmcmVlKCkge1xuICAgIHRoaXMuZGVjcnlwdGlvbktleS5mcmVlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBhIGtleSBiYWNrdXAgaW5mbyBmcm9tIHRoZSBzZXJ2ZXIuXG4gKlxuICogSWYgYHZlcnNpb25gIGlzIHByb3ZpZGVkLCBjYWxscyBgR0VUIC9yb29tX2tleXMvdmVyc2lvbi8kdmVyc2lvbmAgYW5kIGdldHMgdGhlIGJhY2t1cCBpbmZvIGZvciB0aGF0IHZlcnNpb24uXG4gKiBTZWUgaHR0cHM6Ly9zcGVjLm1hdHJpeC5vcmcvdjEuMTIvY2xpZW50LXNlcnZlci1hcGkvI2dldF9tYXRyaXhjbGllbnR2M3Jvb21fa2V5c3ZlcnNpb252ZXJzaW9uLlxuICpcbiAqIElmIG5vdCwgY2FsbHMgYEdFVCAvcm9vbV9rZXlzL3ZlcnNpb25gIGFuZCBnZXRzIHRoZSBsYXRlc3QgYmFja3VwIGluZm8uXG4gKiBTZWUgaHR0cHM6Ly9zcGVjLm1hdHJpeC5vcmcvdjEuMTIvY2xpZW50LXNlcnZlci1hcGkvI2dldF9tYXRyaXhjbGllbnR2M3Jvb21fa2V5c3ZlcnNpb25cbiAqXG4gKiBAcGFyYW0gaHR0cFxuICogQHBhcmFtIHZlcnNpb24gLSB0aGUgc3BlY2lmaWMgdmVyc2lvbiBvZiB0aGUgYmFja3VwIGluZm8gdG8gZmV0Y2hcbiAqIEByZXR1cm5zIFRoZSBrZXkgYmFja3VwIGluZm8gb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBiYWNrdXAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXF1ZXN0S2V5QmFja3VwVmVyc2lvbihfeDIsIF94Mykge1xuICByZXR1cm4gX3JlcXVlc3RLZXlCYWNrdXBWZXJzaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBkZWNyeXB0aW9uIGtleSBtYXRjaGVzIHRoZSBwdWJsaWMga2V5IG9mIHRoZSBrZXkgYmFja3VwIGluZm8uXG4gKlxuICogQHBhcmFtIGRlY3J5cHRpb25LZXkgLSBUaGUgZGVjcnlwdGlvbiBrZXkgdG8gY2hlY2suXG4gKiBAcGFyYW0ga2V5QmFja3VwSW5mbyAtIFRoZSBrZXkgYmFja3VwIGluZm8gdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZGVjcnlwdGlvbiBrZXkgbWF0Y2hlcyB0aGUga2V5IGJhY2t1cCBpbmZvLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gX3JlcXVlc3RLZXlCYWNrdXBWZXJzaW9uKCkge1xuICBfcmVxdWVzdEtleUJhY2t1cFZlcnNpb24gPSBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKGh0dHAsIHZlcnNpb24pIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHBhdGggPSB2ZXJzaW9uID8gZW5jb2RlVXJpKFwiL3Jvb21fa2V5cy92ZXJzaW9uLyR2ZXJzaW9uXCIsIHtcbiAgICAgICAgJHZlcnNpb246IHZlcnNpb25cbiAgICAgIH0pIDogXCIvcm9vbV9rZXlzL3ZlcnNpb25cIjtcbiAgICAgIHJldHVybiB5aWVsZCBodHRwLmF1dGhlZFJlcXVlc3QoTWV0aG9kLkdldCwgcGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgcHJlZml4OiBDbGllbnRQcmVmaXguVjNcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmVycmNvZGUgPT09IFwiTV9OT1RfRk9VTkRcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIF9yZXF1ZXN0S2V5QmFja3VwVmVyc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY3J5cHRpb25LZXlNYXRjaGVzS2V5QmFja3VwSW5mbyhkZWNyeXB0aW9uS2V5LCBrZXlCYWNrdXBJbmZvKSB7XG4gIHZhciBhdXRoRGF0YSA9IGtleUJhY2t1cEluZm8uYXV0aF9kYXRhO1xuICByZXR1cm4gYXV0aERhdGEucHVibGljX2tleSA9PT0gZGVjcnlwdGlvbktleS5tZWdvbG1WMVB1YmxpY0tleS5wdWJsaWNLZXlCYXNlNjQ7XG59XG5cbi8qKlxuICogQ291bnRzIHRoZSB0b3RhbCBudW1iZXIgb2Yga2V5cyBwcmVzZW50IGluIGEga2V5IGJhY2t1cC5cbiAqIEBwYXJhbSBrZXlCYWNrdXAgLSBUaGUga2V5IGJhY2t1cCB0byBjb3VudCB0aGUga2V5cyBmcm9tLlxuICogQHJldHVybnMgVGhlIHRvdGFsIG51bWJlciBvZiBrZXlzIGluIHRoZSBiYWNrdXAuXG4gKi9cbmZ1bmN0aW9uIGNvdW50S2V5c0luQmFja3VwKGtleUJhY2t1cCkge1xuICB2YXIgY291bnQgPSAwO1xuICBmb3IgKHZhciB7XG4gICAgc2Vzc2lvbnNcbiAgfSBvZiBPYmplY3QudmFsdWVzKGtleUJhY2t1cC5yb29tcykpIHtcbiAgICBjb3VudCArPSBPYmplY3Qua2V5cyhzZXNzaW9ucykubGVuZ3RoO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuLyoqXG4gKiBSZXNwb25zZSBmcm9tIEdFVCBgL3Jvb21fa2V5cy9rZXlzYCBlbmRwb2ludC5cbiAqIFNlZSBodHRwczovL3NwZWMubWF0cml4Lm9yZy9sYXRlc3QvY2xpZW50LXNlcnZlci1hcGkvI2dldF9tYXRyaXhjbGllbnR2M3Jvb21fa2V5c2tleXNcbiAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja3VwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/backup.js\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/device-converter.js":
/*!************************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/device-converter.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deviceKeysToDeviceMap: () => (/* binding */ deviceKeysToDeviceMap),\n/* harmony export */   downloadDeviceToJsDevice: () => (/* binding */ downloadDeviceToJsDevice),\n/* harmony export */   rustDeviceToJsDevice: () => (/* binding */ rustDeviceToJsDevice)\n/* harmony export */ });\n/* harmony import */ var _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @matrix-org/matrix-sdk-crypto-wasm */ \"./node_modules/@matrix-org/matrix-sdk-crypto-wasm/index.mjs\");\n/* harmony import */ var _models_device_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/device.js */ \"./node_modules/matrix-js-sdk/lib/models/device.js\");\n/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n\n/**\n * Convert a {@link RustSdkCryptoJs.Device} to a {@link Device}\n * @param device - Rust Sdk device\n * @param userId - owner of the device\n *\n * @internal\n */\nfunction rustDeviceToJsDevice(device, userId) {\n  // Copy rust device keys to Device.keys\n  var keys = new Map();\n  for (var [keyId, key] of device.keys.entries()) {\n    keys.set(keyId.toString(), key.toBase64());\n  }\n\n  // Compute verified from device state\n  var verified = _models_device_js__WEBPACK_IMPORTED_MODULE_1__.DeviceVerification.Unverified;\n  if (device.isBlacklisted()) {\n    verified = _models_device_js__WEBPACK_IMPORTED_MODULE_1__.DeviceVerification.Blocked;\n  } else if (device.isVerified()) {\n    verified = _models_device_js__WEBPACK_IMPORTED_MODULE_1__.DeviceVerification.Verified;\n  }\n\n  // Convert rust signatures to Device.signatures\n  var signatures = new Map();\n  var mayBeSignatureMap = device.signatures.get(userId);\n  if (mayBeSignatureMap) {\n    var convertedSignatures = new Map();\n    // Convert maybeSignatures map to a Map<string, string>\n    for (var [_key, value] of mayBeSignatureMap.entries()) {\n      if (value.isValid() && value.signature) {\n        convertedSignatures.set(_key, value.signature.toBase64());\n      }\n    }\n    signatures.set(userId.toString(), convertedSignatures);\n  }\n\n  // Convert rust algorithms to algorithms\n  var rustAlgorithms = device.algorithms;\n  // Use set to ensure that algorithms are not duplicated\n  var algorithms = new Set();\n  rustAlgorithms.forEach(algorithm => {\n    switch (algorithm) {\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_0__.EncryptionAlgorithm.MegolmV1AesSha2:\n        algorithms.add(\"m.megolm.v1.aes-sha2\");\n        break;\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_0__.EncryptionAlgorithm.OlmV1Curve25519AesSha2:\n      default:\n        algorithms.add(\"m.olm.v1.curve25519-aes-sha2\");\n        break;\n    }\n  });\n  return new _models_device_js__WEBPACK_IMPORTED_MODULE_1__.Device({\n    deviceId: device.deviceId.toString(),\n    userId: userId.toString(),\n    keys,\n    algorithms: Array.from(algorithms),\n    verified,\n    signatures,\n    displayName: device.displayName,\n    dehydrated: device.isDehydrated\n  });\n}\n\n/**\n * Convert {@link DeviceKeys}  from `/keys/query` request to a `Map<string, Device>`\n * @param deviceKeys - Device keys object to convert\n *\n * @internal\n */\nfunction deviceKeysToDeviceMap(deviceKeys) {\n  return new Map(Object.entries(deviceKeys).map(_ref => {\n    var [deviceId, device] = _ref;\n    return [deviceId, downloadDeviceToJsDevice(device)];\n  }));\n}\n\n// Device from `/keys/query` request\n\n/**\n * Convert `/keys/query` {@link QueryDevice} device to {@link Device}\n * @param device - Device from `/keys/query` request\n *\n * @internal\n */\nfunction downloadDeviceToJsDevice(device) {\n  var _device$unsigned;\n  var keys = new Map(Object.entries(device.keys));\n  var displayName = (_device$unsigned = device.unsigned) === null || _device$unsigned === void 0 ? void 0 : _device$unsigned.device_display_name;\n  var signatures = new Map();\n  if (device.signatures) {\n    for (var userId in device.signatures) {\n      signatures.set(userId, new Map(Object.entries(device.signatures[userId])));\n    }\n  }\n  return new _models_device_js__WEBPACK_IMPORTED_MODULE_1__.Device({\n    deviceId: device.device_id,\n    userId: device.user_id,\n    keys,\n    algorithms: device.algorithms,\n    verified: _models_device_js__WEBPACK_IMPORTED_MODULE_1__.DeviceVerification.Unverified,\n    signatures,\n    displayName\n  });\n}\n//# sourceMappingURL=device-converter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vZGV2aWNlLWNvbnZlcnRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0U7QUFDTDtBQUNqRTtBQUNBLGNBQWMsOEJBQThCLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixpRUFBa0I7QUFDbkM7QUFDQSxlQUFlLGlFQUFrQjtBQUNqQyxJQUFJO0FBQ0osZUFBZSxpRUFBa0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBbUM7QUFDOUM7QUFDQTtBQUNBLFdBQVcsbUZBQW1DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGFBQWEscURBQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEIsbUJBQW1CLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscURBQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlFQUFrQjtBQUNoQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc3Rlcmljcy1ncmlkLy4vbm9kZV9tb2R1bGVzL21hdHJpeC1qcy1zZGsvbGliL3J1c3QtY3J5cHRvL2RldmljZS1jb252ZXJ0ZXIuanM/NmY4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMjMgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgKiBhcyBSdXN0U2RrQ3J5cHRvSnMgZnJvbSBcIkBtYXRyaXgtb3JnL21hdHJpeC1zZGstY3J5cHRvLXdhc21cIjtcbmltcG9ydCB7IERldmljZSwgRGV2aWNlVmVyaWZpY2F0aW9uIH0gZnJvbSBcIi4uL21vZGVscy9kZXZpY2UuanNcIjtcbi8qKlxuICogQ29udmVydCBhIHtAbGluayBSdXN0U2RrQ3J5cHRvSnMuRGV2aWNlfSB0byBhIHtAbGluayBEZXZpY2V9XG4gKiBAcGFyYW0gZGV2aWNlIC0gUnVzdCBTZGsgZGV2aWNlXG4gKiBAcGFyYW0gdXNlcklkIC0gb3duZXIgb2YgdGhlIGRldmljZVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVzdERldmljZVRvSnNEZXZpY2UoZGV2aWNlLCB1c2VySWQpIHtcbiAgLy8gQ29weSBydXN0IGRldmljZSBrZXlzIHRvIERldmljZS5rZXlzXG4gIHZhciBrZXlzID0gbmV3IE1hcCgpO1xuICBmb3IgKHZhciBba2V5SWQsIGtleV0gb2YgZGV2aWNlLmtleXMuZW50cmllcygpKSB7XG4gICAga2V5cy5zZXQoa2V5SWQudG9TdHJpbmcoKSwga2V5LnRvQmFzZTY0KCkpO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB2ZXJpZmllZCBmcm9tIGRldmljZSBzdGF0ZVxuICB2YXIgdmVyaWZpZWQgPSBEZXZpY2VWZXJpZmljYXRpb24uVW52ZXJpZmllZDtcbiAgaWYgKGRldmljZS5pc0JsYWNrbGlzdGVkKCkpIHtcbiAgICB2ZXJpZmllZCA9IERldmljZVZlcmlmaWNhdGlvbi5CbG9ja2VkO1xuICB9IGVsc2UgaWYgKGRldmljZS5pc1ZlcmlmaWVkKCkpIHtcbiAgICB2ZXJpZmllZCA9IERldmljZVZlcmlmaWNhdGlvbi5WZXJpZmllZDtcbiAgfVxuXG4gIC8vIENvbnZlcnQgcnVzdCBzaWduYXR1cmVzIHRvIERldmljZS5zaWduYXR1cmVzXG4gIHZhciBzaWduYXR1cmVzID0gbmV3IE1hcCgpO1xuICB2YXIgbWF5QmVTaWduYXR1cmVNYXAgPSBkZXZpY2Uuc2lnbmF0dXJlcy5nZXQodXNlcklkKTtcbiAgaWYgKG1heUJlU2lnbmF0dXJlTWFwKSB7XG4gICAgdmFyIGNvbnZlcnRlZFNpZ25hdHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgLy8gQ29udmVydCBtYXliZVNpZ25hdHVyZXMgbWFwIHRvIGEgTWFwPHN0cmluZywgc3RyaW5nPlxuICAgIGZvciAodmFyIFtfa2V5LCB2YWx1ZV0gb2YgbWF5QmVTaWduYXR1cmVNYXAuZW50cmllcygpKSB7XG4gICAgICBpZiAodmFsdWUuaXNWYWxpZCgpICYmIHZhbHVlLnNpZ25hdHVyZSkge1xuICAgICAgICBjb252ZXJ0ZWRTaWduYXR1cmVzLnNldChfa2V5LCB2YWx1ZS5zaWduYXR1cmUudG9CYXNlNjQoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNpZ25hdHVyZXMuc2V0KHVzZXJJZC50b1N0cmluZygpLCBjb252ZXJ0ZWRTaWduYXR1cmVzKTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgcnVzdCBhbGdvcml0aG1zIHRvIGFsZ29yaXRobXNcbiAgdmFyIHJ1c3RBbGdvcml0aG1zID0gZGV2aWNlLmFsZ29yaXRobXM7XG4gIC8vIFVzZSBzZXQgdG8gZW5zdXJlIHRoYXQgYWxnb3JpdGhtcyBhcmUgbm90IGR1cGxpY2F0ZWRcbiAgdmFyIGFsZ29yaXRobXMgPSBuZXcgU2V0KCk7XG4gIHJ1c3RBbGdvcml0aG1zLmZvckVhY2goYWxnb3JpdGhtID0+IHtcbiAgICBzd2l0Y2ggKGFsZ29yaXRobSkge1xuICAgICAgY2FzZSBSdXN0U2RrQ3J5cHRvSnMuRW5jcnlwdGlvbkFsZ29yaXRobS5NZWdvbG1WMUFlc1NoYTI6XG4gICAgICAgIGFsZ29yaXRobXMuYWRkKFwibS5tZWdvbG0udjEuYWVzLXNoYTJcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSdXN0U2RrQ3J5cHRvSnMuRW5jcnlwdGlvbkFsZ29yaXRobS5PbG1WMUN1cnZlMjU1MTlBZXNTaGEyOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYWxnb3JpdGhtcy5hZGQoXCJtLm9sbS52MS5jdXJ2ZTI1NTE5LWFlcy1zaGEyXCIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IERldmljZSh7XG4gICAgZGV2aWNlSWQ6IGRldmljZS5kZXZpY2VJZC50b1N0cmluZygpLFxuICAgIHVzZXJJZDogdXNlcklkLnRvU3RyaW5nKCksXG4gICAga2V5cyxcbiAgICBhbGdvcml0aG1zOiBBcnJheS5mcm9tKGFsZ29yaXRobXMpLFxuICAgIHZlcmlmaWVkLFxuICAgIHNpZ25hdHVyZXMsXG4gICAgZGlzcGxheU5hbWU6IGRldmljZS5kaXNwbGF5TmFtZSxcbiAgICBkZWh5ZHJhdGVkOiBkZXZpY2UuaXNEZWh5ZHJhdGVkXG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnQge0BsaW5rIERldmljZUtleXN9ICBmcm9tIGAva2V5cy9xdWVyeWAgcmVxdWVzdCB0byBhIGBNYXA8c3RyaW5nLCBEZXZpY2U+YFxuICogQHBhcmFtIGRldmljZUtleXMgLSBEZXZpY2Uga2V5cyBvYmplY3QgdG8gY29udmVydFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV2aWNlS2V5c1RvRGV2aWNlTWFwKGRldmljZUtleXMpIHtcbiAgcmV0dXJuIG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoZGV2aWNlS2V5cykubWFwKF9yZWYgPT4ge1xuICAgIHZhciBbZGV2aWNlSWQsIGRldmljZV0gPSBfcmVmO1xuICAgIHJldHVybiBbZGV2aWNlSWQsIGRvd25sb2FkRGV2aWNlVG9Kc0RldmljZShkZXZpY2UpXTtcbiAgfSkpO1xufVxuXG4vLyBEZXZpY2UgZnJvbSBgL2tleXMvcXVlcnlgIHJlcXVlc3RcblxuLyoqXG4gKiBDb252ZXJ0IGAva2V5cy9xdWVyeWAge0BsaW5rIFF1ZXJ5RGV2aWNlfSBkZXZpY2UgdG8ge0BsaW5rIERldmljZX1cbiAqIEBwYXJhbSBkZXZpY2UgLSBEZXZpY2UgZnJvbSBgL2tleXMvcXVlcnlgIHJlcXVlc3RcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkRGV2aWNlVG9Kc0RldmljZShkZXZpY2UpIHtcbiAgdmFyIF9kZXZpY2UkdW5zaWduZWQ7XG4gIHZhciBrZXlzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhkZXZpY2Uua2V5cykpO1xuICB2YXIgZGlzcGxheU5hbWUgPSAoX2RldmljZSR1bnNpZ25lZCA9IGRldmljZS51bnNpZ25lZCkgPT09IG51bGwgfHwgX2RldmljZSR1bnNpZ25lZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RldmljZSR1bnNpZ25lZC5kZXZpY2VfZGlzcGxheV9uYW1lO1xuICB2YXIgc2lnbmF0dXJlcyA9IG5ldyBNYXAoKTtcbiAgaWYgKGRldmljZS5zaWduYXR1cmVzKSB7XG4gICAgZm9yICh2YXIgdXNlcklkIGluIGRldmljZS5zaWduYXR1cmVzKSB7XG4gICAgICBzaWduYXR1cmVzLnNldCh1c2VySWQsIG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoZGV2aWNlLnNpZ25hdHVyZXNbdXNlcklkXSkpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBEZXZpY2Uoe1xuICAgIGRldmljZUlkOiBkZXZpY2UuZGV2aWNlX2lkLFxuICAgIHVzZXJJZDogZGV2aWNlLnVzZXJfaWQsXG4gICAga2V5cyxcbiAgICBhbGdvcml0aG1zOiBkZXZpY2UuYWxnb3JpdGhtcyxcbiAgICB2ZXJpZmllZDogRGV2aWNlVmVyaWZpY2F0aW9uLlVudmVyaWZpZWQsXG4gICAgc2lnbmF0dXJlcyxcbiAgICBkaXNwbGF5TmFtZVxuICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldmljZS1jb252ZXJ0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/device-converter.js\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initRustCrypto: () => (/* binding */ initRustCrypto)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @matrix-org/matrix-sdk-crypto-wasm */ \"./node_modules/@matrix-org/matrix-sdk-crypto-wasm/index.mjs\");\n/* harmony import */ var _rust_crypto_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rust-crypto.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/rust-crypto.js\");\n/* harmony import */ var _crypto_store_base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../crypto/store/base.js */ \"./node_modules/matrix-js-sdk/lib/crypto/store/base.js\");\n/* harmony import */ var _libolm_migration_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./libolm_migration.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/libolm_migration.js\");\n\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n\n\n\n\n/**\n * Create a new `RustCrypto` implementation\n *\n * @param args - Parameter object\n * @internal\n */\nfunction initRustCrypto(_x) {\n  return _initRustCrypto.apply(this, arguments);\n}\nfunction _initRustCrypto() {\n  _initRustCrypto = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(function* (args) {\n    var {\n      logger\n    } = args;\n\n    // initialise the rust matrix-sdk-crypto-wasm, if it hasn't already been done\n    logger.debug(\"Initialising Rust crypto-sdk WASM artifact\");\n    yield _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.initAsync();\n\n    // enable tracing in the rust-sdk\n    new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.Tracing(_matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.LoggerLevel.Debug).turnOn();\n    logger.debug(\"Opening Rust CryptoStore\");\n    var storeHandle;\n    if (args.storePrefix) {\n      if (args.storeKey) {\n        storeHandle = yield _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.StoreHandle.openWithKey(args.storePrefix, args.storeKey);\n      } else {\n        storeHandle = yield _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.StoreHandle.open(args.storePrefix, args.storePassphrase);\n      }\n    } else {\n      storeHandle = yield _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.StoreHandle.open();\n    }\n    if (args.legacyCryptoStore) {\n      // We have a legacy crypto store, which we may need to migrate from.\n      yield (0,_libolm_migration_js__WEBPACK_IMPORTED_MODULE_5__.migrateFromLegacyCrypto)(_objectSpread({\n        legacyStore: args.legacyCryptoStore,\n        storeHandle\n      }, args));\n    }\n    var rustCrypto = yield initOlmMachine(logger, args.http, args.userId, args.deviceId, args.secretStorage, args.cryptoCallbacks, storeHandle, args.legacyCryptoStore);\n    storeHandle.free();\n    logger.debug(\"Completed rust crypto-sdk setup\");\n    return rustCrypto;\n  });\n  return _initRustCrypto.apply(this, arguments);\n}\nfunction initOlmMachine(_x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9) {\n  return _initOlmMachine.apply(this, arguments);\n}\nfunction _initOlmMachine() {\n  _initOlmMachine = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(function* (logger, http, userId, deviceId, secretStorage, cryptoCallbacks, storeHandle, legacyCryptoStore) {\n    logger.debug(\"Init OlmMachine\");\n    var olmMachine = yield _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.OlmMachine.initFromStore(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.UserId(userId), new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.DeviceId(deviceId), storeHandle);\n\n    // A final migration step, now that we have an OlmMachine.\n    if (legacyCryptoStore) {\n      yield (0,_libolm_migration_js__WEBPACK_IMPORTED_MODULE_5__.migrateRoomSettingsFromLegacyCrypto)({\n        logger,\n        legacyStore: legacyCryptoStore,\n        olmMachine\n      });\n    }\n\n    // Disable room key requests, per https://github.com/vector-im/element-web/issues/26524.\n    olmMachine.roomKeyRequestsEnabled = false;\n    var rustCrypto = new _rust_crypto_js__WEBPACK_IMPORTED_MODULE_3__.RustCrypto(logger, olmMachine, http, userId, deviceId, secretStorage, cryptoCallbacks);\n    yield olmMachine.registerRoomKeyUpdatedCallback(sessions => rustCrypto.onRoomKeysUpdated(sessions));\n    yield olmMachine.registerRoomKeysWithheldCallback(withheld => rustCrypto.onRoomKeysWithheld(withheld));\n    yield olmMachine.registerUserIdentityUpdatedCallback(userId => rustCrypto.onUserIdentityUpdated(userId));\n    yield olmMachine.registerDevicesUpdatedCallback(userIds => rustCrypto.onDevicesUpdated(userIds));\n\n    // Check if there are any key backup secrets pending processing. There may be multiple secrets to process if several devices have gossiped them.\n    // The `registerReceiveSecretCallback` function will only be triggered for new secrets. If the client is restarted before processing them, the secrets will need to be manually handled.\n    rustCrypto.checkSecrets(\"m.megolm_backup.v1\");\n\n    // Register a callback to be notified when a new secret is received, as for now only the key backup secret is supported (the cross signing secrets are handled automatically by the OlmMachine)\n    yield olmMachine.registerReceiveSecretCallback((name, _value) =>\n    // Instead of directly checking the secret value, we poll the inbox to get all values for that secret type.\n    // Once we have all the values, we can safely clear the secret inbox.\n    rustCrypto.checkSecrets(name));\n\n    // Tell the OlmMachine to think about its outgoing requests before we hand control back to the application.\n    //\n    // This is primarily a fudge to get it to correctly populate the `users_for_key_query` list, so that future\n    // calls to getIdentity (etc) block until the key queries are performed.\n    //\n    // Note that we don't actually need to *make* any requests here; it is sufficient to tell the Rust side to think\n    // about them.\n    //\n    // XXX: find a less hacky way to do this.\n    yield olmMachine.outgoingRequests();\n    if (legacyCryptoStore && (yield legacyCryptoStore.containsData())) {\n      var migrationState = yield legacyCryptoStore.getMigrationState();\n      if (migrationState < _crypto_store_base_js__WEBPACK_IMPORTED_MODULE_4__.MigrationState.INITIAL_OWN_KEY_QUERY_DONE) {\n        logger.debug(\"Performing initial key query after migration\");\n        // We need to do an initial keys query so that the rust stack can properly update trust of\n        // the user device and identity from the migrated private keys.\n        // If not done, there is a short period where the own device/identity trust will be undefined after migration.\n        var initialKeyQueryDone = false;\n        while (!initialKeyQueryDone) {\n          try {\n            yield rustCrypto.userHasCrossSigningKeys(userId);\n            initialKeyQueryDone = true;\n          } catch (e) {\n            // If the initial key query fails, we retry until it succeeds.\n            logger.error(\"Failed to check for cross-signing keys after migration, retrying\", e);\n          }\n        }\n\n        // If the private master cross-signing key was not cached in the legacy store, the rust session\n        // will not be able to establish the trust of the user identity.\n        // That means that after migration the session could revert to unverified.\n        // In order to avoid asking the users to re-verify their sessions, we need to migrate the legacy local trust\n        // (if the legacy session was already verified) to the new session.\n        yield (0,_libolm_migration_js__WEBPACK_IMPORTED_MODULE_5__.migrateLegacyLocalTrustIfNeeded)({\n          legacyCryptoStore,\n          rustCrypto,\n          logger\n        });\n        yield legacyCryptoStore.setMigrationState(_crypto_store_base_js__WEBPACK_IMPORTED_MODULE_4__.MigrationState.INITIAL_OWN_KEY_QUERY_DONE);\n      }\n    }\n    return rustCrypto;\n  });\n  return _initOlmMachine.apply(this, arguments);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvRTtBQUNJO0FBQ3hFLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsaUZBQWUsZUFBZSxtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRTtBQUNMO0FBQ25CO0FBQ1c7QUFDNkU7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUZBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxVQUFVLHlFQUF5Qjs7QUFFbkM7QUFDQSxRQUFRLHVFQUF1QixDQUFDLDJFQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyRUFBVztBQUN2QyxRQUFRO0FBQ1IsNEJBQTRCLDJFQUFXO0FBQ3ZDO0FBQ0EsTUFBTTtBQUNOLDBCQUEwQiwyRUFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQSxZQUFZLDZFQUF1QjtBQUNuQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1GQUFpQjtBQUNyQztBQUNBLDJCQUEyQiwwRUFBMEIsbUJBQW1CLHNFQUFzQixjQUFjLHdFQUF3Qjs7QUFFcEk7QUFDQTtBQUNBLFlBQVkseUZBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxRkFBK0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtEQUFrRCxpRUFBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXN0ZXJpY3MtZ3JpZC8uL25vZGVfbW9kdWxlcy9tYXRyaXgtanMtc2RrL2xpYi9ydXN0LWNyeXB0by9pbmRleC5qcz9hZTRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfYXN5bmNUb0dlbmVyYXRvciBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCI7XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbi8qXG5Db3B5cmlnaHQgMjAyMiBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCAqIGFzIFJ1c3RTZGtDcnlwdG9KcyBmcm9tIFwiQG1hdHJpeC1vcmcvbWF0cml4LXNkay1jcnlwdG8td2FzbVwiO1xuaW1wb3J0IHsgU3RvcmVIYW5kbGUgfSBmcm9tIFwiQG1hdHJpeC1vcmcvbWF0cml4LXNkay1jcnlwdG8td2FzbVwiO1xuaW1wb3J0IHsgUnVzdENyeXB0byB9IGZyb20gXCIuL3J1c3QtY3J5cHRvLmpzXCI7XG5pbXBvcnQgeyBNaWdyYXRpb25TdGF0ZSB9IGZyb20gXCIuLi9jcnlwdG8vc3RvcmUvYmFzZS5qc1wiO1xuaW1wb3J0IHsgbWlncmF0ZUZyb21MZWdhY3lDcnlwdG8sIG1pZ3JhdGVMZWdhY3lMb2NhbFRydXN0SWZOZWVkZWQsIG1pZ3JhdGVSb29tU2V0dGluZ3NGcm9tTGVnYWN5Q3J5cHRvIH0gZnJvbSBcIi4vbGlib2xtX21pZ3JhdGlvbi5qc1wiO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYFJ1c3RDcnlwdG9gIGltcGxlbWVudGF0aW9uXG4gKlxuICogQHBhcmFtIGFyZ3MgLSBQYXJhbWV0ZXIgb2JqZWN0XG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRSdXN0Q3J5cHRvKF94KSB7XG4gIHJldHVybiBfaW5pdFJ1c3RDcnlwdG8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9pbml0UnVzdENyeXB0bygpIHtcbiAgX2luaXRSdXN0Q3J5cHRvID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qIChhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIGxvZ2dlclxuICAgIH0gPSBhcmdzO1xuXG4gICAgLy8gaW5pdGlhbGlzZSB0aGUgcnVzdCBtYXRyaXgtc2RrLWNyeXB0by13YXNtLCBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIGRvbmVcbiAgICBsb2dnZXIuZGVidWcoXCJJbml0aWFsaXNpbmcgUnVzdCBjcnlwdG8tc2RrIFdBU00gYXJ0aWZhY3RcIik7XG4gICAgeWllbGQgUnVzdFNka0NyeXB0b0pzLmluaXRBc3luYygpO1xuXG4gICAgLy8gZW5hYmxlIHRyYWNpbmcgaW4gdGhlIHJ1c3Qtc2RrXG4gICAgbmV3IFJ1c3RTZGtDcnlwdG9Kcy5UcmFjaW5nKFJ1c3RTZGtDcnlwdG9Kcy5Mb2dnZXJMZXZlbC5EZWJ1ZykudHVybk9uKCk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiT3BlbmluZyBSdXN0IENyeXB0b1N0b3JlXCIpO1xuICAgIHZhciBzdG9yZUhhbmRsZTtcbiAgICBpZiAoYXJncy5zdG9yZVByZWZpeCkge1xuICAgICAgaWYgKGFyZ3Muc3RvcmVLZXkpIHtcbiAgICAgICAgc3RvcmVIYW5kbGUgPSB5aWVsZCBTdG9yZUhhbmRsZS5vcGVuV2l0aEtleShhcmdzLnN0b3JlUHJlZml4LCBhcmdzLnN0b3JlS2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3JlSGFuZGxlID0geWllbGQgU3RvcmVIYW5kbGUub3BlbihhcmdzLnN0b3JlUHJlZml4LCBhcmdzLnN0b3JlUGFzc3BocmFzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JlSGFuZGxlID0geWllbGQgU3RvcmVIYW5kbGUub3BlbigpO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZWdhY3lDcnlwdG9TdG9yZSkge1xuICAgICAgLy8gV2UgaGF2ZSBhIGxlZ2FjeSBjcnlwdG8gc3RvcmUsIHdoaWNoIHdlIG1heSBuZWVkIHRvIG1pZ3JhdGUgZnJvbS5cbiAgICAgIHlpZWxkIG1pZ3JhdGVGcm9tTGVnYWN5Q3J5cHRvKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBsZWdhY3lTdG9yZTogYXJncy5sZWdhY3lDcnlwdG9TdG9yZSxcbiAgICAgICAgc3RvcmVIYW5kbGVcbiAgICAgIH0sIGFyZ3MpKTtcbiAgICB9XG4gICAgdmFyIHJ1c3RDcnlwdG8gPSB5aWVsZCBpbml0T2xtTWFjaGluZShsb2dnZXIsIGFyZ3MuaHR0cCwgYXJncy51c2VySWQsIGFyZ3MuZGV2aWNlSWQsIGFyZ3Muc2VjcmV0U3RvcmFnZSwgYXJncy5jcnlwdG9DYWxsYmFja3MsIHN0b3JlSGFuZGxlLCBhcmdzLmxlZ2FjeUNyeXB0b1N0b3JlKTtcbiAgICBzdG9yZUhhbmRsZS5mcmVlKCk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiQ29tcGxldGVkIHJ1c3QgY3J5cHRvLXNkayBzZXR1cFwiKTtcbiAgICByZXR1cm4gcnVzdENyeXB0bztcbiAgfSk7XG4gIHJldHVybiBfaW5pdFJ1c3RDcnlwdG8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGluaXRPbG1NYWNoaW5lKF94MiwgX3gzLCBfeDQsIF94NSwgX3g2LCBfeDcsIF94OCwgX3g5KSB7XG4gIHJldHVybiBfaW5pdE9sbU1hY2hpbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9pbml0T2xtTWFjaGluZSgpIHtcbiAgX2luaXRPbG1NYWNoaW5lID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qIChsb2dnZXIsIGh0dHAsIHVzZXJJZCwgZGV2aWNlSWQsIHNlY3JldFN0b3JhZ2UsIGNyeXB0b0NhbGxiYWNrcywgc3RvcmVIYW5kbGUsIGxlZ2FjeUNyeXB0b1N0b3JlKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFwiSW5pdCBPbG1NYWNoaW5lXCIpO1xuICAgIHZhciBvbG1NYWNoaW5lID0geWllbGQgUnVzdFNka0NyeXB0b0pzLk9sbU1hY2hpbmUuaW5pdEZyb21TdG9yZShuZXcgUnVzdFNka0NyeXB0b0pzLlVzZXJJZCh1c2VySWQpLCBuZXcgUnVzdFNka0NyeXB0b0pzLkRldmljZUlkKGRldmljZUlkKSwgc3RvcmVIYW5kbGUpO1xuXG4gICAgLy8gQSBmaW5hbCBtaWdyYXRpb24gc3RlcCwgbm93IHRoYXQgd2UgaGF2ZSBhbiBPbG1NYWNoaW5lLlxuICAgIGlmIChsZWdhY3lDcnlwdG9TdG9yZSkge1xuICAgICAgeWllbGQgbWlncmF0ZVJvb21TZXR0aW5nc0Zyb21MZWdhY3lDcnlwdG8oe1xuICAgICAgICBsb2dnZXIsXG4gICAgICAgIGxlZ2FjeVN0b3JlOiBsZWdhY3lDcnlwdG9TdG9yZSxcbiAgICAgICAgb2xtTWFjaGluZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGlzYWJsZSByb29tIGtleSByZXF1ZXN0cywgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWN0b3ItaW0vZWxlbWVudC13ZWIvaXNzdWVzLzI2NTI0LlxuICAgIG9sbU1hY2hpbmUucm9vbUtleVJlcXVlc3RzRW5hYmxlZCA9IGZhbHNlO1xuICAgIHZhciBydXN0Q3J5cHRvID0gbmV3IFJ1c3RDcnlwdG8obG9nZ2VyLCBvbG1NYWNoaW5lLCBodHRwLCB1c2VySWQsIGRldmljZUlkLCBzZWNyZXRTdG9yYWdlLCBjcnlwdG9DYWxsYmFja3MpO1xuICAgIHlpZWxkIG9sbU1hY2hpbmUucmVnaXN0ZXJSb29tS2V5VXBkYXRlZENhbGxiYWNrKHNlc3Npb25zID0+IHJ1c3RDcnlwdG8ub25Sb29tS2V5c1VwZGF0ZWQoc2Vzc2lvbnMpKTtcbiAgICB5aWVsZCBvbG1NYWNoaW5lLnJlZ2lzdGVyUm9vbUtleXNXaXRoaGVsZENhbGxiYWNrKHdpdGhoZWxkID0+IHJ1c3RDcnlwdG8ub25Sb29tS2V5c1dpdGhoZWxkKHdpdGhoZWxkKSk7XG4gICAgeWllbGQgb2xtTWFjaGluZS5yZWdpc3RlclVzZXJJZGVudGl0eVVwZGF0ZWRDYWxsYmFjayh1c2VySWQgPT4gcnVzdENyeXB0by5vblVzZXJJZGVudGl0eVVwZGF0ZWQodXNlcklkKSk7XG4gICAgeWllbGQgb2xtTWFjaGluZS5yZWdpc3RlckRldmljZXNVcGRhdGVkQ2FsbGJhY2sodXNlcklkcyA9PiBydXN0Q3J5cHRvLm9uRGV2aWNlc1VwZGF0ZWQodXNlcklkcykpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSBrZXkgYmFja3VwIHNlY3JldHMgcGVuZGluZyBwcm9jZXNzaW5nLiBUaGVyZSBtYXkgYmUgbXVsdGlwbGUgc2VjcmV0cyB0byBwcm9jZXNzIGlmIHNldmVyYWwgZGV2aWNlcyBoYXZlIGdvc3NpcGVkIHRoZW0uXG4gICAgLy8gVGhlIGByZWdpc3RlclJlY2VpdmVTZWNyZXRDYWxsYmFja2AgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBmb3IgbmV3IHNlY3JldHMuIElmIHRoZSBjbGllbnQgaXMgcmVzdGFydGVkIGJlZm9yZSBwcm9jZXNzaW5nIHRoZW0sIHRoZSBzZWNyZXRzIHdpbGwgbmVlZCB0byBiZSBtYW51YWxseSBoYW5kbGVkLlxuICAgIHJ1c3RDcnlwdG8uY2hlY2tTZWNyZXRzKFwibS5tZWdvbG1fYmFja3VwLnYxXCIpO1xuXG4gICAgLy8gUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBub3RpZmllZCB3aGVuIGEgbmV3IHNlY3JldCBpcyByZWNlaXZlZCwgYXMgZm9yIG5vdyBvbmx5IHRoZSBrZXkgYmFja3VwIHNlY3JldCBpcyBzdXBwb3J0ZWQgKHRoZSBjcm9zcyBzaWduaW5nIHNlY3JldHMgYXJlIGhhbmRsZWQgYXV0b21hdGljYWxseSBieSB0aGUgT2xtTWFjaGluZSlcbiAgICB5aWVsZCBvbG1NYWNoaW5lLnJlZ2lzdGVyUmVjZWl2ZVNlY3JldENhbGxiYWNrKChuYW1lLCBfdmFsdWUpID0+XG4gICAgLy8gSW5zdGVhZCBvZiBkaXJlY3RseSBjaGVja2luZyB0aGUgc2VjcmV0IHZhbHVlLCB3ZSBwb2xsIHRoZSBpbmJveCB0byBnZXQgYWxsIHZhbHVlcyBmb3IgdGhhdCBzZWNyZXQgdHlwZS5cbiAgICAvLyBPbmNlIHdlIGhhdmUgYWxsIHRoZSB2YWx1ZXMsIHdlIGNhbiBzYWZlbHkgY2xlYXIgdGhlIHNlY3JldCBpbmJveC5cbiAgICBydXN0Q3J5cHRvLmNoZWNrU2VjcmV0cyhuYW1lKSk7XG5cbiAgICAvLyBUZWxsIHRoZSBPbG1NYWNoaW5lIHRvIHRoaW5rIGFib3V0IGl0cyBvdXRnb2luZyByZXF1ZXN0cyBiZWZvcmUgd2UgaGFuZCBjb250cm9sIGJhY2sgdG8gdGhlIGFwcGxpY2F0aW9uLlxuICAgIC8vXG4gICAgLy8gVGhpcyBpcyBwcmltYXJpbHkgYSBmdWRnZSB0byBnZXQgaXQgdG8gY29ycmVjdGx5IHBvcHVsYXRlIHRoZSBgdXNlcnNfZm9yX2tleV9xdWVyeWAgbGlzdCwgc28gdGhhdCBmdXR1cmVcbiAgICAvLyBjYWxscyB0byBnZXRJZGVudGl0eSAoZXRjKSBibG9jayB1bnRpbCB0aGUga2V5IHF1ZXJpZXMgYXJlIHBlcmZvcm1lZC5cbiAgICAvL1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBkb24ndCBhY3R1YWxseSBuZWVkIHRvICptYWtlKiBhbnkgcmVxdWVzdHMgaGVyZTsgaXQgaXMgc3VmZmljaWVudCB0byB0ZWxsIHRoZSBSdXN0IHNpZGUgdG8gdGhpbmtcbiAgICAvLyBhYm91dCB0aGVtLlxuICAgIC8vXG4gICAgLy8gWFhYOiBmaW5kIGEgbGVzcyBoYWNreSB3YXkgdG8gZG8gdGhpcy5cbiAgICB5aWVsZCBvbG1NYWNoaW5lLm91dGdvaW5nUmVxdWVzdHMoKTtcbiAgICBpZiAobGVnYWN5Q3J5cHRvU3RvcmUgJiYgKHlpZWxkIGxlZ2FjeUNyeXB0b1N0b3JlLmNvbnRhaW5zRGF0YSgpKSkge1xuICAgICAgdmFyIG1pZ3JhdGlvblN0YXRlID0geWllbGQgbGVnYWN5Q3J5cHRvU3RvcmUuZ2V0TWlncmF0aW9uU3RhdGUoKTtcbiAgICAgIGlmIChtaWdyYXRpb25TdGF0ZSA8IE1pZ3JhdGlvblN0YXRlLklOSVRJQUxfT1dOX0tFWV9RVUVSWV9ET05FKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlBlcmZvcm1pbmcgaW5pdGlhbCBrZXkgcXVlcnkgYWZ0ZXIgbWlncmF0aW9uXCIpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRvIGFuIGluaXRpYWwga2V5cyBxdWVyeSBzbyB0aGF0IHRoZSBydXN0IHN0YWNrIGNhbiBwcm9wZXJseSB1cGRhdGUgdHJ1c3Qgb2ZcbiAgICAgICAgLy8gdGhlIHVzZXIgZGV2aWNlIGFuZCBpZGVudGl0eSBmcm9tIHRoZSBtaWdyYXRlZCBwcml2YXRlIGtleXMuXG4gICAgICAgIC8vIElmIG5vdCBkb25lLCB0aGVyZSBpcyBhIHNob3J0IHBlcmlvZCB3aGVyZSB0aGUgb3duIGRldmljZS9pZGVudGl0eSB0cnVzdCB3aWxsIGJlIHVuZGVmaW5lZCBhZnRlciBtaWdyYXRpb24uXG4gICAgICAgIHZhciBpbml0aWFsS2V5UXVlcnlEb25lID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghaW5pdGlhbEtleVF1ZXJ5RG9uZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB5aWVsZCBydXN0Q3J5cHRvLnVzZXJIYXNDcm9zc1NpZ25pbmdLZXlzKHVzZXJJZCk7XG4gICAgICAgICAgICBpbml0aWFsS2V5UXVlcnlEb25lID0gdHJ1ZTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgaW5pdGlhbCBrZXkgcXVlcnkgZmFpbHMsIHdlIHJldHJ5IHVudGlsIGl0IHN1Y2NlZWRzLlxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGNoZWNrIGZvciBjcm9zcy1zaWduaW5nIGtleXMgYWZ0ZXIgbWlncmF0aW9uLCByZXRyeWluZ1wiLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgcHJpdmF0ZSBtYXN0ZXIgY3Jvc3Mtc2lnbmluZyBrZXkgd2FzIG5vdCBjYWNoZWQgaW4gdGhlIGxlZ2FjeSBzdG9yZSwgdGhlIHJ1c3Qgc2Vzc2lvblxuICAgICAgICAvLyB3aWxsIG5vdCBiZSBhYmxlIHRvIGVzdGFibGlzaCB0aGUgdHJ1c3Qgb2YgdGhlIHVzZXIgaWRlbnRpdHkuXG4gICAgICAgIC8vIFRoYXQgbWVhbnMgdGhhdCBhZnRlciBtaWdyYXRpb24gdGhlIHNlc3Npb24gY291bGQgcmV2ZXJ0IHRvIHVudmVyaWZpZWQuXG4gICAgICAgIC8vIEluIG9yZGVyIHRvIGF2b2lkIGFza2luZyB0aGUgdXNlcnMgdG8gcmUtdmVyaWZ5IHRoZWlyIHNlc3Npb25zLCB3ZSBuZWVkIHRvIG1pZ3JhdGUgdGhlIGxlZ2FjeSBsb2NhbCB0cnVzdFxuICAgICAgICAvLyAoaWYgdGhlIGxlZ2FjeSBzZXNzaW9uIHdhcyBhbHJlYWR5IHZlcmlmaWVkKSB0byB0aGUgbmV3IHNlc3Npb24uXG4gICAgICAgIHlpZWxkIG1pZ3JhdGVMZWdhY3lMb2NhbFRydXN0SWZOZWVkZWQoe1xuICAgICAgICAgIGxlZ2FjeUNyeXB0b1N0b3JlLFxuICAgICAgICAgIHJ1c3RDcnlwdG8sXG4gICAgICAgICAgbG9nZ2VyXG4gICAgICAgIH0pO1xuICAgICAgICB5aWVsZCBsZWdhY3lDcnlwdG9TdG9yZS5zZXRNaWdyYXRpb25TdGF0ZShNaWdyYXRpb25TdGF0ZS5JTklUSUFMX09XTl9LRVlfUVVFUllfRE9ORSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydXN0Q3J5cHRvO1xuICB9KTtcbiAgcmV0dXJuIF9pbml0T2xtTWFjaGluZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/index.js\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/libolm_migration.js":
/*!************************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/libolm_migration.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   migrateFromLegacyCrypto: () => (/* binding */ migrateFromLegacyCrypto),\n/* harmony export */   migrateLegacyLocalTrustIfNeeded: () => (/* binding */ migrateLegacyLocalTrustIfNeeded),\n/* harmony export */   migrateRoomSettingsFromLegacyCrypto: () => (/* binding */ migrateRoomSettingsFromLegacyCrypto)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @matrix-org/matrix-sdk-crypto-wasm */ \"./node_modules/@matrix-org/matrix-sdk-crypto-wasm/index.mjs\");\n/* harmony import */ var _crypto_store_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/store/base.js */ \"./node_modules/matrix-js-sdk/lib/crypto/store/base.js\");\n/* harmony import */ var _crypto_store_indexeddb_crypto_store_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/store/indexeddb-crypto-store.js */ \"./node_modules/matrix-js-sdk/lib/crypto/store/indexeddb-crypto-store.js\");\n/* harmony import */ var _backup_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./backup.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/backup.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/matrix-js-sdk/lib/utils.js\");\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base64.js */ \"./node_modules/matrix-js-sdk/lib/base64.js\");\n/* harmony import */ var _utils_decryptAESSecretStorageItem_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/decryptAESSecretStorageItem.js */ \"./node_modules/matrix-js-sdk/lib/utils/decryptAESSecretStorageItem.js\");\n\n/*\nCopyright 2023-2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n\n\n\n\n\n\n/**\n * Determine if any data needs migrating from the legacy store, and do so.\n *\n * This migrates the base account data, and olm and megolm sessions. It does *not* migrate the room list, which should\n * happen after an `OlmMachine` is created, via {@link migrateRoomSettingsFromLegacyCrypto}.\n *\n * @param args - Arguments object.\n */\nfunction migrateFromLegacyCrypto(_x) {\n  return _migrateFromLegacyCrypto.apply(this, arguments);\n}\nfunction _migrateFromLegacyCrypto() {\n  _migrateFromLegacyCrypto = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (args) {\n    var _args$legacyMigration2;\n    var {\n      logger,\n      legacyStore\n    } = args;\n\n    // initialise the rust matrix-sdk-crypto-wasm, if it hasn't already been done\n    yield _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.initAsync();\n\n    // enable tracing in the rust-sdk\n    new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.Tracing(_matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.LoggerLevel.Debug).turnOn();\n    if (!(yield legacyStore.containsData())) {\n      // This store was never used. Nothing to migrate.\n      return;\n    }\n    yield legacyStore.startup();\n    var accountPickle = null;\n    yield legacyStore.doTxn(\"readonly\", [_crypto_store_indexeddb_crypto_store_js__WEBPACK_IMPORTED_MODULE_3__.IndexedDBCryptoStore.STORE_ACCOUNT], txn => {\n      legacyStore.getAccount(txn, acctPickle => {\n        accountPickle = acctPickle;\n      });\n    });\n    if (!accountPickle) {\n      // This store is not properly set up. Nothing to migrate.\n      logger.debug(\"Legacy crypto store is not set up (no account found). Not migrating.\");\n      return;\n    }\n    var migrationState = yield legacyStore.getMigrationState();\n    if (migrationState >= _crypto_store_base_js__WEBPACK_IMPORTED_MODULE_2__.MigrationState.MEGOLM_SESSIONS_MIGRATED) {\n      // All migration is done for now. The room list comes later, once we have an OlmMachine.\n      return;\n    }\n    var nOlmSessions = yield countOlmSessions(logger, legacyStore);\n    var nMegolmSessions = yield countMegolmSessions(logger, legacyStore);\n    var totalSteps = 1 + nOlmSessions + nMegolmSessions;\n    logger.info(\"Migrating data from legacy crypto store. \".concat(nOlmSessions, \" olm sessions and \").concat(nMegolmSessions, \" megolm sessions to migrate.\"));\n    var stepsDone = 0;\n    function onProgress(steps) {\n      var _args$legacyMigration;\n      stepsDone += steps;\n      (_args$legacyMigration = args.legacyMigrationProgressListener) === null || _args$legacyMigration === void 0 || _args$legacyMigration.call(args, stepsDone, totalSteps);\n    }\n    onProgress(0);\n    var pickleKey = new TextEncoder().encode(args.legacyPickleKey);\n    if (migrationState === _crypto_store_base_js__WEBPACK_IMPORTED_MODULE_2__.MigrationState.NOT_STARTED) {\n      logger.info(\"Migrating data from legacy crypto store. Step 1: base data\");\n      yield migrateBaseData(args.http, args.userId, args.deviceId, legacyStore, pickleKey, args.storeHandle, logger);\n      migrationState = _crypto_store_base_js__WEBPACK_IMPORTED_MODULE_2__.MigrationState.INITIAL_DATA_MIGRATED;\n      yield legacyStore.setMigrationState(migrationState);\n    }\n    onProgress(1);\n    if (migrationState === _crypto_store_base_js__WEBPACK_IMPORTED_MODULE_2__.MigrationState.INITIAL_DATA_MIGRATED) {\n      logger.info(\"Migrating data from legacy crypto store. Step 2: olm sessions (\".concat(nOlmSessions, \" sessions to migrate).\"));\n      yield migrateOlmSessions(logger, legacyStore, pickleKey, args.storeHandle, onProgress);\n      migrationState = _crypto_store_base_js__WEBPACK_IMPORTED_MODULE_2__.MigrationState.OLM_SESSIONS_MIGRATED;\n      yield legacyStore.setMigrationState(migrationState);\n    }\n    if (migrationState === _crypto_store_base_js__WEBPACK_IMPORTED_MODULE_2__.MigrationState.OLM_SESSIONS_MIGRATED) {\n      logger.info(\"Migrating data from legacy crypto store. Step 3: megolm sessions (\".concat(nMegolmSessions, \" sessions to migrate).\"));\n      yield migrateMegolmSessions(logger, legacyStore, pickleKey, args.storeHandle, onProgress);\n      migrationState = _crypto_store_base_js__WEBPACK_IMPORTED_MODULE_2__.MigrationState.MEGOLM_SESSIONS_MIGRATED;\n      yield legacyStore.setMigrationState(migrationState);\n    }\n\n    // Migration is done.\n    (_args$legacyMigration2 = args.legacyMigrationProgressListener) === null || _args$legacyMigration2 === void 0 || _args$legacyMigration2.call(args, -1, -1);\n    logger.info(\"Migration from legacy crypto store complete\");\n  });\n  return _migrateFromLegacyCrypto.apply(this, arguments);\n}\nfunction migrateBaseData(_x2, _x3, _x4, _x5, _x6, _x7, _x8) {\n  return _migrateBaseData.apply(this, arguments);\n}\nfunction _migrateBaseData() {\n  _migrateBaseData = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (http, userId, deviceId, legacyStore, pickleKey, storeHandle, logger) {\n    var migrationData = new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.BaseMigrationData();\n    migrationData.userId = new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.UserId(userId);\n    migrationData.deviceId = new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.DeviceId(deviceId);\n    yield legacyStore.doTxn(\"readonly\", [_crypto_store_indexeddb_crypto_store_js__WEBPACK_IMPORTED_MODULE_3__.IndexedDBCryptoStore.STORE_ACCOUNT], txn => legacyStore.getAccount(txn, a => {\n      migrationData.pickledAccount = a !== null && a !== void 0 ? a : \"\";\n    }));\n    var recoveryKey = yield getAndDecryptCachedSecretKey(legacyStore, pickleKey, \"m.megolm_backup.v1\");\n\n    // If we have a backup recovery key, we need to try to figure out which backup version it is for.\n    // All we can really do is ask the server for the most recent version and check if the cached key we have matches.\n    // It is possible that the backup has changed since last time his session was opened.\n    if (recoveryKey) {\n      var backupCallDone = false;\n      var backupInfo = null;\n      while (!backupCallDone) {\n        try {\n          backupInfo = yield (0,_backup_js__WEBPACK_IMPORTED_MODULE_4__.requestKeyBackupVersion)(http);\n          backupCallDone = true;\n        } catch (e) {\n          logger.info(\"Failed to get backup version during migration, retrying in 2 seconds\", e);\n          // Retry until successful, use simple constant delay\n          yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.sleep)(2000);\n        }\n      }\n      if (backupInfo && backupInfo.algorithm == \"m.megolm_backup.v1.curve25519-aes-sha2\") {\n        // check if the recovery key matches, as the active backup version may have changed since the key was cached\n        // and the migration started.\n        try {\n          var _backupInfo$auth_data;\n          var decryptionKey = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.BackupDecryptionKey.fromBase64(recoveryKey);\n          var publicKey = (_backupInfo$auth_data = backupInfo.auth_data) === null || _backupInfo$auth_data === void 0 ? void 0 : _backupInfo$auth_data.public_key;\n          var isValid = decryptionKey.megolmV1PublicKey.publicKeyBase64 == publicKey;\n          if (isValid) {\n            migrationData.backupVersion = backupInfo.version;\n            migrationData.backupRecoveryKey = recoveryKey;\n          } else {\n            logger.debug(\"The backup key to migrate does not match the active backup version\", \"Cached pub key: \".concat(decryptionKey.megolmV1PublicKey.publicKeyBase64), \"Active pub key: \".concat(publicKey));\n          }\n        } catch (e) {\n          logger.warn(\"Failed to check if the backup key to migrate matches the active backup version\", e);\n        }\n      }\n    }\n    migrationData.privateCrossSigningMasterKey = yield getAndDecryptCachedSecretKey(legacyStore, pickleKey, \"master\");\n    migrationData.privateCrossSigningSelfSigningKey = yield getAndDecryptCachedSecretKey(legacyStore, pickleKey, \"self_signing\");\n    migrationData.privateCrossSigningUserSigningKey = yield getAndDecryptCachedSecretKey(legacyStore, pickleKey, \"user_signing\");\n    yield _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.Migration.migrateBaseData(migrationData, pickleKey, storeHandle);\n  });\n  return _migrateBaseData.apply(this, arguments);\n}\nfunction countOlmSessions(_x9, _x10) {\n  return _countOlmSessions.apply(this, arguments);\n}\nfunction _countOlmSessions() {\n  _countOlmSessions = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (logger, legacyStore) {\n    logger.debug(\"Counting olm sessions to be migrated\");\n    var nSessions;\n    yield legacyStore.doTxn(\"readonly\", [_crypto_store_indexeddb_crypto_store_js__WEBPACK_IMPORTED_MODULE_3__.IndexedDBCryptoStore.STORE_SESSIONS], txn => legacyStore.countEndToEndSessions(txn, n => nSessions = n));\n    return nSessions;\n  });\n  return _countOlmSessions.apply(this, arguments);\n}\nfunction countMegolmSessions(_x11, _x12) {\n  return _countMegolmSessions.apply(this, arguments);\n}\nfunction _countMegolmSessions() {\n  _countMegolmSessions = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (logger, legacyStore) {\n    logger.debug(\"Counting megolm sessions to be migrated\");\n    return yield legacyStore.countEndToEndInboundGroupSessions();\n  });\n  return _countMegolmSessions.apply(this, arguments);\n}\nfunction migrateOlmSessions(_x13, _x14, _x15, _x16, _x17) {\n  return _migrateOlmSessions.apply(this, arguments);\n}\nfunction _migrateOlmSessions() {\n  _migrateOlmSessions = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (logger, legacyStore, pickleKey, storeHandle, onBatchDone) {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      var batch = yield legacyStore.getEndToEndSessionsBatch();\n      if (batch === null) return;\n      logger.debug(\"Migrating batch of \".concat(batch.length, \" olm sessions\"));\n      var migrationData = [];\n      for (var session of batch) {\n        var pickledSession = new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.PickledSession();\n        pickledSession.senderKey = session.deviceKey;\n        pickledSession.pickle = session.session;\n        pickledSession.lastUseTime = pickledSession.creationTime = new Date(session.lastReceivedMessageTs);\n        migrationData.push(pickledSession);\n      }\n      yield _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.Migration.migrateOlmSessions(migrationData, pickleKey, storeHandle);\n      yield legacyStore.deleteEndToEndSessionsBatch(batch);\n      onBatchDone(batch.length);\n    }\n  });\n  return _migrateOlmSessions.apply(this, arguments);\n}\nfunction migrateMegolmSessions(_x18, _x19, _x20, _x21, _x22) {\n  return _migrateMegolmSessions.apply(this, arguments);\n}\n/**\n * Determine if any room settings need migrating from the legacy store, and do so.\n *\n * @param args - Arguments object.\n */\nfunction _migrateMegolmSessions() {\n  _migrateMegolmSessions = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (logger, legacyStore, pickleKey, storeHandle, onBatchDone) {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      var batch = yield legacyStore.getEndToEndInboundGroupSessionsBatch();\n      if (batch === null) return;\n      logger.debug(\"Migrating batch of \".concat(batch.length, \" megolm sessions\"));\n      var migrationData = [];\n      for (var session of batch) {\n        var _sessionData$keysClai;\n        var sessionData = session.sessionData;\n        var pickledSession = new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.PickledInboundGroupSession();\n        pickledSession.pickle = sessionData.session;\n        pickledSession.roomId = new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.RoomId(sessionData.room_id);\n        pickledSession.senderKey = session.senderKey;\n        pickledSession.senderSigningKey = (_sessionData$keysClai = sessionData.keysClaimed) === null || _sessionData$keysClai === void 0 ? void 0 : _sessionData$keysClai[\"ed25519\"];\n        pickledSession.backedUp = !session.needsBackup;\n\n        // The Rust SDK `imported` flag is used to indicate the authenticity status of a Megolm\n        // session, which tells us whether we can reliably tell which Olm device is the owner\n        // (creator) of the session.\n        //\n        // If `imported` is true, then we have no cryptographic proof that the session is owned\n        // by the device with the identity key `senderKey`.\n        //\n        // Only Megolm sessions received directly from the owning device via an encrypted\n        // `m.room_key` to-device message should have `imported` flag set to false. Megolm\n        // sessions received by any other currently available means (i.e. from a\n        // `m.forwarded_room_key`, from v1 asymmetric server-side key backup, imported from a\n        // file, etc) should have the `imported` flag set to true.\n        //\n        // Messages encrypted with such Megolm sessions will have a grey shield in the UI\n        // (\"Authenticity of this message cannot be guaranteed\").\n        //\n        // However, we don't want to bluntly mark all sessions as `imported` during migration\n        // because users will suddenly start seeing all their historic messages decorated with a\n        // grey shield, which would be seen as a non-actionable regression.\n        //\n        // In the legacy crypto stack, the flag encoding similar information was called\n        // `InboundGroupSessionData.untrusted`. The value of this flag was set as follows:\n        //\n        // - For outbound Megolm sessions created by our own device, `untrusted` is `undefined`.\n        // - For Megolm sessions received via a `m.room_key` to-device message, `untrusted` is\n        //   `undefined`.\n        // - For Megolm sessions received via a `m.forwarded_room_key` to-device message,\n        //   `untrusted` is `true`.\n        // - For Megolm sessions imported from a (v1 asymmetric / \"legacy\") server-side key\n        //   backup, `untrusted` is `true`.\n        // - For Megolm sessions imported from a file, untrusted is `undefined`.\n        //\n        // The main difference between the legacy crypto stack and the Rust crypto stack is that\n        // the Rust stack considers sessions imported from a file as `imported` (not\n        // authenticated). This is because the Megolm session export file format does not\n        // encode this authenticity information.\n        //\n        // Given this migration is only a one-time thing, we make a concession to accept the\n        // loss of information in this case, to avoid degrading UX in a non-actionable way.\n        pickledSession.imported = sessionData.untrusted === true;\n        migrationData.push(pickledSession);\n      }\n      yield _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.Migration.migrateMegolmSessions(migrationData, pickleKey, storeHandle);\n      yield legacyStore.deleteEndToEndInboundGroupSessionsBatch(batch);\n      onBatchDone(batch.length);\n    }\n  });\n  return _migrateMegolmSessions.apply(this, arguments);\n}\nfunction migrateRoomSettingsFromLegacyCrypto(_x23) {\n  return _migrateRoomSettingsFromLegacyCrypto.apply(this, arguments);\n}\nfunction _migrateRoomSettingsFromLegacyCrypto() {\n  _migrateRoomSettingsFromLegacyCrypto = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (_ref) {\n    var {\n      logger,\n      legacyStore,\n      olmMachine\n    } = _ref;\n    if (!(yield legacyStore.containsData())) {\n      // This store was never used. Nothing to migrate.\n      return;\n    }\n    var migrationState = yield legacyStore.getMigrationState();\n    if (migrationState >= _crypto_store_base_js__WEBPACK_IMPORTED_MODULE_2__.MigrationState.ROOM_SETTINGS_MIGRATED) {\n      // We've already migrated the room settings.\n      return;\n    }\n    var rooms = {};\n    yield legacyStore.doTxn(\"readwrite\", [_crypto_store_indexeddb_crypto_store_js__WEBPACK_IMPORTED_MODULE_3__.IndexedDBCryptoStore.STORE_ROOMS], txn => {\n      legacyStore.getEndToEndRooms(txn, result => {\n        rooms = result;\n      });\n    });\n    logger.debug(\"Migrating \".concat(Object.keys(rooms).length, \" sets of room settings\"));\n    for (var [roomId, legacySettings] of Object.entries(rooms)) {\n      try {\n        var rustSettings = new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.RoomSettings();\n        if (legacySettings.algorithm !== \"m.megolm.v1.aes-sha2\") {\n          logger.warn(\"Room \".concat(roomId, \": ignoring room with invalid algorithm \").concat(legacySettings.algorithm));\n          continue;\n        }\n        rustSettings.algorithm = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.EncryptionAlgorithm.MegolmV1AesSha2;\n        rustSettings.sessionRotationPeriodMs = legacySettings.rotation_period_ms;\n        rustSettings.sessionRotationPeriodMessages = legacySettings.rotation_period_msgs;\n        yield olmMachine.setRoomSettings(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_1__.RoomId(roomId), rustSettings);\n\n        // We don't attempt to clear out the settings from the old store, or record where we've gotten up to,\n        // which means that if the app gets restarted while we're in the middle of this migration, we'll start\n        // again from scratch. So be it. Given that legacy crypto loads the whole room list into memory on startup\n        // anyway, we know it can't be that big.\n      } catch (e) {\n        logger.warn(\"Room \".concat(roomId, \": ignoring settings \").concat(JSON.stringify(legacySettings), \" which caused error \").concat(e));\n      }\n    }\n    logger.debug(\"Completed room settings migration\");\n    yield legacyStore.setMigrationState(_crypto_store_base_js__WEBPACK_IMPORTED_MODULE_2__.MigrationState.ROOM_SETTINGS_MIGRATED);\n  });\n  return _migrateRoomSettingsFromLegacyCrypto.apply(this, arguments);\n}\nfunction getAndDecryptCachedSecretKey(_x24, _x25, _x26) {\n  return _getAndDecryptCachedSecretKey.apply(this, arguments);\n}\n/**\n * Check if the user's published identity (ie, public cross-signing keys) was trusted by the legacy session,\n * and if so mark it as trusted in the Rust session if needed.\n *\n * By default, if the legacy session didn't have the private MSK, the migrated session will revert to unverified,\n * even if the user has verified the session in the past.\n *\n * This only occurs if the private MSK was not cached in the crypto store (USK and SSK private keys won't help\n * to establish trust: the trust is rooted in the MSK).\n *\n * Rust crypto will only consider the current session as trusted if we import the private MSK itself.\n *\n * We could prompt the user to verify the session again, but it's probably better to just mark the user identity\n * as locally verified if it was before.\n *\n * See https://github.com/element-hq/element-web/issues/27079\n *\n * @param args - Argument object.\n */\nfunction _getAndDecryptCachedSecretKey() {\n  _getAndDecryptCachedSecretKey = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (legacyStore, legacyPickleKey, name) {\n    var key = yield new Promise(resolve => {\n      legacyStore.doTxn(\"readonly\", [_crypto_store_indexeddb_crypto_store_js__WEBPACK_IMPORTED_MODULE_3__.IndexedDBCryptoStore.STORE_ACCOUNT], txn => {\n        legacyStore.getSecretStorePrivateKey(txn, resolve, name);\n      });\n    });\n    if (key && key.ciphertext && key.iv && key.mac) {\n      return yield (0,_utils_decryptAESSecretStorageItem_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(key, legacyPickleKey, name);\n    } else if (key instanceof Uint8Array) {\n      // This is a legacy backward compatibility case where the key was stored in clear.\n      return (0,_base64_js__WEBPACK_IMPORTED_MODULE_6__.encodeBase64)(key);\n    } else {\n      return undefined;\n    }\n  });\n  return _getAndDecryptCachedSecretKey.apply(this, arguments);\n}\nfunction migrateLegacyLocalTrustIfNeeded(_x27) {\n  return _migrateLegacyLocalTrustIfNeeded.apply(this, arguments);\n}\n\n/**\n * Checks if the legacy store has a trusted public master key, and returns it if so.\n *\n * @param legacyStore - The legacy store to check.\n *\n * @returns `null` if there were no cross signing keys or if they were not trusted. The trusted public master key if it was.\n */\nfunction _migrateLegacyLocalTrustIfNeeded() {\n  _migrateLegacyLocalTrustIfNeeded = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (args) {\n    var {\n      legacyCryptoStore,\n      rustCrypto,\n      logger\n    } = args;\n    // Get the public cross-signing identity from rust.\n    var rustOwnIdentity = yield rustCrypto.getOwnIdentity();\n    if (!rustOwnIdentity) {\n      // There are no cross-signing keys published server side, so nothing to do here.\n      return;\n    }\n    if (rustOwnIdentity.isVerified()) {\n      // The rust session already trusts the keys, so again, nothing to do.\n      return;\n    }\n    var legacyLocallyTrustedMSK = yield getLegacyTrustedPublicMasterKeyBase64(legacyCryptoStore);\n    if (!legacyLocallyTrustedMSK) {\n      // The user never verified their identity in the legacy session, so nothing to do.\n      return;\n    }\n    var mskInfo = JSON.parse(rustOwnIdentity.masterKey);\n    if (!mskInfo.keys || Object.keys(mskInfo.keys).length === 0) {\n      // This should not happen, but let's be safe\n      logger.error(\"Post Migration | Unexpected error: no master key in the rust session.\");\n      return;\n    }\n    var rustSeenMSK = Object.values(mskInfo.keys)[0];\n    if (rustSeenMSK && rustSeenMSK == legacyLocallyTrustedMSK) {\n      logger.info(\"Post Migration: Migrating legacy trusted MSK: \".concat(legacyLocallyTrustedMSK, \" to locally verified.\"));\n      // Let's mark the user identity as locally verified as part of the migration.\n      yield rustOwnIdentity.verify();\n      // As well as marking the MSK as trusted, `OlmMachine.verify` returns a\n      // `SignatureUploadRequest` which will publish a signature of the MSK using\n      // this device. In this case, we ignore the request: since the user hasn't\n      // actually re-verified the MSK, we don't publish a new signature. (`.verify`\n      // doesn't store the signature, and if we drop the request here it won't be\n      // retried.)\n      //\n      // Not publishing the signature is consistent with the behaviour of\n      // matrix-crypto-sdk when the private key is imported via\n      // `importCrossSigningKeys`, and when the identity is verified via interactive\n      // verification.\n      //\n      // [Aside: device signatures on the MSK are not considered by the rust-sdk to\n      // establish the trust of the user identity so in any case, what we actually do\n      // here is somewhat moot.]\n    }\n  });\n  return _migrateLegacyLocalTrustIfNeeded.apply(this, arguments);\n}\nfunction getLegacyTrustedPublicMasterKeyBase64(_x28) {\n  return _getLegacyTrustedPublicMasterKeyBase.apply(this, arguments);\n}\nfunction _getLegacyTrustedPublicMasterKeyBase() {\n  _getLegacyTrustedPublicMasterKeyBase = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (legacyStore) {\n    var maybeTrustedKeys = null;\n    yield legacyStore.doTxn(\"readonly\", \"account\", txn => {\n      legacyStore.getCrossSigningKeys(txn, keys => {\n        // can be an empty object after resetting cross-signing keys, see storeTrustedSelfKeys\n        var msk = keys === null || keys === void 0 ? void 0 : keys.master;\n        if (msk && Object.keys(msk.keys).length != 0) {\n          // `msk.keys` is an object with { [`ed25519:${pubKey}`]: pubKey }\n          maybeTrustedKeys = Object.values(msk.keys)[0];\n        }\n      });\n    });\n    return maybeTrustedKeys;\n  });\n  return _getLegacyTrustedPublicMasterKeyBase.apply(this, arguments);\n}\n//# sourceMappingURL=libolm_migration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vbGlib2xtX21pZ3JhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF3RTtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNFO0FBQ2I7QUFDd0I7QUFDM0I7QUFDbEI7QUFDUTtBQUNzQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwwQ0FBMEM7QUFDM0Y7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUZBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLFVBQVUseUVBQXlCOztBQUVuQztBQUNBLFFBQVEsdUVBQXVCLENBQUMsMkVBQTJCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx5RkFBb0I7QUFDN0Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlFQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpRUFBYztBQUN6QztBQUNBO0FBQ0EsdUJBQXVCLGlFQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpRUFBYztBQUN6QztBQUNBO0FBQ0EsdUJBQXVCLGlFQUFjO0FBQ3JDO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQWM7QUFDekM7QUFDQTtBQUNBLHVCQUF1QixpRUFBYztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUZBQWlCO0FBQ3RDLDRCQUE0QixpRkFBaUM7QUFDN0QsK0JBQStC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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1GQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1GQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWSxPQUFPO0FBQy9EO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FzdGVyaWNzLWdyaWQvLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vbGlib2xtX21pZ3JhdGlvbi5qcz8wMTgyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfYXN5bmNUb0dlbmVyYXRvciBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCI7XG4vKlxuQ29weXJpZ2h0IDIwMjMtMjAyNCBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCAqIGFzIFJ1c3RTZGtDcnlwdG9KcyBmcm9tIFwiQG1hdHJpeC1vcmcvbWF0cml4LXNkay1jcnlwdG8td2FzbVwiO1xuaW1wb3J0IHsgTWlncmF0aW9uU3RhdGUgfSBmcm9tIFwiLi4vY3J5cHRvL3N0b3JlL2Jhc2UuanNcIjtcbmltcG9ydCB7IEluZGV4ZWREQkNyeXB0b1N0b3JlIH0gZnJvbSBcIi4uL2NyeXB0by9zdG9yZS9pbmRleGVkZGItY3J5cHRvLXN0b3JlLmpzXCI7XG5pbXBvcnQgeyByZXF1ZXN0S2V5QmFja3VwVmVyc2lvbiB9IGZyb20gXCIuL2JhY2t1cC5qc1wiO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IGVuY29kZUJhc2U2NCB9IGZyb20gXCIuLi9iYXNlNjQuanNcIjtcbmltcG9ydCBkZWNyeXB0QUVTU2VjcmV0U3RvcmFnZUl0ZW0gZnJvbSBcIi4uL3V0aWxzL2RlY3J5cHRBRVNTZWNyZXRTdG9yYWdlSXRlbS5qc1wiO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW55IGRhdGEgbmVlZHMgbWlncmF0aW5nIGZyb20gdGhlIGxlZ2FjeSBzdG9yZSwgYW5kIGRvIHNvLlxuICpcbiAqIFRoaXMgbWlncmF0ZXMgdGhlIGJhc2UgYWNjb3VudCBkYXRhLCBhbmQgb2xtIGFuZCBtZWdvbG0gc2Vzc2lvbnMuIEl0IGRvZXMgKm5vdCogbWlncmF0ZSB0aGUgcm9vbSBsaXN0LCB3aGljaCBzaG91bGRcbiAqIGhhcHBlbiBhZnRlciBhbiBgT2xtTWFjaGluZWAgaXMgY3JlYXRlZCwgdmlhIHtAbGluayBtaWdyYXRlUm9vbVNldHRpbmdzRnJvbUxlZ2FjeUNyeXB0b30uXG4gKlxuICogQHBhcmFtIGFyZ3MgLSBBcmd1bWVudHMgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWlncmF0ZUZyb21MZWdhY3lDcnlwdG8oX3gpIHtcbiAgcmV0dXJuIF9taWdyYXRlRnJvbUxlZ2FjeUNyeXB0by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX21pZ3JhdGVGcm9tTGVnYWN5Q3J5cHRvKCkge1xuICBfbWlncmF0ZUZyb21MZWdhY3lDcnlwdG8gPSBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKGFyZ3MpIHtcbiAgICB2YXIgX2FyZ3MkbGVnYWN5TWlncmF0aW9uMjtcbiAgICB2YXIge1xuICAgICAgbG9nZ2VyLFxuICAgICAgbGVnYWN5U3RvcmVcbiAgICB9ID0gYXJncztcblxuICAgIC8vIGluaXRpYWxpc2UgdGhlIHJ1c3QgbWF0cml4LXNkay1jcnlwdG8td2FzbSwgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBkb25lXG4gICAgeWllbGQgUnVzdFNka0NyeXB0b0pzLmluaXRBc3luYygpO1xuXG4gICAgLy8gZW5hYmxlIHRyYWNpbmcgaW4gdGhlIHJ1c3Qtc2RrXG4gICAgbmV3IFJ1c3RTZGtDcnlwdG9Kcy5UcmFjaW5nKFJ1c3RTZGtDcnlwdG9Kcy5Mb2dnZXJMZXZlbC5EZWJ1ZykudHVybk9uKCk7XG4gICAgaWYgKCEoeWllbGQgbGVnYWN5U3RvcmUuY29udGFpbnNEYXRhKCkpKSB7XG4gICAgICAvLyBUaGlzIHN0b3JlIHdhcyBuZXZlciB1c2VkLiBOb3RoaW5nIHRvIG1pZ3JhdGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHlpZWxkIGxlZ2FjeVN0b3JlLnN0YXJ0dXAoKTtcbiAgICB2YXIgYWNjb3VudFBpY2tsZSA9IG51bGw7XG4gICAgeWllbGQgbGVnYWN5U3RvcmUuZG9UeG4oXCJyZWFkb25seVwiLCBbSW5kZXhlZERCQ3J5cHRvU3RvcmUuU1RPUkVfQUNDT1VOVF0sIHR4biA9PiB7XG4gICAgICBsZWdhY3lTdG9yZS5nZXRBY2NvdW50KHR4biwgYWNjdFBpY2tsZSA9PiB7XG4gICAgICAgIGFjY291bnRQaWNrbGUgPSBhY2N0UGlja2xlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKCFhY2NvdW50UGlja2xlKSB7XG4gICAgICAvLyBUaGlzIHN0b3JlIGlzIG5vdCBwcm9wZXJseSBzZXQgdXAuIE5vdGhpbmcgdG8gbWlncmF0ZS5cbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIkxlZ2FjeSBjcnlwdG8gc3RvcmUgaXMgbm90IHNldCB1cCAobm8gYWNjb3VudCBmb3VuZCkuIE5vdCBtaWdyYXRpbmcuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbWlncmF0aW9uU3RhdGUgPSB5aWVsZCBsZWdhY3lTdG9yZS5nZXRNaWdyYXRpb25TdGF0ZSgpO1xuICAgIGlmIChtaWdyYXRpb25TdGF0ZSA+PSBNaWdyYXRpb25TdGF0ZS5NRUdPTE1fU0VTU0lPTlNfTUlHUkFURUQpIHtcbiAgICAgIC8vIEFsbCBtaWdyYXRpb24gaXMgZG9uZSBmb3Igbm93LiBUaGUgcm9vbSBsaXN0IGNvbWVzIGxhdGVyLCBvbmNlIHdlIGhhdmUgYW4gT2xtTWFjaGluZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5PbG1TZXNzaW9ucyA9IHlpZWxkIGNvdW50T2xtU2Vzc2lvbnMobG9nZ2VyLCBsZWdhY3lTdG9yZSk7XG4gICAgdmFyIG5NZWdvbG1TZXNzaW9ucyA9IHlpZWxkIGNvdW50TWVnb2xtU2Vzc2lvbnMobG9nZ2VyLCBsZWdhY3lTdG9yZSk7XG4gICAgdmFyIHRvdGFsU3RlcHMgPSAxICsgbk9sbVNlc3Npb25zICsgbk1lZ29sbVNlc3Npb25zO1xuICAgIGxvZ2dlci5pbmZvKFwiTWlncmF0aW5nIGRhdGEgZnJvbSBsZWdhY3kgY3J5cHRvIHN0b3JlLiBcIi5jb25jYXQobk9sbVNlc3Npb25zLCBcIiBvbG0gc2Vzc2lvbnMgYW5kIFwiKS5jb25jYXQobk1lZ29sbVNlc3Npb25zLCBcIiBtZWdvbG0gc2Vzc2lvbnMgdG8gbWlncmF0ZS5cIikpO1xuICAgIHZhciBzdGVwc0RvbmUgPSAwO1xuICAgIGZ1bmN0aW9uIG9uUHJvZ3Jlc3Moc3RlcHMpIHtcbiAgICAgIHZhciBfYXJncyRsZWdhY3lNaWdyYXRpb247XG4gICAgICBzdGVwc0RvbmUgKz0gc3RlcHM7XG4gICAgICAoX2FyZ3MkbGVnYWN5TWlncmF0aW9uID0gYXJncy5sZWdhY3lNaWdyYXRpb25Qcm9ncmVzc0xpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYXJncyRsZWdhY3lNaWdyYXRpb24gPT09IHZvaWQgMCB8fCBfYXJncyRsZWdhY3lNaWdyYXRpb24uY2FsbChhcmdzLCBzdGVwc0RvbmUsIHRvdGFsU3RlcHMpO1xuICAgIH1cbiAgICBvblByb2dyZXNzKDApO1xuICAgIHZhciBwaWNrbGVLZXkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoYXJncy5sZWdhY3lQaWNrbGVLZXkpO1xuICAgIGlmIChtaWdyYXRpb25TdGF0ZSA9PT0gTWlncmF0aW9uU3RhdGUuTk9UX1NUQVJURUQpIHtcbiAgICAgIGxvZ2dlci5pbmZvKFwiTWlncmF0aW5nIGRhdGEgZnJvbSBsZWdhY3kgY3J5cHRvIHN0b3JlLiBTdGVwIDE6IGJhc2UgZGF0YVwiKTtcbiAgICAgIHlpZWxkIG1pZ3JhdGVCYXNlRGF0YShhcmdzLmh0dHAsIGFyZ3MudXNlcklkLCBhcmdzLmRldmljZUlkLCBsZWdhY3lTdG9yZSwgcGlja2xlS2V5LCBhcmdzLnN0b3JlSGFuZGxlLCBsb2dnZXIpO1xuICAgICAgbWlncmF0aW9uU3RhdGUgPSBNaWdyYXRpb25TdGF0ZS5JTklUSUFMX0RBVEFfTUlHUkFURUQ7XG4gICAgICB5aWVsZCBsZWdhY3lTdG9yZS5zZXRNaWdyYXRpb25TdGF0ZShtaWdyYXRpb25TdGF0ZSk7XG4gICAgfVxuICAgIG9uUHJvZ3Jlc3MoMSk7XG4gICAgaWYgKG1pZ3JhdGlvblN0YXRlID09PSBNaWdyYXRpb25TdGF0ZS5JTklUSUFMX0RBVEFfTUlHUkFURUQpIHtcbiAgICAgIGxvZ2dlci5pbmZvKFwiTWlncmF0aW5nIGRhdGEgZnJvbSBsZWdhY3kgY3J5cHRvIHN0b3JlLiBTdGVwIDI6IG9sbSBzZXNzaW9ucyAoXCIuY29uY2F0KG5PbG1TZXNzaW9ucywgXCIgc2Vzc2lvbnMgdG8gbWlncmF0ZSkuXCIpKTtcbiAgICAgIHlpZWxkIG1pZ3JhdGVPbG1TZXNzaW9ucyhsb2dnZXIsIGxlZ2FjeVN0b3JlLCBwaWNrbGVLZXksIGFyZ3Muc3RvcmVIYW5kbGUsIG9uUHJvZ3Jlc3MpO1xuICAgICAgbWlncmF0aW9uU3RhdGUgPSBNaWdyYXRpb25TdGF0ZS5PTE1fU0VTU0lPTlNfTUlHUkFURUQ7XG4gICAgICB5aWVsZCBsZWdhY3lTdG9yZS5zZXRNaWdyYXRpb25TdGF0ZShtaWdyYXRpb25TdGF0ZSk7XG4gICAgfVxuICAgIGlmIChtaWdyYXRpb25TdGF0ZSA9PT0gTWlncmF0aW9uU3RhdGUuT0xNX1NFU1NJT05TX01JR1JBVEVEKSB7XG4gICAgICBsb2dnZXIuaW5mbyhcIk1pZ3JhdGluZyBkYXRhIGZyb20gbGVnYWN5IGNyeXB0byBzdG9yZS4gU3RlcCAzOiBtZWdvbG0gc2Vzc2lvbnMgKFwiLmNvbmNhdChuTWVnb2xtU2Vzc2lvbnMsIFwiIHNlc3Npb25zIHRvIG1pZ3JhdGUpLlwiKSk7XG4gICAgICB5aWVsZCBtaWdyYXRlTWVnb2xtU2Vzc2lvbnMobG9nZ2VyLCBsZWdhY3lTdG9yZSwgcGlja2xlS2V5LCBhcmdzLnN0b3JlSGFuZGxlLCBvblByb2dyZXNzKTtcbiAgICAgIG1pZ3JhdGlvblN0YXRlID0gTWlncmF0aW9uU3RhdGUuTUVHT0xNX1NFU1NJT05TX01JR1JBVEVEO1xuICAgICAgeWllbGQgbGVnYWN5U3RvcmUuc2V0TWlncmF0aW9uU3RhdGUobWlncmF0aW9uU3RhdGUpO1xuICAgIH1cblxuICAgIC8vIE1pZ3JhdGlvbiBpcyBkb25lLlxuICAgIChfYXJncyRsZWdhY3lNaWdyYXRpb24yID0gYXJncy5sZWdhY3lNaWdyYXRpb25Qcm9ncmVzc0xpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYXJncyRsZWdhY3lNaWdyYXRpb24yID09PSB2b2lkIDAgfHwgX2FyZ3MkbGVnYWN5TWlncmF0aW9uMi5jYWxsKGFyZ3MsIC0xLCAtMSk7XG4gICAgbG9nZ2VyLmluZm8oXCJNaWdyYXRpb24gZnJvbSBsZWdhY3kgY3J5cHRvIHN0b3JlIGNvbXBsZXRlXCIpO1xuICB9KTtcbiAgcmV0dXJuIF9taWdyYXRlRnJvbUxlZ2FjeUNyeXB0by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gbWlncmF0ZUJhc2VEYXRhKF94MiwgX3gzLCBfeDQsIF94NSwgX3g2LCBfeDcsIF94OCkge1xuICByZXR1cm4gX21pZ3JhdGVCYXNlRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX21pZ3JhdGVCYXNlRGF0YSgpIHtcbiAgX21pZ3JhdGVCYXNlRGF0YSA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoaHR0cCwgdXNlcklkLCBkZXZpY2VJZCwgbGVnYWN5U3RvcmUsIHBpY2tsZUtleSwgc3RvcmVIYW5kbGUsIGxvZ2dlcikge1xuICAgIHZhciBtaWdyYXRpb25EYXRhID0gbmV3IFJ1c3RTZGtDcnlwdG9Kcy5CYXNlTWlncmF0aW9uRGF0YSgpO1xuICAgIG1pZ3JhdGlvbkRhdGEudXNlcklkID0gbmV3IFJ1c3RTZGtDcnlwdG9Kcy5Vc2VySWQodXNlcklkKTtcbiAgICBtaWdyYXRpb25EYXRhLmRldmljZUlkID0gbmV3IFJ1c3RTZGtDcnlwdG9Kcy5EZXZpY2VJZChkZXZpY2VJZCk7XG4gICAgeWllbGQgbGVnYWN5U3RvcmUuZG9UeG4oXCJyZWFkb25seVwiLCBbSW5kZXhlZERCQ3J5cHRvU3RvcmUuU1RPUkVfQUNDT1VOVF0sIHR4biA9PiBsZWdhY3lTdG9yZS5nZXRBY2NvdW50KHR4biwgYSA9PiB7XG4gICAgICBtaWdyYXRpb25EYXRhLnBpY2tsZWRBY2NvdW50ID0gYSAhPT0gbnVsbCAmJiBhICE9PSB2b2lkIDAgPyBhIDogXCJcIjtcbiAgICB9KSk7XG4gICAgdmFyIHJlY292ZXJ5S2V5ID0geWllbGQgZ2V0QW5kRGVjcnlwdENhY2hlZFNlY3JldEtleShsZWdhY3lTdG9yZSwgcGlja2xlS2V5LCBcIm0ubWVnb2xtX2JhY2t1cC52MVwiKTtcblxuICAgIC8vIElmIHdlIGhhdmUgYSBiYWNrdXAgcmVjb3Zlcnkga2V5LCB3ZSBuZWVkIHRvIHRyeSB0byBmaWd1cmUgb3V0IHdoaWNoIGJhY2t1cCB2ZXJzaW9uIGl0IGlzIGZvci5cbiAgICAvLyBBbGwgd2UgY2FuIHJlYWxseSBkbyBpcyBhc2sgdGhlIHNlcnZlciBmb3IgdGhlIG1vc3QgcmVjZW50IHZlcnNpb24gYW5kIGNoZWNrIGlmIHRoZSBjYWNoZWQga2V5IHdlIGhhdmUgbWF0Y2hlcy5cbiAgICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBiYWNrdXAgaGFzIGNoYW5nZWQgc2luY2UgbGFzdCB0aW1lIGhpcyBzZXNzaW9uIHdhcyBvcGVuZWQuXG4gICAgaWYgKHJlY292ZXJ5S2V5KSB7XG4gICAgICB2YXIgYmFja3VwQ2FsbERvbmUgPSBmYWxzZTtcbiAgICAgIHZhciBiYWNrdXBJbmZvID0gbnVsbDtcbiAgICAgIHdoaWxlICghYmFja3VwQ2FsbERvbmUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBiYWNrdXBJbmZvID0geWllbGQgcmVxdWVzdEtleUJhY2t1cFZlcnNpb24oaHR0cCk7XG4gICAgICAgICAgYmFja3VwQ2FsbERvbmUgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oXCJGYWlsZWQgdG8gZ2V0IGJhY2t1cCB2ZXJzaW9uIGR1cmluZyBtaWdyYXRpb24sIHJldHJ5aW5nIGluIDIgc2Vjb25kc1wiLCBlKTtcbiAgICAgICAgICAvLyBSZXRyeSB1bnRpbCBzdWNjZXNzZnVsLCB1c2Ugc2ltcGxlIGNvbnN0YW50IGRlbGF5XG4gICAgICAgICAgeWllbGQgc2xlZXAoMjAwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChiYWNrdXBJbmZvICYmIGJhY2t1cEluZm8uYWxnb3JpdGhtID09IFwibS5tZWdvbG1fYmFja3VwLnYxLmN1cnZlMjU1MTktYWVzLXNoYTJcIikge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgcmVjb3Zlcnkga2V5IG1hdGNoZXMsIGFzIHRoZSBhY3RpdmUgYmFja3VwIHZlcnNpb24gbWF5IGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUga2V5IHdhcyBjYWNoZWRcbiAgICAgICAgLy8gYW5kIHRoZSBtaWdyYXRpb24gc3RhcnRlZC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgX2JhY2t1cEluZm8kYXV0aF9kYXRhO1xuICAgICAgICAgIHZhciBkZWNyeXB0aW9uS2V5ID0gUnVzdFNka0NyeXB0b0pzLkJhY2t1cERlY3J5cHRpb25LZXkuZnJvbUJhc2U2NChyZWNvdmVyeUtleSk7XG4gICAgICAgICAgdmFyIHB1YmxpY0tleSA9IChfYmFja3VwSW5mbyRhdXRoX2RhdGEgPSBiYWNrdXBJbmZvLmF1dGhfZGF0YSkgPT09IG51bGwgfHwgX2JhY2t1cEluZm8kYXV0aF9kYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYmFja3VwSW5mbyRhdXRoX2RhdGEucHVibGljX2tleTtcbiAgICAgICAgICB2YXIgaXNWYWxpZCA9IGRlY3J5cHRpb25LZXkubWVnb2xtVjFQdWJsaWNLZXkucHVibGljS2V5QmFzZTY0ID09IHB1YmxpY0tleTtcbiAgICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgbWlncmF0aW9uRGF0YS5iYWNrdXBWZXJzaW9uID0gYmFja3VwSW5mby52ZXJzaW9uO1xuICAgICAgICAgICAgbWlncmF0aW9uRGF0YS5iYWNrdXBSZWNvdmVyeUtleSA9IHJlY292ZXJ5S2V5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJUaGUgYmFja3VwIGtleSB0byBtaWdyYXRlIGRvZXMgbm90IG1hdGNoIHRoZSBhY3RpdmUgYmFja3VwIHZlcnNpb25cIiwgXCJDYWNoZWQgcHViIGtleTogXCIuY29uY2F0KGRlY3J5cHRpb25LZXkubWVnb2xtVjFQdWJsaWNLZXkucHVibGljS2V5QmFzZTY0KSwgXCJBY3RpdmUgcHViIGtleTogXCIuY29uY2F0KHB1YmxpY0tleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFwiRmFpbGVkIHRvIGNoZWNrIGlmIHRoZSBiYWNrdXAga2V5IHRvIG1pZ3JhdGUgbWF0Y2hlcyB0aGUgYWN0aXZlIGJhY2t1cCB2ZXJzaW9uXCIsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1pZ3JhdGlvbkRhdGEucHJpdmF0ZUNyb3NzU2lnbmluZ01hc3RlcktleSA9IHlpZWxkIGdldEFuZERlY3J5cHRDYWNoZWRTZWNyZXRLZXkobGVnYWN5U3RvcmUsIHBpY2tsZUtleSwgXCJtYXN0ZXJcIik7XG4gICAgbWlncmF0aW9uRGF0YS5wcml2YXRlQ3Jvc3NTaWduaW5nU2VsZlNpZ25pbmdLZXkgPSB5aWVsZCBnZXRBbmREZWNyeXB0Q2FjaGVkU2VjcmV0S2V5KGxlZ2FjeVN0b3JlLCBwaWNrbGVLZXksIFwic2VsZl9zaWduaW5nXCIpO1xuICAgIG1pZ3JhdGlvbkRhdGEucHJpdmF0ZUNyb3NzU2lnbmluZ1VzZXJTaWduaW5nS2V5ID0geWllbGQgZ2V0QW5kRGVjcnlwdENhY2hlZFNlY3JldEtleShsZWdhY3lTdG9yZSwgcGlja2xlS2V5LCBcInVzZXJfc2lnbmluZ1wiKTtcbiAgICB5aWVsZCBSdXN0U2RrQ3J5cHRvSnMuTWlncmF0aW9uLm1pZ3JhdGVCYXNlRGF0YShtaWdyYXRpb25EYXRhLCBwaWNrbGVLZXksIHN0b3JlSGFuZGxlKTtcbiAgfSk7XG4gIHJldHVybiBfbWlncmF0ZUJhc2VEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBjb3VudE9sbVNlc3Npb25zKF94OSwgX3gxMCkge1xuICByZXR1cm4gX2NvdW50T2xtU2Vzc2lvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9jb3VudE9sbVNlc3Npb25zKCkge1xuICBfY291bnRPbG1TZXNzaW9ucyA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAobG9nZ2VyLCBsZWdhY3lTdG9yZSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkNvdW50aW5nIG9sbSBzZXNzaW9ucyB0byBiZSBtaWdyYXRlZFwiKTtcbiAgICB2YXIgblNlc3Npb25zO1xuICAgIHlpZWxkIGxlZ2FjeVN0b3JlLmRvVHhuKFwicmVhZG9ubHlcIiwgW0luZGV4ZWREQkNyeXB0b1N0b3JlLlNUT1JFX1NFU1NJT05TXSwgdHhuID0+IGxlZ2FjeVN0b3JlLmNvdW50RW5kVG9FbmRTZXNzaW9ucyh0eG4sIG4gPT4gblNlc3Npb25zID0gbikpO1xuICAgIHJldHVybiBuU2Vzc2lvbnM7XG4gIH0pO1xuICByZXR1cm4gX2NvdW50T2xtU2Vzc2lvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGNvdW50TWVnb2xtU2Vzc2lvbnMoX3gxMSwgX3gxMikge1xuICByZXR1cm4gX2NvdW50TWVnb2xtU2Vzc2lvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9jb3VudE1lZ29sbVNlc3Npb25zKCkge1xuICBfY291bnRNZWdvbG1TZXNzaW9ucyA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAobG9nZ2VyLCBsZWdhY3lTdG9yZSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkNvdW50aW5nIG1lZ29sbSBzZXNzaW9ucyB0byBiZSBtaWdyYXRlZFwiKTtcbiAgICByZXR1cm4geWllbGQgbGVnYWN5U3RvcmUuY291bnRFbmRUb0VuZEluYm91bmRHcm91cFNlc3Npb25zKCk7XG4gIH0pO1xuICByZXR1cm4gX2NvdW50TWVnb2xtU2Vzc2lvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIG1pZ3JhdGVPbG1TZXNzaW9ucyhfeDEzLCBfeDE0LCBfeDE1LCBfeDE2LCBfeDE3KSB7XG4gIHJldHVybiBfbWlncmF0ZU9sbVNlc3Npb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfbWlncmF0ZU9sbVNlc3Npb25zKCkge1xuICBfbWlncmF0ZU9sbVNlc3Npb25zID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qIChsb2dnZXIsIGxlZ2FjeVN0b3JlLCBwaWNrbGVLZXksIHN0b3JlSGFuZGxlLCBvbkJhdGNoRG9uZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGJhdGNoID0geWllbGQgbGVnYWN5U3RvcmUuZ2V0RW5kVG9FbmRTZXNzaW9uc0JhdGNoKCk7XG4gICAgICBpZiAoYmF0Y2ggPT09IG51bGwpIHJldHVybjtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIk1pZ3JhdGluZyBiYXRjaCBvZiBcIi5jb25jYXQoYmF0Y2gubGVuZ3RoLCBcIiBvbG0gc2Vzc2lvbnNcIikpO1xuICAgICAgdmFyIG1pZ3JhdGlvbkRhdGEgPSBbXTtcbiAgICAgIGZvciAodmFyIHNlc3Npb24gb2YgYmF0Y2gpIHtcbiAgICAgICAgdmFyIHBpY2tsZWRTZXNzaW9uID0gbmV3IFJ1c3RTZGtDcnlwdG9Kcy5QaWNrbGVkU2Vzc2lvbigpO1xuICAgICAgICBwaWNrbGVkU2Vzc2lvbi5zZW5kZXJLZXkgPSBzZXNzaW9uLmRldmljZUtleTtcbiAgICAgICAgcGlja2xlZFNlc3Npb24ucGlja2xlID0gc2Vzc2lvbi5zZXNzaW9uO1xuICAgICAgICBwaWNrbGVkU2Vzc2lvbi5sYXN0VXNlVGltZSA9IHBpY2tsZWRTZXNzaW9uLmNyZWF0aW9uVGltZSA9IG5ldyBEYXRlKHNlc3Npb24ubGFzdFJlY2VpdmVkTWVzc2FnZVRzKTtcbiAgICAgICAgbWlncmF0aW9uRGF0YS5wdXNoKHBpY2tsZWRTZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIFJ1c3RTZGtDcnlwdG9Kcy5NaWdyYXRpb24ubWlncmF0ZU9sbVNlc3Npb25zKG1pZ3JhdGlvbkRhdGEsIHBpY2tsZUtleSwgc3RvcmVIYW5kbGUpO1xuICAgICAgeWllbGQgbGVnYWN5U3RvcmUuZGVsZXRlRW5kVG9FbmRTZXNzaW9uc0JhdGNoKGJhdGNoKTtcbiAgICAgIG9uQmF0Y2hEb25lKGJhdGNoLmxlbmd0aCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIF9taWdyYXRlT2xtU2Vzc2lvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIG1pZ3JhdGVNZWdvbG1TZXNzaW9ucyhfeDE4LCBfeDE5LCBfeDIwLCBfeDIxLCBfeDIyKSB7XG4gIHJldHVybiBfbWlncmF0ZU1lZ29sbVNlc3Npb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIERldGVybWluZSBpZiBhbnkgcm9vbSBzZXR0aW5ncyBuZWVkIG1pZ3JhdGluZyBmcm9tIHRoZSBsZWdhY3kgc3RvcmUsIGFuZCBkbyBzby5cbiAqXG4gKiBAcGFyYW0gYXJncyAtIEFyZ3VtZW50cyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIF9taWdyYXRlTWVnb2xtU2Vzc2lvbnMoKSB7XG4gIF9taWdyYXRlTWVnb2xtU2Vzc2lvbnMgPSBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKGxvZ2dlciwgbGVnYWN5U3RvcmUsIHBpY2tsZUtleSwgc3RvcmVIYW5kbGUsIG9uQmF0Y2hEb25lKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgYmF0Y2ggPSB5aWVsZCBsZWdhY3lTdG9yZS5nZXRFbmRUb0VuZEluYm91bmRHcm91cFNlc3Npb25zQmF0Y2goKTtcbiAgICAgIGlmIChiYXRjaCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiTWlncmF0aW5nIGJhdGNoIG9mIFwiLmNvbmNhdChiYXRjaC5sZW5ndGgsIFwiIG1lZ29sbSBzZXNzaW9uc1wiKSk7XG4gICAgICB2YXIgbWlncmF0aW9uRGF0YSA9IFtdO1xuICAgICAgZm9yICh2YXIgc2Vzc2lvbiBvZiBiYXRjaCkge1xuICAgICAgICB2YXIgX3Nlc3Npb25EYXRhJGtleXNDbGFpO1xuICAgICAgICB2YXIgc2Vzc2lvbkRhdGEgPSBzZXNzaW9uLnNlc3Npb25EYXRhO1xuICAgICAgICB2YXIgcGlja2xlZFNlc3Npb24gPSBuZXcgUnVzdFNka0NyeXB0b0pzLlBpY2tsZWRJbmJvdW5kR3JvdXBTZXNzaW9uKCk7XG4gICAgICAgIHBpY2tsZWRTZXNzaW9uLnBpY2tsZSA9IHNlc3Npb25EYXRhLnNlc3Npb247XG4gICAgICAgIHBpY2tsZWRTZXNzaW9uLnJvb21JZCA9IG5ldyBSdXN0U2RrQ3J5cHRvSnMuUm9vbUlkKHNlc3Npb25EYXRhLnJvb21faWQpO1xuICAgICAgICBwaWNrbGVkU2Vzc2lvbi5zZW5kZXJLZXkgPSBzZXNzaW9uLnNlbmRlcktleTtcbiAgICAgICAgcGlja2xlZFNlc3Npb24uc2VuZGVyU2lnbmluZ0tleSA9IChfc2Vzc2lvbkRhdGEka2V5c0NsYWkgPSBzZXNzaW9uRGF0YS5rZXlzQ2xhaW1lZCkgPT09IG51bGwgfHwgX3Nlc3Npb25EYXRhJGtleXNDbGFpID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2Vzc2lvbkRhdGEka2V5c0NsYWlbXCJlZDI1NTE5XCJdO1xuICAgICAgICBwaWNrbGVkU2Vzc2lvbi5iYWNrZWRVcCA9ICFzZXNzaW9uLm5lZWRzQmFja3VwO1xuXG4gICAgICAgIC8vIFRoZSBSdXN0IFNESyBgaW1wb3J0ZWRgIGZsYWcgaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGUgYXV0aGVudGljaXR5IHN0YXR1cyBvZiBhIE1lZ29sbVxuICAgICAgICAvLyBzZXNzaW9uLCB3aGljaCB0ZWxscyB1cyB3aGV0aGVyIHdlIGNhbiByZWxpYWJseSB0ZWxsIHdoaWNoIE9sbSBkZXZpY2UgaXMgdGhlIG93bmVyXG4gICAgICAgIC8vIChjcmVhdG9yKSBvZiB0aGUgc2Vzc2lvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgYGltcG9ydGVkYCBpcyB0cnVlLCB0aGVuIHdlIGhhdmUgbm8gY3J5cHRvZ3JhcGhpYyBwcm9vZiB0aGF0IHRoZSBzZXNzaW9uIGlzIG93bmVkXG4gICAgICAgIC8vIGJ5IHRoZSBkZXZpY2Ugd2l0aCB0aGUgaWRlbnRpdHkga2V5IGBzZW5kZXJLZXlgLlxuICAgICAgICAvL1xuICAgICAgICAvLyBPbmx5IE1lZ29sbSBzZXNzaW9ucyByZWNlaXZlZCBkaXJlY3RseSBmcm9tIHRoZSBvd25pbmcgZGV2aWNlIHZpYSBhbiBlbmNyeXB0ZWRcbiAgICAgICAgLy8gYG0ucm9vbV9rZXlgIHRvLWRldmljZSBtZXNzYWdlIHNob3VsZCBoYXZlIGBpbXBvcnRlZGAgZmxhZyBzZXQgdG8gZmFsc2UuIE1lZ29sbVxuICAgICAgICAvLyBzZXNzaW9ucyByZWNlaXZlZCBieSBhbnkgb3RoZXIgY3VycmVudGx5IGF2YWlsYWJsZSBtZWFucyAoaS5lLiBmcm9tIGFcbiAgICAgICAgLy8gYG0uZm9yd2FyZGVkX3Jvb21fa2V5YCwgZnJvbSB2MSBhc3ltbWV0cmljIHNlcnZlci1zaWRlIGtleSBiYWNrdXAsIGltcG9ydGVkIGZyb20gYVxuICAgICAgICAvLyBmaWxlLCBldGMpIHNob3VsZCBoYXZlIHRoZSBgaW1wb3J0ZWRgIGZsYWcgc2V0IHRvIHRydWUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE1lc3NhZ2VzIGVuY3J5cHRlZCB3aXRoIHN1Y2ggTWVnb2xtIHNlc3Npb25zIHdpbGwgaGF2ZSBhIGdyZXkgc2hpZWxkIGluIHRoZSBVSVxuICAgICAgICAvLyAoXCJBdXRoZW50aWNpdHkgb2YgdGhpcyBtZXNzYWdlIGNhbm5vdCBiZSBndWFyYW50ZWVkXCIpLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCB3ZSBkb24ndCB3YW50IHRvIGJsdW50bHkgbWFyayBhbGwgc2Vzc2lvbnMgYXMgYGltcG9ydGVkYCBkdXJpbmcgbWlncmF0aW9uXG4gICAgICAgIC8vIGJlY2F1c2UgdXNlcnMgd2lsbCBzdWRkZW5seSBzdGFydCBzZWVpbmcgYWxsIHRoZWlyIGhpc3RvcmljIG1lc3NhZ2VzIGRlY29yYXRlZCB3aXRoIGFcbiAgICAgICAgLy8gZ3JleSBzaGllbGQsIHdoaWNoIHdvdWxkIGJlIHNlZW4gYXMgYSBub24tYWN0aW9uYWJsZSByZWdyZXNzaW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiB0aGUgbGVnYWN5IGNyeXB0byBzdGFjaywgdGhlIGZsYWcgZW5jb2Rpbmcgc2ltaWxhciBpbmZvcm1hdGlvbiB3YXMgY2FsbGVkXG4gICAgICAgIC8vIGBJbmJvdW5kR3JvdXBTZXNzaW9uRGF0YS51bnRydXN0ZWRgLiBUaGUgdmFsdWUgb2YgdGhpcyBmbGFnIHdhcyBzZXQgYXMgZm9sbG93czpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gLSBGb3Igb3V0Ym91bmQgTWVnb2xtIHNlc3Npb25zIGNyZWF0ZWQgYnkgb3VyIG93biBkZXZpY2UsIGB1bnRydXN0ZWRgIGlzIGB1bmRlZmluZWRgLlxuICAgICAgICAvLyAtIEZvciBNZWdvbG0gc2Vzc2lvbnMgcmVjZWl2ZWQgdmlhIGEgYG0ucm9vbV9rZXlgIHRvLWRldmljZSBtZXNzYWdlLCBgdW50cnVzdGVkYCBpc1xuICAgICAgICAvLyAgIGB1bmRlZmluZWRgLlxuICAgICAgICAvLyAtIEZvciBNZWdvbG0gc2Vzc2lvbnMgcmVjZWl2ZWQgdmlhIGEgYG0uZm9yd2FyZGVkX3Jvb21fa2V5YCB0by1kZXZpY2UgbWVzc2FnZSxcbiAgICAgICAgLy8gICBgdW50cnVzdGVkYCBpcyBgdHJ1ZWAuXG4gICAgICAgIC8vIC0gRm9yIE1lZ29sbSBzZXNzaW9ucyBpbXBvcnRlZCBmcm9tIGEgKHYxIGFzeW1tZXRyaWMgLyBcImxlZ2FjeVwiKSBzZXJ2ZXItc2lkZSBrZXlcbiAgICAgICAgLy8gICBiYWNrdXAsIGB1bnRydXN0ZWRgIGlzIGB0cnVlYC5cbiAgICAgICAgLy8gLSBGb3IgTWVnb2xtIHNlc3Npb25zIGltcG9ydGVkIGZyb20gYSBmaWxlLCB1bnRydXN0ZWQgaXMgYHVuZGVmaW5lZGAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBtYWluIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbGVnYWN5IGNyeXB0byBzdGFjayBhbmQgdGhlIFJ1c3QgY3J5cHRvIHN0YWNrIGlzIHRoYXRcbiAgICAgICAgLy8gdGhlIFJ1c3Qgc3RhY2sgY29uc2lkZXJzIHNlc3Npb25zIGltcG9ydGVkIGZyb20gYSBmaWxlIGFzIGBpbXBvcnRlZGAgKG5vdFxuICAgICAgICAvLyBhdXRoZW50aWNhdGVkKS4gVGhpcyBpcyBiZWNhdXNlIHRoZSBNZWdvbG0gc2Vzc2lvbiBleHBvcnQgZmlsZSBmb3JtYXQgZG9lcyBub3RcbiAgICAgICAgLy8gZW5jb2RlIHRoaXMgYXV0aGVudGljaXR5IGluZm9ybWF0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiB0aGlzIG1pZ3JhdGlvbiBpcyBvbmx5IGEgb25lLXRpbWUgdGhpbmcsIHdlIG1ha2UgYSBjb25jZXNzaW9uIHRvIGFjY2VwdCB0aGVcbiAgICAgICAgLy8gbG9zcyBvZiBpbmZvcm1hdGlvbiBpbiB0aGlzIGNhc2UsIHRvIGF2b2lkIGRlZ3JhZGluZyBVWCBpbiBhIG5vbi1hY3Rpb25hYmxlIHdheS5cbiAgICAgICAgcGlja2xlZFNlc3Npb24uaW1wb3J0ZWQgPSBzZXNzaW9uRGF0YS51bnRydXN0ZWQgPT09IHRydWU7XG4gICAgICAgIG1pZ3JhdGlvbkRhdGEucHVzaChwaWNrbGVkU2Vzc2lvbik7XG4gICAgICB9XG4gICAgICB5aWVsZCBSdXN0U2RrQ3J5cHRvSnMuTWlncmF0aW9uLm1pZ3JhdGVNZWdvbG1TZXNzaW9ucyhtaWdyYXRpb25EYXRhLCBwaWNrbGVLZXksIHN0b3JlSGFuZGxlKTtcbiAgICAgIHlpZWxkIGxlZ2FjeVN0b3JlLmRlbGV0ZUVuZFRvRW5kSW5ib3VuZEdyb3VwU2Vzc2lvbnNCYXRjaChiYXRjaCk7XG4gICAgICBvbkJhdGNoRG9uZShiYXRjaC5sZW5ndGgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBfbWlncmF0ZU1lZ29sbVNlc3Npb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWlncmF0ZVJvb21TZXR0aW5nc0Zyb21MZWdhY3lDcnlwdG8oX3gyMykge1xuICByZXR1cm4gX21pZ3JhdGVSb29tU2V0dGluZ3NGcm9tTGVnYWN5Q3J5cHRvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfbWlncmF0ZVJvb21TZXR0aW5nc0Zyb21MZWdhY3lDcnlwdG8oKSB7XG4gIF9taWdyYXRlUm9vbVNldHRpbmdzRnJvbUxlZ2FjeUNyeXB0byA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoX3JlZikge1xuICAgIHZhciB7XG4gICAgICBsb2dnZXIsXG4gICAgICBsZWdhY3lTdG9yZSxcbiAgICAgIG9sbU1hY2hpbmVcbiAgICB9ID0gX3JlZjtcbiAgICBpZiAoISh5aWVsZCBsZWdhY3lTdG9yZS5jb250YWluc0RhdGEoKSkpIHtcbiAgICAgIC8vIFRoaXMgc3RvcmUgd2FzIG5ldmVyIHVzZWQuIE5vdGhpbmcgdG8gbWlncmF0ZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG1pZ3JhdGlvblN0YXRlID0geWllbGQgbGVnYWN5U3RvcmUuZ2V0TWlncmF0aW9uU3RhdGUoKTtcbiAgICBpZiAobWlncmF0aW9uU3RhdGUgPj0gTWlncmF0aW9uU3RhdGUuUk9PTV9TRVRUSU5HU19NSUdSQVRFRCkge1xuICAgICAgLy8gV2UndmUgYWxyZWFkeSBtaWdyYXRlZCB0aGUgcm9vbSBzZXR0aW5ncy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJvb21zID0ge307XG4gICAgeWllbGQgbGVnYWN5U3RvcmUuZG9UeG4oXCJyZWFkd3JpdGVcIiwgW0luZGV4ZWREQkNyeXB0b1N0b3JlLlNUT1JFX1JPT01TXSwgdHhuID0+IHtcbiAgICAgIGxlZ2FjeVN0b3JlLmdldEVuZFRvRW5kUm9vbXModHhuLCByZXN1bHQgPT4ge1xuICAgICAgICByb29tcyA9IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGxvZ2dlci5kZWJ1ZyhcIk1pZ3JhdGluZyBcIi5jb25jYXQoT2JqZWN0LmtleXMocm9vbXMpLmxlbmd0aCwgXCIgc2V0cyBvZiByb29tIHNldHRpbmdzXCIpKTtcbiAgICBmb3IgKHZhciBbcm9vbUlkLCBsZWdhY3lTZXR0aW5nc10gb2YgT2JqZWN0LmVudHJpZXMocm9vbXMpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcnVzdFNldHRpbmdzID0gbmV3IFJ1c3RTZGtDcnlwdG9Kcy5Sb29tU2V0dGluZ3MoKTtcbiAgICAgICAgaWYgKGxlZ2FjeVNldHRpbmdzLmFsZ29yaXRobSAhPT0gXCJtLm1lZ29sbS52MS5hZXMtc2hhMlwiKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXCJSb29tIFwiLmNvbmNhdChyb29tSWQsIFwiOiBpZ25vcmluZyByb29tIHdpdGggaW52YWxpZCBhbGdvcml0aG0gXCIpLmNvbmNhdChsZWdhY3lTZXR0aW5ncy5hbGdvcml0aG0pKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBydXN0U2V0dGluZ3MuYWxnb3JpdGhtID0gUnVzdFNka0NyeXB0b0pzLkVuY3J5cHRpb25BbGdvcml0aG0uTWVnb2xtVjFBZXNTaGEyO1xuICAgICAgICBydXN0U2V0dGluZ3Muc2Vzc2lvblJvdGF0aW9uUGVyaW9kTXMgPSBsZWdhY3lTZXR0aW5ncy5yb3RhdGlvbl9wZXJpb2RfbXM7XG4gICAgICAgIHJ1c3RTZXR0aW5ncy5zZXNzaW9uUm90YXRpb25QZXJpb2RNZXNzYWdlcyA9IGxlZ2FjeVNldHRpbmdzLnJvdGF0aW9uX3BlcmlvZF9tc2dzO1xuICAgICAgICB5aWVsZCBvbG1NYWNoaW5lLnNldFJvb21TZXR0aW5ncyhuZXcgUnVzdFNka0NyeXB0b0pzLlJvb21JZChyb29tSWQpLCBydXN0U2V0dGluZ3MpO1xuXG4gICAgICAgIC8vIFdlIGRvbid0IGF0dGVtcHQgdG8gY2xlYXIgb3V0IHRoZSBzZXR0aW5ncyBmcm9tIHRoZSBvbGQgc3RvcmUsIG9yIHJlY29yZCB3aGVyZSB3ZSd2ZSBnb3R0ZW4gdXAgdG8sXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIHRoYXQgaWYgdGhlIGFwcCBnZXRzIHJlc3RhcnRlZCB3aGlsZSB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHRoaXMgbWlncmF0aW9uLCB3ZSdsbCBzdGFydFxuICAgICAgICAvLyBhZ2FpbiBmcm9tIHNjcmF0Y2guIFNvIGJlIGl0LiBHaXZlbiB0aGF0IGxlZ2FjeSBjcnlwdG8gbG9hZHMgdGhlIHdob2xlIHJvb20gbGlzdCBpbnRvIG1lbW9yeSBvbiBzdGFydHVwXG4gICAgICAgIC8vIGFueXdheSwgd2Uga25vdyBpdCBjYW4ndCBiZSB0aGF0IGJpZy5cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJSb29tIFwiLmNvbmNhdChyb29tSWQsIFwiOiBpZ25vcmluZyBzZXR0aW5ncyBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KGxlZ2FjeVNldHRpbmdzKSwgXCIgd2hpY2ggY2F1c2VkIGVycm9yIFwiKS5jb25jYXQoZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2dnZXIuZGVidWcoXCJDb21wbGV0ZWQgcm9vbSBzZXR0aW5ncyBtaWdyYXRpb25cIik7XG4gICAgeWllbGQgbGVnYWN5U3RvcmUuc2V0TWlncmF0aW9uU3RhdGUoTWlncmF0aW9uU3RhdGUuUk9PTV9TRVRUSU5HU19NSUdSQVRFRCk7XG4gIH0pO1xuICByZXR1cm4gX21pZ3JhdGVSb29tU2V0dGluZ3NGcm9tTGVnYWN5Q3J5cHRvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBnZXRBbmREZWNyeXB0Q2FjaGVkU2VjcmV0S2V5KF94MjQsIF94MjUsIF94MjYpIHtcbiAgcmV0dXJuIF9nZXRBbmREZWNyeXB0Q2FjaGVkU2VjcmV0S2V5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSB1c2VyJ3MgcHVibGlzaGVkIGlkZW50aXR5IChpZSwgcHVibGljIGNyb3NzLXNpZ25pbmcga2V5cykgd2FzIHRydXN0ZWQgYnkgdGhlIGxlZ2FjeSBzZXNzaW9uLFxuICogYW5kIGlmIHNvIG1hcmsgaXQgYXMgdHJ1c3RlZCBpbiB0aGUgUnVzdCBzZXNzaW9uIGlmIG5lZWRlZC5cbiAqXG4gKiBCeSBkZWZhdWx0LCBpZiB0aGUgbGVnYWN5IHNlc3Npb24gZGlkbid0IGhhdmUgdGhlIHByaXZhdGUgTVNLLCB0aGUgbWlncmF0ZWQgc2Vzc2lvbiB3aWxsIHJldmVydCB0byB1bnZlcmlmaWVkLFxuICogZXZlbiBpZiB0aGUgdXNlciBoYXMgdmVyaWZpZWQgdGhlIHNlc3Npb24gaW4gdGhlIHBhc3QuXG4gKlxuICogVGhpcyBvbmx5IG9jY3VycyBpZiB0aGUgcHJpdmF0ZSBNU0sgd2FzIG5vdCBjYWNoZWQgaW4gdGhlIGNyeXB0byBzdG9yZSAoVVNLIGFuZCBTU0sgcHJpdmF0ZSBrZXlzIHdvbid0IGhlbHBcbiAqIHRvIGVzdGFibGlzaCB0cnVzdDogdGhlIHRydXN0IGlzIHJvb3RlZCBpbiB0aGUgTVNLKS5cbiAqXG4gKiBSdXN0IGNyeXB0byB3aWxsIG9ubHkgY29uc2lkZXIgdGhlIGN1cnJlbnQgc2Vzc2lvbiBhcyB0cnVzdGVkIGlmIHdlIGltcG9ydCB0aGUgcHJpdmF0ZSBNU0sgaXRzZWxmLlxuICpcbiAqIFdlIGNvdWxkIHByb21wdCB0aGUgdXNlciB0byB2ZXJpZnkgdGhlIHNlc3Npb24gYWdhaW4sIGJ1dCBpdCdzIHByb2JhYmx5IGJldHRlciB0byBqdXN0IG1hcmsgdGhlIHVzZXIgaWRlbnRpdHlcbiAqIGFzIGxvY2FsbHkgdmVyaWZpZWQgaWYgaXQgd2FzIGJlZm9yZS5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsZW1lbnQtaHEvZWxlbWVudC13ZWIvaXNzdWVzLzI3MDc5XG4gKlxuICogQHBhcmFtIGFyZ3MgLSBBcmd1bWVudCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIF9nZXRBbmREZWNyeXB0Q2FjaGVkU2VjcmV0S2V5KCkge1xuICBfZ2V0QW5kRGVjcnlwdENhY2hlZFNlY3JldEtleSA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAobGVnYWN5U3RvcmUsIGxlZ2FjeVBpY2tsZUtleSwgbmFtZSkge1xuICAgIHZhciBrZXkgPSB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxlZ2FjeVN0b3JlLmRvVHhuKFwicmVhZG9ubHlcIiwgW0luZGV4ZWREQkNyeXB0b1N0b3JlLlNUT1JFX0FDQ09VTlRdLCB0eG4gPT4ge1xuICAgICAgICBsZWdhY3lTdG9yZS5nZXRTZWNyZXRTdG9yZVByaXZhdGVLZXkodHhuLCByZXNvbHZlLCBuYW1lKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChrZXkgJiYga2V5LmNpcGhlcnRleHQgJiYga2V5Lml2ICYmIGtleS5tYWMpIHtcbiAgICAgIHJldHVybiB5aWVsZCBkZWNyeXB0QUVTU2VjcmV0U3RvcmFnZUl0ZW0oa2V5LCBsZWdhY3lQaWNrbGVLZXksIG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgLy8gVGhpcyBpcyBhIGxlZ2FjeSBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGNhc2Ugd2hlcmUgdGhlIGtleSB3YXMgc3RvcmVkIGluIGNsZWFyLlxuICAgICAgcmV0dXJuIGVuY29kZUJhc2U2NChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBfZ2V0QW5kRGVjcnlwdENhY2hlZFNlY3JldEtleS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1pZ3JhdGVMZWdhY3lMb2NhbFRydXN0SWZOZWVkZWQoX3gyNykge1xuICByZXR1cm4gX21pZ3JhdGVMZWdhY3lMb2NhbFRydXN0SWZOZWVkZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGxlZ2FjeSBzdG9yZSBoYXMgYSB0cnVzdGVkIHB1YmxpYyBtYXN0ZXIga2V5LCBhbmQgcmV0dXJucyBpdCBpZiBzby5cbiAqXG4gKiBAcGFyYW0gbGVnYWN5U3RvcmUgLSBUaGUgbGVnYWN5IHN0b3JlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm5zIGBudWxsYCBpZiB0aGVyZSB3ZXJlIG5vIGNyb3NzIHNpZ25pbmcga2V5cyBvciBpZiB0aGV5IHdlcmUgbm90IHRydXN0ZWQuIFRoZSB0cnVzdGVkIHB1YmxpYyBtYXN0ZXIga2V5IGlmIGl0IHdhcy5cbiAqL1xuZnVuY3Rpb24gX21pZ3JhdGVMZWdhY3lMb2NhbFRydXN0SWZOZWVkZWQoKSB7XG4gIF9taWdyYXRlTGVnYWN5TG9jYWxUcnVzdElmTmVlZGVkID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qIChhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIGxlZ2FjeUNyeXB0b1N0b3JlLFxuICAgICAgcnVzdENyeXB0byxcbiAgICAgIGxvZ2dlclxuICAgIH0gPSBhcmdzO1xuICAgIC8vIEdldCB0aGUgcHVibGljIGNyb3NzLXNpZ25pbmcgaWRlbnRpdHkgZnJvbSBydXN0LlxuICAgIHZhciBydXN0T3duSWRlbnRpdHkgPSB5aWVsZCBydXN0Q3J5cHRvLmdldE93bklkZW50aXR5KCk7XG4gICAgaWYgKCFydXN0T3duSWRlbnRpdHkpIHtcbiAgICAgIC8vIFRoZXJlIGFyZSBubyBjcm9zcy1zaWduaW5nIGtleXMgcHVibGlzaGVkIHNlcnZlciBzaWRlLCBzbyBub3RoaW5nIHRvIGRvIGhlcmUuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChydXN0T3duSWRlbnRpdHkuaXNWZXJpZmllZCgpKSB7XG4gICAgICAvLyBUaGUgcnVzdCBzZXNzaW9uIGFscmVhZHkgdHJ1c3RzIHRoZSBrZXlzLCBzbyBhZ2Fpbiwgbm90aGluZyB0byBkby5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxlZ2FjeUxvY2FsbHlUcnVzdGVkTVNLID0geWllbGQgZ2V0TGVnYWN5VHJ1c3RlZFB1YmxpY01hc3RlcktleUJhc2U2NChsZWdhY3lDcnlwdG9TdG9yZSk7XG4gICAgaWYgKCFsZWdhY3lMb2NhbGx5VHJ1c3RlZE1TSykge1xuICAgICAgLy8gVGhlIHVzZXIgbmV2ZXIgdmVyaWZpZWQgdGhlaXIgaWRlbnRpdHkgaW4gdGhlIGxlZ2FjeSBzZXNzaW9uLCBzbyBub3RoaW5nIHRvIGRvLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbXNrSW5mbyA9IEpTT04ucGFyc2UocnVzdE93bklkZW50aXR5Lm1hc3RlcktleSk7XG4gICAgaWYgKCFtc2tJbmZvLmtleXMgfHwgT2JqZWN0LmtleXMobXNrSW5mby5rZXlzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4sIGJ1dCBsZXQncyBiZSBzYWZlXG4gICAgICBsb2dnZXIuZXJyb3IoXCJQb3N0IE1pZ3JhdGlvbiB8IFVuZXhwZWN0ZWQgZXJyb3I6IG5vIG1hc3RlciBrZXkgaW4gdGhlIHJ1c3Qgc2Vzc2lvbi5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBydXN0U2Vlbk1TSyA9IE9iamVjdC52YWx1ZXMobXNrSW5mby5rZXlzKVswXTtcbiAgICBpZiAocnVzdFNlZW5NU0sgJiYgcnVzdFNlZW5NU0sgPT0gbGVnYWN5TG9jYWxseVRydXN0ZWRNU0spIHtcbiAgICAgIGxvZ2dlci5pbmZvKFwiUG9zdCBNaWdyYXRpb246IE1pZ3JhdGluZyBsZWdhY3kgdHJ1c3RlZCBNU0s6IFwiLmNvbmNhdChsZWdhY3lMb2NhbGx5VHJ1c3RlZE1TSywgXCIgdG8gbG9jYWxseSB2ZXJpZmllZC5cIikpO1xuICAgICAgLy8gTGV0J3MgbWFyayB0aGUgdXNlciBpZGVudGl0eSBhcyBsb2NhbGx5IHZlcmlmaWVkIGFzIHBhcnQgb2YgdGhlIG1pZ3JhdGlvbi5cbiAgICAgIHlpZWxkIHJ1c3RPd25JZGVudGl0eS52ZXJpZnkoKTtcbiAgICAgIC8vIEFzIHdlbGwgYXMgbWFya2luZyB0aGUgTVNLIGFzIHRydXN0ZWQsIGBPbG1NYWNoaW5lLnZlcmlmeWAgcmV0dXJucyBhXG4gICAgICAvLyBgU2lnbmF0dXJlVXBsb2FkUmVxdWVzdGAgd2hpY2ggd2lsbCBwdWJsaXNoIGEgc2lnbmF0dXJlIG9mIHRoZSBNU0sgdXNpbmdcbiAgICAgIC8vIHRoaXMgZGV2aWNlLiBJbiB0aGlzIGNhc2UsIHdlIGlnbm9yZSB0aGUgcmVxdWVzdDogc2luY2UgdGhlIHVzZXIgaGFzbid0XG4gICAgICAvLyBhY3R1YWxseSByZS12ZXJpZmllZCB0aGUgTVNLLCB3ZSBkb24ndCBwdWJsaXNoIGEgbmV3IHNpZ25hdHVyZS4gKGAudmVyaWZ5YFxuICAgICAgLy8gZG9lc24ndCBzdG9yZSB0aGUgc2lnbmF0dXJlLCBhbmQgaWYgd2UgZHJvcCB0aGUgcmVxdWVzdCBoZXJlIGl0IHdvbid0IGJlXG4gICAgICAvLyByZXRyaWVkLilcbiAgICAgIC8vXG4gICAgICAvLyBOb3QgcHVibGlzaGluZyB0aGUgc2lnbmF0dXJlIGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgYmVoYXZpb3VyIG9mXG4gICAgICAvLyBtYXRyaXgtY3J5cHRvLXNkayB3aGVuIHRoZSBwcml2YXRlIGtleSBpcyBpbXBvcnRlZCB2aWFcbiAgICAgIC8vIGBpbXBvcnRDcm9zc1NpZ25pbmdLZXlzYCwgYW5kIHdoZW4gdGhlIGlkZW50aXR5IGlzIHZlcmlmaWVkIHZpYSBpbnRlcmFjdGl2ZVxuICAgICAgLy8gdmVyaWZpY2F0aW9uLlxuICAgICAgLy9cbiAgICAgIC8vIFtBc2lkZTogZGV2aWNlIHNpZ25hdHVyZXMgb24gdGhlIE1TSyBhcmUgbm90IGNvbnNpZGVyZWQgYnkgdGhlIHJ1c3Qtc2RrIHRvXG4gICAgICAvLyBlc3RhYmxpc2ggdGhlIHRydXN0IG9mIHRoZSB1c2VyIGlkZW50aXR5IHNvIGluIGFueSBjYXNlLCB3aGF0IHdlIGFjdHVhbGx5IGRvXG4gICAgICAvLyBoZXJlIGlzIHNvbWV3aGF0IG1vb3QuXVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBfbWlncmF0ZUxlZ2FjeUxvY2FsVHJ1c3RJZk5lZWRlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gZ2V0TGVnYWN5VHJ1c3RlZFB1YmxpY01hc3RlcktleUJhc2U2NChfeDI4KSB7XG4gIHJldHVybiBfZ2V0TGVnYWN5VHJ1c3RlZFB1YmxpY01hc3RlcktleUJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9nZXRMZWdhY3lUcnVzdGVkUHVibGljTWFzdGVyS2V5QmFzZSgpIHtcbiAgX2dldExlZ2FjeVRydXN0ZWRQdWJsaWNNYXN0ZXJLZXlCYXNlID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qIChsZWdhY3lTdG9yZSkge1xuICAgIHZhciBtYXliZVRydXN0ZWRLZXlzID0gbnVsbDtcbiAgICB5aWVsZCBsZWdhY3lTdG9yZS5kb1R4bihcInJlYWRvbmx5XCIsIFwiYWNjb3VudFwiLCB0eG4gPT4ge1xuICAgICAgbGVnYWN5U3RvcmUuZ2V0Q3Jvc3NTaWduaW5nS2V5cyh0eG4sIGtleXMgPT4ge1xuICAgICAgICAvLyBjYW4gYmUgYW4gZW1wdHkgb2JqZWN0IGFmdGVyIHJlc2V0dGluZyBjcm9zcy1zaWduaW5nIGtleXMsIHNlZSBzdG9yZVRydXN0ZWRTZWxmS2V5c1xuICAgICAgICB2YXIgbXNrID0ga2V5cyA9PT0gbnVsbCB8fCBrZXlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBrZXlzLm1hc3RlcjtcbiAgICAgICAgaWYgKG1zayAmJiBPYmplY3Qua2V5cyhtc2sua2V5cykubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAvLyBgbXNrLmtleXNgIGlzIGFuIG9iamVjdCB3aXRoIHsgW2BlZDI1NTE5OiR7cHViS2V5fWBdOiBwdWJLZXkgfVxuICAgICAgICAgIG1heWJlVHJ1c3RlZEtleXMgPSBPYmplY3QudmFsdWVzKG1zay5rZXlzKVswXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1heWJlVHJ1c3RlZEtleXM7XG4gIH0pO1xuICByZXR1cm4gX2dldExlZ2FjeVRydXN0ZWRQdWJsaWNNYXN0ZXJLZXlCYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWJvbG1fbWlncmF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/libolm_migration.js\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/rust-crypto.js":
/*!*******************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/rust-crypto.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RustCrypto: () => (/* binding */ RustCrypto)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var another_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! another-json */ \"./node_modules/another-json/another-json.js\");\n/* harmony import */ var _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @matrix-org/matrix-sdk-crypto-wasm */ \"./node_modules/@matrix-org/matrix-sdk-crypto-wasm/index.mjs\");\n/* harmony import */ var _types_membership_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../@types/membership.js */ \"./node_modules/matrix-js-sdk/lib/@types/membership.js\");\n/* harmony import */ var _models_event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../models/event.js */ \"./node_modules/matrix-js-sdk/lib/models/event.js\");\n/* harmony import */ var _common_crypto_CryptoBackend_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common-crypto/CryptoBackend.js */ \"./node_modules/matrix-js-sdk/lib/common-crypto/CryptoBackend.js\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../logger.js */ \"./node_modules/matrix-js-sdk/lib/logger.js\");\n/* harmony import */ var _http_api_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../http-api/index.js */ \"./node_modules/matrix-js-sdk/lib/http-api/index.js\");\n/* harmony import */ var _RoomEncryptor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./RoomEncryptor.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/RoomEncryptor.js\");\n/* harmony import */ var _OutgoingRequestProcessor_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./OutgoingRequestProcessor.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/OutgoingRequestProcessor.js\");\n/* harmony import */ var _KeyClaimManager_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./KeyClaimManager.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/KeyClaimManager.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/matrix-js-sdk/lib/utils.js\");\n/* harmony import */ var _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../crypto-api/index.js */ \"./node_modules/matrix-js-sdk/lib/crypto-api/index.js\");\n/* harmony import */ var _device_converter_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./device-converter.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/device-converter.js\");\n/* harmony import */ var _secret_storage_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../secret-storage.js */ \"./node_modules/matrix-js-sdk/lib/secret-storage.js\");\n/* harmony import */ var _CrossSigningIdentity_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./CrossSigningIdentity.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/CrossSigningIdentity.js\");\n/* harmony import */ var _secret_storage_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./secret-storage.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/secret-storage.js\");\n/* harmony import */ var _verification_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./verification.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/verification.js\");\n/* harmony import */ var _types_event_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../@types/event.js */ \"./node_modules/matrix-js-sdk/lib/@types/event.js\");\n/* harmony import */ var _models_typed_event_emitter_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../models/typed-event-emitter.js */ \"./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js\");\n/* harmony import */ var _backup_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./backup.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/backup.js\");\n/* harmony import */ var _ReEmitter_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../ReEmitter.js */ \"./node_modules/matrix-js-sdk/lib/ReEmitter.js\");\n/* harmony import */ var _randomstring_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../randomstring.js */ \"./node_modules/matrix-js-sdk/lib/randomstring.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/matrix-js-sdk/lib/errors.js\");\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../base64.js */ \"./node_modules/matrix-js-sdk/lib/base64.js\");\n/* harmony import */ var _OutgoingRequestsManager_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./OutgoingRequestsManager.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/OutgoingRequestsManager.js\");\n/* harmony import */ var _PerSessionKeyBackupDownloader_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./PerSessionKeyBackupDownloader.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/PerSessionKeyBackupDownloader.js\");\n/* harmony import */ var _DehydratedDeviceManager_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./DehydratedDeviceManager.js */ \"./node_modules/matrix-js-sdk/lib/rust-crypto/DehydratedDeviceManager.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../types.js */ \"./node_modules/matrix-js-sdk/lib/types.js\");\n/* harmony import */ var _common_crypto_key_passphrase_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../common-crypto/key-passphrase.js */ \"./node_modules/matrix-js-sdk/lib/common-crypto/key-passphrase.js\");\n\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/*\nCopyright 2022-2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar ALL_VERIFICATION_METHODS = [_types_js__WEBPACK_IMPORTED_MODULE_29__.VerificationMethod.Sas, _types_js__WEBPACK_IMPORTED_MODULE_29__.VerificationMethod.ScanQrCode, _types_js__WEBPACK_IMPORTED_MODULE_29__.VerificationMethod.ShowQrCode, _types_js__WEBPACK_IMPORTED_MODULE_29__.VerificationMethod.Reciprocate];\n/**\n * An implementation of {@link CryptoBackend} using the Rust matrix-sdk-crypto.\n *\n * @internal\n */\nclass RustCrypto extends _models_typed_event_emitter_js__WEBPACK_IMPORTED_MODULE_20__.TypedEventEmitter {\n  constructor(logger, /** The `OlmMachine` from the underlying rust crypto sdk. */\n  olmMachine,\n  /**\n   * Low-level HTTP interface: used to make outgoing requests required by the rust SDK.\n   *\n   * We expect it to set the access token, etc.\n   */\n  http, /** The local user's User ID. */\n  userId, /** The local user's Device ID. */\n  _deviceId, /** Interface to server-side secret storage */\n  secretStorage, /** Crypto callbacks provided by the application */\n  cryptoCallbacks) {\n    super();\n    this.logger = logger;\n    this.olmMachine = olmMachine;\n    this.http = http;\n    this.userId = userId;\n    this.secretStorage = secretStorage;\n    this.cryptoCallbacks = cryptoCallbacks;\n    /**\n     * The number of iterations to use when deriving a recovery key from a passphrase.\n     */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"RECOVERY_KEY_DERIVATION_ITERATIONS\", 500000);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"_trustCrossSignedDevices\", true);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"deviceIsolationMode\", new _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.AllDevicesIsolationMode(false));\n    /** whether {@link stop} has been called */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"stopped\", false);\n    /** mapping of roomId  encryptor class */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"roomEncryptors\", {});\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"eventDecryptor\", void 0);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"keyClaimManager\", void 0);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"outgoingRequestProcessor\", void 0);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"crossSigningIdentity\", void 0);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"backupManager\", void 0);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"outgoingRequestsManager\", void 0);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"perSessionBackupDownloader\", void 0);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"dehydratedDeviceManager\", void 0);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"reemitter\", new _ReEmitter_js__WEBPACK_IMPORTED_MODULE_22__.TypedReEmitter(this));\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // CryptoApi implementation\n    //\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"globalBlacklistUnverifiedDevices\", false);\n    /**\n     * The verification methods we offer to the other side during an interactive verification.\n     */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"_supportedVerificationMethods\", ALL_VERIFICATION_METHODS);\n    this.outgoingRequestProcessor = new _OutgoingRequestProcessor_js__WEBPACK_IMPORTED_MODULE_10__.OutgoingRequestProcessor(olmMachine, http);\n    this.outgoingRequestsManager = new _OutgoingRequestsManager_js__WEBPACK_IMPORTED_MODULE_26__.OutgoingRequestsManager(this.logger, olmMachine, this.outgoingRequestProcessor);\n    this.keyClaimManager = new _KeyClaimManager_js__WEBPACK_IMPORTED_MODULE_11__.KeyClaimManager(olmMachine, this.outgoingRequestProcessor);\n    this.backupManager = new _backup_js__WEBPACK_IMPORTED_MODULE_21__.RustBackupManager(olmMachine, http, this.outgoingRequestProcessor);\n    this.perSessionBackupDownloader = new _PerSessionKeyBackupDownloader_js__WEBPACK_IMPORTED_MODULE_27__.PerSessionKeyBackupDownloader(this.logger, this.olmMachine, this.http, this.backupManager);\n    this.dehydratedDeviceManager = new _DehydratedDeviceManager_js__WEBPACK_IMPORTED_MODULE_28__.DehydratedDeviceManager(this.logger, olmMachine, http, this.outgoingRequestProcessor, secretStorage);\n    this.eventDecryptor = new EventDecryptor(this.logger, olmMachine, this.perSessionBackupDownloader);\n\n    // re-emit the events emitted by managers\n    this.reemitter.reEmit(this.backupManager, [_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.KeyBackupStatus, _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.KeyBackupSessionsRemaining, _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.KeyBackupFailed, _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.KeyBackupDecryptionKeyCached]);\n    this.reemitter.reEmit(this.dehydratedDeviceManager, [_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.DehydratedDeviceCreated, _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.DehydratedDeviceUploaded, _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.RehydrationStarted, _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.RehydrationProgress, _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.RehydrationCompleted, _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.RehydrationError, _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.DehydrationKeyCached, _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.DehydratedDeviceRotationError]);\n    this.crossSigningIdentity = new _CrossSigningIdentity_js__WEBPACK_IMPORTED_MODULE_16__.CrossSigningIdentity(olmMachine, this.outgoingRequestProcessor, secretStorage);\n\n    // Check and start in background the key backup connection\n    this.checkKeyBackupAndEnable();\n  }\n\n  /**\n   * Return the OlmMachine only if {@link RustCrypto#stop} has not been called.\n   *\n   * This allows us to better handle race conditions where the client is stopped before or during a crypto API call.\n   *\n   * @throws ClientStoppedError if {@link RustCrypto#stop} has been called.\n   */\n  getOlmMachineOrThrow() {\n    if (this.stopped) {\n      throw new _errors_js__WEBPACK_IMPORTED_MODULE_24__.ClientStoppedError();\n    }\n    return this.olmMachine;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  //\n  // CryptoBackend implementation\n  //\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  set globalErrorOnUnknownDevices(_v) {\n    // Not implemented for rust crypto.\n  }\n  get globalErrorOnUnknownDevices() {\n    // Not implemented for rust crypto.\n    return false;\n  }\n  stop() {\n    // stop() may be called multiple times, but attempting to close() the OlmMachine twice\n    // will cause an error.\n    if (this.stopped) {\n      return;\n    }\n    this.stopped = true;\n    this.keyClaimManager.stop();\n    this.backupManager.stop();\n    this.outgoingRequestsManager.stop();\n    this.perSessionBackupDownloader.stop();\n    this.dehydratedDeviceManager.stop();\n\n    // make sure we close() the OlmMachine; doing so means that all the Rust objects will be\n    // cleaned up; in particular, the indexeddb connections will be closed, which means they\n    // can then be deleted.\n    this.olmMachine.close();\n  }\n  encryptEvent(event, _room) {\n    var _this = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var roomId = event.getRoomId();\n      var encryptor = _this.roomEncryptors[roomId];\n      if (!encryptor) {\n        throw new Error(\"Cannot encrypt event in unconfigured room \".concat(roomId));\n      }\n      yield encryptor.encryptEvent(event, _this.globalBlacklistUnverifiedDevices, _this.deviceIsolationMode);\n    })();\n  }\n  decryptEvent(event) {\n    var _this2 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var roomId = event.getRoomId();\n      if (!roomId) {\n        // presumably, a to-device message. These are normally decrypted in preprocessToDeviceMessages\n        // so the fact it has come back here suggests that decryption failed.\n        //\n        // once we drop support for the libolm crypto implementation, we can stop passing to-device messages\n        // through decryptEvent and hence get rid of this case.\n        throw new Error(\"to-device event was not decrypted in preprocessToDeviceMessages\");\n      }\n      return yield _this2.eventDecryptor.attemptEventDecryption(event, _this2.deviceIsolationMode);\n    })();\n  }\n\n  /**\n   * Implementation of (deprecated) {@link MatrixClient#getEventEncryptionInfo}.\n   *\n   * @param event - event to inspect\n   */\n  getEventEncryptionInfo(event) {\n    var _event$getSenderKey;\n    var ret = {};\n    ret.senderKey = (_event$getSenderKey = event.getSenderKey()) !== null && _event$getSenderKey !== void 0 ? _event$getSenderKey : undefined;\n    ret.algorithm = event.getWireContent().algorithm;\n    if (!ret.senderKey || !ret.algorithm) {\n      ret.encrypted = false;\n      return ret;\n    }\n    ret.encrypted = true;\n    ret.authenticated = true;\n    ret.mismatchedSender = true;\n    return ret;\n  }\n\n  /**\n   * Implementation of {@link CryptoBackend#checkUserTrust}.\n   *\n   * Stub for backwards compatibility.\n   *\n   */\n  checkUserTrust(userId) {\n    return new _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.UserVerificationStatus(false, false, false);\n  }\n\n  /**\n   * Get the cross signing information for a given user.\n   *\n   * The cross-signing API is currently UNSTABLE and may change without notice.\n   *\n   * @param userId - the user ID to get the cross-signing info for.\n   *\n   * @returns the cross signing information for the user.\n   */\n  getStoredCrossSigningForUser(userId) {\n    // TODO\n    return null;\n  }\n\n  /**\n   * This function is unneeded for the rust-crypto.\n   * The cross signing key import and the device verification are done in {@link CryptoApi#bootstrapCrossSigning}\n   *\n   * The function is stub to keep the compatibility with the old crypto.\n   * More information: https://github.com/vector-im/element-web/issues/25648\n   *\n   * Implementation of {@link CryptoBackend#checkOwnCrossSigningTrust}\n   */\n  checkOwnCrossSigningTrust() {\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return;\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoBackend#getBackupDecryptor}.\n   */\n  getBackupDecryptor(backupInfo, privKey) {\n    var _this3 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      if (!(privKey instanceof Uint8Array)) {\n        throw new Error(\"getBackupDecryptor: expects Uint8Array\");\n      }\n      if (backupInfo.algorithm != \"m.megolm_backup.v1.curve25519-aes-sha2\") {\n        throw new Error(\"getBackupDecryptor: Unsupported algorithm \".concat(backupInfo.algorithm));\n      }\n      var backupDecryptionKey = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.BackupDecryptionKey.fromBase64((0,_base64_js__WEBPACK_IMPORTED_MODULE_25__.encodeBase64)(privKey));\n      if (!(0,_backup_js__WEBPACK_IMPORTED_MODULE_21__.decryptionKeyMatchesKeyBackupInfo)(backupDecryptionKey, backupInfo)) {\n        throw new Error(\"getBackupDecryptor: key backup on server does not match the decryption key\");\n      }\n      return _this3.backupManager.createBackupDecryptor(backupDecryptionKey);\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoBackend#importBackedUpRoomKeys}.\n   */\n  importBackedUpRoomKeys(keys, backupVersion, opts) {\n    var _this4 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return yield _this4.backupManager.importBackedUpRoomKeys(keys, backupVersion, opts);\n    })();\n  }\n  /**\n   * Implementation of {@link CryptoApi#getVersion}.\n   */\n  getVersion() {\n    var versions = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.getVersions();\n    return \"Rust SDK \".concat(versions.matrix_sdk_crypto, \" (\").concat(versions.git_sha, \"), Vodozemac \").concat(versions.vodozemac);\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#setDeviceIsolationMode}.\n   */\n  setDeviceIsolationMode(isolationMode) {\n    this.deviceIsolationMode = isolationMode;\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#isEncryptionEnabledInRoom}.\n   */\n  isEncryptionEnabledInRoom(roomId) {\n    var _this5 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var roomSettings = yield _this5.olmMachine.getRoomSettings(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.RoomId(roomId));\n      return Boolean(roomSettings === null || roomSettings === void 0 ? void 0 : roomSettings.algorithm);\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#getOwnDeviceKeys}.\n   */\n  getOwnDeviceKeys() {\n    var _this6 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var keys = _this6.olmMachine.identityKeys;\n      return {\n        ed25519: keys.ed25519.toBase64(),\n        curve25519: keys.curve25519.toBase64()\n      };\n    })();\n  }\n  prepareToEncrypt(room) {\n    var encryptor = this.roomEncryptors[room.roomId];\n    if (encryptor) {\n      encryptor.prepareForEncryption(this.globalBlacklistUnverifiedDevices, this.deviceIsolationMode);\n    }\n  }\n  forceDiscardSession(roomId) {\n    var _this$roomEncryptors$;\n    return (_this$roomEncryptors$ = this.roomEncryptors[roomId]) === null || _this$roomEncryptors$ === void 0 ? void 0 : _this$roomEncryptors$.forceDiscardSession();\n  }\n  exportRoomKeys() {\n    var _this7 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var raw = yield _this7.olmMachine.exportRoomKeys(() => true);\n      return JSON.parse(raw);\n    })();\n  }\n  exportRoomKeysAsJson() {\n    var _this8 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return yield _this8.olmMachine.exportRoomKeys(() => true);\n    })();\n  }\n  importRoomKeys(keys, opts) {\n    var _this9 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return yield _this9.backupManager.importRoomKeys(keys, opts);\n    })();\n  }\n  importRoomKeysAsJson(keys, opts) {\n    var _this10 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return yield _this10.backupManager.importRoomKeysAsJson(keys, opts);\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi.userHasCrossSigningKeys}.\n   */\n  userHasCrossSigningKeys() {\n    var _arguments = arguments,\n      _this11 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var userId = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : _this11.userId;\n      var downloadUncached = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : false;\n      // TODO: could probably do with a more efficient way of doing this than returning the whole set and searching\n      var rustTrackedUsers = yield _this11.olmMachine.trackedUsers();\n      var rustTrackedUser;\n      for (var u of rustTrackedUsers) {\n        if (userId === u.toString()) {\n          rustTrackedUser = u;\n          break;\n        }\n      }\n      if (rustTrackedUser !== undefined) {\n        if (userId === _this11.userId) {\n          /* make sure we have an *up-to-date* idea of the user's cross-signing keys. This is important, because if we\n           * return \"false\" here, we will end up generating new cross-signing keys and replacing the existing ones.\n           */\n          var request = _this11.olmMachine.queryKeysForUsers(\n          // clone as rust layer will take ownership and it's reused later\n          [rustTrackedUser.clone()]);\n          yield _this11.outgoingRequestProcessor.makeOutgoingRequest(request);\n        }\n        var userIdentity = yield _this11.olmMachine.getIdentity(rustTrackedUser);\n        userIdentity === null || userIdentity === void 0 || userIdentity.free();\n        return userIdentity !== undefined;\n      } else if (downloadUncached) {\n        var _keyResult$master_key;\n        // Download the cross signing keys and check if the master key is available\n        var keyResult = yield _this11.downloadDeviceList(new Set([userId]));\n        var keys = (_keyResult$master_key = keyResult.master_keys) === null || _keyResult$master_key === void 0 ? void 0 : _keyResult$master_key[userId];\n\n        // No master key\n        if (!keys) return false;\n\n        // `keys` is an object with { [`ed25519:${pubKey}`]: pubKey }\n        // We assume only a single key, and we want the bare form without type\n        // prefix, so we select the values.\n        return Boolean(Object.values(keys.keys)[0]);\n      } else {\n        return false;\n      }\n    })();\n  }\n\n  /**\n   * Get the device information for the given list of users.\n   *\n   * @param userIds - The users to fetch.\n   * @param downloadUncached - If true, download the device list for users whose device list we are not\n   *    currently tracking. Defaults to false, in which case such users will not appear at all in the result map.\n   *\n   * @returns A map `{@link DeviceMap}`.\n   */\n  getUserDeviceInfo(userIds) {\n    var _arguments2 = arguments,\n      _this12 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var downloadUncached = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : false;\n      var deviceMapByUserId = new Map();\n      var rustTrackedUsers = yield _this12.getOlmMachineOrThrow().trackedUsers();\n\n      // Convert RustSdkCryptoJs.UserId to a `Set<string>`\n      var trackedUsers = new Set();\n      rustTrackedUsers.forEach(rustUserId => trackedUsers.add(rustUserId.toString()));\n\n      // Keep untracked user to download their keys after\n      var untrackedUsers = new Set();\n      for (var _userId of userIds) {\n        // if this is a tracked user, we can just fetch the device list from the rust-sdk\n        // (NB: this is probably ok even if we race with a leave event such that we stop tracking the user's\n        // devices: the rust-sdk will return the last-known device list, which will be good enough.)\n        if (trackedUsers.has(_userId)) {\n          deviceMapByUserId.set(_userId, yield _this12.getUserDevices(_userId));\n        } else {\n          untrackedUsers.add(_userId);\n        }\n      }\n\n      // for any users whose device lists we are not tracking, fall back to downloading the device list\n      // over HTTP.\n      if (downloadUncached && untrackedUsers.size >= 1) {\n        var queryResult = yield _this12.downloadDeviceList(untrackedUsers);\n        Object.entries(queryResult.device_keys).forEach(_ref => {\n          var [userId, deviceKeys] = _ref;\n          return deviceMapByUserId.set(userId, (0,_device_converter_js__WEBPACK_IMPORTED_MODULE_14__.deviceKeysToDeviceMap)(deviceKeys));\n        });\n      }\n      return deviceMapByUserId;\n    })();\n  }\n\n  /**\n   * Get the device list for the given user from the olm machine\n   * @param userId - Rust SDK UserId\n   */\n  getUserDevices(userId) {\n    var _this13 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var rustUserId = new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId);\n\n      // For reasons I don't really understand, the Javascript FinalizationRegistry doesn't seem to run the\n      // registered callbacks when `userDevices` goes out of scope, nor when the individual devices in the array\n      // returned by `userDevices.devices` do so.\n      //\n      // This is particularly problematic, because each of those structures holds a reference to the\n      // VerificationMachine, which in turn holds a reference to the IndexeddbCryptoStore. Hence, we end up leaking\n      // open connections to the crypto store, which means the store can't be deleted on logout.\n      //\n      // To fix this, we explicitly call `.free` on each of the objects, which tells the rust code to drop the\n      // allocated memory and decrement the refcounts for the crypto store.\n\n      // Wait for up to a second for any in-flight device list requests to complete.\n      // The reason for this isn't so much to avoid races (some level of raciness is\n      // inevitable for this method) but to make testing easier.\n      var userDevices = yield _this13.olmMachine.getUserDevices(rustUserId, 1);\n      try {\n        var deviceArray = userDevices.devices();\n        try {\n          return new Map(deviceArray.map(device => [device.deviceId.toString(), (0,_device_converter_js__WEBPACK_IMPORTED_MODULE_14__.rustDeviceToJsDevice)(device, rustUserId)]));\n        } finally {\n          deviceArray.forEach(d => d.free());\n        }\n      } finally {\n        userDevices.free();\n      }\n    })();\n  }\n\n  /**\n   * Download the given user keys by calling `/keys/query` request\n   * @param untrackedUsers - download keys of these users\n   */\n  downloadDeviceList(untrackedUsers) {\n    var _this14 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var queryBody = {\n        device_keys: {}\n      };\n      untrackedUsers.forEach(user => queryBody.device_keys[user] = []);\n      return yield _this14.http.authedRequest(_http_api_index_js__WEBPACK_IMPORTED_MODULE_8__.Method.Post, \"/_matrix/client/v3/keys/query\", undefined, queryBody, {\n        prefix: \"\"\n      });\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#getTrustCrossSignedDevices}.\n   */\n  getTrustCrossSignedDevices() {\n    return this._trustCrossSignedDevices;\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#setTrustCrossSignedDevices}.\n   */\n  setTrustCrossSignedDevices(val) {\n    this._trustCrossSignedDevices = val;\n    // TODO: legacy crypto goes through the list of known devices and emits DeviceVerificationChanged\n    //  events. Maybe we need to do the same?\n  }\n\n  /**\n   * Mark the given device as locally verified.\n   *\n   * Implementation of {@link CryptoApi#setDeviceVerified}.\n   */\n  setDeviceVerified(userId, deviceId) {\n    var _arguments3 = arguments,\n      _this15 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var verified = _arguments3.length > 2 && _arguments3[2] !== undefined ? _arguments3[2] : true;\n      var device = yield _this15.olmMachine.getDevice(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId), new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DeviceId(deviceId));\n      if (!device) {\n        throw new Error(\"Unknown device \".concat(userId, \"|\").concat(deviceId));\n      }\n      try {\n        yield device.setLocalTrust(verified ? _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.LocalTrust.Verified : _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.LocalTrust.Unset);\n      } finally {\n        device.free();\n      }\n    })();\n  }\n\n  /**\n   * Blindly cross-sign one of our other devices.\n   *\n   * Implementation of {@link CryptoApi#crossSignDevice}.\n   */\n  crossSignDevice(deviceId) {\n    var _this16 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var device = yield _this16.olmMachine.getDevice(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(_this16.userId), new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DeviceId(deviceId));\n      if (!device) {\n        throw new Error(\"Unknown device \".concat(deviceId));\n      }\n      try {\n        var outgoingRequest = yield device.verify();\n        yield _this16.outgoingRequestProcessor.makeOutgoingRequest(outgoingRequest);\n      } finally {\n        device.free();\n      }\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#getDeviceVerificationStatus}.\n   */\n  getDeviceVerificationStatus(userId, deviceId) {\n    var _this17 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var device = yield _this17.olmMachine.getDevice(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId), new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DeviceId(deviceId));\n      if (!device) return null;\n      try {\n        return new _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DeviceVerificationStatus({\n          signedByOwner: device.isCrossSignedByOwner(),\n          crossSigningVerified: device.isCrossSigningTrusted(),\n          localVerified: device.isLocallyTrusted(),\n          trustCrossSignedDevices: _this17._trustCrossSignedDevices\n        });\n      } finally {\n        device.free();\n      }\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#getUserVerificationStatus}.\n   */\n  getUserVerificationStatus(userId) {\n    var _this18 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var userIdentity = yield _this18.getOlmMachineOrThrow().getIdentity(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId));\n      if (userIdentity === undefined) {\n        return new _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.UserVerificationStatus(false, false, false);\n      }\n      var verified = userIdentity.isVerified();\n      var wasVerified = userIdentity.wasPreviouslyVerified();\n      var needsUserApproval = userIdentity instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.OtherUserIdentity ? userIdentity.identityNeedsUserApproval() : false;\n      userIdentity.free();\n      return new _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.UserVerificationStatus(verified, wasVerified, false, needsUserApproval);\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#pinCurrentUserIdentity}.\n   */\n  pinCurrentUserIdentity(userId) {\n    var _this19 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var userIdentity = yield _this19.getOlmMachineOrThrow().getIdentity(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId));\n      if (userIdentity === undefined) {\n        throw new Error(\"Cannot pin identity of unknown user\");\n      }\n      if (userIdentity instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.OwnUserIdentity) {\n        throw new Error(\"Cannot pin identity of own user\");\n      }\n      yield userIdentity.pinCurrentMasterKey();\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#withdrawVerificationRequirement}.\n   */\n  withdrawVerificationRequirement(userId) {\n    var _this20 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var userIdentity = yield _this20.getOlmMachineOrThrow().getIdentity(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId));\n      if (userIdentity === undefined) {\n        throw new Error(\"Cannot withdraw verification of unknown user\");\n      }\n      yield userIdentity.withdrawVerification();\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#isCrossSigningReady}\n   */\n  isCrossSigningReady() {\n    var _this21 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var {\n        privateKeysInSecretStorage,\n        privateKeysCachedLocally\n      } = yield _this21.getCrossSigningStatus();\n      var hasKeysInCache = Boolean(privateKeysCachedLocally.masterKey) && Boolean(privateKeysCachedLocally.selfSigningKey) && Boolean(privateKeysCachedLocally.userSigningKey);\n      var identity = yield _this21.getOwnIdentity();\n\n      // Cross-signing is ready if the public identity is trusted, and the private keys\n      // are either cached, or accessible via secret-storage.\n      return !!(identity !== null && identity !== void 0 && identity.isVerified()) && (hasKeysInCache || privateKeysInSecretStorage);\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#getCrossSigningKeyId}\n   */\n  getCrossSigningKeyId() {\n    var _arguments4 = arguments,\n      _this22 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var type = _arguments4.length > 0 && _arguments4[0] !== undefined ? _arguments4[0] : _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CrossSigningKey.Master;\n      var userIdentity = yield _this22.olmMachine.getIdentity(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(_this22.userId));\n      if (!userIdentity) {\n        // The public keys are not available on this device\n        return null;\n      }\n      try {\n        var crossSigningStatus = yield _this22.olmMachine.crossSigningStatus();\n        var privateKeysOnDevice = crossSigningStatus.hasMaster && crossSigningStatus.hasUserSigning && crossSigningStatus.hasSelfSigning;\n        if (!privateKeysOnDevice) {\n          // The private keys are not available on this device\n          return null;\n        }\n        if (!userIdentity.isVerified()) {\n          // We have both public and private keys, but they don't match!\n          return null;\n        }\n        var key;\n        switch (type) {\n          case _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CrossSigningKey.Master:\n            key = userIdentity.masterKey;\n            break;\n          case _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CrossSigningKey.SelfSigning:\n            key = userIdentity.selfSigningKey;\n            break;\n          case _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CrossSigningKey.UserSigning:\n            key = userIdentity.userSigningKey;\n            break;\n          default:\n            // Unknown type\n            return null;\n        }\n        var parsedKey = JSON.parse(key);\n        // `keys` is an object with { [`ed25519:${pubKey}`]: pubKey }\n        // We assume only a single key, and we want the bare form without type\n        // prefix, so we select the values.\n        return Object.values(parsedKey.keys)[0];\n      } finally {\n        userIdentity.free();\n      }\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#bootstrapCrossSigning}\n   */\n  bootstrapCrossSigning(opts) {\n    var _this23 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      yield _this23.crossSigningIdentity.bootstrapCrossSigning(opts);\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#isSecretStorageReady}\n   */\n  isSecretStorageReady() {\n    var _this24 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // make sure that the cross-signing keys are stored\n      var secretsToCheck = [\"m.cross_signing.master\", \"m.cross_signing.user_signing\", \"m.cross_signing.self_signing\"];\n\n      // if key backup is active, we also need to check that the backup decryption key is stored\n      var keyBackupEnabled = (yield _this24.backupManager.getActiveBackupVersion()) != null;\n      if (keyBackupEnabled) {\n        secretsToCheck.push(\"m.megolm_backup.v1\");\n      }\n      return (0,_secret_storage_js__WEBPACK_IMPORTED_MODULE_17__.secretStorageCanAccessSecrets)(_this24.secretStorage, secretsToCheck);\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#bootstrapSecretStorage}\n   */\n  bootstrapSecretStorage() {\n    var _arguments5 = arguments,\n      _this25 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var {\n        createSecretStorageKey,\n        setupNewSecretStorage,\n        setupNewKeyBackup\n      } = _arguments5.length > 0 && _arguments5[0] !== undefined ? _arguments5[0] : {};\n      // If an AES Key is already stored in the secret storage and setupNewSecretStorage is not set\n      // we don't want to create a new key\n      var isNewSecretStorageKeyNeeded = setupNewSecretStorage || !(yield _this25.secretStorageHasAESKey());\n      if (isNewSecretStorageKeyNeeded) {\n        if (!createSecretStorageKey) {\n          throw new Error(\"unable to create a new secret storage key, createSecretStorageKey is not set\");\n        }\n\n        // Create a new storage key and add it to secret storage\n        _this25.logger.info(\"bootstrapSecretStorage: creating new secret storage key\");\n        var recoveryKey = yield createSecretStorageKey();\n        if (!recoveryKey) {\n          throw new Error(\"createSecretStorageKey() callback did not return a secret storage key\");\n        }\n        yield _this25.addSecretStorageKeyToSecretStorage(recoveryKey);\n      }\n      var crossSigningStatus = yield _this25.olmMachine.crossSigningStatus();\n      var hasPrivateKeys = crossSigningStatus.hasMaster && crossSigningStatus.hasSelfSigning && crossSigningStatus.hasUserSigning;\n\n      // If we have cross-signing private keys cached, store them in secret\n      // storage if they are not there already.\n      if (hasPrivateKeys && (isNewSecretStorageKeyNeeded || !(yield (0,_secret_storage_js__WEBPACK_IMPORTED_MODULE_17__.secretStorageContainsCrossSigningKeys)(_this25.secretStorage)))) {\n        _this25.logger.info(\"bootstrapSecretStorage: cross-signing keys not yet exported; doing so now.\");\n        var crossSigningPrivateKeys = yield _this25.olmMachine.exportCrossSigningKeys();\n        if (!crossSigningPrivateKeys.masterKey) {\n          throw new Error(\"missing master key in cross signing private keys\");\n        }\n        if (!crossSigningPrivateKeys.userSigningKey) {\n          throw new Error(\"missing user signing key in cross signing private keys\");\n        }\n        if (!crossSigningPrivateKeys.self_signing_key) {\n          throw new Error(\"missing self signing key in cross signing private keys\");\n        }\n        yield _this25.secretStorage.store(\"m.cross_signing.master\", crossSigningPrivateKeys.masterKey);\n        yield _this25.secretStorage.store(\"m.cross_signing.user_signing\", crossSigningPrivateKeys.userSigningKey);\n        yield _this25.secretStorage.store(\"m.cross_signing.self_signing\", crossSigningPrivateKeys.self_signing_key);\n      }\n\n      // likewise with the key backup key: if we have one, store it in secret storage (if it's not already there)\n      // also don't bother storing it if we're about to set up a new backup\n      if (!setupNewKeyBackup) {\n        yield _this25.saveBackupKeyToStorage();\n      } else {\n        yield _this25.resetKeyBackup();\n      }\n    })();\n  }\n\n  /**\n   * If we have a backup key for the current, trusted backup in cache,\n   * save it to secret storage.\n   */\n  saveBackupKeyToStorage() {\n    var _this26 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var keyBackupInfo = yield _this26.backupManager.getServerBackupInfo();\n      if (!keyBackupInfo || !keyBackupInfo.version) {\n        _logger_js__WEBPACK_IMPORTED_MODULE_7__.logger.info(\"Not saving backup key to secret storage: no backup info\");\n        return;\n      }\n      var backupKeys = yield _this26.olmMachine.getBackupKeys();\n      if (!backupKeys.decryptionKey) {\n        _logger_js__WEBPACK_IMPORTED_MODULE_7__.logger.info(\"Not saving backup key to secret storage: no backup key\");\n        return;\n      }\n      if (!(0,_backup_js__WEBPACK_IMPORTED_MODULE_21__.decryptionKeyMatchesKeyBackupInfo)(backupKeys.decryptionKey, keyBackupInfo)) {\n        _logger_js__WEBPACK_IMPORTED_MODULE_7__.logger.info(\"Not saving backup key to secret storage: decryption key does not match backup info\");\n        return;\n      }\n      var backupKeyBase64 = backupKeys.decryptionKey.toBase64();\n      yield _this26.secretStorage.store(\"m.megolm_backup.v1\", backupKeyBase64);\n    })();\n  }\n\n  /**\n   * Add the secretStorage key to the secret storage\n   * - The secret storage key must have the `keyInfo` field filled\n   * - The secret storage key is set as the default key of the secret storage\n   * - Call `cryptoCallbacks.cacheSecretStorageKey` when done\n   *\n   * @param secretStorageKey - The secret storage key to add in the secret storage.\n   */\n  addSecretStorageKeyToSecretStorage(secretStorageKey) {\n    var _this27 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var _secretStorageKey$key, _secretStorageKey$key2, _this27$cryptoCallbac, _this27$cryptoCallbac2;\n      var secretStorageKeyObject = yield _this27.secretStorage.addKey(_secret_storage_js__WEBPACK_IMPORTED_MODULE_15__.SECRET_STORAGE_ALGORITHM_V1_AES, {\n        passphrase: (_secretStorageKey$key = secretStorageKey.keyInfo) === null || _secretStorageKey$key === void 0 ? void 0 : _secretStorageKey$key.passphrase,\n        name: (_secretStorageKey$key2 = secretStorageKey.keyInfo) === null || _secretStorageKey$key2 === void 0 ? void 0 : _secretStorageKey$key2.name,\n        key: secretStorageKey.privateKey\n      });\n      yield _this27.secretStorage.setDefaultKeyId(secretStorageKeyObject.keyId);\n      (_this27$cryptoCallbac = (_this27$cryptoCallbac2 = _this27.cryptoCallbacks).cacheSecretStorageKey) === null || _this27$cryptoCallbac === void 0 || _this27$cryptoCallbac.call(_this27$cryptoCallbac2, secretStorageKeyObject.keyId, secretStorageKeyObject.keyInfo, secretStorageKey.privateKey);\n    })();\n  }\n\n  /**\n   * Check if a secret storage AES Key is already added in secret storage\n   *\n   * @returns True if an AES key is in the secret storage\n   */\n  secretStorageHasAESKey() {\n    var _this28 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // See if we already have an AES secret-storage key.\n      var secretStorageKeyTuple = yield _this28.secretStorage.getKey();\n      if (!secretStorageKeyTuple) return false;\n      var [, keyInfo] = secretStorageKeyTuple;\n\n      // Check if the key is an AES key\n      return keyInfo.algorithm === _secret_storage_js__WEBPACK_IMPORTED_MODULE_15__.SECRET_STORAGE_ALGORITHM_V1_AES;\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#getCrossSigningStatus}\n   */\n  getCrossSigningStatus() {\n    var _this29 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var userIdentity = yield _this29.getOlmMachineOrThrow().getIdentity(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(_this29.userId));\n      var publicKeysOnDevice = Boolean(userIdentity === null || userIdentity === void 0 ? void 0 : userIdentity.masterKey) && Boolean(userIdentity === null || userIdentity === void 0 ? void 0 : userIdentity.selfSigningKey) && Boolean(userIdentity === null || userIdentity === void 0 ? void 0 : userIdentity.userSigningKey);\n      userIdentity === null || userIdentity === void 0 || userIdentity.free();\n      var privateKeysInSecretStorage = yield (0,_secret_storage_js__WEBPACK_IMPORTED_MODULE_17__.secretStorageContainsCrossSigningKeys)(_this29.secretStorage);\n      var crossSigningStatus = yield _this29.getOlmMachineOrThrow().crossSigningStatus();\n      return {\n        publicKeysOnDevice,\n        privateKeysInSecretStorage,\n        privateKeysCachedLocally: {\n          masterKey: Boolean(crossSigningStatus === null || crossSigningStatus === void 0 ? void 0 : crossSigningStatus.hasMaster),\n          userSigningKey: Boolean(crossSigningStatus === null || crossSigningStatus === void 0 ? void 0 : crossSigningStatus.hasUserSigning),\n          selfSigningKey: Boolean(crossSigningStatus === null || crossSigningStatus === void 0 ? void 0 : crossSigningStatus.hasSelfSigning)\n        }\n      };\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#createRecoveryKeyFromPassphrase}\n   */\n  createRecoveryKeyFromPassphrase(password) {\n    var _this30 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      if (password) {\n        // Generate the key from the passphrase\n        // first we generate a random salt\n        var salt = (0,_randomstring_js__WEBPACK_IMPORTED_MODULE_23__.secureRandomString)(32);\n        // then we derive the key from the passphrase\n        var recoveryKey = yield (0,_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.deriveRecoveryKeyFromPassphrase)(password, salt, _this30.RECOVERY_KEY_DERIVATION_ITERATIONS);\n        return {\n          keyInfo: {\n            passphrase: {\n              algorithm: \"m.pbkdf2\",\n              iterations: _this30.RECOVERY_KEY_DERIVATION_ITERATIONS,\n              salt\n            }\n          },\n          privateKey: recoveryKey,\n          encodedPrivateKey: (0,_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.encodeRecoveryKey)(recoveryKey)\n        };\n      } else {\n        // Using the navigator crypto API to generate the private key\n        var key = new Uint8Array(32);\n        globalThis.crypto.getRandomValues(key);\n        return {\n          privateKey: key,\n          encodedPrivateKey: (0,_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.encodeRecoveryKey)(key)\n        };\n      }\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#getEncryptionInfoForEvent}.\n   */\n  getEncryptionInfoForEvent(event) {\n    var _this31 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return _this31.eventDecryptor.getEncryptionInfoForEvent(event);\n    })();\n  }\n\n  /**\n   * Returns to-device verification requests that are already in progress for the given user id.\n   *\n   * Implementation of {@link CryptoApi#getVerificationRequestsToDeviceInProgress}\n   *\n   * @param userId - the ID of the user to query\n   *\n   * @returns the VerificationRequests that are in progress\n   */\n  getVerificationRequestsToDeviceInProgress(userId) {\n    var requests = this.olmMachine.getVerificationRequests(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId));\n    return requests.filter(request => request.roomId === undefined).map(request => new _verification_js__WEBPACK_IMPORTED_MODULE_18__.RustVerificationRequest(this.olmMachine, request, this.outgoingRequestProcessor, this._supportedVerificationMethods));\n  }\n\n  /**\n   * Finds a DM verification request that is already in progress for the given room id\n   *\n   * Implementation of {@link CryptoApi#findVerificationRequestDMInProgress}\n   *\n   * @param roomId - the room to use for verification\n   * @param userId - search the verification request for the given user\n   *\n   * @returns the VerificationRequest that is in progress, if any\n   *\n   */\n  findVerificationRequestDMInProgress(roomId, userId) {\n    if (!userId) throw new Error(\"missing userId\");\n    var requests = this.olmMachine.getVerificationRequests(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId));\n\n    // Search for the verification request for the given room id\n    var request = requests.find(request => {\n      var _request$roomId;\n      return ((_request$roomId = request.roomId) === null || _request$roomId === void 0 ? void 0 : _request$roomId.toString()) === roomId;\n    });\n    if (request) {\n      return new _verification_js__WEBPACK_IMPORTED_MODULE_18__.RustVerificationRequest(this.olmMachine, request, this.outgoingRequestProcessor, this._supportedVerificationMethods);\n    }\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#requestVerificationDM}\n   */\n  requestVerificationDM(userId, roomId) {\n    var _this32 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var userIdentity = yield _this32.olmMachine.getIdentity(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId));\n      if (!userIdentity) throw new Error(\"unknown userId \".concat(userId));\n      try {\n        // Transform the verification methods into rust objects\n        var methods = _this32._supportedVerificationMethods.map(method => (0,_verification_js__WEBPACK_IMPORTED_MODULE_18__.verificationMethodIdentifierToMethod)(method));\n        // Get the request content to send to the DM room\n        var verificationEventContent = yield userIdentity.verificationRequestContent(methods);\n\n        // Send the request content to send to the DM room\n        var eventId = yield _this32.sendVerificationRequestContent(roomId, verificationEventContent);\n\n        // Get a verification request\n        var request = yield userIdentity.requestVerification(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.RoomId(roomId), new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.EventId(eventId), methods);\n        return new _verification_js__WEBPACK_IMPORTED_MODULE_18__.RustVerificationRequest(_this32.olmMachine, request, _this32.outgoingRequestProcessor, _this32._supportedVerificationMethods);\n      } finally {\n        userIdentity.free();\n      }\n    })();\n  }\n\n  /**\n   * Send the verification content to a room\n   * See https://spec.matrix.org/v1.7/client-server-api/#put_matrixclientv3roomsroomidsendeventtypetxnid\n   *\n   * Prefer to use {@link OutgoingRequestProcessor.makeOutgoingRequest} when dealing with {@link RustSdkCryptoJs.RoomMessageRequest}\n   *\n   * @param roomId - the targeted room\n   * @param verificationEventContent - the request body.\n   *\n   * @returns the event id\n   */\n  sendVerificationRequestContent(roomId, verificationEventContent) {\n    var _this33 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var txId = (0,_randomstring_js__WEBPACK_IMPORTED_MODULE_23__.secureRandomString)(32);\n      // Send the verification request content to the DM room\n      var {\n        event_id: eventId\n      } = yield _this33.http.authedRequest(_http_api_index_js__WEBPACK_IMPORTED_MODULE_8__.Method.Put, \"/_matrix/client/v3/rooms/\".concat(encodeURIComponent(roomId), \"/send/m.room.message/\").concat(encodeURIComponent(txId)), undefined, verificationEventContent, {\n        prefix: \"\"\n      });\n      return eventId;\n    })();\n  }\n  /**\n   * Set the verification methods we offer to the other side during an interactive verification.\n   *\n   * If `undefined`, we will offer all the methods supported by the Rust SDK.\n   */\n  setSupportedVerificationMethods(methods) {\n    // by default, the Rust SDK does not offer `m.qr_code.scan.v1`, but we do want to offer that.\n    this._supportedVerificationMethods = methods !== null && methods !== void 0 ? methods : ALL_VERIFICATION_METHODS;\n  }\n\n  /**\n   * Send a verification request to our other devices.\n   *\n   * If a verification is already in flight, returns it. Otherwise, initiates a new one.\n   *\n   * Implementation of {@link CryptoApi#requestOwnUserVerification}.\n   *\n   * @returns a VerificationRequest when the request has been sent to the other party.\n   */\n  requestOwnUserVerification() {\n    var _this34 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var userIdentity = yield _this34.olmMachine.getIdentity(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(_this34.userId));\n      if (userIdentity === undefined) {\n        throw new Error(\"cannot request verification for this device when there is no existing cross-signing key\");\n      }\n      try {\n        var [request, outgoingRequest] = yield userIdentity.requestVerification(_this34._supportedVerificationMethods.map(_verification_js__WEBPACK_IMPORTED_MODULE_18__.verificationMethodIdentifierToMethod));\n        yield _this34.outgoingRequestProcessor.makeOutgoingRequest(outgoingRequest);\n        return new _verification_js__WEBPACK_IMPORTED_MODULE_18__.RustVerificationRequest(_this34.olmMachine, request, _this34.outgoingRequestProcessor, _this34._supportedVerificationMethods);\n      } finally {\n        userIdentity.free();\n      }\n    })();\n  }\n\n  /**\n   * Request an interactive verification with the given device.\n   *\n   * If a verification is already in flight, returns it. Otherwise, initiates a new one.\n   *\n   * Implementation of {@link CryptoApi#requestDeviceVerification}.\n   *\n   * @param userId - ID of the owner of the device to verify\n   * @param deviceId - ID of the device to verify\n   *\n   * @returns a VerificationRequest when the request has been sent to the other party.\n   */\n  requestDeviceVerification(userId, deviceId) {\n    var _this35 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var device = yield _this35.olmMachine.getDevice(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId), new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DeviceId(deviceId));\n      if (!device) {\n        throw new Error(\"Not a known device\");\n      }\n      try {\n        var [request, outgoingRequest] = device.requestVerification(_this35._supportedVerificationMethods.map(_verification_js__WEBPACK_IMPORTED_MODULE_18__.verificationMethodIdentifierToMethod));\n        yield _this35.outgoingRequestProcessor.makeOutgoingRequest(outgoingRequest);\n        return new _verification_js__WEBPACK_IMPORTED_MODULE_18__.RustVerificationRequest(_this35.olmMachine, request, _this35.outgoingRequestProcessor, _this35._supportedVerificationMethods);\n      } finally {\n        device.free();\n      }\n    })();\n  }\n\n  /**\n   * Fetch the backup decryption key we have saved in our store.\n   *\n   * Implementation of {@link CryptoApi#getSessionBackupPrivateKey}.\n   *\n   * @returns the key, if any, or null\n   */\n  getSessionBackupPrivateKey() {\n    var _this36 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var backupKeys = yield _this36.olmMachine.getBackupKeys();\n      if (!backupKeys.decryptionKey) return null;\n      return (0,_base64_js__WEBPACK_IMPORTED_MODULE_25__.decodeBase64)(backupKeys.decryptionKey.toBase64());\n    })();\n  }\n\n  /**\n   * Store the backup decryption key.\n   *\n   * Implementation of {@link CryptoApi#storeSessionBackupPrivateKey}.\n   *\n   * @param key - the backup decryption key\n   * @param version - the backup version for this key.\n   */\n  storeSessionBackupPrivateKey(key, version) {\n    var _this37 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var base64Key = (0,_base64_js__WEBPACK_IMPORTED_MODULE_25__.encodeBase64)(key);\n      if (!version) {\n        throw new Error(\"storeSessionBackupPrivateKey: version is required\");\n      }\n      yield _this37.backupManager.saveBackupDecryptionKey(_matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.BackupDecryptionKey.fromBase64(base64Key), version);\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#loadSessionBackupPrivateKeyFromSecretStorage}.\n   */\n  loadSessionBackupPrivateKeyFromSecretStorage() {\n    var _this38 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var backupKey = yield _this38.secretStorage.get(\"m.megolm_backup.v1\");\n      if (!backupKey) {\n        throw new Error(\"loadSessionBackupPrivateKeyFromSecretStorage: missing decryption key in secret storage\");\n      }\n      var keyBackupInfo = yield _this38.backupManager.getServerBackupInfo();\n      if (!keyBackupInfo || !keyBackupInfo.version) {\n        throw new Error(\"loadSessionBackupPrivateKeyFromSecretStorage: unable to get backup version\");\n      }\n      var backupDecryptionKey = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.BackupDecryptionKey.fromBase64(backupKey);\n      if (!(0,_backup_js__WEBPACK_IMPORTED_MODULE_21__.decryptionKeyMatchesKeyBackupInfo)(backupDecryptionKey, keyBackupInfo)) {\n        throw new Error(\"loadSessionBackupPrivateKeyFromSecretStorage: decryption key does not match backup info\");\n      }\n      yield _this38.backupManager.saveBackupDecryptionKey(backupDecryptionKey, keyBackupInfo.version);\n    })();\n  }\n\n  /**\n   * Get the current status of key backup.\n   *\n   * Implementation of {@link CryptoApi#getActiveSessionBackupVersion}.\n   */\n  getActiveSessionBackupVersion() {\n    var _this39 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return yield _this39.backupManager.getActiveBackupVersion();\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#getKeyBackupInfo}.\n   */\n  getKeyBackupInfo() {\n    var _this40 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return (yield _this40.backupManager.getServerBackupInfo()) || null;\n    })();\n  }\n\n  /**\n   * Determine if a key backup can be trusted.\n   *\n   * Implementation of {@link CryptoApi#isKeyBackupTrusted}.\n   */\n  isKeyBackupTrusted(info) {\n    var _this41 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return yield _this41.backupManager.isKeyBackupTrusted(info);\n    })();\n  }\n\n  /**\n   * Force a re-check of the key backup and enable/disable it as appropriate.\n   *\n   * Implementation of {@link CryptoApi#checkKeyBackupAndEnable}.\n   */\n  checkKeyBackupAndEnable() {\n    var _this42 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return yield _this42.backupManager.checkKeyBackupAndEnable(true);\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#deleteKeyBackupVersion}.\n   */\n  deleteKeyBackupVersion(version) {\n    var _this43 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      yield _this43.backupManager.deleteKeyBackupVersion(version);\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#resetKeyBackup}.\n   */\n  resetKeyBackup() {\n    var _this44 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var backupInfo = yield _this44.backupManager.setupKeyBackup(o => _this44.signObject(o));\n\n      // we want to store the private key in 4S\n      // need to check if 4S is set up?\n      if (yield _this44.secretStorageHasAESKey()) {\n        yield _this44.secretStorage.store(\"m.megolm_backup.v1\", backupInfo.decryptionKey.toBase64());\n      }\n\n      // we can check and start async\n      _this44.checkKeyBackupAndEnable();\n    })();\n  }\n\n  /**\n   * Signs the given object with the current device and current identity (if available).\n   * As defined in {@link https://spec.matrix.org/v1.8/appendices/#signing-json | Signing JSON}.\n   *\n   * Helper for {@link RustCrypto#resetKeyBackup}.\n   *\n   * @param obj - The object to sign\n   */\n  signObject(obj) {\n    var _this45 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var sigs = new Map(Object.entries(obj.signatures || {}));\n      var unsigned = obj.unsigned;\n      delete obj.signatures;\n      delete obj.unsigned;\n      var userSignatures = sigs.get(_this45.userId) || {};\n      var canonalizedJson = another_json__WEBPACK_IMPORTED_MODULE_2__.stringify(obj);\n      var signatures = yield _this45.olmMachine.sign(canonalizedJson);\n      var map = JSON.parse(signatures.asJSON());\n      sigs.set(_this45.userId, _objectSpread(_objectSpread({}, userSignatures), map[_this45.userId]));\n      if (unsigned !== undefined) obj.unsigned = unsigned;\n      obj.signatures = Object.fromEntries(sigs.entries());\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#restoreKeyBackupWithPassphrase}.\n   */\n  restoreKeyBackupWithPassphrase(passphrase, opts) {\n    var _this46 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var backupInfo = yield _this46.backupManager.getServerBackupInfo();\n      if (!(backupInfo !== null && backupInfo !== void 0 && backupInfo.version)) {\n        throw new Error(\"No backup info available\");\n      }\n      var privateKey = yield (0,_common_crypto_key_passphrase_js__WEBPACK_IMPORTED_MODULE_30__.keyFromAuthData)(backupInfo.auth_data, passphrase);\n\n      // Cache the key\n      yield _this46.storeSessionBackupPrivateKey(privateKey, backupInfo.version);\n      return _this46.restoreKeyBackup(opts);\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#restoreKeyBackup}.\n   */\n  restoreKeyBackup(opts) {\n    var _this47 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // Get the decryption key from the crypto store\n      var backupKeys = yield _this47.olmMachine.getBackupKeys();\n      var {\n        decryptionKey,\n        backupVersion\n      } = backupKeys;\n      if (!decryptionKey || !backupVersion) throw new Error(\"No decryption key found in crypto store\");\n      var decodedDecryptionKey = (0,_base64_js__WEBPACK_IMPORTED_MODULE_25__.decodeBase64)(decryptionKey.toBase64());\n      var backupInfo = yield _this47.backupManager.requestKeyBackupVersion(backupVersion);\n      if (!backupInfo) throw new Error(\"Backup version to restore \".concat(backupVersion, \" not found on server\"));\n      var backupDecryptor = yield _this47.getBackupDecryptor(backupInfo, decodedDecryptionKey);\n      try {\n        var _opts$progressCallbac;\n        opts === null || opts === void 0 || (_opts$progressCallbac = opts.progressCallback) === null || _opts$progressCallbac === void 0 || _opts$progressCallbac.call(opts, {\n          stage: \"fetch\"\n        });\n        return yield _this47.backupManager.restoreKeyBackup(backupVersion, backupDecryptor, opts);\n      } finally {\n        // Free to avoid to keep in memory the decryption key stored in it. To avoid to exposing it to an attacker.\n        backupDecryptor.free();\n      }\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#isDehydrationSupported}.\n   */\n  isDehydrationSupported() {\n    var _this48 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return yield _this48.dehydratedDeviceManager.isSupported();\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#startDehydration}.\n   */\n  startDehydration() {\n    var _arguments6 = arguments,\n      _this49 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var opts = _arguments6.length > 0 && _arguments6[0] !== undefined ? _arguments6[0] : {};\n      if (!(yield _this49.isCrossSigningReady()) || !(yield _this49.isSecretStorageReady())) {\n        throw new Error(\"Device dehydration requires cross-signing and secret storage to be set up\");\n      }\n      return yield _this49.dehydratedDeviceManager.start(opts || {});\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#importSecretsBundle}.\n   */\n  importSecretsBundle(secrets) {\n    var _this50 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var secretsBundle = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.SecretsBundle.from_json(secrets);\n      yield _this50.getOlmMachineOrThrow().importSecretsBundle(secretsBundle); // this method frees the SecretsBundle\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#exportSecretsBundle}.\n   */\n  exportSecretsBundle() {\n    var _this51 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var secretsBundle = yield _this51.getOlmMachineOrThrow().exportSecretsBundle();\n      var secrets = secretsBundle.to_json();\n      secretsBundle.free();\n      return secrets;\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#encryptToDeviceMessages}.\n   */\n  encryptToDeviceMessages(eventType, devices, payload) {\n    var _this52 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var logger = new _logger_js__WEBPACK_IMPORTED_MODULE_7__.LogSpan(_this52.logger, \"encryptToDeviceMessages\");\n      var uniqueUsers = new Set(devices.map(_ref2 => {\n        var {\n          userId\n        } = _ref2;\n        return userId;\n      }));\n\n      // This will ensure we have Olm sessions for all of the users' devices.\n      // However, we only care about some of the devices.\n      // So, perhaps we can optimise this later on.\n      yield _this52.keyClaimManager.ensureSessionsForUsers(logger, Array.from(uniqueUsers).map(userId => new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId)));\n      var batch = {\n        batch: [],\n        eventType: _types_event_js__WEBPACK_IMPORTED_MODULE_19__.EventType.RoomMessageEncrypted\n      };\n      yield Promise.all(devices.map(/*#__PURE__*/function () {\n        var _ref4 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (_ref3) {\n          var {\n            userId,\n            deviceId\n          } = _ref3;\n          var device = yield _this52.olmMachine.getDevice(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId), new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DeviceId(deviceId));\n          if (device) {\n            var encryptedPayload = JSON.parse(yield device.encryptToDeviceEvent(eventType, payload));\n            batch.batch.push({\n              deviceId,\n              userId,\n              payload: encryptedPayload\n            });\n          } else {\n            _this52.logger.warn(\"encryptToDeviceMessages: unknown device \".concat(userId, \":\").concat(deviceId));\n          }\n        });\n        return function (_x) {\n          return _ref4.apply(this, arguments);\n        };\n      }()));\n      return batch;\n    })();\n  }\n\n  /**\n   * Implementation of {@link CryptoApi#resetEncryption}.\n   */\n  resetEncryption(authUploadDeviceSigningKeys) {\n    var _this53 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      _this53.logger.debug(\"resetEncryption: resetting encryption\");\n\n      // Disable backup, and delete all the backups from the server\n      yield _this53.backupManager.deleteAllKeyBackupVersions();\n\n      // Disable the recovery key and the secret storage\n      yield _this53.secretStorage.setDefaultKeyId(null);\n\n      // Reset the cross-signing keys\n      yield _this53.crossSigningIdentity.bootstrapCrossSigning({\n        setupNewCrossSigning: true,\n        authUploadDeviceSigningKeys\n      });\n\n      // Create a new key backup\n      yield _this53.resetKeyBackup();\n      _this53.logger.debug(\"resetEncryption: ended\");\n    })();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  //\n  // SyncCryptoCallbacks implementation\n  //\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Apply sync changes to the olm machine\n   * @param events - the received to-device messages\n   * @param oneTimeKeysCounts - the received one time key counts\n   * @param unusedFallbackKeys - the received unused fallback keys\n   * @param devices - the received device list updates\n   * @returns A list of preprocessed to-device messages.\n   */\n  receiveSyncChanges(_ref5) {\n    var _this54 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var {\n        events,\n        oneTimeKeysCounts = new Map(),\n        unusedFallbackKeys,\n        devices = new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DeviceLists()\n      } = _ref5;\n      var result = yield (0,_utils_js__WEBPACK_IMPORTED_MODULE_12__.logDuration)(_logger_js__WEBPACK_IMPORTED_MODULE_7__.logger, \"receiveSyncChanges\", /*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n        return yield _this54.olmMachine.receiveSyncChanges(events ? JSON.stringify(events) : \"[]\", devices, oneTimeKeysCounts, unusedFallbackKeys);\n      }));\n\n      // receiveSyncChanges returns a JSON-encoded list of decrypted to-device messages.\n      return JSON.parse(result);\n    })();\n  }\n\n  /** called by the sync loop to preprocess incoming to-device messages\n   *\n   * @param events - the received to-device messages\n   * @returns A list of preprocessed to-device messages.\n   */\n  preprocessToDeviceMessages(events) {\n    var _this55 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // send the received to-device messages into receiveSyncChanges. We have no info on device-list changes,\n      // one-time-keys, or fallback keys, so just pass empty data.\n      var processed = yield _this55.receiveSyncChanges({\n        events\n      });\n\n      // look for interesting to-device messages\n      for (var message of processed) {\n        if (message.type === _types_event_js__WEBPACK_IMPORTED_MODULE_19__.EventType.KeyVerificationRequest) {\n          var sender = message.sender;\n          var transactionId = message.content.transaction_id;\n          if (transactionId && sender) {\n            _this55.onIncomingKeyVerificationRequest(sender, transactionId);\n          }\n        }\n      }\n      return processed;\n    })();\n  }\n\n  /** called by the sync loop to process one time key counts and unused fallback keys\n   *\n   * @param oneTimeKeysCounts - the received one time key counts\n   * @param unusedFallbackKeys - the received unused fallback keys\n   */\n  processKeyCounts(oneTimeKeysCounts, unusedFallbackKeys) {\n    var _this56 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var mapOneTimeKeysCount = oneTimeKeysCounts && new Map(Object.entries(oneTimeKeysCounts));\n      var setUnusedFallbackKeys = unusedFallbackKeys && new Set(unusedFallbackKeys);\n      if (mapOneTimeKeysCount !== undefined || setUnusedFallbackKeys !== undefined) {\n        yield _this56.receiveSyncChanges({\n          oneTimeKeysCounts: mapOneTimeKeysCount,\n          unusedFallbackKeys: setUnusedFallbackKeys\n        });\n      }\n    })();\n  }\n\n  /** called by the sync loop to process the notification that device lists have\n   * been changed.\n   *\n   * @param deviceLists - device_lists field from /sync\n   */\n  processDeviceLists(deviceLists) {\n    var _this57 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var _deviceLists$changed, _deviceLists$left;\n      var devices = new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DeviceLists((_deviceLists$changed = deviceLists.changed) === null || _deviceLists$changed === void 0 ? void 0 : _deviceLists$changed.map(userId => new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId)), (_deviceLists$left = deviceLists.left) === null || _deviceLists$left === void 0 ? void 0 : _deviceLists$left.map(userId => new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(userId)));\n      yield _this57.receiveSyncChanges({\n        devices\n      });\n    })();\n  }\n\n  /** called by the sync loop on m.room.encrypted events\n   *\n   * @param room - in which the event was received\n   * @param event - encryption event to be processed\n   */\n  onCryptoEvent(room, event) {\n    var _this58 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var config = event.getContent();\n      var settings = new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.RoomSettings();\n      if (config.algorithm === \"m.megolm.v1.aes-sha2\") {\n        settings.algorithm = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.EncryptionAlgorithm.MegolmV1AesSha2;\n      } else {\n        // Among other situations, this happens if the crypto state event is redacted.\n        _this58.logger.warn(\"Room \".concat(room.roomId, \": ignoring crypto event with invalid algorithm \").concat(config.algorithm));\n        return;\n      }\n      try {\n        settings.sessionRotationPeriodMs = config.rotation_period_ms;\n        settings.sessionRotationPeriodMessages = config.rotation_period_msgs;\n        yield _this58.olmMachine.setRoomSettings(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.RoomId(room.roomId), settings);\n      } catch (e) {\n        _this58.logger.warn(\"Room \".concat(room.roomId, \": ignoring crypto event which caused error: \").concat(e));\n        return;\n      }\n\n      // If we got this far, the SDK found the event acceptable.\n      // We need to either create or update the active RoomEncryptor.\n      var existingEncryptor = _this58.roomEncryptors[room.roomId];\n      if (existingEncryptor) {\n        existingEncryptor.onCryptoEvent(config);\n      } else {\n        _this58.roomEncryptors[room.roomId] = new _RoomEncryptor_js__WEBPACK_IMPORTED_MODULE_9__.RoomEncryptor(_this58.olmMachine, _this58.keyClaimManager, _this58.outgoingRequestsManager, room, config);\n      }\n    })();\n  }\n\n  /** called by the sync loop after processing each sync.\n   *\n   * TODO: figure out something equivalent for sliding sync.\n   *\n   * @param syncState - information on the completed sync.\n   */\n  onSyncCompleted(syncState) {\n    // Processing the /sync may have produced new outgoing requests which need sending, so kick off the outgoing\n    // request loop, if it's not already running.\n    this.outgoingRequestsManager.doProcessOutgoingRequests().catch(e => {\n      this.logger.warn(\"onSyncCompleted: Error processing outgoing requests\", e);\n    });\n  }\n\n  /**\n   * Handle an incoming m.key.verification.request event, received either in-room or in a to-device message.\n   *\n   * @param sender - the sender of the event\n   * @param transactionId - the transaction ID for the verification. For to-device messages, this comes from the\n   *    content of the message; for in-room messages it is the event ID.\n   */\n  onIncomingKeyVerificationRequest(sender, transactionId) {\n    var request = this.olmMachine.getVerificationRequest(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(sender), transactionId);\n    if (request) {\n      this.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.VerificationRequestReceived, new _verification_js__WEBPACK_IMPORTED_MODULE_18__.RustVerificationRequest(this.olmMachine, request, this.outgoingRequestProcessor, this._supportedVerificationMethods));\n    } else {\n      // There are multiple reasons this can happen; probably the most likely is that the event is an\n      // in-room event which is too old.\n      this.logger.info(\"Ignoring just-received verification request \".concat(transactionId, \" which did not start a rust-side verification\"));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  //\n  // Other public functions\n  //\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /** called by the MatrixClient on a room membership event\n   *\n   * @param event - The matrix event which caused this event to fire.\n   * @param member - The member whose RoomMember.membership changed.\n   * @param oldMembership - The previous membership state. Null if it's a new member.\n   */\n  onRoomMembership(event, member, oldMembership) {\n    var enc = this.roomEncryptors[event.getRoomId()];\n    if (!enc) {\n      // not encrypting in this room\n      return;\n    }\n    enc.onRoomMembership(member);\n  }\n\n  /** Callback for OlmMachine.registerRoomKeyUpdatedCallback\n   *\n   * Called by the rust-sdk whenever there is an update to (megolm) room keys. We\n   * check if we have any events waiting for the given keys, and schedule them for\n   * a decryption retry if so.\n   *\n   * @param keys - details of the updated keys\n   */\n  onRoomKeysUpdated(keys) {\n    var _this59 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      for (var key of keys) {\n        _this59.onRoomKeyUpdated(key);\n      }\n      _this59.backupManager.maybeUploadKey();\n    })();\n  }\n  onRoomKeyUpdated(key) {\n    var _this60 = this;\n    if (this.stopped) return;\n    this.logger.debug(\"Got update for session \".concat(key.sessionId, \" from sender \").concat(key.senderKey.toBase64(), \" in \").concat(key.roomId.toString()));\n    var pendingList = this.eventDecryptor.getEventsPendingRoomKey(key.roomId.toString(), key.sessionId);\n    if (pendingList.length === 0) return;\n    this.logger.debug(\"Retrying decryption on events:\", pendingList.map(e => \"\".concat(e.getId())));\n\n    // Have another go at decrypting events with this key.\n    //\n    // We don't want to end up blocking the callback from Rust, which could otherwise end up dropping updates,\n    // so we don't wait for the decryption to complete. In any case, there is no need to wait:\n    // MatrixEvent.attemptDecryption ensures that there is only one decryption attempt happening at once,\n    // and deduplicates repeated attempts for the same event.\n    var _loop = function _loop(ev) {\n      ev.attemptDecryption(_this60, {\n        isRetry: true\n      }).catch(_e => {\n        _this60.logger.info(\"Still unable to decrypt event \".concat(ev.getId(), \" after receiving key\"));\n      });\n    };\n    for (var ev of pendingList) {\n      _loop(ev);\n    }\n  }\n\n  /**\n   * Callback for `OlmMachine.registerRoomKeyWithheldCallback`.\n   *\n   * Called by the rust sdk whenever we are told that a key has been withheld. We see if we had any events that\n   * failed to decrypt for the given session, and update their status if so.\n   *\n   * @param withheld - Details of the withheld sessions.\n   */\n  onRoomKeysWithheld(withheld) {\n    var _this61 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      for (var session of withheld) {\n        _this61.logger.debug(\"Got withheld message for session \".concat(session.sessionId, \" in \").concat(session.roomId.toString()));\n        var pendingList = _this61.eventDecryptor.getEventsPendingRoomKey(session.roomId.toString(), session.sessionId);\n        if (pendingList.length === 0) return;\n\n        // The easiest way to update the status of the event is to have another go at decrypting it.\n        _this61.logger.debug(\"Retrying decryption on events:\", pendingList.map(e => \"\".concat(e.getId())));\n        for (var ev of pendingList) {\n          ev.attemptDecryption(_this61, {\n            isRetry: true\n          }).catch(_e => {\n            // It's somewhat expected that we still can't decrypt here.\n          });\n        }\n      }\n    })();\n  }\n\n  /**\n   * Callback for `OlmMachine.registerUserIdentityUpdatedCallback`\n   *\n   * Called by the rust-sdk whenever there is an update to any user's cross-signing status. We re-check their trust\n   * status and emit a `UserTrustStatusChanged` event, as well as a `KeysChanged` if it is our own identity that changed.\n   *\n   * @param userId - the user with the updated identity\n   */\n  onUserIdentityUpdated(userId) {\n    var _this62 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var newVerification = yield _this62.getUserVerificationStatus(userId.toString());\n      _this62.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.UserTrustStatusChanged, userId.toString(), newVerification);\n\n      // If our own user identity has changed, we may now trust the key backup where we did not before.\n      // So, re-check the key backup status and enable it if available.\n      if (userId.toString() === _this62.userId) {\n        _this62.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.KeysChanged, {});\n        yield _this62.checkKeyBackupAndEnable();\n      }\n    })();\n  }\n\n  /**\n   * Callback for `OlmMachine.registerDevicesUpdatedCallback`\n   *\n   * Called when users' devices have updated. Emits `WillUpdateDevices` and `DevicesUpdated`. In the JavaScript\n   * crypto backend, these events are called at separate times, with `WillUpdateDevices` being emitted just before\n   * the devices are saved, and `DevicesUpdated` being emitted just after. But the OlmMachine only gives us\n   * one event, so we emit both events here.\n   *\n   * @param userIds - an array of user IDs of users whose devices have updated.\n   */\n  onDevicesUpdated(userIds) {\n    var _this63 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      _this63.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.WillUpdateDevices, userIds, false);\n      _this63.emit(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.CryptoEvent.DevicesUpdated, userIds, false);\n    })();\n  }\n\n  /**\n   * Handles secret received from the rust secret inbox.\n   *\n   * The gossipped secrets are received using the `m.secret.send` event type\n   * and are guaranteed to have been received over a 1-to-1 Olm\n   * Session from a verified device.\n   *\n   * The only secret currently handled in this way is `m.megolm_backup.v1`.\n   *\n   * @param name - the secret name\n   * @param value - the secret value\n   */\n  handleSecretReceived(name, value) {\n    var _this64 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      _this64.logger.debug(\"onReceiveSecret: Received secret \".concat(name));\n      if (name === \"m.megolm_backup.v1\") {\n        return yield _this64.backupManager.handleBackupSecretReceived(value);\n        // XXX at this point we should probably try to download the backup and import the keys,\n        // or at least retry for the current decryption failures?\n        // Maybe add some signaling when a new secret is received, and let clients handle it?\n        // as it's where the restore from backup APIs are exposed.\n      }\n      return false;\n    })();\n  }\n\n  /**\n   * Called when a new secret is received in the rust secret inbox.\n   *\n   * Will poll the secret inbox and handle the secrets received.\n   *\n   * @param name - The name of the secret received.\n   */\n  checkSecrets(name) {\n    var _this65 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var pendingValues = yield _this65.olmMachine.getSecretsFromInbox(name);\n      for (var value of pendingValues) {\n        if (yield _this65.handleSecretReceived(name, value)) {\n          // If we have a valid secret for that name there is no point of processing the other secrets values.\n          // It's probably the same secret shared by another device.\n          break;\n        }\n      }\n\n      // Important to call this after handling the secrets as good hygiene.\n      yield _this65.olmMachine.deleteSecretsFromInbox(name);\n    })();\n  }\n\n  /**\n   * Handle a live event received via /sync.\n   * See {@link ClientEventHandlerMap#event}\n   *\n   * @param event - live event\n   */\n  onLiveEventFromSync(event) {\n    var _this66 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // Ignore state event or remote echo\n      // transaction_id is provided in case of remote echo {@link https://spec.matrix.org/v1.7/client-server-api/#local-echo}\n      if (event.isState() || !!event.getUnsigned().transaction_id) return;\n      var processEvent = /*#__PURE__*/function () {\n        var _ref7 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (evt) {\n          // Process only verification event\n          if ((0,_verification_js__WEBPACK_IMPORTED_MODULE_18__.isVerificationEvent)(event)) {\n            yield _this66.onKeyVerificationEvent(evt);\n          }\n        });\n        return function processEvent(_x2) {\n          return _ref7.apply(this, arguments);\n        };\n      }();\n\n      // If the event is encrypted of in failure, we wait for decryption\n      if (event.isDecryptionFailure() || event.isEncrypted()) {\n        // 5 mins\n        var TIMEOUT_DELAY = 5 * 60 * 1000;\n\n        // After 5mins, we are not expecting the event to be decrypted\n        var timeoutId = setTimeout(() => event.off(_models_event_js__WEBPACK_IMPORTED_MODULE_5__.MatrixEventEvent.Decrypted, onDecrypted), TIMEOUT_DELAY);\n        var onDecrypted = (decryptedEvent, error) => {\n          if (error) return;\n          clearTimeout(timeoutId);\n          event.off(_models_event_js__WEBPACK_IMPORTED_MODULE_5__.MatrixEventEvent.Decrypted, onDecrypted);\n          processEvent(decryptedEvent);\n        };\n        event.on(_models_event_js__WEBPACK_IMPORTED_MODULE_5__.MatrixEventEvent.Decrypted, onDecrypted);\n      } else {\n        yield processEvent(event);\n      }\n    })();\n  }\n\n  /**\n   * Handle an in-room key verification event.\n   *\n   * @param event - a key validation request event.\n   */\n  onKeyVerificationEvent(event) {\n    var _this67 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var roomId = event.getRoomId();\n      if (!roomId) {\n        throw new Error(\"missing roomId in the event\");\n      }\n      _this67.logger.debug(\"Incoming verification event \".concat(event.getId(), \" type \").concat(event.getType(), \" from \").concat(event.getSender()));\n      yield _this67.olmMachine.receiveVerificationEvent(JSON.stringify({\n        event_id: event.getId(),\n        type: event.getType(),\n        sender: event.getSender(),\n        state_key: event.getStateKey(),\n        content: event.getContent(),\n        origin_server_ts: event.getTs()\n      }), new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.RoomId(roomId));\n      if (event.getType() === _types_event_js__WEBPACK_IMPORTED_MODULE_19__.EventType.RoomMessage && event.getContent().msgtype === _types_event_js__WEBPACK_IMPORTED_MODULE_19__.MsgType.KeyVerificationRequest) {\n        _this67.onIncomingKeyVerificationRequest(event.getSender(), event.getId());\n      }\n\n      // that may have caused us to queue up outgoing requests, so make sure we send them.\n      _this67.outgoingRequestsManager.doProcessOutgoingRequests().catch(e => {\n        _this67.logger.warn(\"onKeyVerificationRequest: Error processing outgoing requests\", e);\n      });\n    })();\n  }\n\n  /**\n   * Returns the cross-signing user identity of the current user.\n   *\n   * Not part of the public crypto-api interface.\n   * Used during migration from legacy js-crypto to update local trust if needed.\n   */\n  getOwnIdentity() {\n    var _this68 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      return yield _this68.olmMachine.getIdentity(new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.UserId(_this68.userId));\n    })();\n  }\n}\nclass EventDecryptor {\n  constructor(logger, olmMachine, perSessionBackupDownloader) {\n    this.logger = logger;\n    this.olmMachine = olmMachine;\n    this.perSessionBackupDownloader = perSessionBackupDownloader;\n    /**\n     * Events which we couldn't decrypt due to unknown sessions / indexes.\n     *\n     * Map from roomId to sessionId to Set of MatrixEvents\n     */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"eventsPendingKey\", new _utils_js__WEBPACK_IMPORTED_MODULE_12__.MapWithDefault(() => new _utils_js__WEBPACK_IMPORTED_MODULE_12__.MapWithDefault(() => new Set())));\n  }\n  attemptEventDecryption(event, isolationMode) {\n    var _this69 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // add the event to the pending list *before* attempting to decrypt.\n      // then, if the key turns up while decryption is in progress (and\n      // decryption fails), we will schedule a retry.\n      // (fixes https://github.com/vector-im/element-web/issues/5001)\n      _this69.addEventToPendingList(event);\n      var trustRequirement;\n      switch (isolationMode.kind) {\n        case _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DeviceIsolationModeKind.AllDevicesIsolationMode:\n          trustRequirement = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.TrustRequirement.Untrusted;\n          break;\n        case _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DeviceIsolationModeKind.OnlySignedDevicesIsolationMode:\n          trustRequirement = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.TrustRequirement.CrossSignedOrLegacy;\n          break;\n      }\n      try {\n        var res = yield _this69.olmMachine.decryptRoomEvent(stringifyEvent(event), new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.RoomId(event.getRoomId()), new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DecryptionSettings(trustRequirement));\n\n        // Success. We can remove the event from the pending list, if\n        // that hasn't already happened.\n        _this69.removeEventFromPendingList(event);\n        return {\n          clearEvent: JSON.parse(res.event),\n          claimedEd25519Key: res.senderClaimedEd25519Key,\n          senderCurve25519Key: res.senderCurve25519Key,\n          forwardingCurve25519KeyChain: res.forwardingCurve25519KeyChain\n        };\n      } catch (err) {\n        if (err instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.MegolmDecryptionError) {\n          _this69.onMegolmDecryptionError(event, err, yield _this69.perSessionBackupDownloader.getServerBackupInfo());\n        } else {\n          throw new _common_crypto_CryptoBackend_js__WEBPACK_IMPORTED_MODULE_6__.DecryptionError(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DecryptionFailureCode.UNKNOWN_ERROR, \"Unknown error\");\n        }\n      }\n    })();\n  }\n\n  /**\n   * Handle a `MegolmDecryptionError` returned by the rust SDK.\n   *\n   * Fires off a request to the `perSessionBackupDownloader`, if appropriate, and then throws a `DecryptionError`.\n   *\n   * @param event - The event which could not be decrypted.\n   * @param err - The error from the Rust SDK.\n   * @param serverBackupInfo - Details about the current backup from the server. `null` if there is no backup.\n   *     `undefined` if our attempt to check failed.\n   */\n  onMegolmDecryptionError(event, err, serverBackupInfo) {\n    var content = event.getWireContent();\n    var errorDetails = {\n      sender_key: content.sender_key,\n      session_id: content.session_id\n    };\n\n    // If the error looks like it might be recoverable from backup, queue up a request to try that.\n    if (err.code === _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DecryptionErrorCode.MissingRoomKey || err.code === _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DecryptionErrorCode.UnknownMessageIndex) {\n      this.perSessionBackupDownloader.onDecryptionKeyMissingError(event.getRoomId(), content.session_id);\n\n      // If the server is telling us our membership at the time the event\n      // was sent, and it isn't \"join\", we use a different error code.\n      var membership = event.getMembershipAtEvent();\n      if (membership && membership !== _types_membership_js__WEBPACK_IMPORTED_MODULE_4__.KnownMembership.Join && membership !== _types_membership_js__WEBPACK_IMPORTED_MODULE_4__.KnownMembership.Invite) {\n        throw new _common_crypto_CryptoBackend_js__WEBPACK_IMPORTED_MODULE_6__.DecryptionError(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DecryptionFailureCode.HISTORICAL_MESSAGE_USER_NOT_JOINED, \"This message was sent when we were not a member of the room.\", errorDetails);\n      }\n\n      // If the event was sent before this device was created, we use some different error codes.\n      if (event.getTs() <= this.olmMachine.deviceCreationTimeMs) {\n        if (serverBackupInfo === null) {\n          throw new _common_crypto_CryptoBackend_js__WEBPACK_IMPORTED_MODULE_6__.DecryptionError(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DecryptionFailureCode.HISTORICAL_MESSAGE_NO_KEY_BACKUP, \"This message was sent before this device logged in, and there is no key backup on the server.\", errorDetails);\n        } else if (!this.perSessionBackupDownloader.isKeyBackupDownloadConfigured()) {\n          throw new _common_crypto_CryptoBackend_js__WEBPACK_IMPORTED_MODULE_6__.DecryptionError(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DecryptionFailureCode.HISTORICAL_MESSAGE_BACKUP_UNCONFIGURED, \"This message was sent before this device logged in, and key backup is not working.\", errorDetails);\n        } else {\n          throw new _common_crypto_CryptoBackend_js__WEBPACK_IMPORTED_MODULE_6__.DecryptionError(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DecryptionFailureCode.HISTORICAL_MESSAGE_WORKING_BACKUP, \"This message was sent before this device logged in. Key backup is working, but we still do not (yet) have the key.\", errorDetails);\n        }\n      }\n    }\n\n    // If we got a withheld code, expose that.\n    if (err.maybe_withheld) {\n      // Unfortunately the Rust SDK API doesn't let us distinguish between different withheld cases, other than\n      // by string-matching.\n      var failureCode = err.maybe_withheld === \"The sender has disabled encrypting to unverified devices.\" ? _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DecryptionFailureCode.MEGOLM_KEY_WITHHELD_FOR_UNVERIFIED_DEVICE : _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DecryptionFailureCode.MEGOLM_KEY_WITHHELD;\n      throw new _common_crypto_CryptoBackend_js__WEBPACK_IMPORTED_MODULE_6__.DecryptionError(failureCode, err.maybe_withheld, errorDetails);\n    }\n    switch (err.code) {\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DecryptionErrorCode.MissingRoomKey:\n        throw new _common_crypto_CryptoBackend_js__WEBPACK_IMPORTED_MODULE_6__.DecryptionError(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DecryptionFailureCode.MEGOLM_UNKNOWN_INBOUND_SESSION_ID, \"The sender's device has not sent us the keys for this message.\", errorDetails);\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DecryptionErrorCode.UnknownMessageIndex:\n        throw new _common_crypto_CryptoBackend_js__WEBPACK_IMPORTED_MODULE_6__.DecryptionError(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DecryptionFailureCode.OLM_UNKNOWN_MESSAGE_INDEX, \"The sender's device has not sent us the keys for this message at this index.\", errorDetails);\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DecryptionErrorCode.SenderIdentityVerificationViolation:\n        // We're refusing to decrypt due to not trusting the sender,\n        // rather than failing to decrypt due to lack of keys, so we\n        // don't need to keep it on the pending list.\n        this.removeEventFromPendingList(event);\n        throw new _common_crypto_CryptoBackend_js__WEBPACK_IMPORTED_MODULE_6__.DecryptionError(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DecryptionFailureCode.SENDER_IDENTITY_PREVIOUSLY_VERIFIED, \"The sender identity is unverified, but was previously verified.\");\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DecryptionErrorCode.UnknownSenderDevice:\n        // We're refusing to decrypt due to not trusting the sender,\n        // rather than failing to decrypt due to lack of keys, so we\n        // don't need to keep it on the pending list.\n        this.removeEventFromPendingList(event);\n        throw new _common_crypto_CryptoBackend_js__WEBPACK_IMPORTED_MODULE_6__.DecryptionError(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DecryptionFailureCode.UNKNOWN_SENDER_DEVICE, \"The sender device is not known.\");\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.DecryptionErrorCode.UnsignedSenderDevice:\n        // We're refusing to decrypt due to not trusting the sender,\n        // rather than failing to decrypt due to lack of keys, so we\n        // don't need to keep it on the pending list.\n        this.removeEventFromPendingList(event);\n        throw new _common_crypto_CryptoBackend_js__WEBPACK_IMPORTED_MODULE_6__.DecryptionError(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DecryptionFailureCode.UNSIGNED_SENDER_DEVICE, \"The sender identity is not cross-signed.\");\n\n      // We don't map MismatchedIdentityKeys for now, as there is no equivalent in legacy.\n      // Just put it on the `UNKNOWN_ERROR` bucket.\n      default:\n        throw new _common_crypto_CryptoBackend_js__WEBPACK_IMPORTED_MODULE_6__.DecryptionError(_crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.DecryptionFailureCode.UNKNOWN_ERROR, err.description, errorDetails);\n    }\n  }\n  getEncryptionInfoForEvent(event) {\n    var _this70 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      if (!event.getClearContent() || event.isDecryptionFailure()) {\n        // not successfully decrypted\n        return null;\n      }\n\n      // special-case outgoing events, which the rust crypto-sdk will barf on\n      if (event.status !== null) {\n        return {\n          shieldColour: _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.EventShieldColour.NONE,\n          shieldReason: null\n        };\n      }\n      var encryptionInfo = yield _this70.olmMachine.getRoomEventEncryptionInfo(stringifyEvent(event), new _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.RoomId(event.getRoomId()));\n      return rustEncryptionInfoToJsEncryptionInfo(_this70.logger, encryptionInfo);\n    })();\n  }\n\n  /**\n   * Look for events which are waiting for a given megolm session\n   *\n   * Returns a list of events which were encrypted by `session` and could not be decrypted\n   */\n  getEventsPendingRoomKey(roomId, sessionId) {\n    var roomPendingEvents = this.eventsPendingKey.get(roomId);\n    if (!roomPendingEvents) return [];\n    var sessionPendingEvents = roomPendingEvents.get(sessionId);\n    if (!sessionPendingEvents) return [];\n    return [...sessionPendingEvents];\n  }\n\n  /**\n   * Add an event to the list of those awaiting their session keys.\n   */\n  addEventToPendingList(event) {\n    var roomId = event.getRoomId();\n    // We shouldn't have events without a room id here.\n    if (!roomId) return;\n    var roomPendingEvents = this.eventsPendingKey.getOrCreate(roomId);\n    var sessionPendingEvents = roomPendingEvents.getOrCreate(event.getWireContent().session_id);\n    sessionPendingEvents.add(event);\n  }\n\n  /**\n   * Remove an event from the list of those awaiting their session keys.\n   */\n  removeEventFromPendingList(event) {\n    var roomId = event.getRoomId();\n    if (!roomId) return;\n    var roomPendingEvents = this.eventsPendingKey.getOrCreate(roomId);\n    if (!roomPendingEvents) return;\n    var sessionPendingEvents = roomPendingEvents.get(event.getWireContent().session_id);\n    if (!sessionPendingEvents) return;\n    sessionPendingEvents.delete(event);\n\n    // also clean up the higher-level maps if they are now empty\n    if (sessionPendingEvents.size === 0) {\n      roomPendingEvents.delete(event.getWireContent().session_id);\n      if (roomPendingEvents.size === 0) {\n        this.eventsPendingKey.delete(roomId);\n      }\n    }\n  }\n}\nfunction stringifyEvent(event) {\n  return JSON.stringify({\n    event_id: event.getId(),\n    type: event.getWireType(),\n    sender: event.getSender(),\n    state_key: event.getStateKey(),\n    content: event.getWireContent(),\n    origin_server_ts: event.getTs()\n  });\n}\nfunction rustEncryptionInfoToJsEncryptionInfo(logger, encryptionInfo) {\n  if (encryptionInfo === undefined) {\n    // not decrypted here\n    return null;\n  }\n\n  // TODO: use strict shield semantics.\n  var shieldState = encryptionInfo.shieldState(false);\n  var shieldColour;\n  switch (shieldState.color) {\n    case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.ShieldColor.Grey:\n      shieldColour = _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.EventShieldColour.GREY;\n      break;\n    case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.ShieldColor.None:\n      shieldColour = _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.EventShieldColour.NONE;\n      break;\n    default:\n      shieldColour = _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.EventShieldColour.RED;\n  }\n  var shieldReason;\n  switch (shieldState.code) {\n    case undefined:\n    case null:\n      shieldReason = null;\n      break;\n    case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.ShieldStateCode.AuthenticityNotGuaranteed:\n      shieldReason = _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.EventShieldReason.AUTHENTICITY_NOT_GUARANTEED;\n      break;\n    case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.ShieldStateCode.UnknownDevice:\n      shieldReason = _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.EventShieldReason.UNKNOWN_DEVICE;\n      break;\n    case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.ShieldStateCode.UnsignedDevice:\n      shieldReason = _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.EventShieldReason.UNSIGNED_DEVICE;\n      break;\n    case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.ShieldStateCode.UnverifiedIdentity:\n      shieldReason = _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.EventShieldReason.UNVERIFIED_IDENTITY;\n      break;\n    case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.ShieldStateCode.SentInClear:\n      shieldReason = _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.EventShieldReason.SENT_IN_CLEAR;\n      break;\n    case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_3__.ShieldStateCode.VerificationViolation:\n      shieldReason = _crypto_api_index_js__WEBPACK_IMPORTED_MODULE_13__.EventShieldReason.VERIFICATION_VIOLATION;\n      break;\n  }\n  return {\n    shieldColour,\n    shieldReason\n  };\n}\n//# sourceMappingURL=rust-crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vcnVzdC1jcnlwdG8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0U7QUFDSjtBQUNwRSx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELGlGQUFlLGVBQWUsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUM7QUFDK0I7QUFDWjtBQUNKO0FBQ2M7QUFDckI7QUFDRDtBQUNLO0FBQ3NCO0FBQ2xCO0FBQ0c7QUFDaU87QUFDdk07QUFDYjtBQUNOO0FBQzBDO0FBQ1k7QUFDL0Q7QUFDYTtBQUNjO0FBQ2xDO0FBQ087QUFDTjtBQUNRO0FBQ2E7QUFDWTtBQUNaO0FBQ3RCO0FBQ29CO0FBQ3JFLGdDQUFnQywwREFBa0IsTUFBTSwwREFBa0IsYUFBYSwwREFBa0IsYUFBYSwwREFBa0I7QUFDeEk7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNPLHlCQUF5Qiw4RUFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlGQUFlO0FBQ25CLElBQUksaUZBQWU7QUFDbkIsSUFBSSxpRkFBZSxrQ0FBa0MsMEVBQXVCO0FBQzVFLGlCQUFpQixZQUFZO0FBQzdCLElBQUksaUZBQWU7QUFDbkI7QUFDQSxJQUFJLGlGQUFlLDJCQUEyQjtBQUM5QyxJQUFJLGlGQUFlO0FBQ25CLElBQUksaUZBQWU7QUFDbkIsSUFBSSxpRkFBZTtBQUNuQixJQUFJLGlGQUFlO0FBQ25CLElBQUksaUZBQWU7QUFDbkIsSUFBSSxpRkFBZTtBQUNuQixJQUFJLGlGQUFlO0FBQ25CLElBQUksaUZBQWU7QUFDbkIsSUFBSSxpRkFBZSx3QkFBd0IsMERBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUZBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQix3Q0FBd0MsbUZBQXdCO0FBQ2hFLHVDQUF1QyxpRkFBdUI7QUFDOUQsK0JBQStCLGlFQUFlO0FBQzlDLDZCQUE2QiwwREFBaUI7QUFDOUMsMENBQTBDLDZGQUE2QjtBQUN2RSx1Q0FBdUMsaUZBQXVCO0FBQzlEOztBQUVBO0FBQ0EsK0NBQStDLDhEQUFXLGtCQUFrQiw4REFBVyw2QkFBNkIsOERBQVcsa0JBQWtCLDhEQUFXO0FBQzVKLHlEQUF5RCw4REFBVywwQkFBMEIsOERBQVcsMkJBQTJCLDhEQUFXLHFCQUFxQiw4REFBVyxzQkFBc0IsOERBQVcsdUJBQXVCLDhEQUFXLG1CQUFtQiw4REFBVyx1QkFBdUIsOERBQVc7QUFDbFQsb0NBQW9DLDJFQUFvQjs7QUFFeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBa0I7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EscUNBQXFDLDBDQUEwQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5RUFBc0I7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0IsdUNBQXVDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtRkFBbUMsWUFBWSx5REFBWTtBQUMzRixXQUFXLDhFQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0IsMkNBQTJDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQSxtQkFBbUIsMkVBQTJCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsdUNBQXVDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDBDQUEwQztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QixxRUFBcUUsc0VBQXNCO0FBQzNGO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHdCQUF3Qix3Q0FBd0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsWUFBWSxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDRFQUFxQjtBQUNwRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QiwyQkFBMkIsc0VBQXNCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiwyRUFBb0I7QUFDcEcsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzREFBTTtBQUNwRDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0IsMkNBQTJDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0EsMERBQTBELHNFQUFzQixjQUFjLHdFQUF3QjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwRUFBMEIsWUFBWSwwRUFBMEI7QUFDOUcsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QiwwREFBMEQsc0VBQXNCLHNCQUFzQix3RUFBd0I7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0IsNENBQTRDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCLDBEQUEwRCxzRUFBc0IsY0FBYyx3RUFBd0I7QUFDdEg7QUFDQTtBQUNBLG1CQUFtQiwyRUFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0IsMENBQTBDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCLDhFQUE4RSxzRUFBc0I7QUFDcEc7QUFDQSxtQkFBbUIseUVBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxpRkFBaUM7QUFDdkY7QUFDQSxpQkFBaUIseUVBQXNCO0FBQ3ZDLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHdCQUF3Qix1Q0FBdUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUIsOEVBQThFLHNFQUFzQjtBQUNwRztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0VBQStCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHdCQUF3QixnREFBZ0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUIsOEVBQThFLHNFQUFzQjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QiwyRkFBMkYsa0VBQWU7QUFDMUcsa0VBQWtFLHNFQUFzQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrRUFBZTtBQUM5QjtBQUNBO0FBQ0EsZUFBZSxrRUFBZTtBQUM5QjtBQUNBO0FBQ0EsZUFBZSxrRUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZLE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrRkFBNkI7QUFDMUMsS0FBSztBQUNMOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRSwwRkFBcUM7QUFDekcsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0EsUUFBUSw4Q0FBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4Q0FBTTtBQUNkO0FBQ0E7QUFDQSxXQUFXLDhFQUFpQztBQUM1QyxRQUFRLDhDQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBLHNFQUFzRSxnRkFBK0I7QUFDckc7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxnRkFBK0I7QUFDbEUsS0FBSztBQUNMOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCLDhFQUE4RSxzRUFBc0I7QUFDcEc7QUFDQTtBQUNBLDZDQUE2QywwRkFBcUM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFFQUFrQjtBQUNyQztBQUNBLGdDQUFnQyxzRkFBK0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw2QkFBNkIsd0VBQWlCO0FBQzlDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0VBQWlCO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0IsMENBQTBDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsc0VBQXNCO0FBQ3JGLHVGQUF1RixzRUFBdUI7QUFDOUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxzRUFBc0I7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCLHNFQUF1QjtBQUN4QztBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCLGtFQUFrRSxzRUFBc0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHVGQUFvQztBQUM5RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUUsc0VBQXNCLGNBQWMsdUVBQXVCO0FBQzVILG1CQUFtQixzRUFBdUI7QUFDMUMsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9ELG1CQUFtQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUIsaUJBQWlCLHFFQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxRQUFRLG1DQUFtQyxzREFBTTtBQUNqRDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUIsa0VBQWtFLHNFQUFzQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSCxtRkFBb0M7QUFDOUo7QUFDQSxtQkFBbUIsc0VBQXVCO0FBQzFDLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMENBQTBDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QiwwREFBMEQsc0VBQXNCLGNBQWMsd0VBQXdCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHLG1GQUFvQztBQUNsSjtBQUNBLG1CQUFtQixzRUFBdUI7QUFDMUMsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBLGFBQWEseURBQVk7QUFDekIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBNkM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUIsc0JBQXNCLHlEQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxtRkFBbUM7QUFDN0YsS0FBSztBQUNMOztBQUVBO0FBQ0Esd0JBQXdCLDZEQUE2RDtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1GQUFtQztBQUNuRSxXQUFXLDhFQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUE4QztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0NBQXdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0Esd0JBQXdCLHVDQUF1QztBQUMvRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsMkVBQTJFO0FBQy9GO0FBQ0EsaUJBQWlCLGdDQUFnQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUIsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1EQUFxQjtBQUNqRDtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0IsK0NBQStDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtGQUFlOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpQ0FBaUMseURBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0Esd0JBQXdCLHVDQUF1QztBQUMvRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0Isb0NBQW9DO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCLDBCQUEwQiw2RUFBNkI7QUFDdkQsK0VBQStFO0FBQy9FLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHdCQUF3QixvQ0FBb0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0Isd0NBQXdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCLHVCQUF1QiwrQ0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RyxzRUFBc0I7QUFDbkk7QUFDQTtBQUNBLG1CQUFtQix1REFBUztBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLG1GQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osOERBQThELHNFQUFzQixjQUFjLHdFQUF3QjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkVBQTJCO0FBQ2pELFFBQVE7QUFDUix5QkFBeUIsdURBQVcsQ0FBQyw4Q0FBTSxxQ0FBcUMsbUZBQWlCO0FBQ2pHO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSw2QkFBNkIsdURBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0Esd0JBQXdCLDJFQUEyQiw0SUFBNEksc0VBQXNCLDBJQUEwSSxzRUFBc0I7QUFDclg7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBLHlCQUF5Qiw0RUFBNEI7QUFDckQ7QUFDQSw2QkFBNkIsbUZBQW1DO0FBQ2hFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxzRUFBc0I7QUFDM0UsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtEQUFrRCw0REFBYTtBQUMvRDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLDZEQUE2RCxzRUFBc0I7QUFDbkY7QUFDQSxnQkFBZ0IsOERBQVcsa0NBQWtDLHNFQUF1QjtBQUNwRixNQUFNO0FBQ04scURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBLG1CQUFtQiw4REFBVzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhEQUFXLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCLG1CQUFtQiw4REFBVztBQUM5QixtQkFBbUIsOERBQVc7QUFDOUIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQWlCO0FBQzVCO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxvQkFBb0IsbUZBQWlCO0FBQ3JDO0FBQ0EsY0FBYyxzRUFBbUI7QUFDakM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELDhEQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOERBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxpQkFBaUIsOERBQWdCO0FBQ2pDLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxPQUFPLHNFQUFzQjtBQUNwQyw4QkFBOEIsdURBQVMsK0NBQStDLHFEQUFPO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRkFBaUI7QUFDNUIsc0RBQXNELHNFQUFzQjtBQUM1RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRkFBZSwrQkFBK0Isc0RBQWMsV0FBVyxzREFBYztBQUN6RjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEVBQXVCO0FBQ3BDLDZCQUE2QixnRkFBZ0M7QUFDN0Q7QUFDQSxhQUFhLDBFQUF1QjtBQUNwQyw2QkFBNkIsZ0ZBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixzRUFBc0IseUJBQXlCLGtGQUFrQzs7QUFFeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDJCQUEyQixxRkFBcUM7QUFDaEU7QUFDQSxVQUFVO0FBQ1Ysb0JBQW9CLDRFQUFlLENBQUMsd0VBQXFCO0FBQ3pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUZBQW1DLGdDQUFnQyxtRkFBbUM7QUFDM0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlFQUFlLHdCQUF3QixpRUFBZTtBQUM3RixrQkFBa0IsNEVBQWUsQ0FBQyx3RUFBcUI7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRFQUFlLENBQUMsd0VBQXFCO0FBQ3pELFVBQVU7QUFDVixvQkFBb0IsNEVBQWUsQ0FBQyx3RUFBcUI7QUFDekQsVUFBVTtBQUNWLG9CQUFvQiw0RUFBZSxDQUFDLHdFQUFxQjtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsd0VBQXFCLDZDQUE2Qyx3RUFBcUI7QUFDcE0sZ0JBQWdCLDRFQUFlO0FBQy9CO0FBQ0E7QUFDQSxXQUFXLG1GQUFtQztBQUM5QyxrQkFBa0IsNEVBQWUsQ0FBQyx3RUFBcUI7QUFDdkQsV0FBVyxtRkFBbUM7QUFDOUMsa0JBQWtCLDRFQUFlLENBQUMsd0VBQXFCO0FBQ3ZELFdBQVcsbUZBQW1DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRFQUFlLENBQUMsd0VBQXFCO0FBQ3ZELFdBQVcsbUZBQW1DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRFQUFlLENBQUMsd0VBQXFCO0FBQ3ZELFdBQVcsbUZBQW1DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRFQUFlLENBQUMsd0VBQXFCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEVBQWUsQ0FBQyx3RUFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0VBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxzRUFBc0I7QUFDaEk7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkVBQTJCO0FBQ3BDLHFCQUFxQixvRUFBaUI7QUFDdEM7QUFDQSxTQUFTLDJFQUEyQjtBQUNwQyxxQkFBcUIsb0VBQWlCO0FBQ3RDO0FBQ0E7QUFDQSxxQkFBcUIsb0VBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywrRUFBK0I7QUFDeEMscUJBQXFCLG9FQUFpQjtBQUN0QztBQUNBLFNBQVMsK0VBQStCO0FBQ3hDLHFCQUFxQixvRUFBaUI7QUFDdEM7QUFDQSxTQUFTLCtFQUErQjtBQUN4QyxxQkFBcUIsb0VBQWlCO0FBQ3RDO0FBQ0EsU0FBUywrRUFBK0I7QUFDeEMscUJBQXFCLG9FQUFpQjtBQUN0QztBQUNBLFNBQVMsK0VBQStCO0FBQ3hDLHFCQUFxQixvRUFBaUI7QUFDdEM7QUFDQSxTQUFTLCtFQUErQjtBQUN4QyxxQkFBcUIsb0VBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc3Rlcmljcy1ncmlkLy4vbm9kZV9tb2R1bGVzL21hdHJpeC1qcy1zZGsvbGliL3J1c3QtY3J5cHRvL3J1c3QtY3J5cHRvLmpzPzM4ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9hc3luY1RvR2VuZXJhdG9yIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLypcbkNvcHlyaWdodCAyMDIyLTIwMjMgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgYW5vdGhlcmpzb24gZnJvbSBcImFub3RoZXItanNvblwiO1xuaW1wb3J0ICogYXMgUnVzdFNka0NyeXB0b0pzIGZyb20gXCJAbWF0cml4LW9yZy9tYXRyaXgtc2RrLWNyeXB0by13YXNtXCI7XG5pbXBvcnQgeyBLbm93bk1lbWJlcnNoaXAgfSBmcm9tIFwiLi4vQHR5cGVzL21lbWJlcnNoaXAuanNcIjtcbmltcG9ydCB7IE1hdHJpeEV2ZW50RXZlbnQgfSBmcm9tIFwiLi4vbW9kZWxzL2V2ZW50LmpzXCI7XG5pbXBvcnQgeyBEZWNyeXB0aW9uRXJyb3IgfSBmcm9tIFwiLi4vY29tbW9uLWNyeXB0by9DcnlwdG9CYWNrZW5kLmpzXCI7XG5pbXBvcnQgeyBsb2dnZXIsIExvZ1NwYW4gfSBmcm9tIFwiLi4vbG9nZ2VyLmpzXCI7XG5pbXBvcnQgeyBNZXRob2QgfSBmcm9tIFwiLi4vaHR0cC1hcGkvaW5kZXguanNcIjtcbmltcG9ydCB7IFJvb21FbmNyeXB0b3IgfSBmcm9tIFwiLi9Sb29tRW5jcnlwdG9yLmpzXCI7XG5pbXBvcnQgeyBPdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IgfSBmcm9tIFwiLi9PdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IuanNcIjtcbmltcG9ydCB7IEtleUNsYWltTWFuYWdlciB9IGZyb20gXCIuL0tleUNsYWltTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgbG9nRHVyYXRpb24sIE1hcFdpdGhEZWZhdWx0IH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBDcm9zc1NpZ25pbmdLZXksIERlY3J5cHRpb25GYWlsdXJlQ29kZSwgRGV2aWNlVmVyaWZpY2F0aW9uU3RhdHVzLCBFdmVudFNoaWVsZENvbG91ciwgRXZlbnRTaGllbGRSZWFzb24sIFVzZXJWZXJpZmljYXRpb25TdGF0dXMsIGVuY29kZVJlY292ZXJ5S2V5LCBkZXJpdmVSZWNvdmVyeUtleUZyb21QYXNzcGhyYXNlLCBBbGxEZXZpY2VzSXNvbGF0aW9uTW9kZSwgRGV2aWNlSXNvbGF0aW9uTW9kZUtpbmQsIENyeXB0b0V2ZW50IH0gZnJvbSBcIi4uL2NyeXB0by1hcGkvaW5kZXguanNcIjtcbmltcG9ydCB7IGRldmljZUtleXNUb0RldmljZU1hcCwgcnVzdERldmljZVRvSnNEZXZpY2UgfSBmcm9tIFwiLi9kZXZpY2UtY29udmVydGVyLmpzXCI7XG5pbXBvcnQgeyBTRUNSRVRfU1RPUkFHRV9BTEdPUklUSE1fVjFfQUVTIH0gZnJvbSBcIi4uL3NlY3JldC1zdG9yYWdlLmpzXCI7XG5pbXBvcnQgeyBDcm9zc1NpZ25pbmdJZGVudGl0eSB9IGZyb20gXCIuL0Nyb3NzU2lnbmluZ0lkZW50aXR5LmpzXCI7XG5pbXBvcnQgeyBzZWNyZXRTdG9yYWdlQ2FuQWNjZXNzU2VjcmV0cywgc2VjcmV0U3RvcmFnZUNvbnRhaW5zQ3Jvc3NTaWduaW5nS2V5cyB9IGZyb20gXCIuL3NlY3JldC1zdG9yYWdlLmpzXCI7XG5pbXBvcnQgeyBpc1ZlcmlmaWNhdGlvbkV2ZW50LCBSdXN0VmVyaWZpY2F0aW9uUmVxdWVzdCwgdmVyaWZpY2F0aW9uTWV0aG9kSWRlbnRpZmllclRvTWV0aG9kIH0gZnJvbSBcIi4vdmVyaWZpY2F0aW9uLmpzXCI7XG5pbXBvcnQgeyBFdmVudFR5cGUsIE1zZ1R5cGUgfSBmcm9tIFwiLi4vQHR5cGVzL2V2ZW50LmpzXCI7XG5pbXBvcnQgeyBUeXBlZEV2ZW50RW1pdHRlciB9IGZyb20gXCIuLi9tb2RlbHMvdHlwZWQtZXZlbnQtZW1pdHRlci5qc1wiO1xuaW1wb3J0IHsgZGVjcnlwdGlvbktleU1hdGNoZXNLZXlCYWNrdXBJbmZvLCBSdXN0QmFja3VwTWFuYWdlciB9IGZyb20gXCIuL2JhY2t1cC5qc1wiO1xuaW1wb3J0IHsgVHlwZWRSZUVtaXR0ZXIgfSBmcm9tIFwiLi4vUmVFbWl0dGVyLmpzXCI7XG5pbXBvcnQgeyBzZWN1cmVSYW5kb21TdHJpbmcgfSBmcm9tIFwiLi4vcmFuZG9tc3RyaW5nLmpzXCI7XG5pbXBvcnQgeyBDbGllbnRTdG9wcGVkRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBkZWNvZGVCYXNlNjQsIGVuY29kZUJhc2U2NCB9IGZyb20gXCIuLi9iYXNlNjQuanNcIjtcbmltcG9ydCB7IE91dGdvaW5nUmVxdWVzdHNNYW5hZ2VyIH0gZnJvbSBcIi4vT3V0Z29pbmdSZXF1ZXN0c01hbmFnZXIuanNcIjtcbmltcG9ydCB7IFBlclNlc3Npb25LZXlCYWNrdXBEb3dubG9hZGVyIH0gZnJvbSBcIi4vUGVyU2Vzc2lvbktleUJhY2t1cERvd25sb2FkZXIuanNcIjtcbmltcG9ydCB7IERlaHlkcmF0ZWREZXZpY2VNYW5hZ2VyIH0gZnJvbSBcIi4vRGVoeWRyYXRlZERldmljZU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IFZlcmlmaWNhdGlvbk1ldGhvZCB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuaW1wb3J0IHsga2V5RnJvbUF1dGhEYXRhIH0gZnJvbSBcIi4uL2NvbW1vbi1jcnlwdG8va2V5LXBhc3NwaHJhc2UuanNcIjtcbnZhciBBTExfVkVSSUZJQ0FUSU9OX01FVEhPRFMgPSBbVmVyaWZpY2F0aW9uTWV0aG9kLlNhcywgVmVyaWZpY2F0aW9uTWV0aG9kLlNjYW5RckNvZGUsIFZlcmlmaWNhdGlvbk1ldGhvZC5TaG93UXJDb2RlLCBWZXJpZmljYXRpb25NZXRob2QuUmVjaXByb2NhdGVdO1xuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ3J5cHRvQmFja2VuZH0gdXNpbmcgdGhlIFJ1c3QgbWF0cml4LXNkay1jcnlwdG8uXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBSdXN0Q3J5cHRvIGV4dGVuZHMgVHlwZWRFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIsIC8qKiBUaGUgYE9sbU1hY2hpbmVgIGZyb20gdGhlIHVuZGVybHlpbmcgcnVzdCBjcnlwdG8gc2RrLiAqL1xuICBvbG1NYWNoaW5lLFxuICAvKipcbiAgICogTG93LWxldmVsIEhUVFAgaW50ZXJmYWNlOiB1c2VkIHRvIG1ha2Ugb3V0Z29pbmcgcmVxdWVzdHMgcmVxdWlyZWQgYnkgdGhlIHJ1c3QgU0RLLlxuICAgKlxuICAgKiBXZSBleHBlY3QgaXQgdG8gc2V0IHRoZSBhY2Nlc3MgdG9rZW4sIGV0Yy5cbiAgICovXG4gIGh0dHAsIC8qKiBUaGUgbG9jYWwgdXNlcidzIFVzZXIgSUQuICovXG4gIHVzZXJJZCwgLyoqIFRoZSBsb2NhbCB1c2VyJ3MgRGV2aWNlIElELiAqL1xuICBfZGV2aWNlSWQsIC8qKiBJbnRlcmZhY2UgdG8gc2VydmVyLXNpZGUgc2VjcmV0IHN0b3JhZ2UgKi9cbiAgc2VjcmV0U3RvcmFnZSwgLyoqIENyeXB0byBjYWxsYmFja3MgcHJvdmlkZWQgYnkgdGhlIGFwcGxpY2F0aW9uICovXG4gIGNyeXB0b0NhbGxiYWNrcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy5vbG1NYWNoaW5lID0gb2xtTWFjaGluZTtcbiAgICB0aGlzLmh0dHAgPSBodHRwO1xuICAgIHRoaXMudXNlcklkID0gdXNlcklkO1xuICAgIHRoaXMuc2VjcmV0U3RvcmFnZSA9IHNlY3JldFN0b3JhZ2U7XG4gICAgdGhpcy5jcnlwdG9DYWxsYmFja3MgPSBjcnlwdG9DYWxsYmFja3M7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHVzZSB3aGVuIGRlcml2aW5nIGEgcmVjb3Zlcnkga2V5IGZyb20gYSBwYXNzcGhyYXNlLlxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIlJFQ09WRVJZX0tFWV9ERVJJVkFUSU9OX0lURVJBVElPTlNcIiwgNTAwMDAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdHJ1c3RDcm9zc1NpZ25lZERldmljZXNcIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGV2aWNlSXNvbGF0aW9uTW9kZVwiLCBuZXcgQWxsRGV2aWNlc0lzb2xhdGlvbk1vZGUoZmFsc2UpKTtcbiAgICAvKiogd2hldGhlciB7QGxpbmsgc3RvcH0gaGFzIGJlZW4gY2FsbGVkICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcHBlZFwiLCBmYWxzZSk7XG4gICAgLyoqIG1hcHBpbmcgb2Ygcm9vbUlkIOKGkiBlbmNyeXB0b3IgY2xhc3MgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb29tRW5jcnlwdG9yc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnREZWNyeXB0b3JcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlDbGFpbU1hbmFnZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3JcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjcm9zc1NpZ25pbmdJZGVudGl0eVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhY2t1cE1hbmFnZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdXRnb2luZ1JlcXVlc3RzTWFuYWdlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBlclNlc3Npb25CYWNrdXBEb3dubG9hZGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVoeWRyYXRlZERldmljZU1hbmFnZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWVtaXR0ZXJcIiwgbmV3IFR5cGVkUmVFbWl0dGVyKHRoaXMpKTtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy9cbiAgICAvLyBDcnlwdG9BcGkgaW1wbGVtZW50YXRpb25cbiAgICAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnbG9iYWxCbGFja2xpc3RVbnZlcmlmaWVkRGV2aWNlc1wiLCBmYWxzZSk7XG4gICAgLyoqXG4gICAgICogVGhlIHZlcmlmaWNhdGlvbiBtZXRob2RzIHdlIG9mZmVyIHRvIHRoZSBvdGhlciBzaWRlIGR1cmluZyBhbiBpbnRlcmFjdGl2ZSB2ZXJpZmljYXRpb24uXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N1cHBvcnRlZFZlcmlmaWNhdGlvbk1ldGhvZHNcIiwgQUxMX1ZFUklGSUNBVElPTl9NRVRIT0RTKTtcbiAgICB0aGlzLm91dGdvaW5nUmVxdWVzdFByb2Nlc3NvciA9IG5ldyBPdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3Iob2xtTWFjaGluZSwgaHR0cCk7XG4gICAgdGhpcy5vdXRnb2luZ1JlcXVlc3RzTWFuYWdlciA9IG5ldyBPdXRnb2luZ1JlcXVlc3RzTWFuYWdlcih0aGlzLmxvZ2dlciwgb2xtTWFjaGluZSwgdGhpcy5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IpO1xuICAgIHRoaXMua2V5Q2xhaW1NYW5hZ2VyID0gbmV3IEtleUNsYWltTWFuYWdlcihvbG1NYWNoaW5lLCB0aGlzLm91dGdvaW5nUmVxdWVzdFByb2Nlc3Nvcik7XG4gICAgdGhpcy5iYWNrdXBNYW5hZ2VyID0gbmV3IFJ1c3RCYWNrdXBNYW5hZ2VyKG9sbU1hY2hpbmUsIGh0dHAsIHRoaXMub3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yKTtcbiAgICB0aGlzLnBlclNlc3Npb25CYWNrdXBEb3dubG9hZGVyID0gbmV3IFBlclNlc3Npb25LZXlCYWNrdXBEb3dubG9hZGVyKHRoaXMubG9nZ2VyLCB0aGlzLm9sbU1hY2hpbmUsIHRoaXMuaHR0cCwgdGhpcy5iYWNrdXBNYW5hZ2VyKTtcbiAgICB0aGlzLmRlaHlkcmF0ZWREZXZpY2VNYW5hZ2VyID0gbmV3IERlaHlkcmF0ZWREZXZpY2VNYW5hZ2VyKHRoaXMubG9nZ2VyLCBvbG1NYWNoaW5lLCBodHRwLCB0aGlzLm91dGdvaW5nUmVxdWVzdFByb2Nlc3Nvciwgc2VjcmV0U3RvcmFnZSk7XG4gICAgdGhpcy5ldmVudERlY3J5cHRvciA9IG5ldyBFdmVudERlY3J5cHRvcih0aGlzLmxvZ2dlciwgb2xtTWFjaGluZSwgdGhpcy5wZXJTZXNzaW9uQmFja3VwRG93bmxvYWRlcik7XG5cbiAgICAvLyByZS1lbWl0IHRoZSBldmVudHMgZW1pdHRlZCBieSBtYW5hZ2Vyc1xuICAgIHRoaXMucmVlbWl0dGVyLnJlRW1pdCh0aGlzLmJhY2t1cE1hbmFnZXIsIFtDcnlwdG9FdmVudC5LZXlCYWNrdXBTdGF0dXMsIENyeXB0b0V2ZW50LktleUJhY2t1cFNlc3Npb25zUmVtYWluaW5nLCBDcnlwdG9FdmVudC5LZXlCYWNrdXBGYWlsZWQsIENyeXB0b0V2ZW50LktleUJhY2t1cERlY3J5cHRpb25LZXlDYWNoZWRdKTtcbiAgICB0aGlzLnJlZW1pdHRlci5yZUVtaXQodGhpcy5kZWh5ZHJhdGVkRGV2aWNlTWFuYWdlciwgW0NyeXB0b0V2ZW50LkRlaHlkcmF0ZWREZXZpY2VDcmVhdGVkLCBDcnlwdG9FdmVudC5EZWh5ZHJhdGVkRGV2aWNlVXBsb2FkZWQsIENyeXB0b0V2ZW50LlJlaHlkcmF0aW9uU3RhcnRlZCwgQ3J5cHRvRXZlbnQuUmVoeWRyYXRpb25Qcm9ncmVzcywgQ3J5cHRvRXZlbnQuUmVoeWRyYXRpb25Db21wbGV0ZWQsIENyeXB0b0V2ZW50LlJlaHlkcmF0aW9uRXJyb3IsIENyeXB0b0V2ZW50LkRlaHlkcmF0aW9uS2V5Q2FjaGVkLCBDcnlwdG9FdmVudC5EZWh5ZHJhdGVkRGV2aWNlUm90YXRpb25FcnJvcl0pO1xuICAgIHRoaXMuY3Jvc3NTaWduaW5nSWRlbnRpdHkgPSBuZXcgQ3Jvc3NTaWduaW5nSWRlbnRpdHkob2xtTWFjaGluZSwgdGhpcy5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IsIHNlY3JldFN0b3JhZ2UpO1xuXG4gICAgLy8gQ2hlY2sgYW5kIHN0YXJ0IGluIGJhY2tncm91bmQgdGhlIGtleSBiYWNrdXAgY29ubmVjdGlvblxuICAgIHRoaXMuY2hlY2tLZXlCYWNrdXBBbmRFbmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIE9sbU1hY2hpbmUgb25seSBpZiB7QGxpbmsgUnVzdENyeXB0byNzdG9wfSBoYXMgbm90IGJlZW4gY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIGFsbG93cyB1cyB0byBiZXR0ZXIgaGFuZGxlIHJhY2UgY29uZGl0aW9ucyB3aGVyZSB0aGUgY2xpZW50IGlzIHN0b3BwZWQgYmVmb3JlIG9yIGR1cmluZyBhIGNyeXB0byBBUEkgY2FsbC5cbiAgICpcbiAgICogQHRocm93cyBDbGllbnRTdG9wcGVkRXJyb3IgaWYge0BsaW5rIFJ1c3RDcnlwdG8jc3RvcH0gaGFzIGJlZW4gY2FsbGVkLlxuICAgKi9cbiAgZ2V0T2xtTWFjaGluZU9yVGhyb3coKSB7XG4gICAgaWYgKHRoaXMuc3RvcHBlZCkge1xuICAgICAgdGhyb3cgbmV3IENsaWVudFN0b3BwZWRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vbG1NYWNoaW5lO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvL1xuICAvLyBDcnlwdG9CYWNrZW5kIGltcGxlbWVudGF0aW9uXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBzZXQgZ2xvYmFsRXJyb3JPblVua25vd25EZXZpY2VzKF92KSB7XG4gICAgLy8gTm90IGltcGxlbWVudGVkIGZvciBydXN0IGNyeXB0by5cbiAgfVxuICBnZXQgZ2xvYmFsRXJyb3JPblVua25vd25EZXZpY2VzKCkge1xuICAgIC8vIE5vdCBpbXBsZW1lbnRlZCBmb3IgcnVzdCBjcnlwdG8uXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgLy8gc3RvcCgpIG1heSBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIGJ1dCBhdHRlbXB0aW5nIHRvIGNsb3NlKCkgdGhlIE9sbU1hY2hpbmUgdHdpY2VcbiAgICAvLyB3aWxsIGNhdXNlIGFuIGVycm9yLlxuICAgIGlmICh0aGlzLnN0b3BwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICB0aGlzLmtleUNsYWltTWFuYWdlci5zdG9wKCk7XG4gICAgdGhpcy5iYWNrdXBNYW5hZ2VyLnN0b3AoKTtcbiAgICB0aGlzLm91dGdvaW5nUmVxdWVzdHNNYW5hZ2VyLnN0b3AoKTtcbiAgICB0aGlzLnBlclNlc3Npb25CYWNrdXBEb3dubG9hZGVyLnN0b3AoKTtcbiAgICB0aGlzLmRlaHlkcmF0ZWREZXZpY2VNYW5hZ2VyLnN0b3AoKTtcblxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBjbG9zZSgpIHRoZSBPbG1NYWNoaW5lOyBkb2luZyBzbyBtZWFucyB0aGF0IGFsbCB0aGUgUnVzdCBvYmplY3RzIHdpbGwgYmVcbiAgICAvLyBjbGVhbmVkIHVwOyBpbiBwYXJ0aWN1bGFyLCB0aGUgaW5kZXhlZGRiIGNvbm5lY3Rpb25zIHdpbGwgYmUgY2xvc2VkLCB3aGljaCBtZWFucyB0aGV5XG4gICAgLy8gY2FuIHRoZW4gYmUgZGVsZXRlZC5cbiAgICB0aGlzLm9sbU1hY2hpbmUuY2xvc2UoKTtcbiAgfVxuICBlbmNyeXB0RXZlbnQoZXZlbnQsIF9yb29tKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciByb29tSWQgPSBldmVudC5nZXRSb29tSWQoKTtcbiAgICAgIHZhciBlbmNyeXB0b3IgPSBfdGhpcy5yb29tRW5jcnlwdG9yc1tyb29tSWRdO1xuICAgICAgaWYgKCFlbmNyeXB0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGVuY3J5cHQgZXZlbnQgaW4gdW5jb25maWd1cmVkIHJvb20gXCIuY29uY2F0KHJvb21JZCkpO1xuICAgICAgfVxuICAgICAgeWllbGQgZW5jcnlwdG9yLmVuY3J5cHRFdmVudChldmVudCwgX3RoaXMuZ2xvYmFsQmxhY2tsaXN0VW52ZXJpZmllZERldmljZXMsIF90aGlzLmRldmljZUlzb2xhdGlvbk1vZGUpO1xuICAgIH0pKCk7XG4gIH1cbiAgZGVjcnlwdEV2ZW50KGV2ZW50KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgcm9vbUlkID0gZXZlbnQuZ2V0Um9vbUlkKCk7XG4gICAgICBpZiAoIXJvb21JZCkge1xuICAgICAgICAvLyBwcmVzdW1hYmx5LCBhIHRvLWRldmljZSBtZXNzYWdlLiBUaGVzZSBhcmUgbm9ybWFsbHkgZGVjcnlwdGVkIGluIHByZXByb2Nlc3NUb0RldmljZU1lc3NhZ2VzXG4gICAgICAgIC8vIHNvIHRoZSBmYWN0IGl0IGhhcyBjb21lIGJhY2sgaGVyZSBzdWdnZXN0cyB0aGF0IGRlY3J5cHRpb24gZmFpbGVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBvbmNlIHdlIGRyb3Agc3VwcG9ydCBmb3IgdGhlIGxpYm9sbSBjcnlwdG8gaW1wbGVtZW50YXRpb24sIHdlIGNhbiBzdG9wIHBhc3NpbmcgdG8tZGV2aWNlIG1lc3NhZ2VzXG4gICAgICAgIC8vIHRocm91Z2ggZGVjcnlwdEV2ZW50IGFuZCBoZW5jZSBnZXQgcmlkIG9mIHRoaXMgY2FzZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG8tZGV2aWNlIGV2ZW50IHdhcyBub3QgZGVjcnlwdGVkIGluIHByZXByb2Nlc3NUb0RldmljZU1lc3NhZ2VzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHlpZWxkIF90aGlzMi5ldmVudERlY3J5cHRvci5hdHRlbXB0RXZlbnREZWNyeXB0aW9uKGV2ZW50LCBfdGhpczIuZGV2aWNlSXNvbGF0aW9uTW9kZSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiAoZGVwcmVjYXRlZCkge0BsaW5rIE1hdHJpeENsaWVudCNnZXRFdmVudEVuY3J5cHRpb25JbmZvfS5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gZXZlbnQgdG8gaW5zcGVjdFxuICAgKi9cbiAgZ2V0RXZlbnRFbmNyeXB0aW9uSW5mbyhldmVudCkge1xuICAgIHZhciBfZXZlbnQkZ2V0U2VuZGVyS2V5O1xuICAgIHZhciByZXQgPSB7fTtcbiAgICByZXQuc2VuZGVyS2V5ID0gKF9ldmVudCRnZXRTZW5kZXJLZXkgPSBldmVudC5nZXRTZW5kZXJLZXkoKSkgIT09IG51bGwgJiYgX2V2ZW50JGdldFNlbmRlcktleSAhPT0gdm9pZCAwID8gX2V2ZW50JGdldFNlbmRlcktleSA6IHVuZGVmaW5lZDtcbiAgICByZXQuYWxnb3JpdGhtID0gZXZlbnQuZ2V0V2lyZUNvbnRlbnQoKS5hbGdvcml0aG07XG4gICAgaWYgKCFyZXQuc2VuZGVyS2V5IHx8ICFyZXQuYWxnb3JpdGhtKSB7XG4gICAgICByZXQuZW5jcnlwdGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXQuZW5jcnlwdGVkID0gdHJ1ZTtcbiAgICByZXQuYXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgcmV0Lm1pc21hdGNoZWRTZW5kZXIgPSB0cnVlO1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0JhY2tlbmQjY2hlY2tVc2VyVHJ1c3R9LlxuICAgKlxuICAgKiBTdHViIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICpcbiAgICovXG4gIGNoZWNrVXNlclRydXN0KHVzZXJJZCkge1xuICAgIHJldHVybiBuZXcgVXNlclZlcmlmaWNhdGlvblN0YXR1cyhmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNyb3NzIHNpZ25pbmcgaW5mb3JtYXRpb24gZm9yIGEgZ2l2ZW4gdXNlci5cbiAgICpcbiAgICogVGhlIGNyb3NzLXNpZ25pbmcgQVBJIGlzIGN1cnJlbnRseSBVTlNUQUJMRSBhbmQgbWF5IGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJJZCAtIHRoZSB1c2VyIElEIHRvIGdldCB0aGUgY3Jvc3Mtc2lnbmluZyBpbmZvIGZvci5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNyb3NzIHNpZ25pbmcgaW5mb3JtYXRpb24gZm9yIHRoZSB1c2VyLlxuICAgKi9cbiAgZ2V0U3RvcmVkQ3Jvc3NTaWduaW5nRm9yVXNlcih1c2VySWQpIHtcbiAgICAvLyBUT0RPXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB1bm5lZWRlZCBmb3IgdGhlIHJ1c3QtY3J5cHRvLlxuICAgKiBUaGUgY3Jvc3Mgc2lnbmluZyBrZXkgaW1wb3J0IGFuZCB0aGUgZGV2aWNlIHZlcmlmaWNhdGlvbiBhcmUgZG9uZSBpbiB7QGxpbmsgQ3J5cHRvQXBpI2Jvb3RzdHJhcENyb3NzU2lnbmluZ31cbiAgICpcbiAgICogVGhlIGZ1bmN0aW9uIGlzIHN0dWIgdG8ga2VlcCB0aGUgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBvbGQgY3J5cHRvLlxuICAgKiBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vdmVjdG9yLWltL2VsZW1lbnQtd2ViL2lzc3Vlcy8yNTY0OFxuICAgKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ3J5cHRvQmFja2VuZCNjaGVja093bkNyb3NzU2lnbmluZ1RydXN0fVxuICAgKi9cbiAgY2hlY2tPd25Dcm9zc1NpZ25pbmdUcnVzdCgpIHtcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9CYWNrZW5kI2dldEJhY2t1cERlY3J5cHRvcn0uXG4gICAqL1xuICBnZXRCYWNrdXBEZWNyeXB0b3IoYmFja3VwSW5mbywgcHJpdktleSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCEocHJpdktleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImdldEJhY2t1cERlY3J5cHRvcjogZXhwZWN0cyBVaW50OEFycmF5XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGJhY2t1cEluZm8uYWxnb3JpdGhtICE9IFwibS5tZWdvbG1fYmFja3VwLnYxLmN1cnZlMjU1MTktYWVzLXNoYTJcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRCYWNrdXBEZWNyeXB0b3I6IFVuc3VwcG9ydGVkIGFsZ29yaXRobSBcIi5jb25jYXQoYmFja3VwSW5mby5hbGdvcml0aG0pKTtcbiAgICAgIH1cbiAgICAgIHZhciBiYWNrdXBEZWNyeXB0aW9uS2V5ID0gUnVzdFNka0NyeXB0b0pzLkJhY2t1cERlY3J5cHRpb25LZXkuZnJvbUJhc2U2NChlbmNvZGVCYXNlNjQocHJpdktleSkpO1xuICAgICAgaWYgKCFkZWNyeXB0aW9uS2V5TWF0Y2hlc0tleUJhY2t1cEluZm8oYmFja3VwRGVjcnlwdGlvbktleSwgYmFja3VwSW5mbykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0QmFja3VwRGVjcnlwdG9yOiBrZXkgYmFja3VwIG9uIHNlcnZlciBkb2VzIG5vdCBtYXRjaCB0aGUgZGVjcnlwdGlvbiBrZXlcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXMzLmJhY2t1cE1hbmFnZXIuY3JlYXRlQmFja3VwRGVjcnlwdG9yKGJhY2t1cERlY3J5cHRpb25LZXkpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0JhY2tlbmQjaW1wb3J0QmFja2VkVXBSb29tS2V5c30uXG4gICAqL1xuICBpbXBvcnRCYWNrZWRVcFJvb21LZXlzKGtleXMsIGJhY2t1cFZlcnNpb24sIG9wdHMpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB5aWVsZCBfdGhpczQuYmFja3VwTWFuYWdlci5pbXBvcnRCYWNrZWRVcFJvb21LZXlzKGtleXMsIGJhY2t1cFZlcnNpb24sIG9wdHMpO1xuICAgIH0pKCk7XG4gIH1cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjZ2V0VmVyc2lvbn0uXG4gICAqL1xuICBnZXRWZXJzaW9uKCkge1xuICAgIHZhciB2ZXJzaW9ucyA9IFJ1c3RTZGtDcnlwdG9Kcy5nZXRWZXJzaW9ucygpO1xuICAgIHJldHVybiBcIlJ1c3QgU0RLIFwiLmNvbmNhdCh2ZXJzaW9ucy5tYXRyaXhfc2RrX2NyeXB0bywgXCIgKFwiKS5jb25jYXQodmVyc2lvbnMuZ2l0X3NoYSwgXCIpLCBWb2RvemVtYWMgXCIpLmNvbmNhdCh2ZXJzaW9ucy52b2RvemVtYWMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjc2V0RGV2aWNlSXNvbGF0aW9uTW9kZX0uXG4gICAqL1xuICBzZXREZXZpY2VJc29sYXRpb25Nb2RlKGlzb2xhdGlvbk1vZGUpIHtcbiAgICB0aGlzLmRldmljZUlzb2xhdGlvbk1vZGUgPSBpc29sYXRpb25Nb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjaXNFbmNyeXB0aW9uRW5hYmxlZEluUm9vbX0uXG4gICAqL1xuICBpc0VuY3J5cHRpb25FbmFibGVkSW5Sb29tKHJvb21JZCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHJvb21TZXR0aW5ncyA9IHlpZWxkIF90aGlzNS5vbG1NYWNoaW5lLmdldFJvb21TZXR0aW5ncyhuZXcgUnVzdFNka0NyeXB0b0pzLlJvb21JZChyb29tSWQpKTtcbiAgICAgIHJldHVybiBCb29sZWFuKHJvb21TZXR0aW5ncyA9PT0gbnVsbCB8fCByb29tU2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvb21TZXR0aW5ncy5hbGdvcml0aG0pO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNnZXRPd25EZXZpY2VLZXlzfS5cbiAgICovXG4gIGdldE93bkRldmljZUtleXMoKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIga2V5cyA9IF90aGlzNi5vbG1NYWNoaW5lLmlkZW50aXR5S2V5cztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVkMjU1MTk6IGtleXMuZWQyNTUxOS50b0Jhc2U2NCgpLFxuICAgICAgICBjdXJ2ZTI1NTE5OiBrZXlzLmN1cnZlMjU1MTkudG9CYXNlNjQoKVxuICAgICAgfTtcbiAgICB9KSgpO1xuICB9XG4gIHByZXBhcmVUb0VuY3J5cHQocm9vbSkge1xuICAgIHZhciBlbmNyeXB0b3IgPSB0aGlzLnJvb21FbmNyeXB0b3JzW3Jvb20ucm9vbUlkXTtcbiAgICBpZiAoZW5jcnlwdG9yKSB7XG4gICAgICBlbmNyeXB0b3IucHJlcGFyZUZvckVuY3J5cHRpb24odGhpcy5nbG9iYWxCbGFja2xpc3RVbnZlcmlmaWVkRGV2aWNlcywgdGhpcy5kZXZpY2VJc29sYXRpb25Nb2RlKTtcbiAgICB9XG4gIH1cbiAgZm9yY2VEaXNjYXJkU2Vzc2lvbihyb29tSWQpIHtcbiAgICB2YXIgX3RoaXMkcm9vbUVuY3J5cHRvcnMkO1xuICAgIHJldHVybiAoX3RoaXMkcm9vbUVuY3J5cHRvcnMkID0gdGhpcy5yb29tRW5jcnlwdG9yc1tyb29tSWRdKSA9PT0gbnVsbCB8fCBfdGhpcyRyb29tRW5jcnlwdG9ycyQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHJvb21FbmNyeXB0b3JzJC5mb3JjZURpc2NhcmRTZXNzaW9uKCk7XG4gIH1cbiAgZXhwb3J0Um9vbUtleXMoKSB7XG4gICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgcmF3ID0geWllbGQgX3RoaXM3Lm9sbU1hY2hpbmUuZXhwb3J0Um9vbUtleXMoKCkgPT4gdHJ1ZSk7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyYXcpO1xuICAgIH0pKCk7XG4gIH1cbiAgZXhwb3J0Um9vbUtleXNBc0pzb24oKSB7XG4gICAgdmFyIF90aGlzOCA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4geWllbGQgX3RoaXM4Lm9sbU1hY2hpbmUuZXhwb3J0Um9vbUtleXMoKCkgPT4gdHJ1ZSk7XG4gICAgfSkoKTtcbiAgfVxuICBpbXBvcnRSb29tS2V5cyhrZXlzLCBvcHRzKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4geWllbGQgX3RoaXM5LmJhY2t1cE1hbmFnZXIuaW1wb3J0Um9vbUtleXMoa2V5cywgb3B0cyk7XG4gICAgfSkoKTtcbiAgfVxuICBpbXBvcnRSb29tS2V5c0FzSnNvbihrZXlzLCBvcHRzKSB7XG4gICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHlpZWxkIF90aGlzMTAuYmFja3VwTWFuYWdlci5pbXBvcnRSb29tS2V5c0FzSnNvbihrZXlzLCBvcHRzKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkudXNlckhhc0Nyb3NzU2lnbmluZ0tleXN9LlxuICAgKi9cbiAgdXNlckhhc0Nyb3NzU2lnbmluZ0tleXMoKSB7XG4gICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHMsXG4gICAgICBfdGhpczExID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciB1c2VySWQgPSBfYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgX2FyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3VtZW50c1swXSA6IF90aGlzMTEudXNlcklkO1xuICAgICAgdmFyIGRvd25sb2FkVW5jYWNoZWQgPSBfYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgX2FyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgLy8gVE9ETzogY291bGQgcHJvYmFibHkgZG8gd2l0aCBhIG1vcmUgZWZmaWNpZW50IHdheSBvZiBkb2luZyB0aGlzIHRoYW4gcmV0dXJuaW5nIHRoZSB3aG9sZSBzZXQgYW5kIHNlYXJjaGluZ1xuICAgICAgdmFyIHJ1c3RUcmFja2VkVXNlcnMgPSB5aWVsZCBfdGhpczExLm9sbU1hY2hpbmUudHJhY2tlZFVzZXJzKCk7XG4gICAgICB2YXIgcnVzdFRyYWNrZWRVc2VyO1xuICAgICAgZm9yICh2YXIgdSBvZiBydXN0VHJhY2tlZFVzZXJzKSB7XG4gICAgICAgIGlmICh1c2VySWQgPT09IHUudG9TdHJpbmcoKSkge1xuICAgICAgICAgIHJ1c3RUcmFja2VkVXNlciA9IHU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChydXN0VHJhY2tlZFVzZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodXNlcklkID09PSBfdGhpczExLnVzZXJJZCkge1xuICAgICAgICAgIC8qIG1ha2Ugc3VyZSB3ZSBoYXZlIGFuICp1cC10by1kYXRlKiBpZGVhIG9mIHRoZSB1c2VyJ3MgY3Jvc3Mtc2lnbmluZyBrZXlzLiBUaGlzIGlzIGltcG9ydGFudCwgYmVjYXVzZSBpZiB3ZVxuICAgICAgICAgICAqIHJldHVybiBcImZhbHNlXCIgaGVyZSwgd2Ugd2lsbCBlbmQgdXAgZ2VuZXJhdGluZyBuZXcgY3Jvc3Mtc2lnbmluZyBrZXlzIGFuZCByZXBsYWNpbmcgdGhlIGV4aXN0aW5nIG9uZXMuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSBfdGhpczExLm9sbU1hY2hpbmUucXVlcnlLZXlzRm9yVXNlcnMoXG4gICAgICAgICAgLy8gY2xvbmUgYXMgcnVzdCBsYXllciB3aWxsIHRha2Ugb3duZXJzaGlwIGFuZCBpdCdzIHJldXNlZCBsYXRlclxuICAgICAgICAgIFtydXN0VHJhY2tlZFVzZXIuY2xvbmUoKV0pO1xuICAgICAgICAgIHlpZWxkIF90aGlzMTEub3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yLm1ha2VPdXRnb2luZ1JlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVzZXJJZGVudGl0eSA9IHlpZWxkIF90aGlzMTEub2xtTWFjaGluZS5nZXRJZGVudGl0eShydXN0VHJhY2tlZFVzZXIpO1xuICAgICAgICB1c2VySWRlbnRpdHkgPT09IG51bGwgfHwgdXNlcklkZW50aXR5ID09PSB2b2lkIDAgfHwgdXNlcklkZW50aXR5LmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHVzZXJJZGVudGl0eSAhPT0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChkb3dubG9hZFVuY2FjaGVkKSB7XG4gICAgICAgIHZhciBfa2V5UmVzdWx0JG1hc3Rlcl9rZXk7XG4gICAgICAgIC8vIERvd25sb2FkIHRoZSBjcm9zcyBzaWduaW5nIGtleXMgYW5kIGNoZWNrIGlmIHRoZSBtYXN0ZXIga2V5IGlzIGF2YWlsYWJsZVxuICAgICAgICB2YXIga2V5UmVzdWx0ID0geWllbGQgX3RoaXMxMS5kb3dubG9hZERldmljZUxpc3QobmV3IFNldChbdXNlcklkXSkpO1xuICAgICAgICB2YXIga2V5cyA9IChfa2V5UmVzdWx0JG1hc3Rlcl9rZXkgPSBrZXlSZXN1bHQubWFzdGVyX2tleXMpID09PSBudWxsIHx8IF9rZXlSZXN1bHQkbWFzdGVyX2tleSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2tleVJlc3VsdCRtYXN0ZXJfa2V5W3VzZXJJZF07XG5cbiAgICAgICAgLy8gTm8gbWFzdGVyIGtleVxuICAgICAgICBpZiAoIWtleXMpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBga2V5c2AgaXMgYW4gb2JqZWN0IHdpdGggeyBbYGVkMjU1MTk6JHtwdWJLZXl9YF06IHB1YktleSB9XG4gICAgICAgIC8vIFdlIGFzc3VtZSBvbmx5IGEgc2luZ2xlIGtleSwgYW5kIHdlIHdhbnQgdGhlIGJhcmUgZm9ybSB3aXRob3V0IHR5cGVcbiAgICAgICAgLy8gcHJlZml4LCBzbyB3ZSBzZWxlY3QgdGhlIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oT2JqZWN0LnZhbHVlcyhrZXlzLmtleXMpWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGV2aWNlIGluZm9ybWF0aW9uIGZvciB0aGUgZ2l2ZW4gbGlzdCBvZiB1c2Vycy5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJJZHMgLSBUaGUgdXNlcnMgdG8gZmV0Y2guXG4gICAqIEBwYXJhbSBkb3dubG9hZFVuY2FjaGVkIC0gSWYgdHJ1ZSwgZG93bmxvYWQgdGhlIGRldmljZSBsaXN0IGZvciB1c2VycyB3aG9zZSBkZXZpY2UgbGlzdCB3ZSBhcmUgbm90XG4gICAqICAgIGN1cnJlbnRseSB0cmFja2luZy4gRGVmYXVsdHMgdG8gZmFsc2UsIGluIHdoaWNoIGNhc2Ugc3VjaCB1c2VycyB3aWxsIG5vdCBhcHBlYXIgYXQgYWxsIGluIHRoZSByZXN1bHQgbWFwLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIG1hcCBge0BsaW5rIERldmljZU1hcH1gLlxuICAgKi9cbiAgZ2V0VXNlckRldmljZUluZm8odXNlcklkcykge1xuICAgIHZhciBfYXJndW1lbnRzMiA9IGFyZ3VtZW50cyxcbiAgICAgIF90aGlzMTIgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIGRvd25sb2FkVW5jYWNoZWQgPSBfYXJndW1lbnRzMi5sZW5ndGggPiAxICYmIF9hcmd1bWVudHMyWzFdICE9PSB1bmRlZmluZWQgPyBfYXJndW1lbnRzMlsxXSA6IGZhbHNlO1xuICAgICAgdmFyIGRldmljZU1hcEJ5VXNlcklkID0gbmV3IE1hcCgpO1xuICAgICAgdmFyIHJ1c3RUcmFja2VkVXNlcnMgPSB5aWVsZCBfdGhpczEyLmdldE9sbU1hY2hpbmVPclRocm93KCkudHJhY2tlZFVzZXJzKCk7XG5cbiAgICAgIC8vIENvbnZlcnQgUnVzdFNka0NyeXB0b0pzLlVzZXJJZCB0byBhIGBTZXQ8c3RyaW5nPmBcbiAgICAgIHZhciB0cmFja2VkVXNlcnMgPSBuZXcgU2V0KCk7XG4gICAgICBydXN0VHJhY2tlZFVzZXJzLmZvckVhY2gocnVzdFVzZXJJZCA9PiB0cmFja2VkVXNlcnMuYWRkKHJ1c3RVc2VySWQudG9TdHJpbmcoKSkpO1xuXG4gICAgICAvLyBLZWVwIHVudHJhY2tlZCB1c2VyIHRvIGRvd25sb2FkIHRoZWlyIGtleXMgYWZ0ZXJcbiAgICAgIHZhciB1bnRyYWNrZWRVc2VycyA9IG5ldyBTZXQoKTtcbiAgICAgIGZvciAodmFyIF91c2VySWQgb2YgdXNlcklkcykge1xuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdHJhY2tlZCB1c2VyLCB3ZSBjYW4ganVzdCBmZXRjaCB0aGUgZGV2aWNlIGxpc3QgZnJvbSB0aGUgcnVzdC1zZGtcbiAgICAgICAgLy8gKE5COiB0aGlzIGlzIHByb2JhYmx5IG9rIGV2ZW4gaWYgd2UgcmFjZSB3aXRoIGEgbGVhdmUgZXZlbnQgc3VjaCB0aGF0IHdlIHN0b3AgdHJhY2tpbmcgdGhlIHVzZXInc1xuICAgICAgICAvLyBkZXZpY2VzOiB0aGUgcnVzdC1zZGsgd2lsbCByZXR1cm4gdGhlIGxhc3Qta25vd24gZGV2aWNlIGxpc3QsIHdoaWNoIHdpbGwgYmUgZ29vZCBlbm91Z2guKVxuICAgICAgICBpZiAodHJhY2tlZFVzZXJzLmhhcyhfdXNlcklkKSkge1xuICAgICAgICAgIGRldmljZU1hcEJ5VXNlcklkLnNldChfdXNlcklkLCB5aWVsZCBfdGhpczEyLmdldFVzZXJEZXZpY2VzKF91c2VySWQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bnRyYWNrZWRVc2Vycy5hZGQoX3VzZXJJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGFueSB1c2VycyB3aG9zZSBkZXZpY2UgbGlzdHMgd2UgYXJlIG5vdCB0cmFja2luZywgZmFsbCBiYWNrIHRvIGRvd25sb2FkaW5nIHRoZSBkZXZpY2UgbGlzdFxuICAgICAgLy8gb3ZlciBIVFRQLlxuICAgICAgaWYgKGRvd25sb2FkVW5jYWNoZWQgJiYgdW50cmFja2VkVXNlcnMuc2l6ZSA+PSAxKSB7XG4gICAgICAgIHZhciBxdWVyeVJlc3VsdCA9IHlpZWxkIF90aGlzMTIuZG93bmxvYWREZXZpY2VMaXN0KHVudHJhY2tlZFVzZXJzKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocXVlcnlSZXN1bHQuZGV2aWNlX2tleXMpLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICAgICAgdmFyIFt1c2VySWQsIGRldmljZUtleXNdID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gZGV2aWNlTWFwQnlVc2VySWQuc2V0KHVzZXJJZCwgZGV2aWNlS2V5c1RvRGV2aWNlTWFwKGRldmljZUtleXMpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGV2aWNlTWFwQnlVc2VySWQ7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRldmljZSBsaXN0IGZvciB0aGUgZ2l2ZW4gdXNlciBmcm9tIHRoZSBvbG0gbWFjaGluZVxuICAgKiBAcGFyYW0gdXNlcklkIC0gUnVzdCBTREsgVXNlcklkXG4gICAqL1xuICBnZXRVc2VyRGV2aWNlcyh1c2VySWQpIHtcbiAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgcnVzdFVzZXJJZCA9IG5ldyBSdXN0U2RrQ3J5cHRvSnMuVXNlcklkKHVzZXJJZCk7XG5cbiAgICAgIC8vIEZvciByZWFzb25zIEkgZG9uJ3QgcmVhbGx5IHVuZGVyc3RhbmQsIHRoZSBKYXZhc2NyaXB0IEZpbmFsaXphdGlvblJlZ2lzdHJ5IGRvZXNuJ3Qgc2VlbSB0byBydW4gdGhlXG4gICAgICAvLyByZWdpc3RlcmVkIGNhbGxiYWNrcyB3aGVuIGB1c2VyRGV2aWNlc2AgZ29lcyBvdXQgb2Ygc2NvcGUsIG5vciB3aGVuIHRoZSBpbmRpdmlkdWFsIGRldmljZXMgaW4gdGhlIGFycmF5XG4gICAgICAvLyByZXR1cm5lZCBieSBgdXNlckRldmljZXMuZGV2aWNlc2AgZG8gc28uXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBpcyBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMsIGJlY2F1c2UgZWFjaCBvZiB0aG9zZSBzdHJ1Y3R1cmVzIGhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoZVxuICAgICAgLy8gVmVyaWZpY2F0aW9uTWFjaGluZSwgd2hpY2ggaW4gdHVybiBob2xkcyBhIHJlZmVyZW5jZSB0byB0aGUgSW5kZXhlZGRiQ3J5cHRvU3RvcmUuIEhlbmNlLCB3ZSBlbmQgdXAgbGVha2luZ1xuICAgICAgLy8gb3BlbiBjb25uZWN0aW9ucyB0byB0aGUgY3J5cHRvIHN0b3JlLCB3aGljaCBtZWFucyB0aGUgc3RvcmUgY2FuJ3QgYmUgZGVsZXRlZCBvbiBsb2dvdXQuXG4gICAgICAvL1xuICAgICAgLy8gVG8gZml4IHRoaXMsIHdlIGV4cGxpY2l0bHkgY2FsbCBgLmZyZWVgIG9uIGVhY2ggb2YgdGhlIG9iamVjdHMsIHdoaWNoIHRlbGxzIHRoZSBydXN0IGNvZGUgdG8gZHJvcCB0aGVcbiAgICAgIC8vIGFsbG9jYXRlZCBtZW1vcnkgYW5kIGRlY3JlbWVudCB0aGUgcmVmY291bnRzIGZvciB0aGUgY3J5cHRvIHN0b3JlLlxuXG4gICAgICAvLyBXYWl0IGZvciB1cCB0byBhIHNlY29uZCBmb3IgYW55IGluLWZsaWdodCBkZXZpY2UgbGlzdCByZXF1ZXN0cyB0byBjb21wbGV0ZS5cbiAgICAgIC8vIFRoZSByZWFzb24gZm9yIHRoaXMgaXNuJ3Qgc28gbXVjaCB0byBhdm9pZCByYWNlcyAoc29tZSBsZXZlbCBvZiByYWNpbmVzcyBpc1xuICAgICAgLy8gaW5ldml0YWJsZSBmb3IgdGhpcyBtZXRob2QpIGJ1dCB0byBtYWtlIHRlc3RpbmcgZWFzaWVyLlxuICAgICAgdmFyIHVzZXJEZXZpY2VzID0geWllbGQgX3RoaXMxMy5vbG1NYWNoaW5lLmdldFVzZXJEZXZpY2VzKHJ1c3RVc2VySWQsIDEpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGRldmljZUFycmF5ID0gdXNlckRldmljZXMuZGV2aWNlcygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBuZXcgTWFwKGRldmljZUFycmF5Lm1hcChkZXZpY2UgPT4gW2RldmljZS5kZXZpY2VJZC50b1N0cmluZygpLCBydXN0RGV2aWNlVG9Kc0RldmljZShkZXZpY2UsIHJ1c3RVc2VySWQpXSkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGRldmljZUFycmF5LmZvckVhY2goZCA9PiBkLmZyZWUoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVzZXJEZXZpY2VzLmZyZWUoKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERvd25sb2FkIHRoZSBnaXZlbiB1c2VyIGtleXMgYnkgY2FsbGluZyBgL2tleXMvcXVlcnlgIHJlcXVlc3RcbiAgICogQHBhcmFtIHVudHJhY2tlZFVzZXJzIC0gZG93bmxvYWQga2V5cyBvZiB0aGVzZSB1c2Vyc1xuICAgKi9cbiAgZG93bmxvYWREZXZpY2VMaXN0KHVudHJhY2tlZFVzZXJzKSB7XG4gICAgdmFyIF90aGlzMTQgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHF1ZXJ5Qm9keSA9IHtcbiAgICAgICAgZGV2aWNlX2tleXM6IHt9XG4gICAgICB9O1xuICAgICAgdW50cmFja2VkVXNlcnMuZm9yRWFjaCh1c2VyID0+IHF1ZXJ5Qm9keS5kZXZpY2Vfa2V5c1t1c2VyXSA9IFtdKTtcbiAgICAgIHJldHVybiB5aWVsZCBfdGhpczE0Lmh0dHAuYXV0aGVkUmVxdWVzdChNZXRob2QuUG9zdCwgXCIvX21hdHJpeC9jbGllbnQvdjMva2V5cy9xdWVyeVwiLCB1bmRlZmluZWQsIHF1ZXJ5Qm9keSwge1xuICAgICAgICBwcmVmaXg6IFwiXCJcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNnZXRUcnVzdENyb3NzU2lnbmVkRGV2aWNlc30uXG4gICAqL1xuICBnZXRUcnVzdENyb3NzU2lnbmVkRGV2aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJ1c3RDcm9zc1NpZ25lZERldmljZXM7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNzZXRUcnVzdENyb3NzU2lnbmVkRGV2aWNlc30uXG4gICAqL1xuICBzZXRUcnVzdENyb3NzU2lnbmVkRGV2aWNlcyh2YWwpIHtcbiAgICB0aGlzLl90cnVzdENyb3NzU2lnbmVkRGV2aWNlcyA9IHZhbDtcbiAgICAvLyBUT0RPOiBsZWdhY3kgY3J5cHRvIGdvZXMgdGhyb3VnaCB0aGUgbGlzdCBvZiBrbm93biBkZXZpY2VzIGFuZCBlbWl0cyBEZXZpY2VWZXJpZmljYXRpb25DaGFuZ2VkXG4gICAgLy8gIGV2ZW50cy4gTWF5YmUgd2UgbmVlZCB0byBkbyB0aGUgc2FtZT9cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrIHRoZSBnaXZlbiBkZXZpY2UgYXMgbG9jYWxseSB2ZXJpZmllZC5cbiAgICpcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNzZXREZXZpY2VWZXJpZmllZH0uXG4gICAqL1xuICBzZXREZXZpY2VWZXJpZmllZCh1c2VySWQsIGRldmljZUlkKSB7XG4gICAgdmFyIF9hcmd1bWVudHMzID0gYXJndW1lbnRzLFxuICAgICAgX3RoaXMxNSA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgdmVyaWZpZWQgPSBfYXJndW1lbnRzMy5sZW5ndGggPiAyICYmIF9hcmd1bWVudHMzWzJdICE9PSB1bmRlZmluZWQgPyBfYXJndW1lbnRzM1syXSA6IHRydWU7XG4gICAgICB2YXIgZGV2aWNlID0geWllbGQgX3RoaXMxNS5vbG1NYWNoaW5lLmdldERldmljZShuZXcgUnVzdFNka0NyeXB0b0pzLlVzZXJJZCh1c2VySWQpLCBuZXcgUnVzdFNka0NyeXB0b0pzLkRldmljZUlkKGRldmljZUlkKSk7XG4gICAgICBpZiAoIWRldmljZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRldmljZSBcIi5jb25jYXQodXNlcklkLCBcInxcIikuY29uY2F0KGRldmljZUlkKSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCBkZXZpY2Uuc2V0TG9jYWxUcnVzdCh2ZXJpZmllZCA/IFJ1c3RTZGtDcnlwdG9Kcy5Mb2NhbFRydXN0LlZlcmlmaWVkIDogUnVzdFNka0NyeXB0b0pzLkxvY2FsVHJ1c3QuVW5zZXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZGV2aWNlLmZyZWUoKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJsaW5kbHkgY3Jvc3Mtc2lnbiBvbmUgb2Ygb3VyIG90aGVyIGRldmljZXMuXG4gICAqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjY3Jvc3NTaWduRGV2aWNlfS5cbiAgICovXG4gIGNyb3NzU2lnbkRldmljZShkZXZpY2VJZCkge1xuICAgIHZhciBfdGhpczE2ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBkZXZpY2UgPSB5aWVsZCBfdGhpczE2Lm9sbU1hY2hpbmUuZ2V0RGV2aWNlKG5ldyBSdXN0U2RrQ3J5cHRvSnMuVXNlcklkKF90aGlzMTYudXNlcklkKSwgbmV3IFJ1c3RTZGtDcnlwdG9Kcy5EZXZpY2VJZChkZXZpY2VJZCkpO1xuICAgICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkZXZpY2UgXCIuY29uY2F0KGRldmljZUlkKSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgb3V0Z29pbmdSZXF1ZXN0ID0geWllbGQgZGV2aWNlLnZlcmlmeSgpO1xuICAgICAgICB5aWVsZCBfdGhpczE2Lm91dGdvaW5nUmVxdWVzdFByb2Nlc3Nvci5tYWtlT3V0Z29pbmdSZXF1ZXN0KG91dGdvaW5nUmVxdWVzdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkZXZpY2UuZnJlZSgpO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNnZXREZXZpY2VWZXJpZmljYXRpb25TdGF0dXN9LlxuICAgKi9cbiAgZ2V0RGV2aWNlVmVyaWZpY2F0aW9uU3RhdHVzKHVzZXJJZCwgZGV2aWNlSWQpIHtcbiAgICB2YXIgX3RoaXMxNyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgZGV2aWNlID0geWllbGQgX3RoaXMxNy5vbG1NYWNoaW5lLmdldERldmljZShuZXcgUnVzdFNka0NyeXB0b0pzLlVzZXJJZCh1c2VySWQpLCBuZXcgUnVzdFNka0NyeXB0b0pzLkRldmljZUlkKGRldmljZUlkKSk7XG4gICAgICBpZiAoIWRldmljZSkgcmV0dXJuIG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IERldmljZVZlcmlmaWNhdGlvblN0YXR1cyh7XG4gICAgICAgICAgc2lnbmVkQnlPd25lcjogZGV2aWNlLmlzQ3Jvc3NTaWduZWRCeU93bmVyKCksXG4gICAgICAgICAgY3Jvc3NTaWduaW5nVmVyaWZpZWQ6IGRldmljZS5pc0Nyb3NzU2lnbmluZ1RydXN0ZWQoKSxcbiAgICAgICAgICBsb2NhbFZlcmlmaWVkOiBkZXZpY2UuaXNMb2NhbGx5VHJ1c3RlZCgpLFxuICAgICAgICAgIHRydXN0Q3Jvc3NTaWduZWREZXZpY2VzOiBfdGhpczE3Ll90cnVzdENyb3NzU2lnbmVkRGV2aWNlc1xuICAgICAgICB9KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGRldmljZS5mcmVlKCk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ3J5cHRvQXBpI2dldFVzZXJWZXJpZmljYXRpb25TdGF0dXN9LlxuICAgKi9cbiAgZ2V0VXNlclZlcmlmaWNhdGlvblN0YXR1cyh1c2VySWQpIHtcbiAgICB2YXIgX3RoaXMxOCA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgdXNlcklkZW50aXR5ID0geWllbGQgX3RoaXMxOC5nZXRPbG1NYWNoaW5lT3JUaHJvdygpLmdldElkZW50aXR5KG5ldyBSdXN0U2RrQ3J5cHRvSnMuVXNlcklkKHVzZXJJZCkpO1xuICAgICAgaWYgKHVzZXJJZGVudGl0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgVXNlclZlcmlmaWNhdGlvblN0YXR1cyhmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHZhciB2ZXJpZmllZCA9IHVzZXJJZGVudGl0eS5pc1ZlcmlmaWVkKCk7XG4gICAgICB2YXIgd2FzVmVyaWZpZWQgPSB1c2VySWRlbnRpdHkud2FzUHJldmlvdXNseVZlcmlmaWVkKCk7XG4gICAgICB2YXIgbmVlZHNVc2VyQXBwcm92YWwgPSB1c2VySWRlbnRpdHkgaW5zdGFuY2VvZiBSdXN0U2RrQ3J5cHRvSnMuT3RoZXJVc2VySWRlbnRpdHkgPyB1c2VySWRlbnRpdHkuaWRlbnRpdHlOZWVkc1VzZXJBcHByb3ZhbCgpIDogZmFsc2U7XG4gICAgICB1c2VySWRlbnRpdHkuZnJlZSgpO1xuICAgICAgcmV0dXJuIG5ldyBVc2VyVmVyaWZpY2F0aW9uU3RhdHVzKHZlcmlmaWVkLCB3YXNWZXJpZmllZCwgZmFsc2UsIG5lZWRzVXNlckFwcHJvdmFsKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjcGluQ3VycmVudFVzZXJJZGVudGl0eX0uXG4gICAqL1xuICBwaW5DdXJyZW50VXNlcklkZW50aXR5KHVzZXJJZCkge1xuICAgIHZhciBfdGhpczE5ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciB1c2VySWRlbnRpdHkgPSB5aWVsZCBfdGhpczE5LmdldE9sbU1hY2hpbmVPclRocm93KCkuZ2V0SWRlbnRpdHkobmV3IFJ1c3RTZGtDcnlwdG9Kcy5Vc2VySWQodXNlcklkKSk7XG4gICAgICBpZiAodXNlcklkZW50aXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHBpbiBpZGVudGl0eSBvZiB1bmtub3duIHVzZXJcIik7XG4gICAgICB9XG4gICAgICBpZiAodXNlcklkZW50aXR5IGluc3RhbmNlb2YgUnVzdFNka0NyeXB0b0pzLk93blVzZXJJZGVudGl0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcGluIGlkZW50aXR5IG9mIG93biB1c2VyXCIpO1xuICAgICAgfVxuICAgICAgeWllbGQgdXNlcklkZW50aXR5LnBpbkN1cnJlbnRNYXN0ZXJLZXkoKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjd2l0aGRyYXdWZXJpZmljYXRpb25SZXF1aXJlbWVudH0uXG4gICAqL1xuICB3aXRoZHJhd1ZlcmlmaWNhdGlvblJlcXVpcmVtZW50KHVzZXJJZCkge1xuICAgIHZhciBfdGhpczIwID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciB1c2VySWRlbnRpdHkgPSB5aWVsZCBfdGhpczIwLmdldE9sbU1hY2hpbmVPclRocm93KCkuZ2V0SWRlbnRpdHkobmV3IFJ1c3RTZGtDcnlwdG9Kcy5Vc2VySWQodXNlcklkKSk7XG4gICAgICBpZiAodXNlcklkZW50aXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHdpdGhkcmF3IHZlcmlmaWNhdGlvbiBvZiB1bmtub3duIHVzZXJcIik7XG4gICAgICB9XG4gICAgICB5aWVsZCB1c2VySWRlbnRpdHkud2l0aGRyYXdWZXJpZmljYXRpb24oKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjaXNDcm9zc1NpZ25pbmdSZWFkeX1cbiAgICovXG4gIGlzQ3Jvc3NTaWduaW5nUmVhZHkoKSB7XG4gICAgdmFyIF90aGlzMjEgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHtcbiAgICAgICAgcHJpdmF0ZUtleXNJblNlY3JldFN0b3JhZ2UsXG4gICAgICAgIHByaXZhdGVLZXlzQ2FjaGVkTG9jYWxseVxuICAgICAgfSA9IHlpZWxkIF90aGlzMjEuZ2V0Q3Jvc3NTaWduaW5nU3RhdHVzKCk7XG4gICAgICB2YXIgaGFzS2V5c0luQ2FjaGUgPSBCb29sZWFuKHByaXZhdGVLZXlzQ2FjaGVkTG9jYWxseS5tYXN0ZXJLZXkpICYmIEJvb2xlYW4ocHJpdmF0ZUtleXNDYWNoZWRMb2NhbGx5LnNlbGZTaWduaW5nS2V5KSAmJiBCb29sZWFuKHByaXZhdGVLZXlzQ2FjaGVkTG9jYWxseS51c2VyU2lnbmluZ0tleSk7XG4gICAgICB2YXIgaWRlbnRpdHkgPSB5aWVsZCBfdGhpczIxLmdldE93bklkZW50aXR5KCk7XG5cbiAgICAgIC8vIENyb3NzLXNpZ25pbmcgaXMgcmVhZHkgaWYgdGhlIHB1YmxpYyBpZGVudGl0eSBpcyB0cnVzdGVkLCBhbmQgdGhlIHByaXZhdGUga2V5c1xuICAgICAgLy8gYXJlIGVpdGhlciBjYWNoZWQsIG9yIGFjY2Vzc2libGUgdmlhIHNlY3JldC1zdG9yYWdlLlxuICAgICAgcmV0dXJuICEhKGlkZW50aXR5ICE9PSBudWxsICYmIGlkZW50aXR5ICE9PSB2b2lkIDAgJiYgaWRlbnRpdHkuaXNWZXJpZmllZCgpKSAmJiAoaGFzS2V5c0luQ2FjaGUgfHwgcHJpdmF0ZUtleXNJblNlY3JldFN0b3JhZ2UpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNnZXRDcm9zc1NpZ25pbmdLZXlJZH1cbiAgICovXG4gIGdldENyb3NzU2lnbmluZ0tleUlkKCkge1xuICAgIHZhciBfYXJndW1lbnRzNCA9IGFyZ3VtZW50cyxcbiAgICAgIF90aGlzMjIgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHR5cGUgPSBfYXJndW1lbnRzNC5sZW5ndGggPiAwICYmIF9hcmd1bWVudHM0WzBdICE9PSB1bmRlZmluZWQgPyBfYXJndW1lbnRzNFswXSA6IENyb3NzU2lnbmluZ0tleS5NYXN0ZXI7XG4gICAgICB2YXIgdXNlcklkZW50aXR5ID0geWllbGQgX3RoaXMyMi5vbG1NYWNoaW5lLmdldElkZW50aXR5KG5ldyBSdXN0U2RrQ3J5cHRvSnMuVXNlcklkKF90aGlzMjIudXNlcklkKSk7XG4gICAgICBpZiAoIXVzZXJJZGVudGl0eSkge1xuICAgICAgICAvLyBUaGUgcHVibGljIGtleXMgYXJlIG5vdCBhdmFpbGFibGUgb24gdGhpcyBkZXZpY2VcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgY3Jvc3NTaWduaW5nU3RhdHVzID0geWllbGQgX3RoaXMyMi5vbG1NYWNoaW5lLmNyb3NzU2lnbmluZ1N0YXR1cygpO1xuICAgICAgICB2YXIgcHJpdmF0ZUtleXNPbkRldmljZSA9IGNyb3NzU2lnbmluZ1N0YXR1cy5oYXNNYXN0ZXIgJiYgY3Jvc3NTaWduaW5nU3RhdHVzLmhhc1VzZXJTaWduaW5nICYmIGNyb3NzU2lnbmluZ1N0YXR1cy5oYXNTZWxmU2lnbmluZztcbiAgICAgICAgaWYgKCFwcml2YXRlS2V5c09uRGV2aWNlKSB7XG4gICAgICAgICAgLy8gVGhlIHByaXZhdGUga2V5cyBhcmUgbm90IGF2YWlsYWJsZSBvbiB0aGlzIGRldmljZVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXNlcklkZW50aXR5LmlzVmVyaWZpZWQoKSkge1xuICAgICAgICAgIC8vIFdlIGhhdmUgYm90aCBwdWJsaWMgYW5kIHByaXZhdGUga2V5cywgYnV0IHRoZXkgZG9uJ3QgbWF0Y2ghXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBDcm9zc1NpZ25pbmdLZXkuTWFzdGVyOlxuICAgICAgICAgICAga2V5ID0gdXNlcklkZW50aXR5Lm1hc3RlcktleTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgQ3Jvc3NTaWduaW5nS2V5LlNlbGZTaWduaW5nOlxuICAgICAgICAgICAga2V5ID0gdXNlcklkZW50aXR5LnNlbGZTaWduaW5nS2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBDcm9zc1NpZ25pbmdLZXkuVXNlclNpZ25pbmc6XG4gICAgICAgICAgICBrZXkgPSB1c2VySWRlbnRpdHkudXNlclNpZ25pbmdLZXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gVW5rbm93biB0eXBlXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyc2VkS2V5ID0gSlNPTi5wYXJzZShrZXkpO1xuICAgICAgICAvLyBga2V5c2AgaXMgYW4gb2JqZWN0IHdpdGggeyBbYGVkMjU1MTk6JHtwdWJLZXl9YF06IHB1YktleSB9XG4gICAgICAgIC8vIFdlIGFzc3VtZSBvbmx5IGEgc2luZ2xlIGtleSwgYW5kIHdlIHdhbnQgdGhlIGJhcmUgZm9ybSB3aXRob3V0IHR5cGVcbiAgICAgICAgLy8gcHJlZml4LCBzbyB3ZSBzZWxlY3QgdGhlIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocGFyc2VkS2V5LmtleXMpWzBdO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXNlcklkZW50aXR5LmZyZWUoKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjYm9vdHN0cmFwQ3Jvc3NTaWduaW5nfVxuICAgKi9cbiAgYm9vdHN0cmFwQ3Jvc3NTaWduaW5nKG9wdHMpIHtcbiAgICB2YXIgX3RoaXMyMyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfdGhpczIzLmNyb3NzU2lnbmluZ0lkZW50aXR5LmJvb3RzdHJhcENyb3NzU2lnbmluZyhvcHRzKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjaXNTZWNyZXRTdG9yYWdlUmVhZHl9XG4gICAqL1xuICBpc1NlY3JldFN0b3JhZ2VSZWFkeSgpIHtcbiAgICB2YXIgX3RoaXMyNCA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgY3Jvc3Mtc2lnbmluZyBrZXlzIGFyZSBzdG9yZWRcbiAgICAgIHZhciBzZWNyZXRzVG9DaGVjayA9IFtcIm0uY3Jvc3Nfc2lnbmluZy5tYXN0ZXJcIiwgXCJtLmNyb3NzX3NpZ25pbmcudXNlcl9zaWduaW5nXCIsIFwibS5jcm9zc19zaWduaW5nLnNlbGZfc2lnbmluZ1wiXTtcblxuICAgICAgLy8gaWYga2V5IGJhY2t1cCBpcyBhY3RpdmUsIHdlIGFsc28gbmVlZCB0byBjaGVjayB0aGF0IHRoZSBiYWNrdXAgZGVjcnlwdGlvbiBrZXkgaXMgc3RvcmVkXG4gICAgICB2YXIga2V5QmFja3VwRW5hYmxlZCA9ICh5aWVsZCBfdGhpczI0LmJhY2t1cE1hbmFnZXIuZ2V0QWN0aXZlQmFja3VwVmVyc2lvbigpKSAhPSBudWxsO1xuICAgICAgaWYgKGtleUJhY2t1cEVuYWJsZWQpIHtcbiAgICAgICAgc2VjcmV0c1RvQ2hlY2sucHVzaChcIm0ubWVnb2xtX2JhY2t1cC52MVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWNyZXRTdG9yYWdlQ2FuQWNjZXNzU2VjcmV0cyhfdGhpczI0LnNlY3JldFN0b3JhZ2UsIHNlY3JldHNUb0NoZWNrKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjYm9vdHN0cmFwU2VjcmV0U3RvcmFnZX1cbiAgICovXG4gIGJvb3RzdHJhcFNlY3JldFN0b3JhZ2UoKSB7XG4gICAgdmFyIF9hcmd1bWVudHM1ID0gYXJndW1lbnRzLFxuICAgICAgX3RoaXMyNSA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIge1xuICAgICAgICBjcmVhdGVTZWNyZXRTdG9yYWdlS2V5LFxuICAgICAgICBzZXR1cE5ld1NlY3JldFN0b3JhZ2UsXG4gICAgICAgIHNldHVwTmV3S2V5QmFja3VwXG4gICAgICB9ID0gX2FyZ3VtZW50czUubGVuZ3RoID4gMCAmJiBfYXJndW1lbnRzNVswXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3VtZW50czVbMF0gOiB7fTtcbiAgICAgIC8vIElmIGFuIEFFUyBLZXkgaXMgYWxyZWFkeSBzdG9yZWQgaW4gdGhlIHNlY3JldCBzdG9yYWdlIGFuZCBzZXR1cE5ld1NlY3JldFN0b3JhZ2UgaXMgbm90IHNldFxuICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBjcmVhdGUgYSBuZXcga2V5XG4gICAgICB2YXIgaXNOZXdTZWNyZXRTdG9yYWdlS2V5TmVlZGVkID0gc2V0dXBOZXdTZWNyZXRTdG9yYWdlIHx8ICEoeWllbGQgX3RoaXMyNS5zZWNyZXRTdG9yYWdlSGFzQUVTS2V5KCkpO1xuICAgICAgaWYgKGlzTmV3U2VjcmV0U3RvcmFnZUtleU5lZWRlZCkge1xuICAgICAgICBpZiAoIWNyZWF0ZVNlY3JldFN0b3JhZ2VLZXkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gY3JlYXRlIGEgbmV3IHNlY3JldCBzdG9yYWdlIGtleSwgY3JlYXRlU2VjcmV0U3RvcmFnZUtleSBpcyBub3Qgc2V0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHN0b3JhZ2Uga2V5IGFuZCBhZGQgaXQgdG8gc2VjcmV0IHN0b3JhZ2VcbiAgICAgICAgX3RoaXMyNS5sb2dnZXIuaW5mbyhcImJvb3RzdHJhcFNlY3JldFN0b3JhZ2U6IGNyZWF0aW5nIG5ldyBzZWNyZXQgc3RvcmFnZSBrZXlcIik7XG4gICAgICAgIHZhciByZWNvdmVyeUtleSA9IHlpZWxkIGNyZWF0ZVNlY3JldFN0b3JhZ2VLZXkoKTtcbiAgICAgICAgaWYgKCFyZWNvdmVyeUtleSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZVNlY3JldFN0b3JhZ2VLZXkoKSBjYWxsYmFjayBkaWQgbm90IHJldHVybiBhIHNlY3JldCBzdG9yYWdlIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfdGhpczI1LmFkZFNlY3JldFN0b3JhZ2VLZXlUb1NlY3JldFN0b3JhZ2UocmVjb3ZlcnlLZXkpO1xuICAgICAgfVxuICAgICAgdmFyIGNyb3NzU2lnbmluZ1N0YXR1cyA9IHlpZWxkIF90aGlzMjUub2xtTWFjaGluZS5jcm9zc1NpZ25pbmdTdGF0dXMoKTtcbiAgICAgIHZhciBoYXNQcml2YXRlS2V5cyA9IGNyb3NzU2lnbmluZ1N0YXR1cy5oYXNNYXN0ZXIgJiYgY3Jvc3NTaWduaW5nU3RhdHVzLmhhc1NlbGZTaWduaW5nICYmIGNyb3NzU2lnbmluZ1N0YXR1cy5oYXNVc2VyU2lnbmluZztcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBjcm9zcy1zaWduaW5nIHByaXZhdGUga2V5cyBjYWNoZWQsIHN0b3JlIHRoZW0gaW4gc2VjcmV0XG4gICAgICAvLyBzdG9yYWdlIGlmIHRoZXkgYXJlIG5vdCB0aGVyZSBhbHJlYWR5LlxuICAgICAgaWYgKGhhc1ByaXZhdGVLZXlzICYmIChpc05ld1NlY3JldFN0b3JhZ2VLZXlOZWVkZWQgfHwgISh5aWVsZCBzZWNyZXRTdG9yYWdlQ29udGFpbnNDcm9zc1NpZ25pbmdLZXlzKF90aGlzMjUuc2VjcmV0U3RvcmFnZSkpKSkge1xuICAgICAgICBfdGhpczI1LmxvZ2dlci5pbmZvKFwiYm9vdHN0cmFwU2VjcmV0U3RvcmFnZTogY3Jvc3Mtc2lnbmluZyBrZXlzIG5vdCB5ZXQgZXhwb3J0ZWQ7IGRvaW5nIHNvIG5vdy5cIik7XG4gICAgICAgIHZhciBjcm9zc1NpZ25pbmdQcml2YXRlS2V5cyA9IHlpZWxkIF90aGlzMjUub2xtTWFjaGluZS5leHBvcnRDcm9zc1NpZ25pbmdLZXlzKCk7XG4gICAgICAgIGlmICghY3Jvc3NTaWduaW5nUHJpdmF0ZUtleXMubWFzdGVyS2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBtYXN0ZXIga2V5IGluIGNyb3NzIHNpZ25pbmcgcHJpdmF0ZSBrZXlzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3Jvc3NTaWduaW5nUHJpdmF0ZUtleXMudXNlclNpZ25pbmdLZXkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHVzZXIgc2lnbmluZyBrZXkgaW4gY3Jvc3Mgc2lnbmluZyBwcml2YXRlIGtleXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjcm9zc1NpZ25pbmdQcml2YXRlS2V5cy5zZWxmX3NpZ25pbmdfa2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzZWxmIHNpZ25pbmcga2V5IGluIGNyb3NzIHNpZ25pbmcgcHJpdmF0ZSBrZXlzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIF90aGlzMjUuc2VjcmV0U3RvcmFnZS5zdG9yZShcIm0uY3Jvc3Nfc2lnbmluZy5tYXN0ZXJcIiwgY3Jvc3NTaWduaW5nUHJpdmF0ZUtleXMubWFzdGVyS2V5KTtcbiAgICAgICAgeWllbGQgX3RoaXMyNS5zZWNyZXRTdG9yYWdlLnN0b3JlKFwibS5jcm9zc19zaWduaW5nLnVzZXJfc2lnbmluZ1wiLCBjcm9zc1NpZ25pbmdQcml2YXRlS2V5cy51c2VyU2lnbmluZ0tleSk7XG4gICAgICAgIHlpZWxkIF90aGlzMjUuc2VjcmV0U3RvcmFnZS5zdG9yZShcIm0uY3Jvc3Nfc2lnbmluZy5zZWxmX3NpZ25pbmdcIiwgY3Jvc3NTaWduaW5nUHJpdmF0ZUtleXMuc2VsZl9zaWduaW5nX2tleSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxpa2V3aXNlIHdpdGggdGhlIGtleSBiYWNrdXAga2V5OiBpZiB3ZSBoYXZlIG9uZSwgc3RvcmUgaXQgaW4gc2VjcmV0IHN0b3JhZ2UgKGlmIGl0J3Mgbm90IGFscmVhZHkgdGhlcmUpXG4gICAgICAvLyBhbHNvIGRvbid0IGJvdGhlciBzdG9yaW5nIGl0IGlmIHdlJ3JlIGFib3V0IHRvIHNldCB1cCBhIG5ldyBiYWNrdXBcbiAgICAgIGlmICghc2V0dXBOZXdLZXlCYWNrdXApIHtcbiAgICAgICAgeWllbGQgX3RoaXMyNS5zYXZlQmFja3VwS2V5VG9TdG9yYWdlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBfdGhpczI1LnJlc2V0S2V5QmFja3VwKCk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB3ZSBoYXZlIGEgYmFja3VwIGtleSBmb3IgdGhlIGN1cnJlbnQsIHRydXN0ZWQgYmFja3VwIGluIGNhY2hlLFxuICAgKiBzYXZlIGl0IHRvIHNlY3JldCBzdG9yYWdlLlxuICAgKi9cbiAgc2F2ZUJhY2t1cEtleVRvU3RvcmFnZSgpIHtcbiAgICB2YXIgX3RoaXMyNiA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIga2V5QmFja3VwSW5mbyA9IHlpZWxkIF90aGlzMjYuYmFja3VwTWFuYWdlci5nZXRTZXJ2ZXJCYWNrdXBJbmZvKCk7XG4gICAgICBpZiAoIWtleUJhY2t1cEluZm8gfHwgIWtleUJhY2t1cEluZm8udmVyc2lvbikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIk5vdCBzYXZpbmcgYmFja3VwIGtleSB0byBzZWNyZXQgc3RvcmFnZTogbm8gYmFja3VwIGluZm9cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBiYWNrdXBLZXlzID0geWllbGQgX3RoaXMyNi5vbG1NYWNoaW5lLmdldEJhY2t1cEtleXMoKTtcbiAgICAgIGlmICghYmFja3VwS2V5cy5kZWNyeXB0aW9uS2V5KSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiTm90IHNhdmluZyBiYWNrdXAga2V5IHRvIHNlY3JldCBzdG9yYWdlOiBubyBiYWNrdXAga2V5XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWRlY3J5cHRpb25LZXlNYXRjaGVzS2V5QmFja3VwSW5mbyhiYWNrdXBLZXlzLmRlY3J5cHRpb25LZXksIGtleUJhY2t1cEluZm8pKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiTm90IHNhdmluZyBiYWNrdXAga2V5IHRvIHNlY3JldCBzdG9yYWdlOiBkZWNyeXB0aW9uIGtleSBkb2VzIG5vdCBtYXRjaCBiYWNrdXAgaW5mb1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGJhY2t1cEtleUJhc2U2NCA9IGJhY2t1cEtleXMuZGVjcnlwdGlvbktleS50b0Jhc2U2NCgpO1xuICAgICAgeWllbGQgX3RoaXMyNi5zZWNyZXRTdG9yYWdlLnN0b3JlKFwibS5tZWdvbG1fYmFja3VwLnYxXCIsIGJhY2t1cEtleUJhc2U2NCk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHNlY3JldFN0b3JhZ2Uga2V5IHRvIHRoZSBzZWNyZXQgc3RvcmFnZVxuICAgKiAtIFRoZSBzZWNyZXQgc3RvcmFnZSBrZXkgbXVzdCBoYXZlIHRoZSBga2V5SW5mb2AgZmllbGQgZmlsbGVkXG4gICAqIC0gVGhlIHNlY3JldCBzdG9yYWdlIGtleSBpcyBzZXQgYXMgdGhlIGRlZmF1bHQga2V5IG9mIHRoZSBzZWNyZXQgc3RvcmFnZVxuICAgKiAtIENhbGwgYGNyeXB0b0NhbGxiYWNrcy5jYWNoZVNlY3JldFN0b3JhZ2VLZXlgIHdoZW4gZG9uZVxuICAgKlxuICAgKiBAcGFyYW0gc2VjcmV0U3RvcmFnZUtleSAtIFRoZSBzZWNyZXQgc3RvcmFnZSBrZXkgdG8gYWRkIGluIHRoZSBzZWNyZXQgc3RvcmFnZS5cbiAgICovXG4gIGFkZFNlY3JldFN0b3JhZ2VLZXlUb1NlY3JldFN0b3JhZ2Uoc2VjcmV0U3RvcmFnZUtleSkge1xuICAgIHZhciBfdGhpczI3ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfc2VjcmV0U3RvcmFnZUtleSRrZXksIF9zZWNyZXRTdG9yYWdlS2V5JGtleTIsIF90aGlzMjckY3J5cHRvQ2FsbGJhYywgX3RoaXMyNyRjcnlwdG9DYWxsYmFjMjtcbiAgICAgIHZhciBzZWNyZXRTdG9yYWdlS2V5T2JqZWN0ID0geWllbGQgX3RoaXMyNy5zZWNyZXRTdG9yYWdlLmFkZEtleShTRUNSRVRfU1RPUkFHRV9BTEdPUklUSE1fVjFfQUVTLCB7XG4gICAgICAgIHBhc3NwaHJhc2U6IChfc2VjcmV0U3RvcmFnZUtleSRrZXkgPSBzZWNyZXRTdG9yYWdlS2V5LmtleUluZm8pID09PSBudWxsIHx8IF9zZWNyZXRTdG9yYWdlS2V5JGtleSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NlY3JldFN0b3JhZ2VLZXkka2V5LnBhc3NwaHJhc2UsXG4gICAgICAgIG5hbWU6IChfc2VjcmV0U3RvcmFnZUtleSRrZXkyID0gc2VjcmV0U3RvcmFnZUtleS5rZXlJbmZvKSA9PT0gbnVsbCB8fCBfc2VjcmV0U3RvcmFnZUtleSRrZXkyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2VjcmV0U3RvcmFnZUtleSRrZXkyLm5hbWUsXG4gICAgICAgIGtleTogc2VjcmV0U3RvcmFnZUtleS5wcml2YXRlS2V5XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIF90aGlzMjcuc2VjcmV0U3RvcmFnZS5zZXREZWZhdWx0S2V5SWQoc2VjcmV0U3RvcmFnZUtleU9iamVjdC5rZXlJZCk7XG4gICAgICAoX3RoaXMyNyRjcnlwdG9DYWxsYmFjID0gKF90aGlzMjckY3J5cHRvQ2FsbGJhYzIgPSBfdGhpczI3LmNyeXB0b0NhbGxiYWNrcykuY2FjaGVTZWNyZXRTdG9yYWdlS2V5KSA9PT0gbnVsbCB8fCBfdGhpczI3JGNyeXB0b0NhbGxiYWMgPT09IHZvaWQgMCB8fCBfdGhpczI3JGNyeXB0b0NhbGxiYWMuY2FsbChfdGhpczI3JGNyeXB0b0NhbGxiYWMyLCBzZWNyZXRTdG9yYWdlS2V5T2JqZWN0LmtleUlkLCBzZWNyZXRTdG9yYWdlS2V5T2JqZWN0LmtleUluZm8sIHNlY3JldFN0b3JhZ2VLZXkucHJpdmF0ZUtleSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHNlY3JldCBzdG9yYWdlIEFFUyBLZXkgaXMgYWxyZWFkeSBhZGRlZCBpbiBzZWNyZXQgc3RvcmFnZVxuICAgKlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIGFuIEFFUyBrZXkgaXMgaW4gdGhlIHNlY3JldCBzdG9yYWdlXG4gICAqL1xuICBzZWNyZXRTdG9yYWdlSGFzQUVTS2V5KCkge1xuICAgIHZhciBfdGhpczI4ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIFNlZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYW4gQUVTIHNlY3JldC1zdG9yYWdlIGtleS5cbiAgICAgIHZhciBzZWNyZXRTdG9yYWdlS2V5VHVwbGUgPSB5aWVsZCBfdGhpczI4LnNlY3JldFN0b3JhZ2UuZ2V0S2V5KCk7XG4gICAgICBpZiAoIXNlY3JldFN0b3JhZ2VLZXlUdXBsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIFssIGtleUluZm9dID0gc2VjcmV0U3RvcmFnZUtleVR1cGxlO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUga2V5IGlzIGFuIEFFUyBrZXlcbiAgICAgIHJldHVybiBrZXlJbmZvLmFsZ29yaXRobSA9PT0gU0VDUkVUX1NUT1JBR0VfQUxHT1JJVEhNX1YxX0FFUztcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjZ2V0Q3Jvc3NTaWduaW5nU3RhdHVzfVxuICAgKi9cbiAgZ2V0Q3Jvc3NTaWduaW5nU3RhdHVzKCkge1xuICAgIHZhciBfdGhpczI5ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciB1c2VySWRlbnRpdHkgPSB5aWVsZCBfdGhpczI5LmdldE9sbU1hY2hpbmVPclRocm93KCkuZ2V0SWRlbnRpdHkobmV3IFJ1c3RTZGtDcnlwdG9Kcy5Vc2VySWQoX3RoaXMyOS51c2VySWQpKTtcbiAgICAgIHZhciBwdWJsaWNLZXlzT25EZXZpY2UgPSBCb29sZWFuKHVzZXJJZGVudGl0eSA9PT0gbnVsbCB8fCB1c2VySWRlbnRpdHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXJJZGVudGl0eS5tYXN0ZXJLZXkpICYmIEJvb2xlYW4odXNlcklkZW50aXR5ID09PSBudWxsIHx8IHVzZXJJZGVudGl0eSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlcklkZW50aXR5LnNlbGZTaWduaW5nS2V5KSAmJiBCb29sZWFuKHVzZXJJZGVudGl0eSA9PT0gbnVsbCB8fCB1c2VySWRlbnRpdHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXJJZGVudGl0eS51c2VyU2lnbmluZ0tleSk7XG4gICAgICB1c2VySWRlbnRpdHkgPT09IG51bGwgfHwgdXNlcklkZW50aXR5ID09PSB2b2lkIDAgfHwgdXNlcklkZW50aXR5LmZyZWUoKTtcbiAgICAgIHZhciBwcml2YXRlS2V5c0luU2VjcmV0U3RvcmFnZSA9IHlpZWxkIHNlY3JldFN0b3JhZ2VDb250YWluc0Nyb3NzU2lnbmluZ0tleXMoX3RoaXMyOS5zZWNyZXRTdG9yYWdlKTtcbiAgICAgIHZhciBjcm9zc1NpZ25pbmdTdGF0dXMgPSB5aWVsZCBfdGhpczI5LmdldE9sbU1hY2hpbmVPclRocm93KCkuY3Jvc3NTaWduaW5nU3RhdHVzKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwdWJsaWNLZXlzT25EZXZpY2UsXG4gICAgICAgIHByaXZhdGVLZXlzSW5TZWNyZXRTdG9yYWdlLFxuICAgICAgICBwcml2YXRlS2V5c0NhY2hlZExvY2FsbHk6IHtcbiAgICAgICAgICBtYXN0ZXJLZXk6IEJvb2xlYW4oY3Jvc3NTaWduaW5nU3RhdHVzID09PSBudWxsIHx8IGNyb3NzU2lnbmluZ1N0YXR1cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3Jvc3NTaWduaW5nU3RhdHVzLmhhc01hc3RlciksXG4gICAgICAgICAgdXNlclNpZ25pbmdLZXk6IEJvb2xlYW4oY3Jvc3NTaWduaW5nU3RhdHVzID09PSBudWxsIHx8IGNyb3NzU2lnbmluZ1N0YXR1cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3Jvc3NTaWduaW5nU3RhdHVzLmhhc1VzZXJTaWduaW5nKSxcbiAgICAgICAgICBzZWxmU2lnbmluZ0tleTogQm9vbGVhbihjcm9zc1NpZ25pbmdTdGF0dXMgPT09IG51bGwgfHwgY3Jvc3NTaWduaW5nU3RhdHVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjcm9zc1NpZ25pbmdTdGF0dXMuaGFzU2VsZlNpZ25pbmcpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ3J5cHRvQXBpI2NyZWF0ZVJlY292ZXJ5S2V5RnJvbVBhc3NwaHJhc2V9XG4gICAqL1xuICBjcmVhdGVSZWNvdmVyeUtleUZyb21QYXNzcGhyYXNlKHBhc3N3b3JkKSB7XG4gICAgdmFyIF90aGlzMzAgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHBhc3N3b3JkKSB7XG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSBrZXkgZnJvbSB0aGUgcGFzc3BocmFzZVxuICAgICAgICAvLyBmaXJzdCB3ZSBnZW5lcmF0ZSBhIHJhbmRvbSBzYWx0XG4gICAgICAgIHZhciBzYWx0ID0gc2VjdXJlUmFuZG9tU3RyaW5nKDMyKTtcbiAgICAgICAgLy8gdGhlbiB3ZSBkZXJpdmUgdGhlIGtleSBmcm9tIHRoZSBwYXNzcGhyYXNlXG4gICAgICAgIHZhciByZWNvdmVyeUtleSA9IHlpZWxkIGRlcml2ZVJlY292ZXJ5S2V5RnJvbVBhc3NwaHJhc2UocGFzc3dvcmQsIHNhbHQsIF90aGlzMzAuUkVDT1ZFUllfS0VZX0RFUklWQVRJT05fSVRFUkFUSU9OUyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5SW5mbzoge1xuICAgICAgICAgICAgcGFzc3BocmFzZToge1xuICAgICAgICAgICAgICBhbGdvcml0aG06IFwibS5wYmtkZjJcIixcbiAgICAgICAgICAgICAgaXRlcmF0aW9uczogX3RoaXMzMC5SRUNPVkVSWV9LRVlfREVSSVZBVElPTl9JVEVSQVRJT05TLFxuICAgICAgICAgICAgICBzYWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcml2YXRlS2V5OiByZWNvdmVyeUtleSxcbiAgICAgICAgICBlbmNvZGVkUHJpdmF0ZUtleTogZW5jb2RlUmVjb3ZlcnlLZXkocmVjb3ZlcnlLZXkpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2luZyB0aGUgbmF2aWdhdG9yIGNyeXB0byBBUEkgdG8gZ2VuZXJhdGUgdGhlIHByaXZhdGUga2V5XG4gICAgICAgIHZhciBrZXkgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGdsb2JhbFRoaXMuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByaXZhdGVLZXk6IGtleSxcbiAgICAgICAgICBlbmNvZGVkUHJpdmF0ZUtleTogZW5jb2RlUmVjb3ZlcnlLZXkoa2V5KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNnZXRFbmNyeXB0aW9uSW5mb0ZvckV2ZW50fS5cbiAgICovXG4gIGdldEVuY3J5cHRpb25JbmZvRm9yRXZlbnQoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMzMSA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMzMS5ldmVudERlY3J5cHRvci5nZXRFbmNyeXB0aW9uSW5mb0ZvckV2ZW50KGV2ZW50KTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdG8tZGV2aWNlIHZlcmlmaWNhdGlvbiByZXF1ZXN0cyB0aGF0IGFyZSBhbHJlYWR5IGluIHByb2dyZXNzIGZvciB0aGUgZ2l2ZW4gdXNlciBpZC5cbiAgICpcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNnZXRWZXJpZmljYXRpb25SZXF1ZXN0c1RvRGV2aWNlSW5Qcm9ncmVzc31cbiAgICpcbiAgICogQHBhcmFtIHVzZXJJZCAtIHRoZSBJRCBvZiB0aGUgdXNlciB0byBxdWVyeVxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgVmVyaWZpY2F0aW9uUmVxdWVzdHMgdGhhdCBhcmUgaW4gcHJvZ3Jlc3NcbiAgICovXG4gIGdldFZlcmlmaWNhdGlvblJlcXVlc3RzVG9EZXZpY2VJblByb2dyZXNzKHVzZXJJZCkge1xuICAgIHZhciByZXF1ZXN0cyA9IHRoaXMub2xtTWFjaGluZS5nZXRWZXJpZmljYXRpb25SZXF1ZXN0cyhuZXcgUnVzdFNka0NyeXB0b0pzLlVzZXJJZCh1c2VySWQpKTtcbiAgICByZXR1cm4gcmVxdWVzdHMuZmlsdGVyKHJlcXVlc3QgPT4gcmVxdWVzdC5yb29tSWQgPT09IHVuZGVmaW5lZCkubWFwKHJlcXVlc3QgPT4gbmV3IFJ1c3RWZXJpZmljYXRpb25SZXF1ZXN0KHRoaXMub2xtTWFjaGluZSwgcmVxdWVzdCwgdGhpcy5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IsIHRoaXMuX3N1cHBvcnRlZFZlcmlmaWNhdGlvbk1ldGhvZHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhIERNIHZlcmlmaWNhdGlvbiByZXF1ZXN0IHRoYXQgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBmb3IgdGhlIGdpdmVuIHJvb20gaWRcbiAgICpcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNmaW5kVmVyaWZpY2F0aW9uUmVxdWVzdERNSW5Qcm9ncmVzc31cbiAgICpcbiAgICogQHBhcmFtIHJvb21JZCAtIHRoZSByb29tIHRvIHVzZSBmb3IgdmVyaWZpY2F0aW9uXG4gICAqIEBwYXJhbSB1c2VySWQgLSBzZWFyY2ggdGhlIHZlcmlmaWNhdGlvbiByZXF1ZXN0IGZvciB0aGUgZ2l2ZW4gdXNlclxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgVmVyaWZpY2F0aW9uUmVxdWVzdCB0aGF0IGlzIGluIHByb2dyZXNzLCBpZiBhbnlcbiAgICpcbiAgICovXG4gIGZpbmRWZXJpZmljYXRpb25SZXF1ZXN0RE1JblByb2dyZXNzKHJvb21JZCwgdXNlcklkKSB7XG4gICAgaWYgKCF1c2VySWQpIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgdXNlcklkXCIpO1xuICAgIHZhciByZXF1ZXN0cyA9IHRoaXMub2xtTWFjaGluZS5nZXRWZXJpZmljYXRpb25SZXF1ZXN0cyhuZXcgUnVzdFNka0NyeXB0b0pzLlVzZXJJZCh1c2VySWQpKTtcblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIHZlcmlmaWNhdGlvbiByZXF1ZXN0IGZvciB0aGUgZ2l2ZW4gcm9vbSBpZFxuICAgIHZhciByZXF1ZXN0ID0gcmVxdWVzdHMuZmluZChyZXF1ZXN0ID0+IHtcbiAgICAgIHZhciBfcmVxdWVzdCRyb29tSWQ7XG4gICAgICByZXR1cm4gKChfcmVxdWVzdCRyb29tSWQgPSByZXF1ZXN0LnJvb21JZCkgPT09IG51bGwgfHwgX3JlcXVlc3Qkcm9vbUlkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVxdWVzdCRyb29tSWQudG9TdHJpbmcoKSkgPT09IHJvb21JZDtcbiAgICB9KTtcbiAgICBpZiAocmVxdWVzdCkge1xuICAgICAgcmV0dXJuIG5ldyBSdXN0VmVyaWZpY2F0aW9uUmVxdWVzdCh0aGlzLm9sbU1hY2hpbmUsIHJlcXVlc3QsIHRoaXMub3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yLCB0aGlzLl9zdXBwb3J0ZWRWZXJpZmljYXRpb25NZXRob2RzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNyZXF1ZXN0VmVyaWZpY2F0aW9uRE19XG4gICAqL1xuICByZXF1ZXN0VmVyaWZpY2F0aW9uRE0odXNlcklkLCByb29tSWQpIHtcbiAgICB2YXIgX3RoaXMzMiA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgdXNlcklkZW50aXR5ID0geWllbGQgX3RoaXMzMi5vbG1NYWNoaW5lLmdldElkZW50aXR5KG5ldyBSdXN0U2RrQ3J5cHRvSnMuVXNlcklkKHVzZXJJZCkpO1xuICAgICAgaWYgKCF1c2VySWRlbnRpdHkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdXNlcklkIFwiLmNvbmNhdCh1c2VySWQpKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgdmVyaWZpY2F0aW9uIG1ldGhvZHMgaW50byBydXN0IG9iamVjdHNcbiAgICAgICAgdmFyIG1ldGhvZHMgPSBfdGhpczMyLl9zdXBwb3J0ZWRWZXJpZmljYXRpb25NZXRob2RzLm1hcChtZXRob2QgPT4gdmVyaWZpY2F0aW9uTWV0aG9kSWRlbnRpZmllclRvTWV0aG9kKG1ldGhvZCkpO1xuICAgICAgICAvLyBHZXQgdGhlIHJlcXVlc3QgY29udGVudCB0byBzZW5kIHRvIHRoZSBETSByb29tXG4gICAgICAgIHZhciB2ZXJpZmljYXRpb25FdmVudENvbnRlbnQgPSB5aWVsZCB1c2VySWRlbnRpdHkudmVyaWZpY2F0aW9uUmVxdWVzdENvbnRlbnQobWV0aG9kcyk7XG5cbiAgICAgICAgLy8gU2VuZCB0aGUgcmVxdWVzdCBjb250ZW50IHRvIHNlbmQgdG8gdGhlIERNIHJvb21cbiAgICAgICAgdmFyIGV2ZW50SWQgPSB5aWVsZCBfdGhpczMyLnNlbmRWZXJpZmljYXRpb25SZXF1ZXN0Q29udGVudChyb29tSWQsIHZlcmlmaWNhdGlvbkV2ZW50Q29udGVudCk7XG5cbiAgICAgICAgLy8gR2V0IGEgdmVyaWZpY2F0aW9uIHJlcXVlc3RcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB5aWVsZCB1c2VySWRlbnRpdHkucmVxdWVzdFZlcmlmaWNhdGlvbihuZXcgUnVzdFNka0NyeXB0b0pzLlJvb21JZChyb29tSWQpLCBuZXcgUnVzdFNka0NyeXB0b0pzLkV2ZW50SWQoZXZlbnRJZCksIG1ldGhvZHMpO1xuICAgICAgICByZXR1cm4gbmV3IFJ1c3RWZXJpZmljYXRpb25SZXF1ZXN0KF90aGlzMzIub2xtTWFjaGluZSwgcmVxdWVzdCwgX3RoaXMzMi5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IsIF90aGlzMzIuX3N1cHBvcnRlZFZlcmlmaWNhdGlvbk1ldGhvZHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXNlcklkZW50aXR5LmZyZWUoKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgdGhlIHZlcmlmaWNhdGlvbiBjb250ZW50IHRvIGEgcm9vbVxuICAgKiBTZWUgaHR0cHM6Ly9zcGVjLm1hdHJpeC5vcmcvdjEuNy9jbGllbnQtc2VydmVyLWFwaS8jcHV0X21hdHJpeGNsaWVudHYzcm9vbXNyb29taWRzZW5kZXZlbnR0eXBldHhuaWRcbiAgICpcbiAgICogUHJlZmVyIHRvIHVzZSB7QGxpbmsgT3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yLm1ha2VPdXRnb2luZ1JlcXVlc3R9IHdoZW4gZGVhbGluZyB3aXRoIHtAbGluayBSdXN0U2RrQ3J5cHRvSnMuUm9vbU1lc3NhZ2VSZXF1ZXN0fVxuICAgKlxuICAgKiBAcGFyYW0gcm9vbUlkIC0gdGhlIHRhcmdldGVkIHJvb21cbiAgICogQHBhcmFtIHZlcmlmaWNhdGlvbkV2ZW50Q29udGVudCAtIHRoZSByZXF1ZXN0IGJvZHkuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBldmVudCBpZFxuICAgKi9cbiAgc2VuZFZlcmlmaWNhdGlvblJlcXVlc3RDb250ZW50KHJvb21JZCwgdmVyaWZpY2F0aW9uRXZlbnRDb250ZW50KSB7XG4gICAgdmFyIF90aGlzMzMgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHR4SWQgPSBzZWN1cmVSYW5kb21TdHJpbmcoMzIpO1xuICAgICAgLy8gU2VuZCB0aGUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgY29udGVudCB0byB0aGUgRE0gcm9vbVxuICAgICAgdmFyIHtcbiAgICAgICAgZXZlbnRfaWQ6IGV2ZW50SWRcbiAgICAgIH0gPSB5aWVsZCBfdGhpczMzLmh0dHAuYXV0aGVkUmVxdWVzdChNZXRob2QuUHV0LCBcIi9fbWF0cml4L2NsaWVudC92My9yb29tcy9cIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KHJvb21JZCksIFwiL3NlbmQvbS5yb29tLm1lc3NhZ2UvXCIpLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQodHhJZCkpLCB1bmRlZmluZWQsIHZlcmlmaWNhdGlvbkV2ZW50Q29udGVudCwge1xuICAgICAgICBwcmVmaXg6IFwiXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGV2ZW50SWQ7XG4gICAgfSkoKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSB2ZXJpZmljYXRpb24gbWV0aG9kcyB3ZSBvZmZlciB0byB0aGUgb3RoZXIgc2lkZSBkdXJpbmcgYW4gaW50ZXJhY3RpdmUgdmVyaWZpY2F0aW9uLlxuICAgKlxuICAgKiBJZiBgdW5kZWZpbmVkYCwgd2Ugd2lsbCBvZmZlciBhbGwgdGhlIG1ldGhvZHMgc3VwcG9ydGVkIGJ5IHRoZSBSdXN0IFNESy5cbiAgICovXG4gIHNldFN1cHBvcnRlZFZlcmlmaWNhdGlvbk1ldGhvZHMobWV0aG9kcykge1xuICAgIC8vIGJ5IGRlZmF1bHQsIHRoZSBSdXN0IFNESyBkb2VzIG5vdCBvZmZlciBgbS5xcl9jb2RlLnNjYW4udjFgLCBidXQgd2UgZG8gd2FudCB0byBvZmZlciB0aGF0LlxuICAgIHRoaXMuX3N1cHBvcnRlZFZlcmlmaWNhdGlvbk1ldGhvZHMgPSBtZXRob2RzICE9PSBudWxsICYmIG1ldGhvZHMgIT09IHZvaWQgMCA/IG1ldGhvZHMgOiBBTExfVkVSSUZJQ0FUSU9OX01FVEhPRFM7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHZlcmlmaWNhdGlvbiByZXF1ZXN0IHRvIG91ciBvdGhlciBkZXZpY2VzLlxuICAgKlxuICAgKiBJZiBhIHZlcmlmaWNhdGlvbiBpcyBhbHJlYWR5IGluIGZsaWdodCwgcmV0dXJucyBpdC4gT3RoZXJ3aXNlLCBpbml0aWF0ZXMgYSBuZXcgb25lLlxuICAgKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ3J5cHRvQXBpI3JlcXVlc3RPd25Vc2VyVmVyaWZpY2F0aW9ufS5cbiAgICpcbiAgICogQHJldHVybnMgYSBWZXJpZmljYXRpb25SZXF1ZXN0IHdoZW4gdGhlIHJlcXVlc3QgaGFzIGJlZW4gc2VudCB0byB0aGUgb3RoZXIgcGFydHkuXG4gICAqL1xuICByZXF1ZXN0T3duVXNlclZlcmlmaWNhdGlvbigpIHtcbiAgICB2YXIgX3RoaXMzNCA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgdXNlcklkZW50aXR5ID0geWllbGQgX3RoaXMzNC5vbG1NYWNoaW5lLmdldElkZW50aXR5KG5ldyBSdXN0U2RrQ3J5cHRvSnMuVXNlcklkKF90aGlzMzQudXNlcklkKSk7XG4gICAgICBpZiAodXNlcklkZW50aXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHJlcXVlc3QgdmVyaWZpY2F0aW9uIGZvciB0aGlzIGRldmljZSB3aGVuIHRoZXJlIGlzIG5vIGV4aXN0aW5nIGNyb3NzLXNpZ25pbmcga2V5XCIpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIFtyZXF1ZXN0LCBvdXRnb2luZ1JlcXVlc3RdID0geWllbGQgdXNlcklkZW50aXR5LnJlcXVlc3RWZXJpZmljYXRpb24oX3RoaXMzNC5fc3VwcG9ydGVkVmVyaWZpY2F0aW9uTWV0aG9kcy5tYXAodmVyaWZpY2F0aW9uTWV0aG9kSWRlbnRpZmllclRvTWV0aG9kKSk7XG4gICAgICAgIHlpZWxkIF90aGlzMzQub3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yLm1ha2VPdXRnb2luZ1JlcXVlc3Qob3V0Z29pbmdSZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBSdXN0VmVyaWZpY2F0aW9uUmVxdWVzdChfdGhpczM0Lm9sbU1hY2hpbmUsIHJlcXVlc3QsIF90aGlzMzQub3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yLCBfdGhpczM0Ll9zdXBwb3J0ZWRWZXJpZmljYXRpb25NZXRob2RzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVzZXJJZGVudGl0eS5mcmVlKCk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IGFuIGludGVyYWN0aXZlIHZlcmlmaWNhdGlvbiB3aXRoIHRoZSBnaXZlbiBkZXZpY2UuXG4gICAqXG4gICAqIElmIGEgdmVyaWZpY2F0aW9uIGlzIGFscmVhZHkgaW4gZmxpZ2h0LCByZXR1cm5zIGl0LiBPdGhlcndpc2UsIGluaXRpYXRlcyBhIG5ldyBvbmUuXG4gICAqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjcmVxdWVzdERldmljZVZlcmlmaWNhdGlvbn0uXG4gICAqXG4gICAqIEBwYXJhbSB1c2VySWQgLSBJRCBvZiB0aGUgb3duZXIgb2YgdGhlIGRldmljZSB0byB2ZXJpZnlcbiAgICogQHBhcmFtIGRldmljZUlkIC0gSUQgb2YgdGhlIGRldmljZSB0byB2ZXJpZnlcbiAgICpcbiAgICogQHJldHVybnMgYSBWZXJpZmljYXRpb25SZXF1ZXN0IHdoZW4gdGhlIHJlcXVlc3QgaGFzIGJlZW4gc2VudCB0byB0aGUgb3RoZXIgcGFydHkuXG4gICAqL1xuICByZXF1ZXN0RGV2aWNlVmVyaWZpY2F0aW9uKHVzZXJJZCwgZGV2aWNlSWQpIHtcbiAgICB2YXIgX3RoaXMzNSA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgZGV2aWNlID0geWllbGQgX3RoaXMzNS5vbG1NYWNoaW5lLmdldERldmljZShuZXcgUnVzdFNka0NyeXB0b0pzLlVzZXJJZCh1c2VySWQpLCBuZXcgUnVzdFNka0NyeXB0b0pzLkRldmljZUlkKGRldmljZUlkKSk7XG4gICAgICBpZiAoIWRldmljZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBrbm93biBkZXZpY2VcIik7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgW3JlcXVlc3QsIG91dGdvaW5nUmVxdWVzdF0gPSBkZXZpY2UucmVxdWVzdFZlcmlmaWNhdGlvbihfdGhpczM1Ll9zdXBwb3J0ZWRWZXJpZmljYXRpb25NZXRob2RzLm1hcCh2ZXJpZmljYXRpb25NZXRob2RJZGVudGlmaWVyVG9NZXRob2QpKTtcbiAgICAgICAgeWllbGQgX3RoaXMzNS5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IubWFrZU91dGdvaW5nUmVxdWVzdChvdXRnb2luZ1JlcXVlc3QpO1xuICAgICAgICByZXR1cm4gbmV3IFJ1c3RWZXJpZmljYXRpb25SZXF1ZXN0KF90aGlzMzUub2xtTWFjaGluZSwgcmVxdWVzdCwgX3RoaXMzNS5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IsIF90aGlzMzUuX3N1cHBvcnRlZFZlcmlmaWNhdGlvbk1ldGhvZHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZGV2aWNlLmZyZWUoKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBiYWNrdXAgZGVjcnlwdGlvbiBrZXkgd2UgaGF2ZSBzYXZlZCBpbiBvdXIgc3RvcmUuXG4gICAqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjZ2V0U2Vzc2lvbkJhY2t1cFByaXZhdGVLZXl9LlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUga2V5LCBpZiBhbnksIG9yIG51bGxcbiAgICovXG4gIGdldFNlc3Npb25CYWNrdXBQcml2YXRlS2V5KCkge1xuICAgIHZhciBfdGhpczM2ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBiYWNrdXBLZXlzID0geWllbGQgX3RoaXMzNi5vbG1NYWNoaW5lLmdldEJhY2t1cEtleXMoKTtcbiAgICAgIGlmICghYmFja3VwS2V5cy5kZWNyeXB0aW9uS2V5KSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBkZWNvZGVCYXNlNjQoYmFja3VwS2V5cy5kZWNyeXB0aW9uS2V5LnRvQmFzZTY0KCkpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcmUgdGhlIGJhY2t1cCBkZWNyeXB0aW9uIGtleS5cbiAgICpcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNzdG9yZVNlc3Npb25CYWNrdXBQcml2YXRlS2V5fS5cbiAgICpcbiAgICogQHBhcmFtIGtleSAtIHRoZSBiYWNrdXAgZGVjcnlwdGlvbiBrZXlcbiAgICogQHBhcmFtIHZlcnNpb24gLSB0aGUgYmFja3VwIHZlcnNpb24gZm9yIHRoaXMga2V5LlxuICAgKi9cbiAgc3RvcmVTZXNzaW9uQmFja3VwUHJpdmF0ZUtleShrZXksIHZlcnNpb24pIHtcbiAgICB2YXIgX3RoaXMzNyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgYmFzZTY0S2V5ID0gZW5jb2RlQmFzZTY0KGtleSk7XG4gICAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3RvcmVTZXNzaW9uQmFja3VwUHJpdmF0ZUtleTogdmVyc2lvbiBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIF90aGlzMzcuYmFja3VwTWFuYWdlci5zYXZlQmFja3VwRGVjcnlwdGlvbktleShSdXN0U2RrQ3J5cHRvSnMuQmFja3VwRGVjcnlwdGlvbktleS5mcm9tQmFzZTY0KGJhc2U2NEtleSksIHZlcnNpb24pO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNsb2FkU2Vzc2lvbkJhY2t1cFByaXZhdGVLZXlGcm9tU2VjcmV0U3RvcmFnZX0uXG4gICAqL1xuICBsb2FkU2Vzc2lvbkJhY2t1cFByaXZhdGVLZXlGcm9tU2VjcmV0U3RvcmFnZSgpIHtcbiAgICB2YXIgX3RoaXMzOCA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgYmFja3VwS2V5ID0geWllbGQgX3RoaXMzOC5zZWNyZXRTdG9yYWdlLmdldChcIm0ubWVnb2xtX2JhY2t1cC52MVwiKTtcbiAgICAgIGlmICghYmFja3VwS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImxvYWRTZXNzaW9uQmFja3VwUHJpdmF0ZUtleUZyb21TZWNyZXRTdG9yYWdlOiBtaXNzaW5nIGRlY3J5cHRpb24ga2V5IGluIHNlY3JldCBzdG9yYWdlXCIpO1xuICAgICAgfVxuICAgICAgdmFyIGtleUJhY2t1cEluZm8gPSB5aWVsZCBfdGhpczM4LmJhY2t1cE1hbmFnZXIuZ2V0U2VydmVyQmFja3VwSW5mbygpO1xuICAgICAgaWYgKCFrZXlCYWNrdXBJbmZvIHx8ICFrZXlCYWNrdXBJbmZvLnZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFNlc3Npb25CYWNrdXBQcml2YXRlS2V5RnJvbVNlY3JldFN0b3JhZ2U6IHVuYWJsZSB0byBnZXQgYmFja3VwIHZlcnNpb25cIik7XG4gICAgICB9XG4gICAgICB2YXIgYmFja3VwRGVjcnlwdGlvbktleSA9IFJ1c3RTZGtDcnlwdG9Kcy5CYWNrdXBEZWNyeXB0aW9uS2V5LmZyb21CYXNlNjQoYmFja3VwS2V5KTtcbiAgICAgIGlmICghZGVjcnlwdGlvbktleU1hdGNoZXNLZXlCYWNrdXBJbmZvKGJhY2t1cERlY3J5cHRpb25LZXksIGtleUJhY2t1cEluZm8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImxvYWRTZXNzaW9uQmFja3VwUHJpdmF0ZUtleUZyb21TZWNyZXRTdG9yYWdlOiBkZWNyeXB0aW9uIGtleSBkb2VzIG5vdCBtYXRjaCBiYWNrdXAgaW5mb1wiKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIF90aGlzMzguYmFja3VwTWFuYWdlci5zYXZlQmFja3VwRGVjcnlwdGlvbktleShiYWNrdXBEZWNyeXB0aW9uS2V5LCBrZXlCYWNrdXBJbmZvLnZlcnNpb24pO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHN0YXR1cyBvZiBrZXkgYmFja3VwLlxuICAgKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ3J5cHRvQXBpI2dldEFjdGl2ZVNlc3Npb25CYWNrdXBWZXJzaW9ufS5cbiAgICovXG4gIGdldEFjdGl2ZVNlc3Npb25CYWNrdXBWZXJzaW9uKCkge1xuICAgIHZhciBfdGhpczM5ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB5aWVsZCBfdGhpczM5LmJhY2t1cE1hbmFnZXIuZ2V0QWN0aXZlQmFja3VwVmVyc2lvbigpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNnZXRLZXlCYWNrdXBJbmZvfS5cbiAgICovXG4gIGdldEtleUJhY2t1cEluZm8oKSB7XG4gICAgdmFyIF90aGlzNDAgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuICh5aWVsZCBfdGhpczQwLmJhY2t1cE1hbmFnZXIuZ2V0U2VydmVyQmFja3VwSW5mbygpKSB8fCBudWxsO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEga2V5IGJhY2t1cCBjYW4gYmUgdHJ1c3RlZC5cbiAgICpcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNpc0tleUJhY2t1cFRydXN0ZWR9LlxuICAgKi9cbiAgaXNLZXlCYWNrdXBUcnVzdGVkKGluZm8pIHtcbiAgICB2YXIgX3RoaXM0MSA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4geWllbGQgX3RoaXM0MS5iYWNrdXBNYW5hZ2VyLmlzS2V5QmFja3VwVHJ1c3RlZChpbmZvKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIGEgcmUtY2hlY2sgb2YgdGhlIGtleSBiYWNrdXAgYW5kIGVuYWJsZS9kaXNhYmxlIGl0IGFzIGFwcHJvcHJpYXRlLlxuICAgKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ3J5cHRvQXBpI2NoZWNrS2V5QmFja3VwQW5kRW5hYmxlfS5cbiAgICovXG4gIGNoZWNrS2V5QmFja3VwQW5kRW5hYmxlKCkge1xuICAgIHZhciBfdGhpczQyID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB5aWVsZCBfdGhpczQyLmJhY2t1cE1hbmFnZXIuY2hlY2tLZXlCYWNrdXBBbmRFbmFibGUodHJ1ZSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ3J5cHRvQXBpI2RlbGV0ZUtleUJhY2t1cFZlcnNpb259LlxuICAgKi9cbiAgZGVsZXRlS2V5QmFja3VwVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgdmFyIF90aGlzNDMgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgX3RoaXM0My5iYWNrdXBNYW5hZ2VyLmRlbGV0ZUtleUJhY2t1cFZlcnNpb24odmVyc2lvbik7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ3J5cHRvQXBpI3Jlc2V0S2V5QmFja3VwfS5cbiAgICovXG4gIHJlc2V0S2V5QmFja3VwKCkge1xuICAgIHZhciBfdGhpczQ0ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBiYWNrdXBJbmZvID0geWllbGQgX3RoaXM0NC5iYWNrdXBNYW5hZ2VyLnNldHVwS2V5QmFja3VwKG8gPT4gX3RoaXM0NC5zaWduT2JqZWN0KG8pKTtcblxuICAgICAgLy8gd2Ugd2FudCB0byBzdG9yZSB0aGUgcHJpdmF0ZSBrZXkgaW4gNFNcbiAgICAgIC8vIG5lZWQgdG8gY2hlY2sgaWYgNFMgaXMgc2V0IHVwP1xuICAgICAgaWYgKHlpZWxkIF90aGlzNDQuc2VjcmV0U3RvcmFnZUhhc0FFU0tleSgpKSB7XG4gICAgICAgIHlpZWxkIF90aGlzNDQuc2VjcmV0U3RvcmFnZS5zdG9yZShcIm0ubWVnb2xtX2JhY2t1cC52MVwiLCBiYWNrdXBJbmZvLmRlY3J5cHRpb25LZXkudG9CYXNlNjQoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGNhbiBjaGVjayBhbmQgc3RhcnQgYXN5bmNcbiAgICAgIF90aGlzNDQuY2hlY2tLZXlCYWNrdXBBbmRFbmFibGUoKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoZSBnaXZlbiBvYmplY3Qgd2l0aCB0aGUgY3VycmVudCBkZXZpY2UgYW5kIGN1cnJlbnQgaWRlbnRpdHkgKGlmIGF2YWlsYWJsZSkuXG4gICAqIEFzIGRlZmluZWQgaW4ge0BsaW5rIGh0dHBzOi8vc3BlYy5tYXRyaXgub3JnL3YxLjgvYXBwZW5kaWNlcy8jc2lnbmluZy1qc29uIHwgU2lnbmluZyBKU09OfS5cbiAgICpcbiAgICogSGVscGVyIGZvciB7QGxpbmsgUnVzdENyeXB0byNyZXNldEtleUJhY2t1cH0uXG4gICAqXG4gICAqIEBwYXJhbSBvYmogLSBUaGUgb2JqZWN0IHRvIHNpZ25cbiAgICovXG4gIHNpZ25PYmplY3Qob2JqKSB7XG4gICAgdmFyIF90aGlzNDUgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHNpZ3MgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKG9iai5zaWduYXR1cmVzIHx8IHt9KSk7XG4gICAgICB2YXIgdW5zaWduZWQgPSBvYmoudW5zaWduZWQ7XG4gICAgICBkZWxldGUgb2JqLnNpZ25hdHVyZXM7XG4gICAgICBkZWxldGUgb2JqLnVuc2lnbmVkO1xuICAgICAgdmFyIHVzZXJTaWduYXR1cmVzID0gc2lncy5nZXQoX3RoaXM0NS51c2VySWQpIHx8IHt9O1xuICAgICAgdmFyIGNhbm9uYWxpemVkSnNvbiA9IGFub3RoZXJqc29uLnN0cmluZ2lmeShvYmopO1xuICAgICAgdmFyIHNpZ25hdHVyZXMgPSB5aWVsZCBfdGhpczQ1Lm9sbU1hY2hpbmUuc2lnbihjYW5vbmFsaXplZEpzb24pO1xuICAgICAgdmFyIG1hcCA9IEpTT04ucGFyc2Uoc2lnbmF0dXJlcy5hc0pTT04oKSk7XG4gICAgICBzaWdzLnNldChfdGhpczQ1LnVzZXJJZCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB1c2VyU2lnbmF0dXJlcyksIG1hcFtfdGhpczQ1LnVzZXJJZF0pKTtcbiAgICAgIGlmICh1bnNpZ25lZCAhPT0gdW5kZWZpbmVkKSBvYmoudW5zaWduZWQgPSB1bnNpZ25lZDtcbiAgICAgIG9iai5zaWduYXR1cmVzID0gT2JqZWN0LmZyb21FbnRyaWVzKHNpZ3MuZW50cmllcygpKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjcmVzdG9yZUtleUJhY2t1cFdpdGhQYXNzcGhyYXNlfS5cbiAgICovXG4gIHJlc3RvcmVLZXlCYWNrdXBXaXRoUGFzc3BocmFzZShwYXNzcGhyYXNlLCBvcHRzKSB7XG4gICAgdmFyIF90aGlzNDYgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIGJhY2t1cEluZm8gPSB5aWVsZCBfdGhpczQ2LmJhY2t1cE1hbmFnZXIuZ2V0U2VydmVyQmFja3VwSW5mbygpO1xuICAgICAgaWYgKCEoYmFja3VwSW5mbyAhPT0gbnVsbCAmJiBiYWNrdXBJbmZvICE9PSB2b2lkIDAgJiYgYmFja3VwSW5mby52ZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBiYWNrdXAgaW5mbyBhdmFpbGFibGVcIik7XG4gICAgICB9XG4gICAgICB2YXIgcHJpdmF0ZUtleSA9IHlpZWxkIGtleUZyb21BdXRoRGF0YShiYWNrdXBJbmZvLmF1dGhfZGF0YSwgcGFzc3BocmFzZSk7XG5cbiAgICAgIC8vIENhY2hlIHRoZSBrZXlcbiAgICAgIHlpZWxkIF90aGlzNDYuc3RvcmVTZXNzaW9uQmFja3VwUHJpdmF0ZUtleShwcml2YXRlS2V5LCBiYWNrdXBJbmZvLnZlcnNpb24pO1xuICAgICAgcmV0dXJuIF90aGlzNDYucmVzdG9yZUtleUJhY2t1cChvcHRzKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjcmVzdG9yZUtleUJhY2t1cH0uXG4gICAqL1xuICByZXN0b3JlS2V5QmFja3VwKG9wdHMpIHtcbiAgICB2YXIgX3RoaXM0NyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBHZXQgdGhlIGRlY3J5cHRpb24ga2V5IGZyb20gdGhlIGNyeXB0byBzdG9yZVxuICAgICAgdmFyIGJhY2t1cEtleXMgPSB5aWVsZCBfdGhpczQ3Lm9sbU1hY2hpbmUuZ2V0QmFja3VwS2V5cygpO1xuICAgICAgdmFyIHtcbiAgICAgICAgZGVjcnlwdGlvbktleSxcbiAgICAgICAgYmFja3VwVmVyc2lvblxuICAgICAgfSA9IGJhY2t1cEtleXM7XG4gICAgICBpZiAoIWRlY3J5cHRpb25LZXkgfHwgIWJhY2t1cFZlcnNpb24pIHRocm93IG5ldyBFcnJvcihcIk5vIGRlY3J5cHRpb24ga2V5IGZvdW5kIGluIGNyeXB0byBzdG9yZVwiKTtcbiAgICAgIHZhciBkZWNvZGVkRGVjcnlwdGlvbktleSA9IGRlY29kZUJhc2U2NChkZWNyeXB0aW9uS2V5LnRvQmFzZTY0KCkpO1xuICAgICAgdmFyIGJhY2t1cEluZm8gPSB5aWVsZCBfdGhpczQ3LmJhY2t1cE1hbmFnZXIucmVxdWVzdEtleUJhY2t1cFZlcnNpb24oYmFja3VwVmVyc2lvbik7XG4gICAgICBpZiAoIWJhY2t1cEluZm8pIHRocm93IG5ldyBFcnJvcihcIkJhY2t1cCB2ZXJzaW9uIHRvIHJlc3RvcmUgXCIuY29uY2F0KGJhY2t1cFZlcnNpb24sIFwiIG5vdCBmb3VuZCBvbiBzZXJ2ZXJcIikpO1xuICAgICAgdmFyIGJhY2t1cERlY3J5cHRvciA9IHlpZWxkIF90aGlzNDcuZ2V0QmFja3VwRGVjcnlwdG9yKGJhY2t1cEluZm8sIGRlY29kZWREZWNyeXB0aW9uS2V5KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfb3B0cyRwcm9ncmVzc0NhbGxiYWM7XG4gICAgICAgIG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwIHx8IChfb3B0cyRwcm9ncmVzc0NhbGxiYWMgPSBvcHRzLnByb2dyZXNzQ2FsbGJhY2spID09PSBudWxsIHx8IF9vcHRzJHByb2dyZXNzQ2FsbGJhYyA9PT0gdm9pZCAwIHx8IF9vcHRzJHByb2dyZXNzQ2FsbGJhYy5jYWxsKG9wdHMsIHtcbiAgICAgICAgICBzdGFnZTogXCJmZXRjaFwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geWllbGQgX3RoaXM0Ny5iYWNrdXBNYW5hZ2VyLnJlc3RvcmVLZXlCYWNrdXAoYmFja3VwVmVyc2lvbiwgYmFja3VwRGVjcnlwdG9yLCBvcHRzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIEZyZWUgdG8gYXZvaWQgdG8ga2VlcCBpbiBtZW1vcnkgdGhlIGRlY3J5cHRpb24ga2V5IHN0b3JlZCBpbiBpdC4gVG8gYXZvaWQgdG8gZXhwb3NpbmcgaXQgdG8gYW4gYXR0YWNrZXIuXG4gICAgICAgIGJhY2t1cERlY3J5cHRvci5mcmVlKCk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ3J5cHRvQXBpI2lzRGVoeWRyYXRpb25TdXBwb3J0ZWR9LlxuICAgKi9cbiAgaXNEZWh5ZHJhdGlvblN1cHBvcnRlZCgpIHtcbiAgICB2YXIgX3RoaXM0OCA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4geWllbGQgX3RoaXM0OC5kZWh5ZHJhdGVkRGV2aWNlTWFuYWdlci5pc1N1cHBvcnRlZCgpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNzdGFydERlaHlkcmF0aW9ufS5cbiAgICovXG4gIHN0YXJ0RGVoeWRyYXRpb24oKSB7XG4gICAgdmFyIF9hcmd1bWVudHM2ID0gYXJndW1lbnRzLFxuICAgICAgX3RoaXM0OSA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgb3B0cyA9IF9hcmd1bWVudHM2Lmxlbmd0aCA+IDAgJiYgX2FyZ3VtZW50czZbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmd1bWVudHM2WzBdIDoge307XG4gICAgICBpZiAoISh5aWVsZCBfdGhpczQ5LmlzQ3Jvc3NTaWduaW5nUmVhZHkoKSkgfHwgISh5aWVsZCBfdGhpczQ5LmlzU2VjcmV0U3RvcmFnZVJlYWR5KCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRldmljZSBkZWh5ZHJhdGlvbiByZXF1aXJlcyBjcm9zcy1zaWduaW5nIGFuZCBzZWNyZXQgc3RvcmFnZSB0byBiZSBzZXQgdXBcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4geWllbGQgX3RoaXM0OS5kZWh5ZHJhdGVkRGV2aWNlTWFuYWdlci5zdGFydChvcHRzIHx8IHt9KTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG9BcGkjaW1wb3J0U2VjcmV0c0J1bmRsZX0uXG4gICAqL1xuICBpbXBvcnRTZWNyZXRzQnVuZGxlKHNlY3JldHMpIHtcbiAgICB2YXIgX3RoaXM1MCA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgc2VjcmV0c0J1bmRsZSA9IFJ1c3RTZGtDcnlwdG9Kcy5TZWNyZXRzQnVuZGxlLmZyb21fanNvbihzZWNyZXRzKTtcbiAgICAgIHlpZWxkIF90aGlzNTAuZ2V0T2xtTWFjaGluZU9yVGhyb3coKS5pbXBvcnRTZWNyZXRzQnVuZGxlKHNlY3JldHNCdW5kbGUpOyAvLyB0aGlzIG1ldGhvZCBmcmVlcyB0aGUgU2VjcmV0c0J1bmRsZVxuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0b0FwaSNleHBvcnRTZWNyZXRzQnVuZGxlfS5cbiAgICovXG4gIGV4cG9ydFNlY3JldHNCdW5kbGUoKSB7XG4gICAgdmFyIF90aGlzNTEgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHNlY3JldHNCdW5kbGUgPSB5aWVsZCBfdGhpczUxLmdldE9sbU1hY2hpbmVPclRocm93KCkuZXhwb3J0U2VjcmV0c0J1bmRsZSgpO1xuICAgICAgdmFyIHNlY3JldHMgPSBzZWNyZXRzQnVuZGxlLnRvX2pzb24oKTtcbiAgICAgIHNlY3JldHNCdW5kbGUuZnJlZSgpO1xuICAgICAgcmV0dXJuIHNlY3JldHM7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ3J5cHRvQXBpI2VuY3J5cHRUb0RldmljZU1lc3NhZ2VzfS5cbiAgICovXG4gIGVuY3J5cHRUb0RldmljZU1lc3NhZ2VzKGV2ZW50VHlwZSwgZGV2aWNlcywgcGF5bG9hZCkge1xuICAgIHZhciBfdGhpczUyID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBsb2dnZXIgPSBuZXcgTG9nU3BhbihfdGhpczUyLmxvZ2dlciwgXCJlbmNyeXB0VG9EZXZpY2VNZXNzYWdlc1wiKTtcbiAgICAgIHZhciB1bmlxdWVVc2VycyA9IG5ldyBTZXQoZGV2aWNlcy5tYXAoX3JlZjIgPT4ge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHVzZXJJZFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiB1c2VySWQ7XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFRoaXMgd2lsbCBlbnN1cmUgd2UgaGF2ZSBPbG0gc2Vzc2lvbnMgZm9yIGFsbCBvZiB0aGUgdXNlcnMnIGRldmljZXMuXG4gICAgICAvLyBIb3dldmVyLCB3ZSBvbmx5IGNhcmUgYWJvdXQgc29tZSBvZiB0aGUgZGV2aWNlcy5cbiAgICAgIC8vIFNvLCBwZXJoYXBzIHdlIGNhbiBvcHRpbWlzZSB0aGlzIGxhdGVyIG9uLlxuICAgICAgeWllbGQgX3RoaXM1Mi5rZXlDbGFpbU1hbmFnZXIuZW5zdXJlU2Vzc2lvbnNGb3JVc2Vycyhsb2dnZXIsIEFycmF5LmZyb20odW5pcXVlVXNlcnMpLm1hcCh1c2VySWQgPT4gbmV3IFJ1c3RTZGtDcnlwdG9Kcy5Vc2VySWQodXNlcklkKSkpO1xuICAgICAgdmFyIGJhdGNoID0ge1xuICAgICAgICBiYXRjaDogW10sXG4gICAgICAgIGV2ZW50VHlwZTogRXZlbnRUeXBlLlJvb21NZXNzYWdlRW5jcnlwdGVkXG4gICAgICB9O1xuICAgICAgeWllbGQgUHJvbWlzZS5hbGwoZGV2aWNlcy5tYXAoLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWY0ID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qIChfcmVmMykge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgICBkZXZpY2VJZFxuICAgICAgICAgIH0gPSBfcmVmMztcbiAgICAgICAgICB2YXIgZGV2aWNlID0geWllbGQgX3RoaXM1Mi5vbG1NYWNoaW5lLmdldERldmljZShuZXcgUnVzdFNka0NyeXB0b0pzLlVzZXJJZCh1c2VySWQpLCBuZXcgUnVzdFNka0NyeXB0b0pzLkRldmljZUlkKGRldmljZUlkKSk7XG4gICAgICAgICAgaWYgKGRldmljZSkge1xuICAgICAgICAgICAgdmFyIGVuY3J5cHRlZFBheWxvYWQgPSBKU09OLnBhcnNlKHlpZWxkIGRldmljZS5lbmNyeXB0VG9EZXZpY2VFdmVudChldmVudFR5cGUsIHBheWxvYWQpKTtcbiAgICAgICAgICAgIGJhdGNoLmJhdGNoLnB1c2goe1xuICAgICAgICAgICAgICBkZXZpY2VJZCxcbiAgICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBlbmNyeXB0ZWRQYXlsb2FkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXM1Mi5sb2dnZXIud2FybihcImVuY3J5cHRUb0RldmljZU1lc3NhZ2VzOiB1bmtub3duIGRldmljZSBcIi5jb25jYXQodXNlcklkLCBcIjpcIikuY29uY2F0KGRldmljZUlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeCkge1xuICAgICAgICAgIHJldHVybiBfcmVmNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfSgpKSk7XG4gICAgICByZXR1cm4gYmF0Y2g7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ3J5cHRvQXBpI3Jlc2V0RW5jcnlwdGlvbn0uXG4gICAqL1xuICByZXNldEVuY3J5cHRpb24oYXV0aFVwbG9hZERldmljZVNpZ25pbmdLZXlzKSB7XG4gICAgdmFyIF90aGlzNTMgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgX3RoaXM1My5sb2dnZXIuZGVidWcoXCJyZXNldEVuY3J5cHRpb246IHJlc2V0dGluZyBlbmNyeXB0aW9uXCIpO1xuXG4gICAgICAvLyBEaXNhYmxlIGJhY2t1cCwgYW5kIGRlbGV0ZSBhbGwgdGhlIGJhY2t1cHMgZnJvbSB0aGUgc2VydmVyXG4gICAgICB5aWVsZCBfdGhpczUzLmJhY2t1cE1hbmFnZXIuZGVsZXRlQWxsS2V5QmFja3VwVmVyc2lvbnMoKTtcblxuICAgICAgLy8gRGlzYWJsZSB0aGUgcmVjb3Zlcnkga2V5IGFuZCB0aGUgc2VjcmV0IHN0b3JhZ2VcbiAgICAgIHlpZWxkIF90aGlzNTMuc2VjcmV0U3RvcmFnZS5zZXREZWZhdWx0S2V5SWQobnVsbCk7XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBjcm9zcy1zaWduaW5nIGtleXNcbiAgICAgIHlpZWxkIF90aGlzNTMuY3Jvc3NTaWduaW5nSWRlbnRpdHkuYm9vdHN0cmFwQ3Jvc3NTaWduaW5nKHtcbiAgICAgICAgc2V0dXBOZXdDcm9zc1NpZ25pbmc6IHRydWUsXG4gICAgICAgIGF1dGhVcGxvYWREZXZpY2VTaWduaW5nS2V5c1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBrZXkgYmFja3VwXG4gICAgICB5aWVsZCBfdGhpczUzLnJlc2V0S2V5QmFja3VwKCk7XG4gICAgICBfdGhpczUzLmxvZ2dlci5kZWJ1ZyhcInJlc2V0RW5jcnlwdGlvbjogZW5kZWRcIik7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy9cbiAgLy8gU3luY0NyeXB0b0NhbGxiYWNrcyBpbXBsZW1lbnRhdGlvblxuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIEFwcGx5IHN5bmMgY2hhbmdlcyB0byB0aGUgb2xtIG1hY2hpbmVcbiAgICogQHBhcmFtIGV2ZW50cyAtIHRoZSByZWNlaXZlZCB0by1kZXZpY2UgbWVzc2FnZXNcbiAgICogQHBhcmFtIG9uZVRpbWVLZXlzQ291bnRzIC0gdGhlIHJlY2VpdmVkIG9uZSB0aW1lIGtleSBjb3VudHNcbiAgICogQHBhcmFtIHVudXNlZEZhbGxiYWNrS2V5cyAtIHRoZSByZWNlaXZlZCB1bnVzZWQgZmFsbGJhY2sga2V5c1xuICAgKiBAcGFyYW0gZGV2aWNlcyAtIHRoZSByZWNlaXZlZCBkZXZpY2UgbGlzdCB1cGRhdGVzXG4gICAqIEByZXR1cm5zIEEgbGlzdCBvZiBwcmVwcm9jZXNzZWQgdG8tZGV2aWNlIG1lc3NhZ2VzLlxuICAgKi9cbiAgcmVjZWl2ZVN5bmNDaGFuZ2VzKF9yZWY1KSB7XG4gICAgdmFyIF90aGlzNTQgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHtcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBvbmVUaW1lS2V5c0NvdW50cyA9IG5ldyBNYXAoKSxcbiAgICAgICAgdW51c2VkRmFsbGJhY2tLZXlzLFxuICAgICAgICBkZXZpY2VzID0gbmV3IFJ1c3RTZGtDcnlwdG9Kcy5EZXZpY2VMaXN0cygpXG4gICAgICB9ID0gX3JlZjU7XG4gICAgICB2YXIgcmVzdWx0ID0geWllbGQgbG9nRHVyYXRpb24obG9nZ2VyLCBcInJlY2VpdmVTeW5jQ2hhbmdlc1wiLCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIF90aGlzNTQub2xtTWFjaGluZS5yZWNlaXZlU3luY0NoYW5nZXMoZXZlbnRzID8gSlNPTi5zdHJpbmdpZnkoZXZlbnRzKSA6IFwiW11cIiwgZGV2aWNlcywgb25lVGltZUtleXNDb3VudHMsIHVudXNlZEZhbGxiYWNrS2V5cyk7XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIHJlY2VpdmVTeW5jQ2hhbmdlcyByZXR1cm5zIGEgSlNPTi1lbmNvZGVkIGxpc3Qgb2YgZGVjcnlwdGVkIHRvLWRldmljZSBtZXNzYWdlcy5cbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3VsdCk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKiBjYWxsZWQgYnkgdGhlIHN5bmMgbG9vcCB0byBwcmVwcm9jZXNzIGluY29taW5nIHRvLWRldmljZSBtZXNzYWdlc1xuICAgKlxuICAgKiBAcGFyYW0gZXZlbnRzIC0gdGhlIHJlY2VpdmVkIHRvLWRldmljZSBtZXNzYWdlc1xuICAgKiBAcmV0dXJucyBBIGxpc3Qgb2YgcHJlcHJvY2Vzc2VkIHRvLWRldmljZSBtZXNzYWdlcy5cbiAgICovXG4gIHByZXByb2Nlc3NUb0RldmljZU1lc3NhZ2VzKGV2ZW50cykge1xuICAgIHZhciBfdGhpczU1ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIHNlbmQgdGhlIHJlY2VpdmVkIHRvLWRldmljZSBtZXNzYWdlcyBpbnRvIHJlY2VpdmVTeW5jQ2hhbmdlcy4gV2UgaGF2ZSBubyBpbmZvIG9uIGRldmljZS1saXN0IGNoYW5nZXMsXG4gICAgICAvLyBvbmUtdGltZS1rZXlzLCBvciBmYWxsYmFjayBrZXlzLCBzbyBqdXN0IHBhc3MgZW1wdHkgZGF0YS5cbiAgICAgIHZhciBwcm9jZXNzZWQgPSB5aWVsZCBfdGhpczU1LnJlY2VpdmVTeW5jQ2hhbmdlcyh7XG4gICAgICAgIGV2ZW50c1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGxvb2sgZm9yIGludGVyZXN0aW5nIHRvLWRldmljZSBtZXNzYWdlc1xuICAgICAgZm9yICh2YXIgbWVzc2FnZSBvZiBwcm9jZXNzZWQpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gRXZlbnRUeXBlLktleVZlcmlmaWNhdGlvblJlcXVlc3QpIHtcbiAgICAgICAgICB2YXIgc2VuZGVyID0gbWVzc2FnZS5zZW5kZXI7XG4gICAgICAgICAgdmFyIHRyYW5zYWN0aW9uSWQgPSBtZXNzYWdlLmNvbnRlbnQudHJhbnNhY3Rpb25faWQ7XG4gICAgICAgICAgaWYgKHRyYW5zYWN0aW9uSWQgJiYgc2VuZGVyKSB7XG4gICAgICAgICAgICBfdGhpczU1Lm9uSW5jb21pbmdLZXlWZXJpZmljYXRpb25SZXF1ZXN0KHNlbmRlciwgdHJhbnNhY3Rpb25JZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKiogY2FsbGVkIGJ5IHRoZSBzeW5jIGxvb3AgdG8gcHJvY2VzcyBvbmUgdGltZSBrZXkgY291bnRzIGFuZCB1bnVzZWQgZmFsbGJhY2sga2V5c1xuICAgKlxuICAgKiBAcGFyYW0gb25lVGltZUtleXNDb3VudHMgLSB0aGUgcmVjZWl2ZWQgb25lIHRpbWUga2V5IGNvdW50c1xuICAgKiBAcGFyYW0gdW51c2VkRmFsbGJhY2tLZXlzIC0gdGhlIHJlY2VpdmVkIHVudXNlZCBmYWxsYmFjayBrZXlzXG4gICAqL1xuICBwcm9jZXNzS2V5Q291bnRzKG9uZVRpbWVLZXlzQ291bnRzLCB1bnVzZWRGYWxsYmFja0tleXMpIHtcbiAgICB2YXIgX3RoaXM1NiA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgbWFwT25lVGltZUtleXNDb3VudCA9IG9uZVRpbWVLZXlzQ291bnRzICYmIG5ldyBNYXAoT2JqZWN0LmVudHJpZXMob25lVGltZUtleXNDb3VudHMpKTtcbiAgICAgIHZhciBzZXRVbnVzZWRGYWxsYmFja0tleXMgPSB1bnVzZWRGYWxsYmFja0tleXMgJiYgbmV3IFNldCh1bnVzZWRGYWxsYmFja0tleXMpO1xuICAgICAgaWYgKG1hcE9uZVRpbWVLZXlzQ291bnQgIT09IHVuZGVmaW5lZCB8fCBzZXRVbnVzZWRGYWxsYmFja0tleXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB5aWVsZCBfdGhpczU2LnJlY2VpdmVTeW5jQ2hhbmdlcyh7XG4gICAgICAgICAgb25lVGltZUtleXNDb3VudHM6IG1hcE9uZVRpbWVLZXlzQ291bnQsXG4gICAgICAgICAgdW51c2VkRmFsbGJhY2tLZXlzOiBzZXRVbnVzZWRGYWxsYmFja0tleXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKiBjYWxsZWQgYnkgdGhlIHN5bmMgbG9vcCB0byBwcm9jZXNzIHRoZSBub3RpZmljYXRpb24gdGhhdCBkZXZpY2UgbGlzdHMgaGF2ZVxuICAgKiBiZWVuIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSBkZXZpY2VMaXN0cyAtIGRldmljZV9saXN0cyBmaWVsZCBmcm9tIC9zeW5jXG4gICAqL1xuICBwcm9jZXNzRGV2aWNlTGlzdHMoZGV2aWNlTGlzdHMpIHtcbiAgICB2YXIgX3RoaXM1NyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2RldmljZUxpc3RzJGNoYW5nZWQsIF9kZXZpY2VMaXN0cyRsZWZ0O1xuICAgICAgdmFyIGRldmljZXMgPSBuZXcgUnVzdFNka0NyeXB0b0pzLkRldmljZUxpc3RzKChfZGV2aWNlTGlzdHMkY2hhbmdlZCA9IGRldmljZUxpc3RzLmNoYW5nZWQpID09PSBudWxsIHx8IF9kZXZpY2VMaXN0cyRjaGFuZ2VkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGV2aWNlTGlzdHMkY2hhbmdlZC5tYXAodXNlcklkID0+IG5ldyBSdXN0U2RrQ3J5cHRvSnMuVXNlcklkKHVzZXJJZCkpLCAoX2RldmljZUxpc3RzJGxlZnQgPSBkZXZpY2VMaXN0cy5sZWZ0KSA9PT0gbnVsbCB8fCBfZGV2aWNlTGlzdHMkbGVmdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RldmljZUxpc3RzJGxlZnQubWFwKHVzZXJJZCA9PiBuZXcgUnVzdFNka0NyeXB0b0pzLlVzZXJJZCh1c2VySWQpKSk7XG4gICAgICB5aWVsZCBfdGhpczU3LnJlY2VpdmVTeW5jQ2hhbmdlcyh7XG4gICAgICAgIGRldmljZXNcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKiogY2FsbGVkIGJ5IHRoZSBzeW5jIGxvb3Agb24gbS5yb29tLmVuY3J5cHRlZCBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIHJvb20gLSBpbiB3aGljaCB0aGUgZXZlbnQgd2FzIHJlY2VpdmVkXG4gICAqIEBwYXJhbSBldmVudCAtIGVuY3J5cHRpb24gZXZlbnQgdG8gYmUgcHJvY2Vzc2VkXG4gICAqL1xuICBvbkNyeXB0b0V2ZW50KHJvb20sIGV2ZW50KSB7XG4gICAgdmFyIF90aGlzNTggPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIGNvbmZpZyA9IGV2ZW50LmdldENvbnRlbnQoKTtcbiAgICAgIHZhciBzZXR0aW5ncyA9IG5ldyBSdXN0U2RrQ3J5cHRvSnMuUm9vbVNldHRpbmdzKCk7XG4gICAgICBpZiAoY29uZmlnLmFsZ29yaXRobSA9PT0gXCJtLm1lZ29sbS52MS5hZXMtc2hhMlwiKSB7XG4gICAgICAgIHNldHRpbmdzLmFsZ29yaXRobSA9IFJ1c3RTZGtDcnlwdG9Kcy5FbmNyeXB0aW9uQWxnb3JpdGhtLk1lZ29sbVYxQWVzU2hhMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFtb25nIG90aGVyIHNpdHVhdGlvbnMsIHRoaXMgaGFwcGVucyBpZiB0aGUgY3J5cHRvIHN0YXRlIGV2ZW50IGlzIHJlZGFjdGVkLlxuICAgICAgICBfdGhpczU4LmxvZ2dlci53YXJuKFwiUm9vbSBcIi5jb25jYXQocm9vbS5yb29tSWQsIFwiOiBpZ25vcmluZyBjcnlwdG8gZXZlbnQgd2l0aCBpbnZhbGlkIGFsZ29yaXRobSBcIikuY29uY2F0KGNvbmZpZy5hbGdvcml0aG0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0dGluZ3Muc2Vzc2lvblJvdGF0aW9uUGVyaW9kTXMgPSBjb25maWcucm90YXRpb25fcGVyaW9kX21zO1xuICAgICAgICBzZXR0aW5ncy5zZXNzaW9uUm90YXRpb25QZXJpb2RNZXNzYWdlcyA9IGNvbmZpZy5yb3RhdGlvbl9wZXJpb2RfbXNncztcbiAgICAgICAgeWllbGQgX3RoaXM1OC5vbG1NYWNoaW5lLnNldFJvb21TZXR0aW5ncyhuZXcgUnVzdFNka0NyeXB0b0pzLlJvb21JZChyb29tLnJvb21JZCksIHNldHRpbmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgX3RoaXM1OC5sb2dnZXIud2FybihcIlJvb20gXCIuY29uY2F0KHJvb20ucm9vbUlkLCBcIjogaWdub3JpbmcgY3J5cHRvIGV2ZW50IHdoaWNoIGNhdXNlZCBlcnJvcjogXCIpLmNvbmNhdChlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyLCB0aGUgU0RLIGZvdW5kIHRoZSBldmVudCBhY2NlcHRhYmxlLlxuICAgICAgLy8gV2UgbmVlZCB0byBlaXRoZXIgY3JlYXRlIG9yIHVwZGF0ZSB0aGUgYWN0aXZlIFJvb21FbmNyeXB0b3IuXG4gICAgICB2YXIgZXhpc3RpbmdFbmNyeXB0b3IgPSBfdGhpczU4LnJvb21FbmNyeXB0b3JzW3Jvb20ucm9vbUlkXTtcbiAgICAgIGlmIChleGlzdGluZ0VuY3J5cHRvcikge1xuICAgICAgICBleGlzdGluZ0VuY3J5cHRvci5vbkNyeXB0b0V2ZW50KGNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpczU4LnJvb21FbmNyeXB0b3JzW3Jvb20ucm9vbUlkXSA9IG5ldyBSb29tRW5jcnlwdG9yKF90aGlzNTgub2xtTWFjaGluZSwgX3RoaXM1OC5rZXlDbGFpbU1hbmFnZXIsIF90aGlzNTgub3V0Z29pbmdSZXF1ZXN0c01hbmFnZXIsIHJvb20sIGNvbmZpZyk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKiBjYWxsZWQgYnkgdGhlIHN5bmMgbG9vcCBhZnRlciBwcm9jZXNzaW5nIGVhY2ggc3luYy5cbiAgICpcbiAgICogVE9ETzogZmlndXJlIG91dCBzb21ldGhpbmcgZXF1aXZhbGVudCBmb3Igc2xpZGluZyBzeW5jLlxuICAgKlxuICAgKiBAcGFyYW0gc3luY1N0YXRlIC0gaW5mb3JtYXRpb24gb24gdGhlIGNvbXBsZXRlZCBzeW5jLlxuICAgKi9cbiAgb25TeW5jQ29tcGxldGVkKHN5bmNTdGF0ZSkge1xuICAgIC8vIFByb2Nlc3NpbmcgdGhlIC9zeW5jIG1heSBoYXZlIHByb2R1Y2VkIG5ldyBvdXRnb2luZyByZXF1ZXN0cyB3aGljaCBuZWVkIHNlbmRpbmcsIHNvIGtpY2sgb2ZmIHRoZSBvdXRnb2luZ1xuICAgIC8vIHJlcXVlc3QgbG9vcCwgaWYgaXQncyBub3QgYWxyZWFkeSBydW5uaW5nLlxuICAgIHRoaXMub3V0Z29pbmdSZXF1ZXN0c01hbmFnZXIuZG9Qcm9jZXNzT3V0Z29pbmdSZXF1ZXN0cygpLmNhdGNoKGUgPT4ge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcIm9uU3luY0NvbXBsZXRlZDogRXJyb3IgcHJvY2Vzc2luZyBvdXRnb2luZyByZXF1ZXN0c1wiLCBlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gaW5jb21pbmcgbS5rZXkudmVyaWZpY2F0aW9uLnJlcXVlc3QgZXZlbnQsIHJlY2VpdmVkIGVpdGhlciBpbi1yb29tIG9yIGluIGEgdG8tZGV2aWNlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBzZW5kZXIgLSB0aGUgc2VuZGVyIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25JZCAtIHRoZSB0cmFuc2FjdGlvbiBJRCBmb3IgdGhlIHZlcmlmaWNhdGlvbi4gRm9yIHRvLWRldmljZSBtZXNzYWdlcywgdGhpcyBjb21lcyBmcm9tIHRoZVxuICAgKiAgICBjb250ZW50IG9mIHRoZSBtZXNzYWdlOyBmb3IgaW4tcm9vbSBtZXNzYWdlcyBpdCBpcyB0aGUgZXZlbnQgSUQuXG4gICAqL1xuICBvbkluY29taW5nS2V5VmVyaWZpY2F0aW9uUmVxdWVzdChzZW5kZXIsIHRyYW5zYWN0aW9uSWQpIHtcbiAgICB2YXIgcmVxdWVzdCA9IHRoaXMub2xtTWFjaGluZS5nZXRWZXJpZmljYXRpb25SZXF1ZXN0KG5ldyBSdXN0U2RrQ3J5cHRvSnMuVXNlcklkKHNlbmRlciksIHRyYW5zYWN0aW9uSWQpO1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICB0aGlzLmVtaXQoQ3J5cHRvRXZlbnQuVmVyaWZpY2F0aW9uUmVxdWVzdFJlY2VpdmVkLCBuZXcgUnVzdFZlcmlmaWNhdGlvblJlcXVlc3QodGhpcy5vbG1NYWNoaW5lLCByZXF1ZXN0LCB0aGlzLm91dGdvaW5nUmVxdWVzdFByb2Nlc3NvciwgdGhpcy5fc3VwcG9ydGVkVmVyaWZpY2F0aW9uTWV0aG9kcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBhcmUgbXVsdGlwbGUgcmVhc29ucyB0aGlzIGNhbiBoYXBwZW47IHByb2JhYmx5IHRoZSBtb3N0IGxpa2VseSBpcyB0aGF0IHRoZSBldmVudCBpcyBhblxuICAgICAgLy8gaW4tcm9vbSBldmVudCB3aGljaCBpcyB0b28gb2xkLlxuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIklnbm9yaW5nIGp1c3QtcmVjZWl2ZWQgdmVyaWZpY2F0aW9uIHJlcXVlc3QgXCIuY29uY2F0KHRyYW5zYWN0aW9uSWQsIFwiIHdoaWNoIGRpZCBub3Qgc3RhcnQgYSBydXN0LXNpZGUgdmVyaWZpY2F0aW9uXCIpKTtcbiAgICB9XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vIE90aGVyIHB1YmxpYyBmdW5jdGlvbnNcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKiBjYWxsZWQgYnkgdGhlIE1hdHJpeENsaWVudCBvbiBhIHJvb20gbWVtYmVyc2hpcCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgbWF0cml4IGV2ZW50IHdoaWNoIGNhdXNlZCB0aGlzIGV2ZW50IHRvIGZpcmUuXG4gICAqIEBwYXJhbSBtZW1iZXIgLSBUaGUgbWVtYmVyIHdob3NlIFJvb21NZW1iZXIubWVtYmVyc2hpcCBjaGFuZ2VkLlxuICAgKiBAcGFyYW0gb2xkTWVtYmVyc2hpcCAtIFRoZSBwcmV2aW91cyBtZW1iZXJzaGlwIHN0YXRlLiBOdWxsIGlmIGl0J3MgYSBuZXcgbWVtYmVyLlxuICAgKi9cbiAgb25Sb29tTWVtYmVyc2hpcChldmVudCwgbWVtYmVyLCBvbGRNZW1iZXJzaGlwKSB7XG4gICAgdmFyIGVuYyA9IHRoaXMucm9vbUVuY3J5cHRvcnNbZXZlbnQuZ2V0Um9vbUlkKCldO1xuICAgIGlmICghZW5jKSB7XG4gICAgICAvLyBub3QgZW5jcnlwdGluZyBpbiB0aGlzIHJvb21cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5jLm9uUm9vbU1lbWJlcnNoaXAobWVtYmVyKTtcbiAgfVxuXG4gIC8qKiBDYWxsYmFjayBmb3IgT2xtTWFjaGluZS5yZWdpc3RlclJvb21LZXlVcGRhdGVkQ2FsbGJhY2tcbiAgICpcbiAgICogQ2FsbGVkIGJ5IHRoZSBydXN0LXNkayB3aGVuZXZlciB0aGVyZSBpcyBhbiB1cGRhdGUgdG8gKG1lZ29sbSkgcm9vbSBrZXlzLiBXZVxuICAgKiBjaGVjayBpZiB3ZSBoYXZlIGFueSBldmVudHMgd2FpdGluZyBmb3IgdGhlIGdpdmVuIGtleXMsIGFuZCBzY2hlZHVsZSB0aGVtIGZvclxuICAgKiBhIGRlY3J5cHRpb24gcmV0cnkgaWYgc28uXG4gICAqXG4gICAqIEBwYXJhbSBrZXlzIC0gZGV0YWlscyBvZiB0aGUgdXBkYXRlZCBrZXlzXG4gICAqL1xuICBvblJvb21LZXlzVXBkYXRlZChrZXlzKSB7XG4gICAgdmFyIF90aGlzNTkgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIga2V5IG9mIGtleXMpIHtcbiAgICAgICAgX3RoaXM1OS5vblJvb21LZXlVcGRhdGVkKGtleSk7XG4gICAgICB9XG4gICAgICBfdGhpczU5LmJhY2t1cE1hbmFnZXIubWF5YmVVcGxvYWRLZXkoKTtcbiAgICB9KSgpO1xuICB9XG4gIG9uUm9vbUtleVVwZGF0ZWQoa2V5KSB7XG4gICAgdmFyIF90aGlzNjAgPSB0aGlzO1xuICAgIGlmICh0aGlzLnN0b3BwZWQpIHJldHVybjtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkdvdCB1cGRhdGUgZm9yIHNlc3Npb24gXCIuY29uY2F0KGtleS5zZXNzaW9uSWQsIFwiIGZyb20gc2VuZGVyIFwiKS5jb25jYXQoa2V5LnNlbmRlcktleS50b0Jhc2U2NCgpLCBcIiBpbiBcIikuY29uY2F0KGtleS5yb29tSWQudG9TdHJpbmcoKSkpO1xuICAgIHZhciBwZW5kaW5nTGlzdCA9IHRoaXMuZXZlbnREZWNyeXB0b3IuZ2V0RXZlbnRzUGVuZGluZ1Jvb21LZXkoa2V5LnJvb21JZC50b1N0cmluZygpLCBrZXkuc2Vzc2lvbklkKTtcbiAgICBpZiAocGVuZGluZ0xpc3QubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXCJSZXRyeWluZyBkZWNyeXB0aW9uIG9uIGV2ZW50czpcIiwgcGVuZGluZ0xpc3QubWFwKGUgPT4gXCJcIi5jb25jYXQoZS5nZXRJZCgpKSkpO1xuXG4gICAgLy8gSGF2ZSBhbm90aGVyIGdvIGF0IGRlY3J5cHRpbmcgZXZlbnRzIHdpdGggdGhpcyBrZXkuXG4gICAgLy9cbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIGVuZCB1cCBibG9ja2luZyB0aGUgY2FsbGJhY2sgZnJvbSBSdXN0LCB3aGljaCBjb3VsZCBvdGhlcndpc2UgZW5kIHVwIGRyb3BwaW5nIHVwZGF0ZXMsXG4gICAgLy8gc28gd2UgZG9uJ3Qgd2FpdCBmb3IgdGhlIGRlY3J5cHRpb24gdG8gY29tcGxldGUuIEluIGFueSBjYXNlLCB0aGVyZSBpcyBubyBuZWVkIHRvIHdhaXQ6XG4gICAgLy8gTWF0cml4RXZlbnQuYXR0ZW1wdERlY3J5cHRpb24gZW5zdXJlcyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIGRlY3J5cHRpb24gYXR0ZW1wdCBoYXBwZW5pbmcgYXQgb25jZSxcbiAgICAvLyBhbmQgZGVkdXBsaWNhdGVzIHJlcGVhdGVkIGF0dGVtcHRzIGZvciB0aGUgc2FtZSBldmVudC5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChldikge1xuICAgICAgZXYuYXR0ZW1wdERlY3J5cHRpb24oX3RoaXM2MCwge1xuICAgICAgICBpc1JldHJ5OiB0cnVlXG4gICAgICB9KS5jYXRjaChfZSA9PiB7XG4gICAgICAgIF90aGlzNjAubG9nZ2VyLmluZm8oXCJTdGlsbCB1bmFibGUgdG8gZGVjcnlwdCBldmVudCBcIi5jb25jYXQoZXYuZ2V0SWQoKSwgXCIgYWZ0ZXIgcmVjZWl2aW5nIGtleVwiKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZvciAodmFyIGV2IG9mIHBlbmRpbmdMaXN0KSB7XG4gICAgICBfbG9vcChldik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBgT2xtTWFjaGluZS5yZWdpc3RlclJvb21LZXlXaXRoaGVsZENhbGxiYWNrYC5cbiAgICpcbiAgICogQ2FsbGVkIGJ5IHRoZSBydXN0IHNkayB3aGVuZXZlciB3ZSBhcmUgdG9sZCB0aGF0IGEga2V5IGhhcyBiZWVuIHdpdGhoZWxkLiBXZSBzZWUgaWYgd2UgaGFkIGFueSBldmVudHMgdGhhdFxuICAgKiBmYWlsZWQgdG8gZGVjcnlwdCBmb3IgdGhlIGdpdmVuIHNlc3Npb24sIGFuZCB1cGRhdGUgdGhlaXIgc3RhdHVzIGlmIHNvLlxuICAgKlxuICAgKiBAcGFyYW0gd2l0aGhlbGQgLSBEZXRhaWxzIG9mIHRoZSB3aXRoaGVsZCBzZXNzaW9ucy5cbiAgICovXG4gIG9uUm9vbUtleXNXaXRoaGVsZCh3aXRoaGVsZCkge1xuICAgIHZhciBfdGhpczYxID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciAodmFyIHNlc3Npb24gb2Ygd2l0aGhlbGQpIHtcbiAgICAgICAgX3RoaXM2MS5sb2dnZXIuZGVidWcoXCJHb3Qgd2l0aGhlbGQgbWVzc2FnZSBmb3Igc2Vzc2lvbiBcIi5jb25jYXQoc2Vzc2lvbi5zZXNzaW9uSWQsIFwiIGluIFwiKS5jb25jYXQoc2Vzc2lvbi5yb29tSWQudG9TdHJpbmcoKSkpO1xuICAgICAgICB2YXIgcGVuZGluZ0xpc3QgPSBfdGhpczYxLmV2ZW50RGVjcnlwdG9yLmdldEV2ZW50c1BlbmRpbmdSb29tS2V5KHNlc3Npb24ucm9vbUlkLnRvU3RyaW5nKCksIHNlc3Npb24uc2Vzc2lvbklkKTtcbiAgICAgICAgaWYgKHBlbmRpbmdMaXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFRoZSBlYXNpZXN0IHdheSB0byB1cGRhdGUgdGhlIHN0YXR1cyBvZiB0aGUgZXZlbnQgaXMgdG8gaGF2ZSBhbm90aGVyIGdvIGF0IGRlY3J5cHRpbmcgaXQuXG4gICAgICAgIF90aGlzNjEubG9nZ2VyLmRlYnVnKFwiUmV0cnlpbmcgZGVjcnlwdGlvbiBvbiBldmVudHM6XCIsIHBlbmRpbmdMaXN0Lm1hcChlID0+IFwiXCIuY29uY2F0KGUuZ2V0SWQoKSkpKTtcbiAgICAgICAgZm9yICh2YXIgZXYgb2YgcGVuZGluZ0xpc3QpIHtcbiAgICAgICAgICBldi5hdHRlbXB0RGVjcnlwdGlvbihfdGhpczYxLCB7XG4gICAgICAgICAgICBpc1JldHJ5OiB0cnVlXG4gICAgICAgICAgfSkuY2F0Y2goX2UgPT4ge1xuICAgICAgICAgICAgLy8gSXQncyBzb21ld2hhdCBleHBlY3RlZCB0aGF0IHdlIHN0aWxsIGNhbid0IGRlY3J5cHQgaGVyZS5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGBPbG1NYWNoaW5lLnJlZ2lzdGVyVXNlcklkZW50aXR5VXBkYXRlZENhbGxiYWNrYFxuICAgKlxuICAgKiBDYWxsZWQgYnkgdGhlIHJ1c3Qtc2RrIHdoZW5ldmVyIHRoZXJlIGlzIGFuIHVwZGF0ZSB0byBhbnkgdXNlcidzIGNyb3NzLXNpZ25pbmcgc3RhdHVzLiBXZSByZS1jaGVjayB0aGVpciB0cnVzdFxuICAgKiBzdGF0dXMgYW5kIGVtaXQgYSBgVXNlclRydXN0U3RhdHVzQ2hhbmdlZGAgZXZlbnQsIGFzIHdlbGwgYXMgYSBgS2V5c0NoYW5nZWRgIGlmIGl0IGlzIG91ciBvd24gaWRlbnRpdHkgdGhhdCBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0gdXNlcklkIC0gdGhlIHVzZXIgd2l0aCB0aGUgdXBkYXRlZCBpZGVudGl0eVxuICAgKi9cbiAgb25Vc2VySWRlbnRpdHlVcGRhdGVkKHVzZXJJZCkge1xuICAgIHZhciBfdGhpczYyID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBuZXdWZXJpZmljYXRpb24gPSB5aWVsZCBfdGhpczYyLmdldFVzZXJWZXJpZmljYXRpb25TdGF0dXModXNlcklkLnRvU3RyaW5nKCkpO1xuICAgICAgX3RoaXM2Mi5lbWl0KENyeXB0b0V2ZW50LlVzZXJUcnVzdFN0YXR1c0NoYW5nZWQsIHVzZXJJZC50b1N0cmluZygpLCBuZXdWZXJpZmljYXRpb24pO1xuXG4gICAgICAvLyBJZiBvdXIgb3duIHVzZXIgaWRlbnRpdHkgaGFzIGNoYW5nZWQsIHdlIG1heSBub3cgdHJ1c3QgdGhlIGtleSBiYWNrdXAgd2hlcmUgd2UgZGlkIG5vdCBiZWZvcmUuXG4gICAgICAvLyBTbywgcmUtY2hlY2sgdGhlIGtleSBiYWNrdXAgc3RhdHVzIGFuZCBlbmFibGUgaXQgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHVzZXJJZC50b1N0cmluZygpID09PSBfdGhpczYyLnVzZXJJZCkge1xuICAgICAgICBfdGhpczYyLmVtaXQoQ3J5cHRvRXZlbnQuS2V5c0NoYW5nZWQsIHt9KTtcbiAgICAgICAgeWllbGQgX3RoaXM2Mi5jaGVja0tleUJhY2t1cEFuZEVuYWJsZSgpO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGBPbG1NYWNoaW5lLnJlZ2lzdGVyRGV2aWNlc1VwZGF0ZWRDYWxsYmFja2BcbiAgICpcbiAgICogQ2FsbGVkIHdoZW4gdXNlcnMnIGRldmljZXMgaGF2ZSB1cGRhdGVkLiBFbWl0cyBgV2lsbFVwZGF0ZURldmljZXNgIGFuZCBgRGV2aWNlc1VwZGF0ZWRgLiBJbiB0aGUgSmF2YVNjcmlwdFxuICAgKiBjcnlwdG8gYmFja2VuZCwgdGhlc2UgZXZlbnRzIGFyZSBjYWxsZWQgYXQgc2VwYXJhdGUgdGltZXMsIHdpdGggYFdpbGxVcGRhdGVEZXZpY2VzYCBiZWluZyBlbWl0dGVkIGp1c3QgYmVmb3JlXG4gICAqIHRoZSBkZXZpY2VzIGFyZSBzYXZlZCwgYW5kIGBEZXZpY2VzVXBkYXRlZGAgYmVpbmcgZW1pdHRlZCBqdXN0IGFmdGVyLiBCdXQgdGhlIE9sbU1hY2hpbmUgb25seSBnaXZlcyB1c1xuICAgKiBvbmUgZXZlbnQsIHNvIHdlIGVtaXQgYm90aCBldmVudHMgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJJZHMgLSBhbiBhcnJheSBvZiB1c2VyIElEcyBvZiB1c2VycyB3aG9zZSBkZXZpY2VzIGhhdmUgdXBkYXRlZC5cbiAgICovXG4gIG9uRGV2aWNlc1VwZGF0ZWQodXNlcklkcykge1xuICAgIHZhciBfdGhpczYzID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIF90aGlzNjMuZW1pdChDcnlwdG9FdmVudC5XaWxsVXBkYXRlRGV2aWNlcywgdXNlcklkcywgZmFsc2UpO1xuICAgICAgX3RoaXM2My5lbWl0KENyeXB0b0V2ZW50LkRldmljZXNVcGRhdGVkLCB1c2VySWRzLCBmYWxzZSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHNlY3JldCByZWNlaXZlZCBmcm9tIHRoZSBydXN0IHNlY3JldCBpbmJveC5cbiAgICpcbiAgICogVGhlIGdvc3NpcHBlZCBzZWNyZXRzIGFyZSByZWNlaXZlZCB1c2luZyB0aGUgYG0uc2VjcmV0LnNlbmRgIGV2ZW50IHR5cGVcbiAgICogYW5kIGFyZSBndWFyYW50ZWVkIHRvIGhhdmUgYmVlbiByZWNlaXZlZCBvdmVyIGEgMS10by0xIE9sbVxuICAgKiBTZXNzaW9uIGZyb20gYSB2ZXJpZmllZCBkZXZpY2UuXG4gICAqXG4gICAqIFRoZSBvbmx5IHNlY3JldCBjdXJyZW50bHkgaGFuZGxlZCBpbiB0aGlzIHdheSBpcyBgbS5tZWdvbG1fYmFja3VwLnYxYC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSB0aGUgc2VjcmV0IG5hbWVcbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHNlY3JldCB2YWx1ZVxuICAgKi9cbiAgaGFuZGxlU2VjcmV0UmVjZWl2ZWQobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXM2NCA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICBfdGhpczY0LmxvZ2dlci5kZWJ1ZyhcIm9uUmVjZWl2ZVNlY3JldDogUmVjZWl2ZWQgc2VjcmV0IFwiLmNvbmNhdChuYW1lKSk7XG4gICAgICBpZiAobmFtZSA9PT0gXCJtLm1lZ29sbV9iYWNrdXAudjFcIikge1xuICAgICAgICByZXR1cm4geWllbGQgX3RoaXM2NC5iYWNrdXBNYW5hZ2VyLmhhbmRsZUJhY2t1cFNlY3JldFJlY2VpdmVkKHZhbHVlKTtcbiAgICAgICAgLy8gWFhYIGF0IHRoaXMgcG9pbnQgd2Ugc2hvdWxkIHByb2JhYmx5IHRyeSB0byBkb3dubG9hZCB0aGUgYmFja3VwIGFuZCBpbXBvcnQgdGhlIGtleXMsXG4gICAgICAgIC8vIG9yIGF0IGxlYXN0IHJldHJ5IGZvciB0aGUgY3VycmVudCBkZWNyeXB0aW9uIGZhaWx1cmVzP1xuICAgICAgICAvLyBNYXliZSBhZGQgc29tZSBzaWduYWxpbmcgd2hlbiBhIG5ldyBzZWNyZXQgaXMgcmVjZWl2ZWQsIGFuZCBsZXQgY2xpZW50cyBoYW5kbGUgaXQ/XG4gICAgICAgIC8vIGFzIGl0J3Mgd2hlcmUgdGhlIHJlc3RvcmUgZnJvbSBiYWNrdXAgQVBJcyBhcmUgZXhwb3NlZC5cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgbmV3IHNlY3JldCBpcyByZWNlaXZlZCBpbiB0aGUgcnVzdCBzZWNyZXQgaW5ib3guXG4gICAqXG4gICAqIFdpbGwgcG9sbCB0aGUgc2VjcmV0IGluYm94IGFuZCBoYW5kbGUgdGhlIHNlY3JldHMgcmVjZWl2ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNlY3JldCByZWNlaXZlZC5cbiAgICovXG4gIGNoZWNrU2VjcmV0cyhuYW1lKSB7XG4gICAgdmFyIF90aGlzNjUgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHBlbmRpbmdWYWx1ZXMgPSB5aWVsZCBfdGhpczY1Lm9sbU1hY2hpbmUuZ2V0U2VjcmV0c0Zyb21JbmJveChuYW1lKTtcbiAgICAgIGZvciAodmFyIHZhbHVlIG9mIHBlbmRpbmdWYWx1ZXMpIHtcbiAgICAgICAgaWYgKHlpZWxkIF90aGlzNjUuaGFuZGxlU2VjcmV0UmVjZWl2ZWQobmFtZSwgdmFsdWUpKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHZhbGlkIHNlY3JldCBmb3IgdGhhdCBuYW1lIHRoZXJlIGlzIG5vIHBvaW50IG9mIHByb2Nlc3NpbmcgdGhlIG90aGVyIHNlY3JldHMgdmFsdWVzLlxuICAgICAgICAgIC8vIEl0J3MgcHJvYmFibHkgdGhlIHNhbWUgc2VjcmV0IHNoYXJlZCBieSBhbm90aGVyIGRldmljZS5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJbXBvcnRhbnQgdG8gY2FsbCB0aGlzIGFmdGVyIGhhbmRsaW5nIHRoZSBzZWNyZXRzIGFzIGdvb2QgaHlnaWVuZS5cbiAgICAgIHlpZWxkIF90aGlzNjUub2xtTWFjaGluZS5kZWxldGVTZWNyZXRzRnJvbUluYm94KG5hbWUpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgbGl2ZSBldmVudCByZWNlaXZlZCB2aWEgL3N5bmMuXG4gICAqIFNlZSB7QGxpbmsgQ2xpZW50RXZlbnRIYW5kbGVyTWFwI2V2ZW50fVxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBsaXZlIGV2ZW50XG4gICAqL1xuICBvbkxpdmVFdmVudEZyb21TeW5jKGV2ZW50KSB7XG4gICAgdmFyIF90aGlzNjYgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgLy8gSWdub3JlIHN0YXRlIGV2ZW50IG9yIHJlbW90ZSBlY2hvXG4gICAgICAvLyB0cmFuc2FjdGlvbl9pZCBpcyBwcm92aWRlZCBpbiBjYXNlIG9mIHJlbW90ZSBlY2hvIHtAbGluayBodHRwczovL3NwZWMubWF0cml4Lm9yZy92MS43L2NsaWVudC1zZXJ2ZXItYXBpLyNsb2NhbC1lY2hvfVxuICAgICAgaWYgKGV2ZW50LmlzU3RhdGUoKSB8fCAhIWV2ZW50LmdldFVuc2lnbmVkKCkudHJhbnNhY3Rpb25faWQpIHJldHVybjtcbiAgICAgIHZhciBwcm9jZXNzRXZlbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjcgPSBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKGV2dCkge1xuICAgICAgICAgIC8vIFByb2Nlc3Mgb25seSB2ZXJpZmljYXRpb24gZXZlbnRcbiAgICAgICAgICBpZiAoaXNWZXJpZmljYXRpb25FdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIHlpZWxkIF90aGlzNjYub25LZXlWZXJpZmljYXRpb25FdmVudChldnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwcm9jZXNzRXZlbnQoX3gyKSB7XG4gICAgICAgICAgcmV0dXJuIF9yZWY3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KCk7XG5cbiAgICAgIC8vIElmIHRoZSBldmVudCBpcyBlbmNyeXB0ZWQgb2YgaW4gZmFpbHVyZSwgd2Ugd2FpdCBmb3IgZGVjcnlwdGlvblxuICAgICAgaWYgKGV2ZW50LmlzRGVjcnlwdGlvbkZhaWx1cmUoKSB8fCBldmVudC5pc0VuY3J5cHRlZCgpKSB7XG4gICAgICAgIC8vIDUgbWluc1xuICAgICAgICB2YXIgVElNRU9VVF9ERUxBWSA9IDUgKiA2MCAqIDEwMDA7XG5cbiAgICAgICAgLy8gQWZ0ZXIgNW1pbnMsIHdlIGFyZSBub3QgZXhwZWN0aW5nIHRoZSBldmVudCB0byBiZSBkZWNyeXB0ZWRcbiAgICAgICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gZXZlbnQub2ZmKE1hdHJpeEV2ZW50RXZlbnQuRGVjcnlwdGVkLCBvbkRlY3J5cHRlZCksIFRJTUVPVVRfREVMQVkpO1xuICAgICAgICB2YXIgb25EZWNyeXB0ZWQgPSAoZGVjcnlwdGVkRXZlbnQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm47XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgZXZlbnQub2ZmKE1hdHJpeEV2ZW50RXZlbnQuRGVjcnlwdGVkLCBvbkRlY3J5cHRlZCk7XG4gICAgICAgICAgcHJvY2Vzc0V2ZW50KGRlY3J5cHRlZEV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQub24oTWF0cml4RXZlbnRFdmVudC5EZWNyeXB0ZWQsIG9uRGVjcnlwdGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIHByb2Nlc3NFdmVudChldmVudCk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gaW4tcm9vbSBrZXkgdmVyaWZpY2F0aW9uIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBhIGtleSB2YWxpZGF0aW9uIHJlcXVlc3QgZXZlbnQuXG4gICAqL1xuICBvbktleVZlcmlmaWNhdGlvbkV2ZW50KGV2ZW50KSB7XG4gICAgdmFyIF90aGlzNjcgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHJvb21JZCA9IGV2ZW50LmdldFJvb21JZCgpO1xuICAgICAgaWYgKCFyb29tSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyByb29tSWQgaW4gdGhlIGV2ZW50XCIpO1xuICAgICAgfVxuICAgICAgX3RoaXM2Ny5sb2dnZXIuZGVidWcoXCJJbmNvbWluZyB2ZXJpZmljYXRpb24gZXZlbnQgXCIuY29uY2F0KGV2ZW50LmdldElkKCksIFwiIHR5cGUgXCIpLmNvbmNhdChldmVudC5nZXRUeXBlKCksIFwiIGZyb20gXCIpLmNvbmNhdChldmVudC5nZXRTZW5kZXIoKSkpO1xuICAgICAgeWllbGQgX3RoaXM2Ny5vbG1NYWNoaW5lLnJlY2VpdmVWZXJpZmljYXRpb25FdmVudChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGV2ZW50X2lkOiBldmVudC5nZXRJZCgpLFxuICAgICAgICB0eXBlOiBldmVudC5nZXRUeXBlKCksXG4gICAgICAgIHNlbmRlcjogZXZlbnQuZ2V0U2VuZGVyKCksXG4gICAgICAgIHN0YXRlX2tleTogZXZlbnQuZ2V0U3RhdGVLZXkoKSxcbiAgICAgICAgY29udGVudDogZXZlbnQuZ2V0Q29udGVudCgpLFxuICAgICAgICBvcmlnaW5fc2VydmVyX3RzOiBldmVudC5nZXRUcygpXG4gICAgICB9KSwgbmV3IFJ1c3RTZGtDcnlwdG9Kcy5Sb29tSWQocm9vbUlkKSk7XG4gICAgICBpZiAoZXZlbnQuZ2V0VHlwZSgpID09PSBFdmVudFR5cGUuUm9vbU1lc3NhZ2UgJiYgZXZlbnQuZ2V0Q29udGVudCgpLm1zZ3R5cGUgPT09IE1zZ1R5cGUuS2V5VmVyaWZpY2F0aW9uUmVxdWVzdCkge1xuICAgICAgICBfdGhpczY3Lm9uSW5jb21pbmdLZXlWZXJpZmljYXRpb25SZXF1ZXN0KGV2ZW50LmdldFNlbmRlcigpLCBldmVudC5nZXRJZCgpKTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhhdCBtYXkgaGF2ZSBjYXVzZWQgdXMgdG8gcXVldWUgdXAgb3V0Z29pbmcgcmVxdWVzdHMsIHNvIG1ha2Ugc3VyZSB3ZSBzZW5kIHRoZW0uXG4gICAgICBfdGhpczY3Lm91dGdvaW5nUmVxdWVzdHNNYW5hZ2VyLmRvUHJvY2Vzc091dGdvaW5nUmVxdWVzdHMoKS5jYXRjaChlID0+IHtcbiAgICAgICAgX3RoaXM2Ny5sb2dnZXIud2FybihcIm9uS2V5VmVyaWZpY2F0aW9uUmVxdWVzdDogRXJyb3IgcHJvY2Vzc2luZyBvdXRnb2luZyByZXF1ZXN0c1wiLCBlKTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3Jvc3Mtc2lnbmluZyB1c2VyIGlkZW50aXR5IG9mIHRoZSBjdXJyZW50IHVzZXIuXG4gICAqXG4gICAqIE5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgY3J5cHRvLWFwaSBpbnRlcmZhY2UuXG4gICAqIFVzZWQgZHVyaW5nIG1pZ3JhdGlvbiBmcm9tIGxlZ2FjeSBqcy1jcnlwdG8gdG8gdXBkYXRlIGxvY2FsIHRydXN0IGlmIG5lZWRlZC5cbiAgICovXG4gIGdldE93bklkZW50aXR5KCkge1xuICAgIHZhciBfdGhpczY4ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB5aWVsZCBfdGhpczY4Lm9sbU1hY2hpbmUuZ2V0SWRlbnRpdHkobmV3IFJ1c3RTZGtDcnlwdG9Kcy5Vc2VySWQoX3RoaXM2OC51c2VySWQpKTtcbiAgICB9KSgpO1xuICB9XG59XG5jbGFzcyBFdmVudERlY3J5cHRvciB7XG4gIGNvbnN0cnVjdG9yKGxvZ2dlciwgb2xtTWFjaGluZSwgcGVyU2Vzc2lvbkJhY2t1cERvd25sb2FkZXIpIHtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLm9sbU1hY2hpbmUgPSBvbG1NYWNoaW5lO1xuICAgIHRoaXMucGVyU2Vzc2lvbkJhY2t1cERvd25sb2FkZXIgPSBwZXJTZXNzaW9uQmFja3VwRG93bmxvYWRlcjtcbiAgICAvKipcbiAgICAgKiBFdmVudHMgd2hpY2ggd2UgY291bGRuJ3QgZGVjcnlwdCBkdWUgdG8gdW5rbm93biBzZXNzaW9ucyAvIGluZGV4ZXMuXG4gICAgICpcbiAgICAgKiBNYXAgZnJvbSByb29tSWQgdG8gc2Vzc2lvbklkIHRvIFNldCBvZiBNYXRyaXhFdmVudHNcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudHNQZW5kaW5nS2V5XCIsIG5ldyBNYXBXaXRoRGVmYXVsdCgoKSA9PiBuZXcgTWFwV2l0aERlZmF1bHQoKCkgPT4gbmV3IFNldCgpKSkpO1xuICB9XG4gIGF0dGVtcHRFdmVudERlY3J5cHRpb24oZXZlbnQsIGlzb2xhdGlvbk1vZGUpIHtcbiAgICB2YXIgX3RoaXM2OSA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBhZGQgdGhlIGV2ZW50IHRvIHRoZSBwZW5kaW5nIGxpc3QgKmJlZm9yZSogYXR0ZW1wdGluZyB0byBkZWNyeXB0LlxuICAgICAgLy8gdGhlbiwgaWYgdGhlIGtleSB0dXJucyB1cCB3aGlsZSBkZWNyeXB0aW9uIGlzIGluIHByb2dyZXNzIChhbmRcbiAgICAgIC8vIGRlY3J5cHRpb24gZmFpbHMpLCB3ZSB3aWxsIHNjaGVkdWxlIGEgcmV0cnkuXG4gICAgICAvLyAoZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3ZlY3Rvci1pbS9lbGVtZW50LXdlYi9pc3N1ZXMvNTAwMSlcbiAgICAgIF90aGlzNjkuYWRkRXZlbnRUb1BlbmRpbmdMaXN0KGV2ZW50KTtcbiAgICAgIHZhciB0cnVzdFJlcXVpcmVtZW50O1xuICAgICAgc3dpdGNoIChpc29sYXRpb25Nb2RlLmtpbmQpIHtcbiAgICAgICAgY2FzZSBEZXZpY2VJc29sYXRpb25Nb2RlS2luZC5BbGxEZXZpY2VzSXNvbGF0aW9uTW9kZTpcbiAgICAgICAgICB0cnVzdFJlcXVpcmVtZW50ID0gUnVzdFNka0NyeXB0b0pzLlRydXN0UmVxdWlyZW1lbnQuVW50cnVzdGVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERldmljZUlzb2xhdGlvbk1vZGVLaW5kLk9ubHlTaWduZWREZXZpY2VzSXNvbGF0aW9uTW9kZTpcbiAgICAgICAgICB0cnVzdFJlcXVpcmVtZW50ID0gUnVzdFNka0NyeXB0b0pzLlRydXN0UmVxdWlyZW1lbnQuQ3Jvc3NTaWduZWRPckxlZ2FjeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXMgPSB5aWVsZCBfdGhpczY5Lm9sbU1hY2hpbmUuZGVjcnlwdFJvb21FdmVudChzdHJpbmdpZnlFdmVudChldmVudCksIG5ldyBSdXN0U2RrQ3J5cHRvSnMuUm9vbUlkKGV2ZW50LmdldFJvb21JZCgpKSwgbmV3IFJ1c3RTZGtDcnlwdG9Kcy5EZWNyeXB0aW9uU2V0dGluZ3ModHJ1c3RSZXF1aXJlbWVudCkpO1xuXG4gICAgICAgIC8vIFN1Y2Nlc3MuIFdlIGNhbiByZW1vdmUgdGhlIGV2ZW50IGZyb20gdGhlIHBlbmRpbmcgbGlzdCwgaWZcbiAgICAgICAgLy8gdGhhdCBoYXNuJ3QgYWxyZWFkeSBoYXBwZW5lZC5cbiAgICAgICAgX3RoaXM2OS5yZW1vdmVFdmVudEZyb21QZW5kaW5nTGlzdChldmVudCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2xlYXJFdmVudDogSlNPTi5wYXJzZShyZXMuZXZlbnQpLFxuICAgICAgICAgIGNsYWltZWRFZDI1NTE5S2V5OiByZXMuc2VuZGVyQ2xhaW1lZEVkMjU1MTlLZXksXG4gICAgICAgICAgc2VuZGVyQ3VydmUyNTUxOUtleTogcmVzLnNlbmRlckN1cnZlMjU1MTlLZXksXG4gICAgICAgICAgZm9yd2FyZGluZ0N1cnZlMjU1MTlLZXlDaGFpbjogcmVzLmZvcndhcmRpbmdDdXJ2ZTI1NTE5S2V5Q2hhaW5cbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUnVzdFNka0NyeXB0b0pzLk1lZ29sbURlY3J5cHRpb25FcnJvcikge1xuICAgICAgICAgIF90aGlzNjkub25NZWdvbG1EZWNyeXB0aW9uRXJyb3IoZXZlbnQsIGVyciwgeWllbGQgX3RoaXM2OS5wZXJTZXNzaW9uQmFja3VwRG93bmxvYWRlci5nZXRTZXJ2ZXJCYWNrdXBJbmZvKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBEZWNyeXB0aW9uRXJyb3IoRGVjcnlwdGlvbkZhaWx1cmVDb2RlLlVOS05PV05fRVJST1IsIFwiVW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgYE1lZ29sbURlY3J5cHRpb25FcnJvcmAgcmV0dXJuZWQgYnkgdGhlIHJ1c3QgU0RLLlxuICAgKlxuICAgKiBGaXJlcyBvZmYgYSByZXF1ZXN0IHRvIHRoZSBgcGVyU2Vzc2lvbkJhY2t1cERvd25sb2FkZXJgLCBpZiBhcHByb3ByaWF0ZSwgYW5kIHRoZW4gdGhyb3dzIGEgYERlY3J5cHRpb25FcnJvcmAuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBldmVudCB3aGljaCBjb3VsZCBub3QgYmUgZGVjcnlwdGVkLlxuICAgKiBAcGFyYW0gZXJyIC0gVGhlIGVycm9yIGZyb20gdGhlIFJ1c3QgU0RLLlxuICAgKiBAcGFyYW0gc2VydmVyQmFja3VwSW5mbyAtIERldGFpbHMgYWJvdXQgdGhlIGN1cnJlbnQgYmFja3VwIGZyb20gdGhlIHNlcnZlci4gYG51bGxgIGlmIHRoZXJlIGlzIG5vIGJhY2t1cC5cbiAgICogICAgIGB1bmRlZmluZWRgIGlmIG91ciBhdHRlbXB0IHRvIGNoZWNrIGZhaWxlZC5cbiAgICovXG4gIG9uTWVnb2xtRGVjcnlwdGlvbkVycm9yKGV2ZW50LCBlcnIsIHNlcnZlckJhY2t1cEluZm8pIHtcbiAgICB2YXIgY29udGVudCA9IGV2ZW50LmdldFdpcmVDb250ZW50KCk7XG4gICAgdmFyIGVycm9yRGV0YWlscyA9IHtcbiAgICAgIHNlbmRlcl9rZXk6IGNvbnRlbnQuc2VuZGVyX2tleSxcbiAgICAgIHNlc3Npb25faWQ6IGNvbnRlbnQuc2Vzc2lvbl9pZFxuICAgIH07XG5cbiAgICAvLyBJZiB0aGUgZXJyb3IgbG9va3MgbGlrZSBpdCBtaWdodCBiZSByZWNvdmVyYWJsZSBmcm9tIGJhY2t1cCwgcXVldWUgdXAgYSByZXF1ZXN0IHRvIHRyeSB0aGF0LlxuICAgIGlmIChlcnIuY29kZSA9PT0gUnVzdFNka0NyeXB0b0pzLkRlY3J5cHRpb25FcnJvckNvZGUuTWlzc2luZ1Jvb21LZXkgfHwgZXJyLmNvZGUgPT09IFJ1c3RTZGtDcnlwdG9Kcy5EZWNyeXB0aW9uRXJyb3JDb2RlLlVua25vd25NZXNzYWdlSW5kZXgpIHtcbiAgICAgIHRoaXMucGVyU2Vzc2lvbkJhY2t1cERvd25sb2FkZXIub25EZWNyeXB0aW9uS2V5TWlzc2luZ0Vycm9yKGV2ZW50LmdldFJvb21JZCgpLCBjb250ZW50LnNlc3Npb25faWQpO1xuXG4gICAgICAvLyBJZiB0aGUgc2VydmVyIGlzIHRlbGxpbmcgdXMgb3VyIG1lbWJlcnNoaXAgYXQgdGhlIHRpbWUgdGhlIGV2ZW50XG4gICAgICAvLyB3YXMgc2VudCwgYW5kIGl0IGlzbid0IFwiam9pblwiLCB3ZSB1c2UgYSBkaWZmZXJlbnQgZXJyb3IgY29kZS5cbiAgICAgIHZhciBtZW1iZXJzaGlwID0gZXZlbnQuZ2V0TWVtYmVyc2hpcEF0RXZlbnQoKTtcbiAgICAgIGlmIChtZW1iZXJzaGlwICYmIG1lbWJlcnNoaXAgIT09IEtub3duTWVtYmVyc2hpcC5Kb2luICYmIG1lbWJlcnNoaXAgIT09IEtub3duTWVtYmVyc2hpcC5JbnZpdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IERlY3J5cHRpb25FcnJvcihEZWNyeXB0aW9uRmFpbHVyZUNvZGUuSElTVE9SSUNBTF9NRVNTQUdFX1VTRVJfTk9UX0pPSU5FRCwgXCJUaGlzIG1lc3NhZ2Ugd2FzIHNlbnQgd2hlbiB3ZSB3ZXJlIG5vdCBhIG1lbWJlciBvZiB0aGUgcm9vbS5cIiwgZXJyb3JEZXRhaWxzKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGV2ZW50IHdhcyBzZW50IGJlZm9yZSB0aGlzIGRldmljZSB3YXMgY3JlYXRlZCwgd2UgdXNlIHNvbWUgZGlmZmVyZW50IGVycm9yIGNvZGVzLlxuICAgICAgaWYgKGV2ZW50LmdldFRzKCkgPD0gdGhpcy5vbG1NYWNoaW5lLmRldmljZUNyZWF0aW9uVGltZU1zKSB7XG4gICAgICAgIGlmIChzZXJ2ZXJCYWNrdXBJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IERlY3J5cHRpb25FcnJvcihEZWNyeXB0aW9uRmFpbHVyZUNvZGUuSElTVE9SSUNBTF9NRVNTQUdFX05PX0tFWV9CQUNLVVAsIFwiVGhpcyBtZXNzYWdlIHdhcyBzZW50IGJlZm9yZSB0aGlzIGRldmljZSBsb2dnZWQgaW4sIGFuZCB0aGVyZSBpcyBubyBrZXkgYmFja3VwIG9uIHRoZSBzZXJ2ZXIuXCIsIGVycm9yRGV0YWlscyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucGVyU2Vzc2lvbkJhY2t1cERvd25sb2FkZXIuaXNLZXlCYWNrdXBEb3dubG9hZENvbmZpZ3VyZWQoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBEZWNyeXB0aW9uRXJyb3IoRGVjcnlwdGlvbkZhaWx1cmVDb2RlLkhJU1RPUklDQUxfTUVTU0FHRV9CQUNLVVBfVU5DT05GSUdVUkVELCBcIlRoaXMgbWVzc2FnZSB3YXMgc2VudCBiZWZvcmUgdGhpcyBkZXZpY2UgbG9nZ2VkIGluLCBhbmQga2V5IGJhY2t1cCBpcyBub3Qgd29ya2luZy5cIiwgZXJyb3JEZXRhaWxzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRGVjcnlwdGlvbkVycm9yKERlY3J5cHRpb25GYWlsdXJlQ29kZS5ISVNUT1JJQ0FMX01FU1NBR0VfV09SS0lOR19CQUNLVVAsIFwiVGhpcyBtZXNzYWdlIHdhcyBzZW50IGJlZm9yZSB0aGlzIGRldmljZSBsb2dnZWQgaW4uIEtleSBiYWNrdXAgaXMgd29ya2luZywgYnV0IHdlIHN0aWxsIGRvIG5vdCAoeWV0KSBoYXZlIHRoZSBrZXkuXCIsIGVycm9yRGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnb3QgYSB3aXRoaGVsZCBjb2RlLCBleHBvc2UgdGhhdC5cbiAgICBpZiAoZXJyLm1heWJlX3dpdGhoZWxkKSB7XG4gICAgICAvLyBVbmZvcnR1bmF0ZWx5IHRoZSBSdXN0IFNESyBBUEkgZG9lc24ndCBsZXQgdXMgZGlzdGluZ3Vpc2ggYmV0d2VlbiBkaWZmZXJlbnQgd2l0aGhlbGQgY2FzZXMsIG90aGVyIHRoYW5cbiAgICAgIC8vIGJ5IHN0cmluZy1tYXRjaGluZy5cbiAgICAgIHZhciBmYWlsdXJlQ29kZSA9IGVyci5tYXliZV93aXRoaGVsZCA9PT0gXCJUaGUgc2VuZGVyIGhhcyBkaXNhYmxlZCBlbmNyeXB0aW5nIHRvIHVudmVyaWZpZWQgZGV2aWNlcy5cIiA/IERlY3J5cHRpb25GYWlsdXJlQ29kZS5NRUdPTE1fS0VZX1dJVEhIRUxEX0ZPUl9VTlZFUklGSUVEX0RFVklDRSA6IERlY3J5cHRpb25GYWlsdXJlQ29kZS5NRUdPTE1fS0VZX1dJVEhIRUxEO1xuICAgICAgdGhyb3cgbmV3IERlY3J5cHRpb25FcnJvcihmYWlsdXJlQ29kZSwgZXJyLm1heWJlX3dpdGhoZWxkLCBlcnJvckRldGFpbHMpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICBjYXNlIFJ1c3RTZGtDcnlwdG9Kcy5EZWNyeXB0aW9uRXJyb3JDb2RlLk1pc3NpbmdSb29tS2V5OlxuICAgICAgICB0aHJvdyBuZXcgRGVjcnlwdGlvbkVycm9yKERlY3J5cHRpb25GYWlsdXJlQ29kZS5NRUdPTE1fVU5LTk9XTl9JTkJPVU5EX1NFU1NJT05fSUQsIFwiVGhlIHNlbmRlcidzIGRldmljZSBoYXMgbm90IHNlbnQgdXMgdGhlIGtleXMgZm9yIHRoaXMgbWVzc2FnZS5cIiwgZXJyb3JEZXRhaWxzKTtcbiAgICAgIGNhc2UgUnVzdFNka0NyeXB0b0pzLkRlY3J5cHRpb25FcnJvckNvZGUuVW5rbm93bk1lc3NhZ2VJbmRleDpcbiAgICAgICAgdGhyb3cgbmV3IERlY3J5cHRpb25FcnJvcihEZWNyeXB0aW9uRmFpbHVyZUNvZGUuT0xNX1VOS05PV05fTUVTU0FHRV9JTkRFWCwgXCJUaGUgc2VuZGVyJ3MgZGV2aWNlIGhhcyBub3Qgc2VudCB1cyB0aGUga2V5cyBmb3IgdGhpcyBtZXNzYWdlIGF0IHRoaXMgaW5kZXguXCIsIGVycm9yRGV0YWlscyk7XG4gICAgICBjYXNlIFJ1c3RTZGtDcnlwdG9Kcy5EZWNyeXB0aW9uRXJyb3JDb2RlLlNlbmRlcklkZW50aXR5VmVyaWZpY2F0aW9uVmlvbGF0aW9uOlxuICAgICAgICAvLyBXZSdyZSByZWZ1c2luZyB0byBkZWNyeXB0IGR1ZSB0byBub3QgdHJ1c3RpbmcgdGhlIHNlbmRlcixcbiAgICAgICAgLy8gcmF0aGVyIHRoYW4gZmFpbGluZyB0byBkZWNyeXB0IGR1ZSB0byBsYWNrIG9mIGtleXMsIHNvIHdlXG4gICAgICAgIC8vIGRvbid0IG5lZWQgdG8ga2VlcCBpdCBvbiB0aGUgcGVuZGluZyBsaXN0LlxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50RnJvbVBlbmRpbmdMaXN0KGV2ZW50KTtcbiAgICAgICAgdGhyb3cgbmV3IERlY3J5cHRpb25FcnJvcihEZWNyeXB0aW9uRmFpbHVyZUNvZGUuU0VOREVSX0lERU5USVRZX1BSRVZJT1VTTFlfVkVSSUZJRUQsIFwiVGhlIHNlbmRlciBpZGVudGl0eSBpcyB1bnZlcmlmaWVkLCBidXQgd2FzIHByZXZpb3VzbHkgdmVyaWZpZWQuXCIpO1xuICAgICAgY2FzZSBSdXN0U2RrQ3J5cHRvSnMuRGVjcnlwdGlvbkVycm9yQ29kZS5Vbmtub3duU2VuZGVyRGV2aWNlOlxuICAgICAgICAvLyBXZSdyZSByZWZ1c2luZyB0byBkZWNyeXB0IGR1ZSB0byBub3QgdHJ1c3RpbmcgdGhlIHNlbmRlcixcbiAgICAgICAgLy8gcmF0aGVyIHRoYW4gZmFpbGluZyB0byBkZWNyeXB0IGR1ZSB0byBsYWNrIG9mIGtleXMsIHNvIHdlXG4gICAgICAgIC8vIGRvbid0IG5lZWQgdG8ga2VlcCBpdCBvbiB0aGUgcGVuZGluZyBsaXN0LlxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50RnJvbVBlbmRpbmdMaXN0KGV2ZW50KTtcbiAgICAgICAgdGhyb3cgbmV3IERlY3J5cHRpb25FcnJvcihEZWNyeXB0aW9uRmFpbHVyZUNvZGUuVU5LTk9XTl9TRU5ERVJfREVWSUNFLCBcIlRoZSBzZW5kZXIgZGV2aWNlIGlzIG5vdCBrbm93bi5cIik7XG4gICAgICBjYXNlIFJ1c3RTZGtDcnlwdG9Kcy5EZWNyeXB0aW9uRXJyb3JDb2RlLlVuc2lnbmVkU2VuZGVyRGV2aWNlOlxuICAgICAgICAvLyBXZSdyZSByZWZ1c2luZyB0byBkZWNyeXB0IGR1ZSB0byBub3QgdHJ1c3RpbmcgdGhlIHNlbmRlcixcbiAgICAgICAgLy8gcmF0aGVyIHRoYW4gZmFpbGluZyB0byBkZWNyeXB0IGR1ZSB0byBsYWNrIG9mIGtleXMsIHNvIHdlXG4gICAgICAgIC8vIGRvbid0IG5lZWQgdG8ga2VlcCBpdCBvbiB0aGUgcGVuZGluZyBsaXN0LlxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50RnJvbVBlbmRpbmdMaXN0KGV2ZW50KTtcbiAgICAgICAgdGhyb3cgbmV3IERlY3J5cHRpb25FcnJvcihEZWNyeXB0aW9uRmFpbHVyZUNvZGUuVU5TSUdORURfU0VOREVSX0RFVklDRSwgXCJUaGUgc2VuZGVyIGlkZW50aXR5IGlzIG5vdCBjcm9zcy1zaWduZWQuXCIpO1xuXG4gICAgICAvLyBXZSBkb24ndCBtYXAgTWlzbWF0Y2hlZElkZW50aXR5S2V5cyBmb3Igbm93LCBhcyB0aGVyZSBpcyBubyBlcXVpdmFsZW50IGluIGxlZ2FjeS5cbiAgICAgIC8vIEp1c3QgcHV0IGl0IG9uIHRoZSBgVU5LTk9XTl9FUlJPUmAgYnVja2V0LlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IERlY3J5cHRpb25FcnJvcihEZWNyeXB0aW9uRmFpbHVyZUNvZGUuVU5LTk9XTl9FUlJPUiwgZXJyLmRlc2NyaXB0aW9uLCBlcnJvckRldGFpbHMpO1xuICAgIH1cbiAgfVxuICBnZXRFbmNyeXB0aW9uSW5mb0ZvckV2ZW50KGV2ZW50KSB7XG4gICAgdmFyIF90aGlzNzAgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCFldmVudC5nZXRDbGVhckNvbnRlbnQoKSB8fCBldmVudC5pc0RlY3J5cHRpb25GYWlsdXJlKCkpIHtcbiAgICAgICAgLy8gbm90IHN1Y2Nlc3NmdWxseSBkZWNyeXB0ZWRcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIHNwZWNpYWwtY2FzZSBvdXRnb2luZyBldmVudHMsIHdoaWNoIHRoZSBydXN0IGNyeXB0by1zZGsgd2lsbCBiYXJmIG9uXG4gICAgICBpZiAoZXZlbnQuc3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2hpZWxkQ29sb3VyOiBFdmVudFNoaWVsZENvbG91ci5OT05FLFxuICAgICAgICAgIHNoaWVsZFJlYXNvbjogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIGVuY3J5cHRpb25JbmZvID0geWllbGQgX3RoaXM3MC5vbG1NYWNoaW5lLmdldFJvb21FdmVudEVuY3J5cHRpb25JbmZvKHN0cmluZ2lmeUV2ZW50KGV2ZW50KSwgbmV3IFJ1c3RTZGtDcnlwdG9Kcy5Sb29tSWQoZXZlbnQuZ2V0Um9vbUlkKCkpKTtcbiAgICAgIHJldHVybiBydXN0RW5jcnlwdGlvbkluZm9Ub0pzRW5jcnlwdGlvbkluZm8oX3RoaXM3MC5sb2dnZXIsIGVuY3J5cHRpb25JbmZvKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgZm9yIGV2ZW50cyB3aGljaCBhcmUgd2FpdGluZyBmb3IgYSBnaXZlbiBtZWdvbG0gc2Vzc2lvblxuICAgKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBldmVudHMgd2hpY2ggd2VyZSBlbmNyeXB0ZWQgYnkgYHNlc3Npb25gIGFuZCBjb3VsZCBub3QgYmUgZGVjcnlwdGVkXG4gICAqL1xuICBnZXRFdmVudHNQZW5kaW5nUm9vbUtleShyb29tSWQsIHNlc3Npb25JZCkge1xuICAgIHZhciByb29tUGVuZGluZ0V2ZW50cyA9IHRoaXMuZXZlbnRzUGVuZGluZ0tleS5nZXQocm9vbUlkKTtcbiAgICBpZiAoIXJvb21QZW5kaW5nRXZlbnRzKSByZXR1cm4gW107XG4gICAgdmFyIHNlc3Npb25QZW5kaW5nRXZlbnRzID0gcm9vbVBlbmRpbmdFdmVudHMuZ2V0KHNlc3Npb25JZCk7XG4gICAgaWYgKCFzZXNzaW9uUGVuZGluZ0V2ZW50cykgcmV0dXJuIFtdO1xuICAgIHJldHVybiBbLi4uc2Vzc2lvblBlbmRpbmdFdmVudHNdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCB0byB0aGUgbGlzdCBvZiB0aG9zZSBhd2FpdGluZyB0aGVpciBzZXNzaW9uIGtleXMuXG4gICAqL1xuICBhZGRFdmVudFRvUGVuZGluZ0xpc3QoZXZlbnQpIHtcbiAgICB2YXIgcm9vbUlkID0gZXZlbnQuZ2V0Um9vbUlkKCk7XG4gICAgLy8gV2Ugc2hvdWxkbid0IGhhdmUgZXZlbnRzIHdpdGhvdXQgYSByb29tIGlkIGhlcmUuXG4gICAgaWYgKCFyb29tSWQpIHJldHVybjtcbiAgICB2YXIgcm9vbVBlbmRpbmdFdmVudHMgPSB0aGlzLmV2ZW50c1BlbmRpbmdLZXkuZ2V0T3JDcmVhdGUocm9vbUlkKTtcbiAgICB2YXIgc2Vzc2lvblBlbmRpbmdFdmVudHMgPSByb29tUGVuZGluZ0V2ZW50cy5nZXRPckNyZWF0ZShldmVudC5nZXRXaXJlQ29udGVudCgpLnNlc3Npb25faWQpO1xuICAgIHNlc3Npb25QZW5kaW5nRXZlbnRzLmFkZChldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGZyb20gdGhlIGxpc3Qgb2YgdGhvc2UgYXdhaXRpbmcgdGhlaXIgc2Vzc2lvbiBrZXlzLlxuICAgKi9cbiAgcmVtb3ZlRXZlbnRGcm9tUGVuZGluZ0xpc3QoZXZlbnQpIHtcbiAgICB2YXIgcm9vbUlkID0gZXZlbnQuZ2V0Um9vbUlkKCk7XG4gICAgaWYgKCFyb29tSWQpIHJldHVybjtcbiAgICB2YXIgcm9vbVBlbmRpbmdFdmVudHMgPSB0aGlzLmV2ZW50c1BlbmRpbmdLZXkuZ2V0T3JDcmVhdGUocm9vbUlkKTtcbiAgICBpZiAoIXJvb21QZW5kaW5nRXZlbnRzKSByZXR1cm47XG4gICAgdmFyIHNlc3Npb25QZW5kaW5nRXZlbnRzID0gcm9vbVBlbmRpbmdFdmVudHMuZ2V0KGV2ZW50LmdldFdpcmVDb250ZW50KCkuc2Vzc2lvbl9pZCk7XG4gICAgaWYgKCFzZXNzaW9uUGVuZGluZ0V2ZW50cykgcmV0dXJuO1xuICAgIHNlc3Npb25QZW5kaW5nRXZlbnRzLmRlbGV0ZShldmVudCk7XG5cbiAgICAvLyBhbHNvIGNsZWFuIHVwIHRoZSBoaWdoZXItbGV2ZWwgbWFwcyBpZiB0aGV5IGFyZSBub3cgZW1wdHlcbiAgICBpZiAoc2Vzc2lvblBlbmRpbmdFdmVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcm9vbVBlbmRpbmdFdmVudHMuZGVsZXRlKGV2ZW50LmdldFdpcmVDb250ZW50KCkuc2Vzc2lvbl9pZCk7XG4gICAgICBpZiAocm9vbVBlbmRpbmdFdmVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLmV2ZW50c1BlbmRpbmdLZXkuZGVsZXRlKHJvb21JZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlFdmVudChldmVudCkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgIGV2ZW50X2lkOiBldmVudC5nZXRJZCgpLFxuICAgIHR5cGU6IGV2ZW50LmdldFdpcmVUeXBlKCksXG4gICAgc2VuZGVyOiBldmVudC5nZXRTZW5kZXIoKSxcbiAgICBzdGF0ZV9rZXk6IGV2ZW50LmdldFN0YXRlS2V5KCksXG4gICAgY29udGVudDogZXZlbnQuZ2V0V2lyZUNvbnRlbnQoKSxcbiAgICBvcmlnaW5fc2VydmVyX3RzOiBldmVudC5nZXRUcygpXG4gIH0pO1xufVxuZnVuY3Rpb24gcnVzdEVuY3J5cHRpb25JbmZvVG9Kc0VuY3J5cHRpb25JbmZvKGxvZ2dlciwgZW5jcnlwdGlvbkluZm8pIHtcbiAgaWYgKGVuY3J5cHRpb25JbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBub3QgZGVjcnlwdGVkIGhlcmVcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRPRE86IHVzZSBzdHJpY3Qgc2hpZWxkIHNlbWFudGljcy5cbiAgdmFyIHNoaWVsZFN0YXRlID0gZW5jcnlwdGlvbkluZm8uc2hpZWxkU3RhdGUoZmFsc2UpO1xuICB2YXIgc2hpZWxkQ29sb3VyO1xuICBzd2l0Y2ggKHNoaWVsZFN0YXRlLmNvbG9yKSB7XG4gICAgY2FzZSBSdXN0U2RrQ3J5cHRvSnMuU2hpZWxkQ29sb3IuR3JleTpcbiAgICAgIHNoaWVsZENvbG91ciA9IEV2ZW50U2hpZWxkQ29sb3VyLkdSRVk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFJ1c3RTZGtDcnlwdG9Kcy5TaGllbGRDb2xvci5Ob25lOlxuICAgICAgc2hpZWxkQ29sb3VyID0gRXZlbnRTaGllbGRDb2xvdXIuTk9ORTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzaGllbGRDb2xvdXIgPSBFdmVudFNoaWVsZENvbG91ci5SRUQ7XG4gIH1cbiAgdmFyIHNoaWVsZFJlYXNvbjtcbiAgc3dpdGNoIChzaGllbGRTdGF0ZS5jb2RlKSB7XG4gICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgY2FzZSBudWxsOlxuICAgICAgc2hpZWxkUmVhc29uID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUnVzdFNka0NyeXB0b0pzLlNoaWVsZFN0YXRlQ29kZS5BdXRoZW50aWNpdHlOb3RHdWFyYW50ZWVkOlxuICAgICAgc2hpZWxkUmVhc29uID0gRXZlbnRTaGllbGRSZWFzb24uQVVUSEVOVElDSVRZX05PVF9HVUFSQU5URUVEO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBSdXN0U2RrQ3J5cHRvSnMuU2hpZWxkU3RhdGVDb2RlLlVua25vd25EZXZpY2U6XG4gICAgICBzaGllbGRSZWFzb24gPSBFdmVudFNoaWVsZFJlYXNvbi5VTktOT1dOX0RFVklDRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUnVzdFNka0NyeXB0b0pzLlNoaWVsZFN0YXRlQ29kZS5VbnNpZ25lZERldmljZTpcbiAgICAgIHNoaWVsZFJlYXNvbiA9IEV2ZW50U2hpZWxkUmVhc29uLlVOU0lHTkVEX0RFVklDRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUnVzdFNka0NyeXB0b0pzLlNoaWVsZFN0YXRlQ29kZS5VbnZlcmlmaWVkSWRlbnRpdHk6XG4gICAgICBzaGllbGRSZWFzb24gPSBFdmVudFNoaWVsZFJlYXNvbi5VTlZFUklGSUVEX0lERU5USVRZO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBSdXN0U2RrQ3J5cHRvSnMuU2hpZWxkU3RhdGVDb2RlLlNlbnRJbkNsZWFyOlxuICAgICAgc2hpZWxkUmVhc29uID0gRXZlbnRTaGllbGRSZWFzb24uU0VOVF9JTl9DTEVBUjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUnVzdFNka0NyeXB0b0pzLlNoaWVsZFN0YXRlQ29kZS5WZXJpZmljYXRpb25WaW9sYXRpb246XG4gICAgICBzaGllbGRSZWFzb24gPSBFdmVudFNoaWVsZFJlYXNvbi5WRVJJRklDQVRJT05fVklPTEFUSU9OO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzaGllbGRDb2xvdXIsXG4gICAgc2hpZWxkUmVhc29uXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydXN0LWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/rust-crypto.js\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/secret-storage.js":
/*!**********************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/secret-storage.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   secretStorageCanAccessSecrets: () => (/* binding */ secretStorageCanAccessSecrets),\n/* harmony export */   secretStorageContainsCrossSigningKeys: () => (/* binding */ secretStorageContainsCrossSigningKeys)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n\n/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Check that the private cross signing keys (master, self signing, user signing) are stored in the secret storage and encrypted with the default secret storage key.\n *\n * @param secretStorage - The secret store using account data\n * @returns True if the cross-signing keys are all stored and encrypted with the same secret storage key.\n *\n * @internal\n */\nfunction secretStorageContainsCrossSigningKeys(_x) {\n  return _secretStorageContainsCrossSigningKeys.apply(this, arguments);\n}\n\n/**\n *\n * Check that the secret storage can access the given secrets using the default key.\n *\n * @param secretStorage - The secret store using account data\n * @param secretNames - The secret names to check\n * @returns True if all the given secrets are accessible and encrypted with the given key.\n *\n * @internal\n */\nfunction _secretStorageContainsCrossSigningKeys() {\n  _secretStorageContainsCrossSigningKeys = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (secretStorage) {\n    return secretStorageCanAccessSecrets(secretStorage, [\"m.cross_signing.master\", \"m.cross_signing.user_signing\", \"m.cross_signing.self_signing\"]);\n  });\n  return _secretStorageContainsCrossSigningKeys.apply(this, arguments);\n}\nfunction secretStorageCanAccessSecrets(_x2, _x3) {\n  return _secretStorageCanAccessSecrets.apply(this, arguments);\n}\nfunction _secretStorageCanAccessSecrets() {\n  _secretStorageCanAccessSecrets = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* (secretStorage, secretNames) {\n    var defaultKeyId = yield secretStorage.getDefaultKeyId();\n    if (!defaultKeyId) return false;\n    for (var secretName of secretNames) {\n      // check which keys this particular secret is encrypted with\n      var record = (yield secretStorage.isStored(secretName)) || {};\n      // if it's not encrypted with the right key, there is no point continuing\n      if (!(defaultKeyId in record)) return false;\n    }\n    return true;\n  });\n  return _secretStorageCanAccessSecrets.apply(this, arguments);\n}\n//# sourceMappingURL=secret-storage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vc2VjcmV0LXN0b3JhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdFO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsbUZBQWlCO0FBQzVEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtRkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FzdGVyaWNzLWdyaWQvLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vc2VjcmV0LXN0b3JhZ2UuanM/MDBhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2FzeW5jVG9HZW5lcmF0b3IgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiO1xuLypcbkNvcHlyaWdodCAyMDIzIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLyoqXG4gKiBDaGVjayB0aGF0IHRoZSBwcml2YXRlIGNyb3NzIHNpZ25pbmcga2V5cyAobWFzdGVyLCBzZWxmIHNpZ25pbmcsIHVzZXIgc2lnbmluZykgYXJlIHN0b3JlZCBpbiB0aGUgc2VjcmV0IHN0b3JhZ2UgYW5kIGVuY3J5cHRlZCB3aXRoIHRoZSBkZWZhdWx0IHNlY3JldCBzdG9yYWdlIGtleS5cbiAqXG4gKiBAcGFyYW0gc2VjcmV0U3RvcmFnZSAtIFRoZSBzZWNyZXQgc3RvcmUgdXNpbmcgYWNjb3VudCBkYXRhXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjcm9zcy1zaWduaW5nIGtleXMgYXJlIGFsbCBzdG9yZWQgYW5kIGVuY3J5cHRlZCB3aXRoIHRoZSBzYW1lIHNlY3JldCBzdG9yYWdlIGtleS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlY3JldFN0b3JhZ2VDb250YWluc0Nyb3NzU2lnbmluZ0tleXMoX3gpIHtcbiAgcmV0dXJuIF9zZWNyZXRTdG9yYWdlQ29udGFpbnNDcm9zc1NpZ25pbmdLZXlzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICpcbiAqIENoZWNrIHRoYXQgdGhlIHNlY3JldCBzdG9yYWdlIGNhbiBhY2Nlc3MgdGhlIGdpdmVuIHNlY3JldHMgdXNpbmcgdGhlIGRlZmF1bHQga2V5LlxuICpcbiAqIEBwYXJhbSBzZWNyZXRTdG9yYWdlIC0gVGhlIHNlY3JldCBzdG9yZSB1c2luZyBhY2NvdW50IGRhdGFcbiAqIEBwYXJhbSBzZWNyZXROYW1lcyAtIFRoZSBzZWNyZXQgbmFtZXMgdG8gY2hlY2tcbiAqIEByZXR1cm5zIFRydWUgaWYgYWxsIHRoZSBnaXZlbiBzZWNyZXRzIGFyZSBhY2Nlc3NpYmxlIGFuZCBlbmNyeXB0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfc2VjcmV0U3RvcmFnZUNvbnRhaW5zQ3Jvc3NTaWduaW5nS2V5cygpIHtcbiAgX3NlY3JldFN0b3JhZ2VDb250YWluc0Nyb3NzU2lnbmluZ0tleXMgPSBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKHNlY3JldFN0b3JhZ2UpIHtcbiAgICByZXR1cm4gc2VjcmV0U3RvcmFnZUNhbkFjY2Vzc1NlY3JldHMoc2VjcmV0U3RvcmFnZSwgW1wibS5jcm9zc19zaWduaW5nLm1hc3RlclwiLCBcIm0uY3Jvc3Nfc2lnbmluZy51c2VyX3NpZ25pbmdcIiwgXCJtLmNyb3NzX3NpZ25pbmcuc2VsZl9zaWduaW5nXCJdKTtcbiAgfSk7XG4gIHJldHVybiBfc2VjcmV0U3RvcmFnZUNvbnRhaW5zQ3Jvc3NTaWduaW5nS2V5cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlY3JldFN0b3JhZ2VDYW5BY2Nlc3NTZWNyZXRzKF94MiwgX3gzKSB7XG4gIHJldHVybiBfc2VjcmV0U3RvcmFnZUNhbkFjY2Vzc1NlY3JldHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9zZWNyZXRTdG9yYWdlQ2FuQWNjZXNzU2VjcmV0cygpIHtcbiAgX3NlY3JldFN0b3JhZ2VDYW5BY2Nlc3NTZWNyZXRzID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qIChzZWNyZXRTdG9yYWdlLCBzZWNyZXROYW1lcykge1xuICAgIHZhciBkZWZhdWx0S2V5SWQgPSB5aWVsZCBzZWNyZXRTdG9yYWdlLmdldERlZmF1bHRLZXlJZCgpO1xuICAgIGlmICghZGVmYXVsdEtleUlkKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgc2VjcmV0TmFtZSBvZiBzZWNyZXROYW1lcykge1xuICAgICAgLy8gY2hlY2sgd2hpY2gga2V5cyB0aGlzIHBhcnRpY3VsYXIgc2VjcmV0IGlzIGVuY3J5cHRlZCB3aXRoXG4gICAgICB2YXIgcmVjb3JkID0gKHlpZWxkIHNlY3JldFN0b3JhZ2UuaXNTdG9yZWQoc2VjcmV0TmFtZSkpIHx8IHt9O1xuICAgICAgLy8gaWYgaXQncyBub3QgZW5jcnlwdGVkIHdpdGggdGhlIHJpZ2h0IGtleSwgdGhlcmUgaXMgbm8gcG9pbnQgY29udGludWluZ1xuICAgICAgaWYgKCEoZGVmYXVsdEtleUlkIGluIHJlY29yZCkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICByZXR1cm4gX3NlY3JldFN0b3JhZ2VDYW5BY2Nlc3NTZWNyZXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNyZXQtc3RvcmFnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/secret-storage.js\n");

/***/ }),

/***/ "./node_modules/matrix-js-sdk/lib/rust-crypto/verification.js":
/*!********************************************************************!*\
  !*** ./node_modules/matrix-js-sdk/lib/rust-crypto/verification.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RustQrCodeVerifier: () => (/* binding */ RustQrCodeVerifier),\n/* harmony export */   RustSASVerifier: () => (/* binding */ RustSASVerifier),\n/* harmony export */   RustVerificationRequest: () => (/* binding */ RustVerificationRequest),\n/* harmony export */   isVerificationEvent: () => (/* binding */ isVerificationEvent),\n/* harmony export */   verificationMethodIdentifierToMethod: () => (/* binding */ verificationMethodIdentifierToMethod)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @matrix-org/matrix-sdk-crypto-wasm */ \"./node_modules/@matrix-org/matrix-sdk-crypto-wasm/index.mjs\");\n/* harmony import */ var _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto-api/verification.js */ \"./node_modules/matrix-js-sdk/lib/crypto-api/verification.js\");\n/* harmony import */ var _models_typed_event_emitter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../models/typed-event-emitter.js */ \"./node_modules/matrix-js-sdk/lib/models/typed-event-emitter.js\");\n/* harmony import */ var _ReEmitter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ReEmitter.js */ \"./node_modules/matrix-js-sdk/lib/ReEmitter.js\");\n/* harmony import */ var _types_event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../@types/event.js */ \"./node_modules/matrix-js-sdk/lib/@types/event.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/matrix-js-sdk/lib/utils.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../types.js */ \"./node_modules/matrix-js-sdk/lib/types.js\");\n\n\n/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n\n\n\n\n\n\n\n\n\n/**\n * An incoming, or outgoing, request to verify a user or a device via cross-signing.\n *\n * @internal\n */\nclass RustVerificationRequest extends _models_typed_event_emitter_js__WEBPACK_IMPORTED_MODULE_4__.TypedEventEmitter {\n  /**\n   * Construct a new RustVerificationRequest to wrap the rust-level `VerificationRequest`.\n   *\n   * @param olmMachine - The `OlmMachine` from the underlying rust crypto sdk.\n   * @param inner - VerificationRequest from the Rust SDK.\n   * @param outgoingRequestProcessor - `OutgoingRequestProcessor` to use for making outgoing HTTP requests.\n   * @param supportedVerificationMethods - Verification methods to use when `accept()` is called.\n   */\n  constructor(olmMachine, inner, outgoingRequestProcessor, supportedVerificationMethods) {\n    super();\n    this.olmMachine = olmMachine;\n    this.inner = inner;\n    this.outgoingRequestProcessor = outgoingRequestProcessor;\n    this.supportedVerificationMethods = supportedVerificationMethods;\n    /** a remitter which relays VerificationRequestEvent.Changed events emitted by the verifier */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"reEmitter\", void 0);\n    /** Are we in the process of sending an `m.key.verification.ready` event? */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"_accepting\", false);\n    /** Are we in the process of sending an `m.key.verification.cancellation` event? */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"_cancelling\", false);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"_verifier\", void 0);\n    this.reEmitter = new _ReEmitter_js__WEBPACK_IMPORTED_MODULE_5__.TypedReEmitter(this);\n\n    // Obviously, the Rust object maintains a reference to the callback function. If the callback function maintains\n    // a reference to the Rust object, then we have a reference cycle which means that `RustVerificationRequest`\n    // will never be garbage-collected, and hence the underlying rust object will never be freed.\n    //\n    // To avoid this reference cycle, use a weak reference in the callback function. If the `RustVerificationRequest`\n    // gets garbage-collected, then there is nothing to update!\n    var weakThis = new WeakRef(this);\n    inner.registerChangesCallback(/*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var _weakThis$deref;\n      return (_weakThis$deref = weakThis.deref()) === null || _weakThis$deref === void 0 ? void 0 : _weakThis$deref.onChange();\n    }));\n  }\n\n  /**\n   * Hook which is called when the underlying rust class notifies us that there has been a change.\n   */\n  onChange() {\n    var verification = this.inner.getVerification();\n\n    // Set the _verifier object (wrapping the rust `Verification` as a js-sdk Verifier) if:\n    // - we now have a `Verification` where we lacked one before\n    // - we have transitioned from QR to SAS\n    // - we are verifying with SAS, but we need to replace our verifier with a new one because both parties\n    //   tried to start verification at the same time, and we lost the tie breaking\n    if (verification instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.Sas) {\n      if (this._verifier === undefined || this._verifier instanceof RustQrCodeVerifier) {\n        this.setVerifier(new RustSASVerifier(verification, this, this.outgoingRequestProcessor));\n      } else if (this._verifier instanceof RustSASVerifier) {\n        this._verifier.replaceInner(verification);\n      }\n    } else if (verification instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.Qr && this._verifier === undefined) {\n      this.setVerifier(new RustQrCodeVerifier(verification, this.outgoingRequestProcessor));\n    }\n    this.emit(_crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationRequestEvent.Change);\n  }\n  setVerifier(verifier) {\n    // if we already have a verifier, unsubscribe from its events\n    if (this._verifier) {\n      this.reEmitter.stopReEmitting(this._verifier, [_crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationRequestEvent.Change]);\n    }\n    this._verifier = verifier;\n    this.reEmitter.reEmit(this._verifier, [_crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationRequestEvent.Change]);\n  }\n\n  /**\n   * Unique ID for this verification request.\n   *\n   * An ID isn't assigned until the first message is sent, so this may be `undefined` in the early phases.\n   */\n  get transactionId() {\n    return this.inner.flowId;\n  }\n\n  /**\n   * For an in-room verification, the ID of the room.\n   *\n   * For to-device verifications, `undefined`.\n   */\n  get roomId() {\n    var _this$inner$roomId;\n    return (_this$inner$roomId = this.inner.roomId) === null || _this$inner$roomId === void 0 ? void 0 : _this$inner$roomId.toString();\n  }\n\n  /**\n   * True if this request was initiated by the local client.\n   *\n   * For in-room verifications, the initiator is who sent the `m.key.verification.request` event.\n   * For to-device verifications, the initiator is who sent the `m.key.verification.start` event.\n   */\n  get initiatedByMe() {\n    return this.inner.weStarted();\n  }\n\n  /** The user id of the other party in this request */\n  get otherUserId() {\n    return this.inner.otherUserId.toString();\n  }\n\n  /** For verifications via to-device messages: the ID of the other device. Otherwise, undefined. */\n  get otherDeviceId() {\n    var _this$inner$otherDevi;\n    return (_this$inner$otherDevi = this.inner.otherDeviceId) === null || _this$inner$otherDevi === void 0 ? void 0 : _this$inner$otherDevi.toString();\n  }\n\n  /** Get the other device involved in the verification, if it is known */\n  getOtherDevice() {\n    var _this = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var otherDeviceId = _this.inner.otherDeviceId;\n      if (!otherDeviceId) {\n        return undefined;\n      }\n      return yield _this.olmMachine.getDevice(_this.inner.otherUserId, otherDeviceId, 5);\n    })();\n  }\n\n  /** True if the other party in this request is one of this user's own devices. */\n  get isSelfVerification() {\n    return this.inner.isSelfVerification();\n  }\n\n  /** current phase of the request. */\n  get phase() {\n    var phase = this.inner.phase();\n    switch (phase) {\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.VerificationRequestPhase.Created:\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.VerificationRequestPhase.Requested:\n        return _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Requested;\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.VerificationRequestPhase.Ready:\n        // if we're still sending the `m.key.verification.ready`, that counts as \"Requested\" in the js-sdk's\n        // parlance.\n        return this._accepting ? _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Requested : _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Ready;\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.VerificationRequestPhase.Transitioned:\n        if (!this._verifier) {\n          // this shouldn't happen, because the onChange handler should have created a _verifier.\n          throw new Error(\"VerificationRequest: inner phase == Transitioned but no verifier!\");\n        }\n        return this._verifier.verificationPhase;\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.VerificationRequestPhase.Done:\n        return _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Done;\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.VerificationRequestPhase.Cancelled:\n        return _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Cancelled;\n    }\n    throw new Error(\"Unknown verification phase \".concat(phase));\n  }\n\n  /** True if the request has sent its initial event and needs more events to complete\n   * (ie it is in phase `Requested`, `Ready` or `Started`).\n   */\n  get pending() {\n    if (this.inner.isPassive()) return false;\n    var phase = this.phase;\n    return phase !== _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Done && phase !== _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Cancelled;\n  }\n\n  /**\n   * True if we have started the process of sending an `m.key.verification.ready` (but have not necessarily received\n   * the remote echo which causes a transition to {@link VerificationPhase.Ready}.\n   */\n  get accepting() {\n    return this._accepting;\n  }\n\n  /**\n   * True if we have started the process of sending an `m.key.verification.cancel` (but have not necessarily received\n   * the remote echo which causes a transition to {@link VerificationPhase.Cancelled}).\n   */\n  get declining() {\n    return this._cancelling;\n  }\n\n  /**\n   * The remaining number of ms before the request will be automatically cancelled.\n   *\n   * `null` indicates that there is no timeout\n   */\n  get timeout() {\n    return this.inner.timeRemainingMillis();\n  }\n\n  /** once the phase is Started (and !initiatedByMe) or Ready: common methods supported by both sides */\n  get methods() {\n    throw new Error(\"not implemented\");\n  }\n\n  /** the method picked in the .start event */\n  get chosenMethod() {\n    if (this.phase !== _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Started) return null;\n    var verification = this.inner.getVerification();\n    if (verification instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.Sas) {\n      return _types_js__WEBPACK_IMPORTED_MODULE_8__.VerificationMethod.Sas;\n    } else if (verification instanceof _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.Qr) {\n      return _types_js__WEBPACK_IMPORTED_MODULE_8__.VerificationMethod.Reciprocate;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Checks whether the other party supports a given verification method.\n   * This is useful when setting up the QR code UI, as it is somewhat asymmetrical:\n   * if the other party supports SCAN_QR, we should show a QR code in the UI, and vice versa.\n   * For methods that need to be supported by both ends, use the `methods` property.\n   *\n   * @param method - the method to check\n   * @returns true if the other party said they supported the method\n   */\n  otherPartySupportsMethod(method) {\n    var theirMethods = this.inner.theirSupportedMethods;\n    if (theirMethods === undefined) {\n      // no message from the other side yet\n      return false;\n    }\n    var requiredMethod = verificationMethodsByIdentifier[method];\n    return theirMethods.some(m => m === requiredMethod);\n  }\n\n  /**\n   * Accepts the request, sending a .ready event to the other party\n   *\n   * @returns Promise which resolves when the event has been sent.\n   */\n  accept() {\n    var _this2 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      if (_this2.inner.phase() !== _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.VerificationRequestPhase.Requested || _this2._accepting) {\n        throw new Error(\"Cannot accept a verification request in phase \".concat(_this2.phase));\n      }\n      _this2._accepting = true;\n      try {\n        var req = _this2.inner.acceptWithMethods(_this2.supportedVerificationMethods.map(verificationMethodIdentifierToMethod));\n        if (req) {\n          yield _this2.outgoingRequestProcessor.makeOutgoingRequest(req);\n        }\n      } finally {\n        _this2._accepting = false;\n      }\n\n      // phase may have changed, so emit a 'change' event\n      _this2.emit(_crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationRequestEvent.Change);\n    })();\n  }\n\n  /**\n   * Cancels the request, sending a cancellation to the other party\n   *\n   * @param params - Details for the cancellation, including `reason` (defaults to \"User declined\"), and `code`\n   *    (defaults to `m.user`).\n   *\n   * @returns Promise which resolves when the event has been sent.\n   */\n  cancel(params) {\n    var _this3 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      if (_this3._cancelling) {\n        // already cancelling; do nothing\n        return;\n      }\n      _this3._cancelling = true;\n      try {\n        var req = _this3.inner.cancel();\n        if (req) {\n          yield _this3.outgoingRequestProcessor.makeOutgoingRequest(req);\n        }\n      } finally {\n        _this3._cancelling = false;\n      }\n    })();\n  }\n\n  /**\n   * Create a {@link Verifier} to do this verification via a particular method.\n   *\n   * If a verifier has already been created for this request, returns that verifier.\n   *\n   * This does *not* send the `m.key.verification.start` event - to do so, call {@link Verifier#verifier} on the\n   * returned verifier.\n   *\n   * If no previous events have been sent, pass in `targetDevice` to set who to direct this request to.\n   *\n   * @param method - the name of the verification method to use.\n   * @param targetDevice - details of where to send the request to.\n   *\n   * @returns The verifier which will do the actual verification.\n   */\n  beginKeyVerification(method, targetDevice) {\n    throw new Error(\"not implemented\");\n  }\n\n  /**\n   * Send an `m.key.verification.start` event to start verification via a particular method.\n   *\n   * Implementation of {@link Crypto.VerificationRequest#startVerification}.\n   *\n   * @param method - the name of the verification method to use.\n   */\n  startVerification(method) {\n    var _this4 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      if (method !== _types_js__WEBPACK_IMPORTED_MODULE_8__.VerificationMethod.Sas) {\n        throw new Error(\"Unsupported verification method \".concat(method));\n      }\n\n      // make sure that we have a list of the other user's devices (workaround https://github.com/matrix-org/matrix-rust-sdk/issues/2896)\n      if (!(yield _this4.getOtherDevice())) {\n        throw new Error(\"startVerification(): other device is unknown\");\n      }\n      var res = yield _this4.inner.startSas();\n      if (res) {\n        var [, req] = res;\n        yield _this4.outgoingRequestProcessor.makeOutgoingRequest(req);\n      }\n\n      // this should have triggered the onChange callback, and we should now have a verifier\n      if (!_this4._verifier) {\n        throw new Error(\"Still no verifier after startSas() call\");\n      }\n      return _this4._verifier;\n    })();\n  }\n\n  /**\n   * Start a QR code verification by providing a scanned QR code for this verification flow.\n   *\n   * Implementation of {@link Crypto.VerificationRequest#scanQRCode}.\n   *\n   * @param qrCodeData - the decoded QR code.\n   * @returns A verifier; call `.verify()` on it to wait for the other side to complete the verification flow.\n   */\n  scanQRCode(uint8Array) {\n    var _this5 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var scan = _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.QrCodeScan.fromBytes(uint8Array);\n      var verifier = yield _this5.inner.scanQrCode(scan);\n\n      // this should have triggered the onChange callback, and we should now have a verifier\n      if (!_this5._verifier) {\n        throw new Error(\"Still no verifier after scanQrCode() call\");\n      }\n\n      // we can immediately trigger the reciprocate request\n      var req = verifier.reciprocate();\n      if (req) {\n        yield _this5.outgoingRequestProcessor.makeOutgoingRequest(req);\n      }\n      return _this5._verifier;\n    })();\n  }\n\n  /**\n   * The verifier which is doing the actual verification, once the method has been established.\n   * Only defined when the `phase` is Started.\n   */\n  get verifier() {\n    // It's possible for us to have a Verifier before a method has been chosen (in particular,\n    // if we are showing a QR code which the other device has not yet scanned. At that point, we could\n    // still switch to SAS).\n    //\n    // In that case, we should not return it to the application yet, since the application will not expect the\n    // Verifier to be replaced during the lifetime of the VerificationRequest.\n    return this.phase === _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Started ? this._verifier : undefined;\n  }\n\n  /**\n   * Stub implementation of {@link Crypto.VerificationRequest#getQRCodeBytes}.\n   */\n  getQRCodeBytes() {\n    throw new Error(\"getQRCodeBytes() unsupported in Rust Crypto; use generateQRCode() instead.\");\n  }\n\n  /**\n   * Generate the data for a QR code allowing the other device to verify this one, if it supports it.\n   *\n   * Implementation of {@link Crypto.VerificationRequest#generateQRCode}.\n   */\n  generateQRCode() {\n    var _this6 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // make sure that we have a list of the other user's devices (workaround https://github.com/matrix-org/matrix-rust-sdk/issues/2896)\n      if (!(yield _this6.getOtherDevice())) {\n        throw new Error(\"generateQRCode(): other device is unknown\");\n      }\n      var innerVerifier = yield _this6.inner.generateQrCode();\n      // If we are unable to generate a QRCode, we return undefined\n      if (!innerVerifier) return;\n      return innerVerifier.toBytes();\n    })();\n  }\n\n  /**\n   * If this request has been cancelled, the cancellation code (e.g `m.user`) which is responsible for cancelling\n   * this verification.\n   */\n  get cancellationCode() {\n    var _this$inner$cancelInf, _this$inner$cancelInf2;\n    return (_this$inner$cancelInf = (_this$inner$cancelInf2 = this.inner.cancelInfo) === null || _this$inner$cancelInf2 === void 0 ? void 0 : _this$inner$cancelInf2.cancelCode()) !== null && _this$inner$cancelInf !== void 0 ? _this$inner$cancelInf : null;\n  }\n\n  /**\n   * The id of the user that cancelled the request.\n   *\n   * Only defined when phase is Cancelled\n   */\n  get cancellingUserId() {\n    var cancelInfo = this.inner.cancelInfo;\n    if (!cancelInfo) {\n      return undefined;\n    } else if (cancelInfo.cancelledbyUs()) {\n      return this.olmMachine.userId.toString();\n    } else {\n      return this.inner.otherUserId.toString();\n    }\n  }\n}\n\n/** Common base class for `Verifier` implementations which wrap rust classes.\n *\n * The generic parameter `InnerType` is the type of the rust Verification class which we wrap.\n *\n * @internal\n */\nclass BaseRustVerifer extends _models_typed_event_emitter_js__WEBPACK_IMPORTED_MODULE_4__.TypedEventEmitter {\n  constructor(inner, outgoingRequestProcessor) {\n    super();\n    this.inner = inner;\n    this.outgoingRequestProcessor = outgoingRequestProcessor;\n    /** A deferred which completes when the verification completes (or rejects when it is cancelled/fails) */\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"completionDeferred\", void 0);\n    this.completionDeferred = (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.defer)();\n\n    // As with RustVerificationRequest, we need to avoid a reference cycle.\n    // See the comments in RustVerificationRequest.\n    var weakThis = new WeakRef(this);\n    inner.registerChangesCallback(/*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var _weakThis$deref2;\n      return (_weakThis$deref2 = weakThis.deref()) === null || _weakThis$deref2 === void 0 ? void 0 : _weakThis$deref2.onChange();\n    }));\n\n    // stop the runtime complaining if nobody catches a failure\n    this.completionDeferred.promise.catch(() => null);\n  }\n\n  /**\n   * Hook which is called when the underlying rust class notifies us that there has been a change.\n   *\n   * Can be overridden by subclasses to see if we can notify the application about an update. The overriding method\n   * must call `super.onChange()`.\n   */\n  onChange() {\n    if (this.inner.isDone()) {\n      this.completionDeferred.resolve(undefined);\n    } else if (this.inner.isCancelled()) {\n      var cancelInfo = this.inner.cancelInfo();\n      this.completionDeferred.reject(new Error(\"Verification cancelled by \".concat(cancelInfo.cancelledbyUs() ? \"us\" : \"them\", \" with code \").concat(cancelInfo.cancelCode(), \": \").concat(cancelInfo.reason())));\n    }\n    this.emit(_crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationRequestEvent.Change);\n  }\n\n  /**\n   * Returns true if the verification has been cancelled, either by us or the other side.\n   */\n  get hasBeenCancelled() {\n    return this.inner.isCancelled();\n  }\n\n  /**\n   * The ID of the other user in the verification process.\n   */\n  get userId() {\n    return this.inner.otherUserId.toString();\n  }\n\n  /**\n   * Cancel a verification.\n   *\n   * We will send an `m.key.verification.cancel` if the verification is still in flight. The verification promise\n   * will reject, and a {@link Crypto.VerifierEvent#Cancel} will be emitted.\n   *\n   * @param e - the reason for the cancellation.\n   */\n  cancel(e) {\n    // TODO: something with `e`\n    var req = this.inner.cancel();\n    if (req) {\n      this.outgoingRequestProcessor.makeOutgoingRequest(req);\n    }\n  }\n\n  /**\n   * Get the details for an SAS verification, if one is in progress\n   *\n   * Returns `null`, unless this verifier is for a SAS-based verification and we are waiting for the user to confirm\n   * the SAS matches.\n   */\n  getShowSasCallbacks() {\n    return null;\n  }\n\n  /**\n   * Get the details for reciprocating QR code verification, if one is in progress\n   *\n   * Returns `null`, unless this verifier is for reciprocating a QR-code-based verification (ie, the other user has\n   * already scanned our QR code), and we are waiting for the user to confirm.\n   */\n  getReciprocateQrCodeCallbacks() {\n    return null;\n  }\n}\n\n/** A Verifier instance which is used to show and/or scan a QR code. */\nclass RustQrCodeVerifier extends BaseRustVerifer {\n  constructor(inner, outgoingRequestProcessor) {\n    super(inner, outgoingRequestProcessor);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"callbacks\", null);\n  }\n  onChange() {\n    // if the other side has scanned our QR code and sent us a \"reciprocate\" message, it is now time for the\n    // application to prompt the user to confirm their side.\n    if (this.callbacks === null && this.inner.hasBeenScanned()) {\n      this.callbacks = {\n        confirm: () => {\n          this.confirmScanning();\n        },\n        cancel: () => this.cancel()\n      };\n    }\n    super.onChange();\n  }\n\n  /**\n   * Start the key verification, if it has not already been started.\n   *\n   * @returns Promise which resolves when the verification has completed, or rejects if the verification is cancelled\n   *    or times out.\n   */\n  verify() {\n    var _this7 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      // Some applications (hello, matrix-react-sdk) may not check if there is a `ShowQrCodeCallbacks` and instead\n      // register a `ShowReciprocateQr` listener which they expect to be called once `.verify` is called.\n      if (_this7.callbacks !== null) {\n        _this7.emit(_crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerifierEvent.ShowReciprocateQr, _this7.callbacks);\n      }\n      // Nothing to do here but wait.\n      yield _this7.completionDeferred.promise;\n    })();\n  }\n\n  /**\n   * Calculate an appropriate VerificationPhase for a VerificationRequest where this is the verifier.\n   *\n   * This is abnormally complicated because a rust-side QR Code verifier can span several verification phases.\n   */\n  get verificationPhase() {\n    switch (this.inner.state()) {\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.QrState.Created:\n        // we have created a QR for display; neither side has yet sent an `m.key.verification.start`.\n        return _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Ready;\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.QrState.Scanned:\n        // other side has scanned our QR and sent an `m.key.verification.start` with `m.reciprocate.v1`\n        return _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Started;\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.QrState.Confirmed:\n        // we have confirmed the other side's scan and sent an `m.key.verification.done`.\n        //\n        // However, the verification is not yet \"Done\", because we have to wait until we have received the\n        // `m.key.verification.done` from the other side (in particular, we don't mark the device/identity as\n        // verified until that happens). If we return \"Done\" too soon, we risk the user cancelling the flow.\n        return _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Started;\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.QrState.Reciprocated:\n        // although the rust SDK doesn't immediately send the `m.key.verification.start` on transition into this\n        // state, `RustVerificationRequest.scanQrCode` immediately calls `reciprocate()` and does so, so in practice\n        // we can treat the two the same.\n        return _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Started;\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.QrState.Done:\n        return _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Done;\n      case _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.QrState.Cancelled:\n        return _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Cancelled;\n      default:\n        throw new Error(\"Unknown qr code state \".concat(this.inner.state()));\n    }\n  }\n\n  /**\n   * Get the details for reciprocating QR code verification, if one is in progress\n   *\n   * Returns `null`, unless this verifier is for reciprocating a QR-code-based verification (ie, the other user has\n   * already scanned our QR code), and we are waiting for the user to confirm.\n   */\n  getReciprocateQrCodeCallbacks() {\n    return this.callbacks;\n  }\n  confirmScanning() {\n    var _this8 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var req = _this8.inner.confirmScanning();\n      if (req) {\n        yield _this8.outgoingRequestProcessor.makeOutgoingRequest(req);\n      }\n    })();\n  }\n}\n\n/** A Verifier instance which is used if we are exchanging emojis */\nclass RustSASVerifier extends BaseRustVerifer {\n  constructor(inner, _verificationRequest, outgoingRequestProcessor) {\n    super(inner, outgoingRequestProcessor);\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"callbacks\", null);\n  }\n\n  /**\n   * Start the key verification, if it has not already been started.\n   *\n   * This means sending a `m.key.verification.start` if we are the first responder, or a `m.key.verification.accept`\n   * if the other side has already sent a start event.\n   *\n   * @returns Promise which resolves when the verification has completed, or rejects if the verification is cancelled\n   *    or times out.\n   */\n  verify() {\n    var _this9 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      yield _this9.sendAccept();\n      yield _this9.completionDeferred.promise;\n    })();\n  }\n\n  /**\n   * Send the accept or start event, if it hasn't already been sent\n   */\n  sendAccept() {\n    var _this10 = this;\n    return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n      var req = _this10.inner.accept();\n      if (req) {\n        yield _this10.outgoingRequestProcessor.makeOutgoingRequest(req);\n      }\n    })();\n  }\n\n  /** if we can now show the callbacks, do so */\n  onChange() {\n    var _this11 = this;\n    super.onChange();\n    if (this.callbacks === null) {\n      var emoji = this.inner.emoji();\n      var decimal = this.inner.decimals();\n      if (emoji === undefined && decimal === undefined) {\n        return;\n      }\n      var sas = {};\n      if (emoji) {\n        sas.emoji = emoji.map(e => [e.symbol, e.description]);\n      }\n      if (decimal) {\n        sas.decimal = [decimal[0], decimal[1], decimal[2]];\n      }\n      this.callbacks = {\n        sas,\n        confirm: function () {\n          var _confirm = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n            var requests = yield _this11.inner.confirm();\n            for (var m of requests) {\n              yield _this11.outgoingRequestProcessor.makeOutgoingRequest(m);\n            }\n          });\n          function confirm() {\n            return _confirm.apply(this, arguments);\n          }\n          return confirm;\n        }(),\n        mismatch: () => {\n          var request = this.inner.cancelWithCode(\"m.mismatched_sas\");\n          if (request) {\n            this.outgoingRequestProcessor.makeOutgoingRequest(request);\n          }\n        },\n        cancel: () => {\n          var request = this.inner.cancelWithCode(\"m.user\");\n          if (request) {\n            this.outgoingRequestProcessor.makeOutgoingRequest(request);\n          }\n        }\n      };\n      this.emit(_crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerifierEvent.ShowSas, this.callbacks);\n    }\n  }\n\n  /**\n   * Calculate an appropriate VerificationPhase for a VerificationRequest where this is the verifier.\n   */\n  get verificationPhase() {\n    return _crypto_api_verification_js__WEBPACK_IMPORTED_MODULE_3__.VerificationPhase.Started;\n  }\n\n  /**\n   * Get the details for an SAS verification, if one is in progress\n   *\n   * Returns `null`, unless this verifier is for a SAS-based verification and we are waiting for the user to confirm\n   * the SAS matches.\n   */\n  getShowSasCallbacks() {\n    return this.callbacks;\n  }\n\n  /**\n   * Replace the inner Rust verifier with a different one.\n   *\n   * @param inner - the new Rust verifier\n   * @internal\n   */\n  replaceInner(inner) {\n    if (this.inner != inner) {\n      this.inner = inner;\n\n      // As with RustVerificationRequest, we need to avoid a reference cycle.\n      // See the comments in RustVerificationRequest.\n      var weakThis = new WeakRef(this);\n      inner.registerChangesCallback(/*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function* () {\n        var _weakThis$deref3;\n        return (_weakThis$deref3 = weakThis.deref()) === null || _weakThis$deref3 === void 0 ? void 0 : _weakThis$deref3.onChange();\n      }));\n\n      // replaceInner will only get called if we started the verification at the same time as the other side, and we lost\n      // the tie breaker.  So we need to re-accept their verification.\n      this.sendAccept();\n      this.onChange();\n    }\n  }\n}\n\n/** For each specced verification method, the rust-side `VerificationMethod` corresponding to it */\nvar verificationMethodsByIdentifier = {\n  [_types_js__WEBPACK_IMPORTED_MODULE_8__.VerificationMethod.Sas]: _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.VerificationMethod.SasV1,\n  [_types_js__WEBPACK_IMPORTED_MODULE_8__.VerificationMethod.ScanQrCode]: _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.VerificationMethod.QrCodeScanV1,\n  [_types_js__WEBPACK_IMPORTED_MODULE_8__.VerificationMethod.ShowQrCode]: _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.VerificationMethod.QrCodeShowV1,\n  [_types_js__WEBPACK_IMPORTED_MODULE_8__.VerificationMethod.Reciprocate]: _matrix_org_matrix_sdk_crypto_wasm__WEBPACK_IMPORTED_MODULE_2__.VerificationMethod.ReciprocateV1\n};\n\n/**\n * Convert a specced verification method identifier into a rust-side `VerificationMethod`.\n *\n * @param method - specced method identifier, for example `m.sas.v1`.\n * @returns Rust-side `VerificationMethod` corresponding to `method`.\n * @throws An error if the method is unknown.\n *\n * @internal\n */\nfunction verificationMethodIdentifierToMethod(method) {\n  var meth = verificationMethodsByIdentifier[method];\n  if (meth === undefined) {\n    throw new Error(\"Unknown verification method \".concat(method));\n  }\n  return meth;\n}\n\n/**\n * Return true if the event's type matches that of an in-room verification event\n *\n * @param event - MatrixEvent\n * @returns\n *\n * @internal\n */\nfunction isVerificationEvent(event) {\n  switch (event.getType()) {\n    case _types_event_js__WEBPACK_IMPORTED_MODULE_6__.EventType.KeyVerificationCancel:\n    case _types_event_js__WEBPACK_IMPORTED_MODULE_6__.EventType.KeyVerificationDone:\n    case _types_event_js__WEBPACK_IMPORTED_MODULE_6__.EventType.KeyVerificationMac:\n    case _types_event_js__WEBPACK_IMPORTED_MODULE_6__.EventType.KeyVerificationStart:\n    case _types_event_js__WEBPACK_IMPORTED_MODULE_6__.EventType.KeyVerificationKey:\n    case _types_event_js__WEBPACK_IMPORTED_MODULE_6__.EventType.KeyVerificationReady:\n    case _types_event_js__WEBPACK_IMPORTED_MODULE_6__.EventType.KeyVerificationAccept:\n      return true;\n    case _types_event_js__WEBPACK_IMPORTED_MODULE_6__.EventType.RoomMessage:\n      return event.getContent().msgtype === _types_event_js__WEBPACK_IMPORTED_MODULE_6__.MsgType.KeyVerificationRequest;\n    default:\n      return false;\n  }\n}\n//# sourceMappingURL=verification.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vdmVyaWZpY2F0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdFO0FBQ0o7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRTtBQUNUO0FBQzhDO0FBQ3RDO0FBQ3BCO0FBQ087QUFDcEI7QUFDYTs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQyw2RUFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBLElBQUksaUZBQWU7QUFDbkI7QUFDQSxJQUFJLGlGQUFlO0FBQ25CLElBQUksaUZBQWU7QUFDbkIseUJBQXlCLHlEQUFjOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxtRkFBaUI7QUFDaEU7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUVBQW1CO0FBQ25EO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU0saUNBQWlDLGtFQUFrQjtBQUN6RDtBQUNBO0FBQ0EsY0FBYyxpRkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUZBQXdCO0FBQzdFO0FBQ0E7QUFDQSwyQ0FBMkMsaUZBQXdCO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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azovL2FzdGVyaWNzLWdyaWQvLi9ub2RlX21vZHVsZXMvbWF0cml4LWpzLXNkay9saWIvcnVzdC1jcnlwdG8vdmVyaWZpY2F0aW9uLmpzP2IzMDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9hc3luY1RvR2VuZXJhdG9yIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIjtcbi8qXG5Db3B5cmlnaHQgMjAyMyBUaGUgTWF0cml4Lm9yZyBGb3VuZGF0aW9uIEMuSS5DLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCAqIGFzIFJ1c3RTZGtDcnlwdG9KcyBmcm9tIFwiQG1hdHJpeC1vcmcvbWF0cml4LXNkay1jcnlwdG8td2FzbVwiO1xuaW1wb3J0IHsgUXJTdGF0ZSB9IGZyb20gXCJAbWF0cml4LW9yZy9tYXRyaXgtc2RrLWNyeXB0by13YXNtXCI7XG5pbXBvcnQgeyBWZXJpZmljYXRpb25QaGFzZSwgVmVyaWZpY2F0aW9uUmVxdWVzdEV2ZW50LCBWZXJpZmllckV2ZW50IH0gZnJvbSBcIi4uL2NyeXB0by1hcGkvdmVyaWZpY2F0aW9uLmpzXCI7XG5pbXBvcnQgeyBUeXBlZEV2ZW50RW1pdHRlciB9IGZyb20gXCIuLi9tb2RlbHMvdHlwZWQtZXZlbnQtZW1pdHRlci5qc1wiO1xuaW1wb3J0IHsgVHlwZWRSZUVtaXR0ZXIgfSBmcm9tIFwiLi4vUmVFbWl0dGVyLmpzXCI7XG5pbXBvcnQgeyBFdmVudFR5cGUsIE1zZ1R5cGUgfSBmcm9tIFwiLi4vQHR5cGVzL2V2ZW50LmpzXCI7XG5pbXBvcnQgeyBkZWZlciB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgVmVyaWZpY2F0aW9uTWV0aG9kIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5cbi8qKlxuICogQW4gaW5jb21pbmcsIG9yIG91dGdvaW5nLCByZXF1ZXN0IHRvIHZlcmlmeSBhIHVzZXIgb3IgYSBkZXZpY2UgdmlhIGNyb3NzLXNpZ25pbmcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBSdXN0VmVyaWZpY2F0aW9uUmVxdWVzdCBleHRlbmRzIFR5cGVkRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBSdXN0VmVyaWZpY2F0aW9uUmVxdWVzdCB0byB3cmFwIHRoZSBydXN0LWxldmVsIGBWZXJpZmljYXRpb25SZXF1ZXN0YC5cbiAgICpcbiAgICogQHBhcmFtIG9sbU1hY2hpbmUgLSBUaGUgYE9sbU1hY2hpbmVgIGZyb20gdGhlIHVuZGVybHlpbmcgcnVzdCBjcnlwdG8gc2RrLlxuICAgKiBAcGFyYW0gaW5uZXIgLSBWZXJpZmljYXRpb25SZXF1ZXN0IGZyb20gdGhlIFJ1c3QgU0RLLlxuICAgKiBAcGFyYW0gb3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yIC0gYE91dGdvaW5nUmVxdWVzdFByb2Nlc3NvcmAgdG8gdXNlIGZvciBtYWtpbmcgb3V0Z29pbmcgSFRUUCByZXF1ZXN0cy5cbiAgICogQHBhcmFtIHN1cHBvcnRlZFZlcmlmaWNhdGlvbk1ldGhvZHMgLSBWZXJpZmljYXRpb24gbWV0aG9kcyB0byB1c2Ugd2hlbiBgYWNjZXB0KClgIGlzIGNhbGxlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9sbU1hY2hpbmUsIGlubmVyLCBvdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IsIHN1cHBvcnRlZFZlcmlmaWNhdGlvbk1ldGhvZHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub2xtTWFjaGluZSA9IG9sbU1hY2hpbmU7XG4gICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgIHRoaXMub3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yID0gb3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yO1xuICAgIHRoaXMuc3VwcG9ydGVkVmVyaWZpY2F0aW9uTWV0aG9kcyA9IHN1cHBvcnRlZFZlcmlmaWNhdGlvbk1ldGhvZHM7XG4gICAgLyoqIGEgcmXDq21pdHRlciB3aGljaCByZWxheXMgVmVyaWZpY2F0aW9uUmVxdWVzdEV2ZW50LkNoYW5nZWQgZXZlbnRzIGVtaXR0ZWQgYnkgdGhlIHZlcmlmaWVyICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVFbWl0dGVyXCIsIHZvaWQgMCk7XG4gICAgLyoqIEFyZSB3ZSBpbiB0aGUgcHJvY2VzcyBvZiBzZW5kaW5nIGFuIGBtLmtleS52ZXJpZmljYXRpb24ucmVhZHlgIGV2ZW50PyAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hY2NlcHRpbmdcIiwgZmFsc2UpO1xuICAgIC8qKiBBcmUgd2UgaW4gdGhlIHByb2Nlc3Mgb2Ygc2VuZGluZyBhbiBgbS5rZXkudmVyaWZpY2F0aW9uLmNhbmNlbGxhdGlvbmAgZXZlbnQ/ICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NhbmNlbGxpbmdcIiwgZmFsc2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl92ZXJpZmllclwiLCB2b2lkIDApO1xuICAgIHRoaXMucmVFbWl0dGVyID0gbmV3IFR5cGVkUmVFbWl0dGVyKHRoaXMpO1xuXG4gICAgLy8gT2J2aW91c2x5LCB0aGUgUnVzdCBvYmplY3QgbWFpbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi4gSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIG1haW50YWluc1xuICAgIC8vIGEgcmVmZXJlbmNlIHRvIHRoZSBSdXN0IG9iamVjdCwgdGhlbiB3ZSBoYXZlIGEgcmVmZXJlbmNlIGN5Y2xlIHdoaWNoIG1lYW5zIHRoYXQgYFJ1c3RWZXJpZmljYXRpb25SZXF1ZXN0YFxuICAgIC8vIHdpbGwgbmV2ZXIgYmUgZ2FyYmFnZS1jb2xsZWN0ZWQsIGFuZCBoZW5jZSB0aGUgdW5kZXJseWluZyBydXN0IG9iamVjdCB3aWxsIG5ldmVyIGJlIGZyZWVkLlxuICAgIC8vXG4gICAgLy8gVG8gYXZvaWQgdGhpcyByZWZlcmVuY2UgY3ljbGUsIHVzZSBhIHdlYWsgcmVmZXJlbmNlIGluIHRoZSBjYWxsYmFjayBmdW5jdGlvbi4gSWYgdGhlIGBSdXN0VmVyaWZpY2F0aW9uUmVxdWVzdGBcbiAgICAvLyBnZXRzIGdhcmJhZ2UtY29sbGVjdGVkLCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gdXBkYXRlIVxuICAgIHZhciB3ZWFrVGhpcyA9IG5ldyBXZWFrUmVmKHRoaXMpO1xuICAgIGlubmVyLnJlZ2lzdGVyQ2hhbmdlc0NhbGxiYWNrKC8qI19fUFVSRV9fKi9fYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF93ZWFrVGhpcyRkZXJlZjtcbiAgICAgIHJldHVybiAoX3dlYWtUaGlzJGRlcmVmID0gd2Vha1RoaXMuZGVyZWYoKSkgPT09IG51bGwgfHwgX3dlYWtUaGlzJGRlcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2Vha1RoaXMkZGVyZWYub25DaGFuZ2UoKTtcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogSG9vayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgdW5kZXJseWluZyBydXN0IGNsYXNzIG5vdGlmaWVzIHVzIHRoYXQgdGhlcmUgaGFzIGJlZW4gYSBjaGFuZ2UuXG4gICAqL1xuICBvbkNoYW5nZSgpIHtcbiAgICB2YXIgdmVyaWZpY2F0aW9uID0gdGhpcy5pbm5lci5nZXRWZXJpZmljYXRpb24oKTtcblxuICAgIC8vIFNldCB0aGUgX3ZlcmlmaWVyIG9iamVjdCAod3JhcHBpbmcgdGhlIHJ1c3QgYFZlcmlmaWNhdGlvbmAgYXMgYSBqcy1zZGsgVmVyaWZpZXIpIGlmOlxuICAgIC8vIC0gd2Ugbm93IGhhdmUgYSBgVmVyaWZpY2F0aW9uYCB3aGVyZSB3ZSBsYWNrZWQgb25lIGJlZm9yZVxuICAgIC8vIC0gd2UgaGF2ZSB0cmFuc2l0aW9uZWQgZnJvbSBRUiB0byBTQVNcbiAgICAvLyAtIHdlIGFyZSB2ZXJpZnlpbmcgd2l0aCBTQVMsIGJ1dCB3ZSBuZWVkIHRvIHJlcGxhY2Ugb3VyIHZlcmlmaWVyIHdpdGggYSBuZXcgb25lIGJlY2F1c2UgYm90aCBwYXJ0aWVzXG4gICAgLy8gICB0cmllZCB0byBzdGFydCB2ZXJpZmljYXRpb24gYXQgdGhlIHNhbWUgdGltZSwgYW5kIHdlIGxvc3QgdGhlIHRpZSBicmVha2luZ1xuICAgIGlmICh2ZXJpZmljYXRpb24gaW5zdGFuY2VvZiBSdXN0U2RrQ3J5cHRvSnMuU2FzKSB7XG4gICAgICBpZiAodGhpcy5fdmVyaWZpZXIgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl92ZXJpZmllciBpbnN0YW5jZW9mIFJ1c3RRckNvZGVWZXJpZmllcikge1xuICAgICAgICB0aGlzLnNldFZlcmlmaWVyKG5ldyBSdXN0U0FTVmVyaWZpZXIodmVyaWZpY2F0aW9uLCB0aGlzLCB0aGlzLm91dGdvaW5nUmVxdWVzdFByb2Nlc3NvcikpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl92ZXJpZmllciBpbnN0YW5jZW9mIFJ1c3RTQVNWZXJpZmllcikge1xuICAgICAgICB0aGlzLl92ZXJpZmllci5yZXBsYWNlSW5uZXIodmVyaWZpY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZlcmlmaWNhdGlvbiBpbnN0YW5jZW9mIFJ1c3RTZGtDcnlwdG9Kcy5RciAmJiB0aGlzLl92ZXJpZmllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFZlcmlmaWVyKG5ldyBSdXN0UXJDb2RlVmVyaWZpZXIodmVyaWZpY2F0aW9uLCB0aGlzLm91dGdvaW5nUmVxdWVzdFByb2Nlc3NvcikpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoVmVyaWZpY2F0aW9uUmVxdWVzdEV2ZW50LkNoYW5nZSk7XG4gIH1cbiAgc2V0VmVyaWZpZXIodmVyaWZpZXIpIHtcbiAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSB2ZXJpZmllciwgdW5zdWJzY3JpYmUgZnJvbSBpdHMgZXZlbnRzXG4gICAgaWYgKHRoaXMuX3ZlcmlmaWVyKSB7XG4gICAgICB0aGlzLnJlRW1pdHRlci5zdG9wUmVFbWl0dGluZyh0aGlzLl92ZXJpZmllciwgW1ZlcmlmaWNhdGlvblJlcXVlc3RFdmVudC5DaGFuZ2VdKTtcbiAgICB9XG4gICAgdGhpcy5fdmVyaWZpZXIgPSB2ZXJpZmllcjtcbiAgICB0aGlzLnJlRW1pdHRlci5yZUVtaXQodGhpcy5fdmVyaWZpZXIsIFtWZXJpZmljYXRpb25SZXF1ZXN0RXZlbnQuQ2hhbmdlXSk7XG4gIH1cblxuICAvKipcbiAgICogVW5pcXVlIElEIGZvciB0aGlzIHZlcmlmaWNhdGlvbiByZXF1ZXN0LlxuICAgKlxuICAgKiBBbiBJRCBpc24ndCBhc3NpZ25lZCB1bnRpbCB0aGUgZmlyc3QgbWVzc2FnZSBpcyBzZW50LCBzbyB0aGlzIG1heSBiZSBgdW5kZWZpbmVkYCBpbiB0aGUgZWFybHkgcGhhc2VzLlxuICAgKi9cbiAgZ2V0IHRyYW5zYWN0aW9uSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5uZXIuZmxvd0lkO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBhbiBpbi1yb29tIHZlcmlmaWNhdGlvbiwgdGhlIElEIG9mIHRoZSByb29tLlxuICAgKlxuICAgKiBGb3IgdG8tZGV2aWNlIHZlcmlmaWNhdGlvbnMsIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZ2V0IHJvb21JZCgpIHtcbiAgICB2YXIgX3RoaXMkaW5uZXIkcm9vbUlkO1xuICAgIHJldHVybiAoX3RoaXMkaW5uZXIkcm9vbUlkID0gdGhpcy5pbm5lci5yb29tSWQpID09PSBudWxsIHx8IF90aGlzJGlubmVyJHJvb21JZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkaW5uZXIkcm9vbUlkLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGlzIHJlcXVlc3Qgd2FzIGluaXRpYXRlZCBieSB0aGUgbG9jYWwgY2xpZW50LlxuICAgKlxuICAgKiBGb3IgaW4tcm9vbSB2ZXJpZmljYXRpb25zLCB0aGUgaW5pdGlhdG9yIGlzIHdobyBzZW50IHRoZSBgbS5rZXkudmVyaWZpY2F0aW9uLnJlcXVlc3RgIGV2ZW50LlxuICAgKiBGb3IgdG8tZGV2aWNlIHZlcmlmaWNhdGlvbnMsIHRoZSBpbml0aWF0b3IgaXMgd2hvIHNlbnQgdGhlIGBtLmtleS52ZXJpZmljYXRpb24uc3RhcnRgIGV2ZW50LlxuICAgKi9cbiAgZ2V0IGluaXRpYXRlZEJ5TWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5uZXIud2VTdGFydGVkKCk7XG4gIH1cblxuICAvKiogVGhlIHVzZXIgaWQgb2YgdGhlIG90aGVyIHBhcnR5IGluIHRoaXMgcmVxdWVzdCAqL1xuICBnZXQgb3RoZXJVc2VySWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5uZXIub3RoZXJVc2VySWQudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8qKiBGb3IgdmVyaWZpY2F0aW9ucyB2aWEgdG8tZGV2aWNlIG1lc3NhZ2VzOiB0aGUgSUQgb2YgdGhlIG90aGVyIGRldmljZS4gT3RoZXJ3aXNlLCB1bmRlZmluZWQuICovXG4gIGdldCBvdGhlckRldmljZUlkKCkge1xuICAgIHZhciBfdGhpcyRpbm5lciRvdGhlckRldmk7XG4gICAgcmV0dXJuIChfdGhpcyRpbm5lciRvdGhlckRldmkgPSB0aGlzLmlubmVyLm90aGVyRGV2aWNlSWQpID09PSBudWxsIHx8IF90aGlzJGlubmVyJG90aGVyRGV2aSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkaW5uZXIkb3RoZXJEZXZpLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvKiogR2V0IHRoZSBvdGhlciBkZXZpY2UgaW52b2x2ZWQgaW4gdGhlIHZlcmlmaWNhdGlvbiwgaWYgaXQgaXMga25vd24gKi9cbiAgZ2V0T3RoZXJEZXZpY2UoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBvdGhlckRldmljZUlkID0gX3RoaXMuaW5uZXIub3RoZXJEZXZpY2VJZDtcbiAgICAgIGlmICghb3RoZXJEZXZpY2VJZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHlpZWxkIF90aGlzLm9sbU1hY2hpbmUuZ2V0RGV2aWNlKF90aGlzLmlubmVyLm90aGVyVXNlcklkLCBvdGhlckRldmljZUlkLCA1KTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqIFRydWUgaWYgdGhlIG90aGVyIHBhcnR5IGluIHRoaXMgcmVxdWVzdCBpcyBvbmUgb2YgdGhpcyB1c2VyJ3Mgb3duIGRldmljZXMuICovXG4gIGdldCBpc1NlbGZWZXJpZmljYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5uZXIuaXNTZWxmVmVyaWZpY2F0aW9uKCk7XG4gIH1cblxuICAvKiogY3VycmVudCBwaGFzZSBvZiB0aGUgcmVxdWVzdC4gKi9cbiAgZ2V0IHBoYXNlKCkge1xuICAgIHZhciBwaGFzZSA9IHRoaXMuaW5uZXIucGhhc2UoKTtcbiAgICBzd2l0Y2ggKHBoYXNlKSB7XG4gICAgICBjYXNlIFJ1c3RTZGtDcnlwdG9Kcy5WZXJpZmljYXRpb25SZXF1ZXN0UGhhc2UuQ3JlYXRlZDpcbiAgICAgIGNhc2UgUnVzdFNka0NyeXB0b0pzLlZlcmlmaWNhdGlvblJlcXVlc3RQaGFzZS5SZXF1ZXN0ZWQ6XG4gICAgICAgIHJldHVybiBWZXJpZmljYXRpb25QaGFzZS5SZXF1ZXN0ZWQ7XG4gICAgICBjYXNlIFJ1c3RTZGtDcnlwdG9Kcy5WZXJpZmljYXRpb25SZXF1ZXN0UGhhc2UuUmVhZHk6XG4gICAgICAgIC8vIGlmIHdlJ3JlIHN0aWxsIHNlbmRpbmcgdGhlIGBtLmtleS52ZXJpZmljYXRpb24ucmVhZHlgLCB0aGF0IGNvdW50cyBhcyBcIlJlcXVlc3RlZFwiIGluIHRoZSBqcy1zZGsnc1xuICAgICAgICAvLyBwYXJsYW5jZS5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjY2VwdGluZyA/IFZlcmlmaWNhdGlvblBoYXNlLlJlcXVlc3RlZCA6IFZlcmlmaWNhdGlvblBoYXNlLlJlYWR5O1xuICAgICAgY2FzZSBSdXN0U2RrQ3J5cHRvSnMuVmVyaWZpY2F0aW9uUmVxdWVzdFBoYXNlLlRyYW5zaXRpb25lZDpcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZmllcikge1xuICAgICAgICAgIC8vIHRoaXMgc2hvdWxkbid0IGhhcHBlbiwgYmVjYXVzZSB0aGUgb25DaGFuZ2UgaGFuZGxlciBzaG91bGQgaGF2ZSBjcmVhdGVkIGEgX3ZlcmlmaWVyLlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlcmlmaWNhdGlvblJlcXVlc3Q6IGlubmVyIHBoYXNlID09IFRyYW5zaXRpb25lZCBidXQgbm8gdmVyaWZpZXIhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJpZmllci52ZXJpZmljYXRpb25QaGFzZTtcbiAgICAgIGNhc2UgUnVzdFNka0NyeXB0b0pzLlZlcmlmaWNhdGlvblJlcXVlc3RQaGFzZS5Eb25lOlxuICAgICAgICByZXR1cm4gVmVyaWZpY2F0aW9uUGhhc2UuRG9uZTtcbiAgICAgIGNhc2UgUnVzdFNka0NyeXB0b0pzLlZlcmlmaWNhdGlvblJlcXVlc3RQaGFzZS5DYW5jZWxsZWQ6XG4gICAgICAgIHJldHVybiBWZXJpZmljYXRpb25QaGFzZS5DYW5jZWxsZWQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdmVyaWZpY2F0aW9uIHBoYXNlIFwiLmNvbmNhdChwaGFzZSkpO1xuICB9XG5cbiAgLyoqIFRydWUgaWYgdGhlIHJlcXVlc3QgaGFzIHNlbnQgaXRzIGluaXRpYWwgZXZlbnQgYW5kIG5lZWRzIG1vcmUgZXZlbnRzIHRvIGNvbXBsZXRlXG4gICAqIChpZSBpdCBpcyBpbiBwaGFzZSBgUmVxdWVzdGVkYCwgYFJlYWR5YCBvciBgU3RhcnRlZGApLlxuICAgKi9cbiAgZ2V0IHBlbmRpbmcoKSB7XG4gICAgaWYgKHRoaXMuaW5uZXIuaXNQYXNzaXZlKCkpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcGhhc2UgPSB0aGlzLnBoYXNlO1xuICAgIHJldHVybiBwaGFzZSAhPT0gVmVyaWZpY2F0aW9uUGhhc2UuRG9uZSAmJiBwaGFzZSAhPT0gVmVyaWZpY2F0aW9uUGhhc2UuQ2FuY2VsbGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRydWUgaWYgd2UgaGF2ZSBzdGFydGVkIHRoZSBwcm9jZXNzIG9mIHNlbmRpbmcgYW4gYG0ua2V5LnZlcmlmaWNhdGlvbi5yZWFkeWAgKGJ1dCBoYXZlIG5vdCBuZWNlc3NhcmlseSByZWNlaXZlZFxuICAgKiB0aGUgcmVtb3RlIGVjaG8gd2hpY2ggY2F1c2VzIGEgdHJhbnNpdGlvbiB0byB7QGxpbmsgVmVyaWZpY2F0aW9uUGhhc2UuUmVhZHl9LlxuICAgKi9cbiAgZ2V0IGFjY2VwdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjZXB0aW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFRydWUgaWYgd2UgaGF2ZSBzdGFydGVkIHRoZSBwcm9jZXNzIG9mIHNlbmRpbmcgYW4gYG0ua2V5LnZlcmlmaWNhdGlvbi5jYW5jZWxgIChidXQgaGF2ZSBub3QgbmVjZXNzYXJpbHkgcmVjZWl2ZWRcbiAgICogdGhlIHJlbW90ZSBlY2hvIHdoaWNoIGNhdXNlcyBhIHRyYW5zaXRpb24gdG8ge0BsaW5rIFZlcmlmaWNhdGlvblBoYXNlLkNhbmNlbGxlZH0pLlxuICAgKi9cbiAgZ2V0IGRlY2xpbmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FuY2VsbGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmVtYWluaW5nIG51bWJlciBvZiBtcyBiZWZvcmUgdGhlIHJlcXVlc3Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNhbmNlbGxlZC5cbiAgICpcbiAgICogYG51bGxgIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIG5vIHRpbWVvdXRcbiAgICovXG4gIGdldCB0aW1lb3V0KCkge1xuICAgIHJldHVybiB0aGlzLmlubmVyLnRpbWVSZW1haW5pbmdNaWxsaXMoKTtcbiAgfVxuXG4gIC8qKiBvbmNlIHRoZSBwaGFzZSBpcyBTdGFydGVkIChhbmQgIWluaXRpYXRlZEJ5TWUpIG9yIFJlYWR5OiBjb21tb24gbWV0aG9kcyBzdXBwb3J0ZWQgYnkgYm90aCBzaWRlcyAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cblxuICAvKiogdGhlIG1ldGhvZCBwaWNrZWQgaW4gdGhlIC5zdGFydCBldmVudCAqL1xuICBnZXQgY2hvc2VuTWV0aG9kKCkge1xuICAgIGlmICh0aGlzLnBoYXNlICE9PSBWZXJpZmljYXRpb25QaGFzZS5TdGFydGVkKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgdmVyaWZpY2F0aW9uID0gdGhpcy5pbm5lci5nZXRWZXJpZmljYXRpb24oKTtcbiAgICBpZiAodmVyaWZpY2F0aW9uIGluc3RhbmNlb2YgUnVzdFNka0NyeXB0b0pzLlNhcykge1xuICAgICAgcmV0dXJuIFZlcmlmaWNhdGlvbk1ldGhvZC5TYXM7XG4gICAgfSBlbHNlIGlmICh2ZXJpZmljYXRpb24gaW5zdGFuY2VvZiBSdXN0U2RrQ3J5cHRvSnMuUXIpIHtcbiAgICAgIHJldHVybiBWZXJpZmljYXRpb25NZXRob2QuUmVjaXByb2NhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgb3RoZXIgcGFydHkgc3VwcG9ydHMgYSBnaXZlbiB2ZXJpZmljYXRpb24gbWV0aG9kLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHNldHRpbmcgdXAgdGhlIFFSIGNvZGUgVUksIGFzIGl0IGlzIHNvbWV3aGF0IGFzeW1tZXRyaWNhbDpcbiAgICogaWYgdGhlIG90aGVyIHBhcnR5IHN1cHBvcnRzIFNDQU5fUVIsIHdlIHNob3VsZCBzaG93IGEgUVIgY29kZSBpbiB0aGUgVUksIGFuZCB2aWNlIHZlcnNhLlxuICAgKiBGb3IgbWV0aG9kcyB0aGF0IG5lZWQgdG8gYmUgc3VwcG9ydGVkIGJ5IGJvdGggZW5kcywgdXNlIHRoZSBgbWV0aG9kc2AgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSBtZXRob2QgLSB0aGUgbWV0aG9kIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG90aGVyIHBhcnR5IHNhaWQgdGhleSBzdXBwb3J0ZWQgdGhlIG1ldGhvZFxuICAgKi9cbiAgb3RoZXJQYXJ0eVN1cHBvcnRzTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB0aGVpck1ldGhvZHMgPSB0aGlzLmlubmVyLnRoZWlyU3VwcG9ydGVkTWV0aG9kcztcbiAgICBpZiAodGhlaXJNZXRob2RzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIG5vIG1lc3NhZ2UgZnJvbSB0aGUgb3RoZXIgc2lkZSB5ZXRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHJlcXVpcmVkTWV0aG9kID0gdmVyaWZpY2F0aW9uTWV0aG9kc0J5SWRlbnRpZmllclttZXRob2RdO1xuICAgIHJldHVybiB0aGVpck1ldGhvZHMuc29tZShtID0+IG0gPT09IHJlcXVpcmVkTWV0aG9kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIHRoZSByZXF1ZXN0LCBzZW5kaW5nIGEgLnJlYWR5IGV2ZW50IHRvIHRoZSBvdGhlciBwYXJ0eVxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGV2ZW50IGhhcyBiZWVuIHNlbnQuXG4gICAqL1xuICBhY2NlcHQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoX3RoaXMyLmlubmVyLnBoYXNlKCkgIT09IFJ1c3RTZGtDcnlwdG9Kcy5WZXJpZmljYXRpb25SZXF1ZXN0UGhhc2UuUmVxdWVzdGVkIHx8IF90aGlzMi5fYWNjZXB0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhY2NlcHQgYSB2ZXJpZmljYXRpb24gcmVxdWVzdCBpbiBwaGFzZSBcIi5jb25jYXQoX3RoaXMyLnBoYXNlKSk7XG4gICAgICB9XG4gICAgICBfdGhpczIuX2FjY2VwdGluZyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVxID0gX3RoaXMyLmlubmVyLmFjY2VwdFdpdGhNZXRob2RzKF90aGlzMi5zdXBwb3J0ZWRWZXJpZmljYXRpb25NZXRob2RzLm1hcCh2ZXJpZmljYXRpb25NZXRob2RJZGVudGlmaWVyVG9NZXRob2QpKTtcbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgIHlpZWxkIF90aGlzMi5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IubWFrZU91dGdvaW5nUmVxdWVzdChyZXEpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfdGhpczIuX2FjY2VwdGluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBwaGFzZSBtYXkgaGF2ZSBjaGFuZ2VkLCBzbyBlbWl0IGEgJ2NoYW5nZScgZXZlbnRcbiAgICAgIF90aGlzMi5lbWl0KFZlcmlmaWNhdGlvblJlcXVlc3RFdmVudC5DaGFuZ2UpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyB0aGUgcmVxdWVzdCwgc2VuZGluZyBhIGNhbmNlbGxhdGlvbiB0byB0aGUgb3RoZXIgcGFydHlcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIERldGFpbHMgZm9yIHRoZSBjYW5jZWxsYXRpb24sIGluY2x1ZGluZyBgcmVhc29uYCAoZGVmYXVsdHMgdG8gXCJVc2VyIGRlY2xpbmVkXCIpLCBhbmQgYGNvZGVgXG4gICAqICAgIChkZWZhdWx0cyB0byBgbS51c2VyYCkuXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgZXZlbnQgaGFzIGJlZW4gc2VudC5cbiAgICovXG4gIGNhbmNlbChwYXJhbXMpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChfdGhpczMuX2NhbmNlbGxpbmcpIHtcbiAgICAgICAgLy8gYWxyZWFkeSBjYW5jZWxsaW5nOyBkbyBub3RoaW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF90aGlzMy5fY2FuY2VsbGluZyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVxID0gX3RoaXMzLmlubmVyLmNhbmNlbCgpO1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgeWllbGQgX3RoaXMzLm91dGdvaW5nUmVxdWVzdFByb2Nlc3Nvci5tYWtlT3V0Z29pbmdSZXF1ZXN0KHJlcSk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF90aGlzMy5fY2FuY2VsbGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEge0BsaW5rIFZlcmlmaWVyfSB0byBkbyB0aGlzIHZlcmlmaWNhdGlvbiB2aWEgYSBwYXJ0aWN1bGFyIG1ldGhvZC5cbiAgICpcbiAgICogSWYgYSB2ZXJpZmllciBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgZm9yIHRoaXMgcmVxdWVzdCwgcmV0dXJucyB0aGF0IHZlcmlmaWVyLlxuICAgKlxuICAgKiBUaGlzIGRvZXMgKm5vdCogc2VuZCB0aGUgYG0ua2V5LnZlcmlmaWNhdGlvbi5zdGFydGAgZXZlbnQgLSB0byBkbyBzbywgY2FsbCB7QGxpbmsgVmVyaWZpZXIjdmVyaWZpZXJ9IG9uIHRoZVxuICAgKiByZXR1cm5lZCB2ZXJpZmllci5cbiAgICpcbiAgICogSWYgbm8gcHJldmlvdXMgZXZlbnRzIGhhdmUgYmVlbiBzZW50LCBwYXNzIGluIGB0YXJnZXREZXZpY2VgIHRvIHNldCB3aG8gdG8gZGlyZWN0IHRoaXMgcmVxdWVzdCB0by5cbiAgICpcbiAgICogQHBhcmFtIG1ldGhvZCAtIHRoZSBuYW1lIG9mIHRoZSB2ZXJpZmljYXRpb24gbWV0aG9kIHRvIHVzZS5cbiAgICogQHBhcmFtIHRhcmdldERldmljZSAtIGRldGFpbHMgb2Ygd2hlcmUgdG8gc2VuZCB0aGUgcmVxdWVzdCB0by5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHZlcmlmaWVyIHdoaWNoIHdpbGwgZG8gdGhlIGFjdHVhbCB2ZXJpZmljYXRpb24uXG4gICAqL1xuICBiZWdpbktleVZlcmlmaWNhdGlvbihtZXRob2QsIHRhcmdldERldmljZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGFuIGBtLmtleS52ZXJpZmljYXRpb24uc3RhcnRgIGV2ZW50IHRvIHN0YXJ0IHZlcmlmaWNhdGlvbiB2aWEgYSBwYXJ0aWN1bGFyIG1ldGhvZC5cbiAgICpcbiAgICogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIENyeXB0by5WZXJpZmljYXRpb25SZXF1ZXN0I3N0YXJ0VmVyaWZpY2F0aW9ufS5cbiAgICpcbiAgICogQHBhcmFtIG1ldGhvZCAtIHRoZSBuYW1lIG9mIHRoZSB2ZXJpZmljYXRpb24gbWV0aG9kIHRvIHVzZS5cbiAgICovXG4gIHN0YXJ0VmVyaWZpY2F0aW9uKG1ldGhvZCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKG1ldGhvZCAhPT0gVmVyaWZpY2F0aW9uTWV0aG9kLlNhcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB2ZXJpZmljYXRpb24gbWV0aG9kIFwiLmNvbmNhdChtZXRob2QpKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpc3Qgb2YgdGhlIG90aGVyIHVzZXIncyBkZXZpY2VzICh3b3JrYXJvdW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRyaXgtb3JnL21hdHJpeC1ydXN0LXNkay9pc3N1ZXMvMjg5NilcbiAgICAgIGlmICghKHlpZWxkIF90aGlzNC5nZXRPdGhlckRldmljZSgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydFZlcmlmaWNhdGlvbigpOiBvdGhlciBkZXZpY2UgaXMgdW5rbm93blwiKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXMgPSB5aWVsZCBfdGhpczQuaW5uZXIuc3RhcnRTYXMoKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgdmFyIFssIHJlcV0gPSByZXM7XG4gICAgICAgIHlpZWxkIF90aGlzNC5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IubWFrZU91dGdvaW5nUmVxdWVzdChyZXEpO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGlzIHNob3VsZCBoYXZlIHRyaWdnZXJlZCB0aGUgb25DaGFuZ2UgY2FsbGJhY2ssIGFuZCB3ZSBzaG91bGQgbm93IGhhdmUgYSB2ZXJpZmllclxuICAgICAgaWYgKCFfdGhpczQuX3ZlcmlmaWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0aWxsIG5vIHZlcmlmaWVyIGFmdGVyIHN0YXJ0U2FzKCkgY2FsbFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdGhpczQuX3ZlcmlmaWVyO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBRUiBjb2RlIHZlcmlmaWNhdGlvbiBieSBwcm92aWRpbmcgYSBzY2FubmVkIFFSIGNvZGUgZm9yIHRoaXMgdmVyaWZpY2F0aW9uIGZsb3cuXG4gICAqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG8uVmVyaWZpY2F0aW9uUmVxdWVzdCNzY2FuUVJDb2RlfS5cbiAgICpcbiAgICogQHBhcmFtIHFyQ29kZURhdGEgLSB0aGUgZGVjb2RlZCBRUiBjb2RlLlxuICAgKiBAcmV0dXJucyBBIHZlcmlmaWVyOyBjYWxsIGAudmVyaWZ5KClgIG9uIGl0IHRvIHdhaXQgZm9yIHRoZSBvdGhlciBzaWRlIHRvIGNvbXBsZXRlIHRoZSB2ZXJpZmljYXRpb24gZmxvdy5cbiAgICovXG4gIHNjYW5RUkNvZGUodWludDhBcnJheSkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHNjYW4gPSBSdXN0U2RrQ3J5cHRvSnMuUXJDb2RlU2Nhbi5mcm9tQnl0ZXModWludDhBcnJheSk7XG4gICAgICB2YXIgdmVyaWZpZXIgPSB5aWVsZCBfdGhpczUuaW5uZXIuc2NhblFyQ29kZShzY2FuKTtcblxuICAgICAgLy8gdGhpcyBzaG91bGQgaGF2ZSB0cmlnZ2VyZWQgdGhlIG9uQ2hhbmdlIGNhbGxiYWNrLCBhbmQgd2Ugc2hvdWxkIG5vdyBoYXZlIGEgdmVyaWZpZXJcbiAgICAgIGlmICghX3RoaXM1Ll92ZXJpZmllcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGlsbCBubyB2ZXJpZmllciBhZnRlciBzY2FuUXJDb2RlKCkgY2FsbFwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgY2FuIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHJlY2lwcm9jYXRlIHJlcXVlc3RcbiAgICAgIHZhciByZXEgPSB2ZXJpZmllci5yZWNpcHJvY2F0ZSgpO1xuICAgICAgaWYgKHJlcSkge1xuICAgICAgICB5aWVsZCBfdGhpczUub3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yLm1ha2VPdXRnb2luZ1JlcXVlc3QocmVxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdGhpczUuX3ZlcmlmaWVyO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHZlcmlmaWVyIHdoaWNoIGlzIGRvaW5nIHRoZSBhY3R1YWwgdmVyaWZpY2F0aW9uLCBvbmNlIHRoZSBtZXRob2QgaGFzIGJlZW4gZXN0YWJsaXNoZWQuXG4gICAqIE9ubHkgZGVmaW5lZCB3aGVuIHRoZSBgcGhhc2VgIGlzIFN0YXJ0ZWQuXG4gICAqL1xuICBnZXQgdmVyaWZpZXIoKSB7XG4gICAgLy8gSXQncyBwb3NzaWJsZSBmb3IgdXMgdG8gaGF2ZSBhIFZlcmlmaWVyIGJlZm9yZSBhIG1ldGhvZCBoYXMgYmVlbiBjaG9zZW4gKGluIHBhcnRpY3VsYXIsXG4gICAgLy8gaWYgd2UgYXJlIHNob3dpbmcgYSBRUiBjb2RlIHdoaWNoIHRoZSBvdGhlciBkZXZpY2UgaGFzIG5vdCB5ZXQgc2Nhbm5lZC4gQXQgdGhhdCBwb2ludCwgd2UgY291bGRcbiAgICAvLyBzdGlsbCBzd2l0Y2ggdG8gU0FTKS5cbiAgICAvL1xuICAgIC8vIEluIHRoYXQgY2FzZSwgd2Ugc2hvdWxkIG5vdCByZXR1cm4gaXQgdG8gdGhlIGFwcGxpY2F0aW9uIHlldCwgc2luY2UgdGhlIGFwcGxpY2F0aW9uIHdpbGwgbm90IGV4cGVjdCB0aGVcbiAgICAvLyBWZXJpZmllciB0byBiZSByZXBsYWNlZCBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIHRoZSBWZXJpZmljYXRpb25SZXF1ZXN0LlxuICAgIHJldHVybiB0aGlzLnBoYXNlID09PSBWZXJpZmljYXRpb25QaGFzZS5TdGFydGVkID8gdGhpcy5fdmVyaWZpZXIgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU3R1YiBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQ3J5cHRvLlZlcmlmaWNhdGlvblJlcXVlc3QjZ2V0UVJDb2RlQnl0ZXN9LlxuICAgKi9cbiAgZ2V0UVJDb2RlQnl0ZXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0UVJDb2RlQnl0ZXMoKSB1bnN1cHBvcnRlZCBpbiBSdXN0IENyeXB0bzsgdXNlIGdlbmVyYXRlUVJDb2RlKCkgaW5zdGVhZC5cIik7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgdGhlIGRhdGEgZm9yIGEgUVIgY29kZSBhbGxvd2luZyB0aGUgb3RoZXIgZGV2aWNlIHRvIHZlcmlmeSB0aGlzIG9uZSwgaWYgaXQgc3VwcG9ydHMgaXQuXG4gICAqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDcnlwdG8uVmVyaWZpY2F0aW9uUmVxdWVzdCNnZW5lcmF0ZVFSQ29kZX0uXG4gICAqL1xuICBnZW5lcmF0ZVFSQ29kZSgpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXN0IG9mIHRoZSBvdGhlciB1c2VyJ3MgZGV2aWNlcyAod29ya2Fyb3VuZCBodHRwczovL2dpdGh1Yi5jb20vbWF0cml4LW9yZy9tYXRyaXgtcnVzdC1zZGsvaXNzdWVzLzI4OTYpXG4gICAgICBpZiAoISh5aWVsZCBfdGhpczYuZ2V0T3RoZXJEZXZpY2UoKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2VuZXJhdGVRUkNvZGUoKTogb3RoZXIgZGV2aWNlIGlzIHVua25vd25cIik7XG4gICAgICB9XG4gICAgICB2YXIgaW5uZXJWZXJpZmllciA9IHlpZWxkIF90aGlzNi5pbm5lci5nZW5lcmF0ZVFyQ29kZSgpO1xuICAgICAgLy8gSWYgd2UgYXJlIHVuYWJsZSB0byBnZW5lcmF0ZSBhIFFSQ29kZSwgd2UgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgaWYgKCFpbm5lclZlcmlmaWVyKSByZXR1cm47XG4gICAgICByZXR1cm4gaW5uZXJWZXJpZmllci50b0J5dGVzKCk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGlzIHJlcXVlc3QgaGFzIGJlZW4gY2FuY2VsbGVkLCB0aGUgY2FuY2VsbGF0aW9uIGNvZGUgKGUuZyBgbS51c2VyYCkgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIGNhbmNlbGxpbmdcbiAgICogdGhpcyB2ZXJpZmljYXRpb24uXG4gICAqL1xuICBnZXQgY2FuY2VsbGF0aW9uQ29kZSgpIHtcbiAgICB2YXIgX3RoaXMkaW5uZXIkY2FuY2VsSW5mLCBfdGhpcyRpbm5lciRjYW5jZWxJbmYyO1xuICAgIHJldHVybiAoX3RoaXMkaW5uZXIkY2FuY2VsSW5mID0gKF90aGlzJGlubmVyJGNhbmNlbEluZjIgPSB0aGlzLmlubmVyLmNhbmNlbEluZm8pID09PSBudWxsIHx8IF90aGlzJGlubmVyJGNhbmNlbEluZjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGlubmVyJGNhbmNlbEluZjIuY2FuY2VsQ29kZSgpKSAhPT0gbnVsbCAmJiBfdGhpcyRpbm5lciRjYW5jZWxJbmYgIT09IHZvaWQgMCA/IF90aGlzJGlubmVyJGNhbmNlbEluZiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSB1c2VyIHRoYXQgY2FuY2VsbGVkIHRoZSByZXF1ZXN0LlxuICAgKlxuICAgKiBPbmx5IGRlZmluZWQgd2hlbiBwaGFzZSBpcyBDYW5jZWxsZWRcbiAgICovXG4gIGdldCBjYW5jZWxsaW5nVXNlcklkKCkge1xuICAgIHZhciBjYW5jZWxJbmZvID0gdGhpcy5pbm5lci5jYW5jZWxJbmZvO1xuICAgIGlmICghY2FuY2VsSW5mbykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKGNhbmNlbEluZm8uY2FuY2VsbGVkYnlVcygpKSB7XG4gICAgICByZXR1cm4gdGhpcy5vbG1NYWNoaW5lLnVzZXJJZC50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbm5lci5vdGhlclVzZXJJZC50b1N0cmluZygpO1xuICAgIH1cbiAgfVxufVxuXG4vKiogQ29tbW9uIGJhc2UgY2xhc3MgZm9yIGBWZXJpZmllcmAgaW1wbGVtZW50YXRpb25zIHdoaWNoIHdyYXAgcnVzdCBjbGFzc2VzLlxuICpcbiAqIFRoZSBnZW5lcmljIHBhcmFtZXRlciBgSW5uZXJUeXBlYCBpcyB0aGUgdHlwZSBvZiB0aGUgcnVzdCBWZXJpZmljYXRpb24gY2xhc3Mgd2hpY2ggd2Ugd3JhcC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQmFzZVJ1c3RWZXJpZmVyIGV4dGVuZHMgVHlwZWRFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihpbm5lciwgb3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgdGhpcy5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IgPSBvdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3I7XG4gICAgLyoqIEEgZGVmZXJyZWQgd2hpY2ggY29tcGxldGVzIHdoZW4gdGhlIHZlcmlmaWNhdGlvbiBjb21wbGV0ZXMgKG9yIHJlamVjdHMgd2hlbiBpdCBpcyBjYW5jZWxsZWQvZmFpbHMpICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29tcGxldGlvbkRlZmVycmVkXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQgPSBkZWZlcigpO1xuXG4gICAgLy8gQXMgd2l0aCBSdXN0VmVyaWZpY2F0aW9uUmVxdWVzdCwgd2UgbmVlZCB0byBhdm9pZCBhIHJlZmVyZW5jZSBjeWNsZS5cbiAgICAvLyBTZWUgdGhlIGNvbW1lbnRzIGluIFJ1c3RWZXJpZmljYXRpb25SZXF1ZXN0LlxuICAgIHZhciB3ZWFrVGhpcyA9IG5ldyBXZWFrUmVmKHRoaXMpO1xuICAgIGlubmVyLnJlZ2lzdGVyQ2hhbmdlc0NhbGxiYWNrKC8qI19fUFVSRV9fKi9fYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF93ZWFrVGhpcyRkZXJlZjI7XG4gICAgICByZXR1cm4gKF93ZWFrVGhpcyRkZXJlZjIgPSB3ZWFrVGhpcy5kZXJlZigpKSA9PT0gbnVsbCB8fCBfd2Vha1RoaXMkZGVyZWYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2Vha1RoaXMkZGVyZWYyLm9uQ2hhbmdlKCk7XG4gICAgfSkpO1xuXG4gICAgLy8gc3RvcCB0aGUgcnVudGltZSBjb21wbGFpbmluZyBpZiBub2JvZHkgY2F0Y2hlcyBhIGZhaWx1cmVcbiAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5wcm9taXNlLmNhdGNoKCgpID0+IG51bGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhvb2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIHVuZGVybHlpbmcgcnVzdCBjbGFzcyBub3RpZmllcyB1cyB0aGF0IHRoZXJlIGhhcyBiZWVuIGEgY2hhbmdlLlxuICAgKlxuICAgKiBDYW4gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzIHRvIHNlZSBpZiB3ZSBjYW4gbm90aWZ5IHRoZSBhcHBsaWNhdGlvbiBhYm91dCBhbiB1cGRhdGUuIFRoZSBvdmVycmlkaW5nIG1ldGhvZFxuICAgKiBtdXN0IGNhbGwgYHN1cGVyLm9uQ2hhbmdlKClgLlxuICAgKi9cbiAgb25DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuaW5uZXIuaXNEb25lKCkpIHtcbiAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5uZXIuaXNDYW5jZWxsZWQoKSkge1xuICAgICAgdmFyIGNhbmNlbEluZm8gPSB0aGlzLmlubmVyLmNhbmNlbEluZm8oKTtcbiAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnJlamVjdChuZXcgRXJyb3IoXCJWZXJpZmljYXRpb24gY2FuY2VsbGVkIGJ5IFwiLmNvbmNhdChjYW5jZWxJbmZvLmNhbmNlbGxlZGJ5VXMoKSA/IFwidXNcIiA6IFwidGhlbVwiLCBcIiB3aXRoIGNvZGUgXCIpLmNvbmNhdChjYW5jZWxJbmZvLmNhbmNlbENvZGUoKSwgXCI6IFwiKS5jb25jYXQoY2FuY2VsSW5mby5yZWFzb24oKSkpKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFZlcmlmaWNhdGlvblJlcXVlc3RFdmVudC5DaGFuZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmVyaWZpY2F0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCwgZWl0aGVyIGJ5IHVzIG9yIHRoZSBvdGhlciBzaWRlLlxuICAgKi9cbiAgZ2V0IGhhc0JlZW5DYW5jZWxsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5uZXIuaXNDYW5jZWxsZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIG90aGVyIHVzZXIgaW4gdGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzLlxuICAgKi9cbiAgZ2V0IHVzZXJJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbm5lci5vdGhlclVzZXJJZC50b1N0cmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBhIHZlcmlmaWNhdGlvbi5cbiAgICpcbiAgICogV2Ugd2lsbCBzZW5kIGFuIGBtLmtleS52ZXJpZmljYXRpb24uY2FuY2VsYCBpZiB0aGUgdmVyaWZpY2F0aW9uIGlzIHN0aWxsIGluIGZsaWdodC4gVGhlIHZlcmlmaWNhdGlvbiBwcm9taXNlXG4gICAqIHdpbGwgcmVqZWN0LCBhbmQgYSB7QGxpbmsgQ3J5cHRvLlZlcmlmaWVyRXZlbnQjQ2FuY2VsfSB3aWxsIGJlIGVtaXR0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBlIC0gdGhlIHJlYXNvbiBmb3IgdGhlIGNhbmNlbGxhdGlvbi5cbiAgICovXG4gIGNhbmNlbChlKSB7XG4gICAgLy8gVE9ETzogc29tZXRoaW5nIHdpdGggYGVgXG4gICAgdmFyIHJlcSA9IHRoaXMuaW5uZXIuY2FuY2VsKCk7XG4gICAgaWYgKHJlcSkge1xuICAgICAgdGhpcy5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IubWFrZU91dGdvaW5nUmVxdWVzdChyZXEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRldGFpbHMgZm9yIGFuIFNBUyB2ZXJpZmljYXRpb24sIGlmIG9uZSBpcyBpbiBwcm9ncmVzc1xuICAgKlxuICAgKiBSZXR1cm5zIGBudWxsYCwgdW5sZXNzIHRoaXMgdmVyaWZpZXIgaXMgZm9yIGEgU0FTLWJhc2VkIHZlcmlmaWNhdGlvbiBhbmQgd2UgYXJlIHdhaXRpbmcgZm9yIHRoZSB1c2VyIHRvIGNvbmZpcm1cbiAgICogdGhlIFNBUyBtYXRjaGVzLlxuICAgKi9cbiAgZ2V0U2hvd1Nhc0NhbGxiYWNrcygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRldGFpbHMgZm9yIHJlY2lwcm9jYXRpbmcgUVIgY29kZSB2ZXJpZmljYXRpb24sIGlmIG9uZSBpcyBpbiBwcm9ncmVzc1xuICAgKlxuICAgKiBSZXR1cm5zIGBudWxsYCwgdW5sZXNzIHRoaXMgdmVyaWZpZXIgaXMgZm9yIHJlY2lwcm9jYXRpbmcgYSBRUi1jb2RlLWJhc2VkIHZlcmlmaWNhdGlvbiAoaWUsIHRoZSBvdGhlciB1c2VyIGhhc1xuICAgKiBhbHJlYWR5IHNjYW5uZWQgb3VyIFFSIGNvZGUpLCBhbmQgd2UgYXJlIHdhaXRpbmcgZm9yIHRoZSB1c2VyIHRvIGNvbmZpcm0uXG4gICAqL1xuICBnZXRSZWNpcHJvY2F0ZVFyQ29kZUNhbGxiYWNrcygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKiogQSBWZXJpZmllciBpbnN0YW5jZSB3aGljaCBpcyB1c2VkIHRvIHNob3cgYW5kL29yIHNjYW4gYSBRUiBjb2RlLiAqL1xuZXhwb3J0IGNsYXNzIFJ1c3RRckNvZGVWZXJpZmllciBleHRlbmRzIEJhc2VSdXN0VmVyaWZlciB7XG4gIGNvbnN0cnVjdG9yKGlubmVyLCBvdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IpIHtcbiAgICBzdXBlcihpbm5lciwgb3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsYmFja3NcIiwgbnVsbCk7XG4gIH1cbiAgb25DaGFuZ2UoKSB7XG4gICAgLy8gaWYgdGhlIG90aGVyIHNpZGUgaGFzIHNjYW5uZWQgb3VyIFFSIGNvZGUgYW5kIHNlbnQgdXMgYSBcInJlY2lwcm9jYXRlXCIgbWVzc2FnZSwgaXQgaXMgbm93IHRpbWUgZm9yIHRoZVxuICAgIC8vIGFwcGxpY2F0aW9uIHRvIHByb21wdCB0aGUgdXNlciB0byBjb25maXJtIHRoZWlyIHNpZGUuXG4gICAgaWYgKHRoaXMuY2FsbGJhY2tzID09PSBudWxsICYmIHRoaXMuaW5uZXIuaGFzQmVlblNjYW5uZWQoKSkge1xuICAgICAgdGhpcy5jYWxsYmFja3MgPSB7XG4gICAgICAgIGNvbmZpcm06ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNvbmZpcm1TY2FubmluZygpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6ICgpID0+IHRoaXMuY2FuY2VsKClcbiAgICAgIH07XG4gICAgfVxuICAgIHN1cGVyLm9uQ2hhbmdlKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIGtleSB2ZXJpZmljYXRpb24sIGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgdmVyaWZpY2F0aW9uIGhhcyBjb21wbGV0ZWQsIG9yIHJlamVjdHMgaWYgdGhlIHZlcmlmaWNhdGlvbiBpcyBjYW5jZWxsZWRcbiAgICogICAgb3IgdGltZXMgb3V0LlxuICAgKi9cbiAgdmVyaWZ5KCkge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgLy8gU29tZSBhcHBsaWNhdGlvbnMgKGhlbGxvLCBtYXRyaXgtcmVhY3Qtc2RrKSBtYXkgbm90IGNoZWNrIGlmIHRoZXJlIGlzIGEgYFNob3dRckNvZGVDYWxsYmFja3NgIGFuZCBpbnN0ZWFkXG4gICAgICAvLyByZWdpc3RlciBhIGBTaG93UmVjaXByb2NhdGVRcmAgbGlzdGVuZXIgd2hpY2ggdGhleSBleHBlY3QgdG8gYmUgY2FsbGVkIG9uY2UgYC52ZXJpZnlgIGlzIGNhbGxlZC5cbiAgICAgIGlmIChfdGhpczcuY2FsbGJhY2tzICE9PSBudWxsKSB7XG4gICAgICAgIF90aGlzNy5lbWl0KFZlcmlmaWVyRXZlbnQuU2hvd1JlY2lwcm9jYXRlUXIsIF90aGlzNy5jYWxsYmFja3MpO1xuICAgICAgfVxuICAgICAgLy8gTm90aGluZyB0byBkbyBoZXJlIGJ1dCB3YWl0LlxuICAgICAgeWllbGQgX3RoaXM3LmNvbXBsZXRpb25EZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGFuIGFwcHJvcHJpYXRlIFZlcmlmaWNhdGlvblBoYXNlIGZvciBhIFZlcmlmaWNhdGlvblJlcXVlc3Qgd2hlcmUgdGhpcyBpcyB0aGUgdmVyaWZpZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgYWJub3JtYWxseSBjb21wbGljYXRlZCBiZWNhdXNlIGEgcnVzdC1zaWRlIFFSIENvZGUgdmVyaWZpZXIgY2FuIHNwYW4gc2V2ZXJhbCB2ZXJpZmljYXRpb24gcGhhc2VzLlxuICAgKi9cbiAgZ2V0IHZlcmlmaWNhdGlvblBoYXNlKCkge1xuICAgIHN3aXRjaCAodGhpcy5pbm5lci5zdGF0ZSgpKSB7XG4gICAgICBjYXNlIFFyU3RhdGUuQ3JlYXRlZDpcbiAgICAgICAgLy8gd2UgaGF2ZSBjcmVhdGVkIGEgUVIgZm9yIGRpc3BsYXk7IG5laXRoZXIgc2lkZSBoYXMgeWV0IHNlbnQgYW4gYG0ua2V5LnZlcmlmaWNhdGlvbi5zdGFydGAuXG4gICAgICAgIHJldHVybiBWZXJpZmljYXRpb25QaGFzZS5SZWFkeTtcbiAgICAgIGNhc2UgUXJTdGF0ZS5TY2FubmVkOlxuICAgICAgICAvLyBvdGhlciBzaWRlIGhhcyBzY2FubmVkIG91ciBRUiBhbmQgc2VudCBhbiBgbS5rZXkudmVyaWZpY2F0aW9uLnN0YXJ0YCB3aXRoIGBtLnJlY2lwcm9jYXRlLnYxYFxuICAgICAgICByZXR1cm4gVmVyaWZpY2F0aW9uUGhhc2UuU3RhcnRlZDtcbiAgICAgIGNhc2UgUXJTdGF0ZS5Db25maXJtZWQ6XG4gICAgICAgIC8vIHdlIGhhdmUgY29uZmlybWVkIHRoZSBvdGhlciBzaWRlJ3Mgc2NhbiBhbmQgc2VudCBhbiBgbS5rZXkudmVyaWZpY2F0aW9uLmRvbmVgLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCB0aGUgdmVyaWZpY2F0aW9uIGlzIG5vdCB5ZXQgXCJEb25lXCIsIGJlY2F1c2Ugd2UgaGF2ZSB0byB3YWl0IHVudGlsIHdlIGhhdmUgcmVjZWl2ZWQgdGhlXG4gICAgICAgIC8vIGBtLmtleS52ZXJpZmljYXRpb24uZG9uZWAgZnJvbSB0aGUgb3RoZXIgc2lkZSAoaW4gcGFydGljdWxhciwgd2UgZG9uJ3QgbWFyayB0aGUgZGV2aWNlL2lkZW50aXR5IGFzXG4gICAgICAgIC8vIHZlcmlmaWVkIHVudGlsIHRoYXQgaGFwcGVucykuIElmIHdlIHJldHVybiBcIkRvbmVcIiB0b28gc29vbiwgd2UgcmlzayB0aGUgdXNlciBjYW5jZWxsaW5nIHRoZSBmbG93LlxuICAgICAgICByZXR1cm4gVmVyaWZpY2F0aW9uUGhhc2UuU3RhcnRlZDtcbiAgICAgIGNhc2UgUXJTdGF0ZS5SZWNpcHJvY2F0ZWQ6XG4gICAgICAgIC8vIGFsdGhvdWdoIHRoZSBydXN0IFNESyBkb2Vzbid0IGltbWVkaWF0ZWx5IHNlbmQgdGhlIGBtLmtleS52ZXJpZmljYXRpb24uc3RhcnRgIG9uIHRyYW5zaXRpb24gaW50byB0aGlzXG4gICAgICAgIC8vIHN0YXRlLCBgUnVzdFZlcmlmaWNhdGlvblJlcXVlc3Quc2NhblFyQ29kZWAgaW1tZWRpYXRlbHkgY2FsbHMgYHJlY2lwcm9jYXRlKClgIGFuZCBkb2VzIHNvLCBzbyBpbiBwcmFjdGljZVxuICAgICAgICAvLyB3ZSBjYW4gdHJlYXQgdGhlIHR3byB0aGUgc2FtZS5cbiAgICAgICAgcmV0dXJuIFZlcmlmaWNhdGlvblBoYXNlLlN0YXJ0ZWQ7XG4gICAgICBjYXNlIFFyU3RhdGUuRG9uZTpcbiAgICAgICAgcmV0dXJuIFZlcmlmaWNhdGlvblBoYXNlLkRvbmU7XG4gICAgICBjYXNlIFFyU3RhdGUuQ2FuY2VsbGVkOlxuICAgICAgICByZXR1cm4gVmVyaWZpY2F0aW9uUGhhc2UuQ2FuY2VsbGVkO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBxciBjb2RlIHN0YXRlIFwiLmNvbmNhdCh0aGlzLmlubmVyLnN0YXRlKCkpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZXRhaWxzIGZvciByZWNpcHJvY2F0aW5nIFFSIGNvZGUgdmVyaWZpY2F0aW9uLCBpZiBvbmUgaXMgaW4gcHJvZ3Jlc3NcbiAgICpcbiAgICogUmV0dXJucyBgbnVsbGAsIHVubGVzcyB0aGlzIHZlcmlmaWVyIGlzIGZvciByZWNpcHJvY2F0aW5nIGEgUVItY29kZS1iYXNlZCB2ZXJpZmljYXRpb24gKGllLCB0aGUgb3RoZXIgdXNlciBoYXNcbiAgICogYWxyZWFkeSBzY2FubmVkIG91ciBRUiBjb2RlKSwgYW5kIHdlIGFyZSB3YWl0aW5nIGZvciB0aGUgdXNlciB0byBjb25maXJtLlxuICAgKi9cbiAgZ2V0UmVjaXByb2NhdGVRckNvZGVDYWxsYmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2tzO1xuICB9XG4gIGNvbmZpcm1TY2FubmluZygpIHtcbiAgICB2YXIgX3RoaXM4ID0gdGhpcztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciByZXEgPSBfdGhpczguaW5uZXIuY29uZmlybVNjYW5uaW5nKCk7XG4gICAgICBpZiAocmVxKSB7XG4gICAgICAgIHlpZWxkIF90aGlzOC5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IubWFrZU91dGdvaW5nUmVxdWVzdChyZXEpO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cbn1cblxuLyoqIEEgVmVyaWZpZXIgaW5zdGFuY2Ugd2hpY2ggaXMgdXNlZCBpZiB3ZSBhcmUgZXhjaGFuZ2luZyBlbW9qaXMgKi9cbmV4cG9ydCBjbGFzcyBSdXN0U0FTVmVyaWZpZXIgZXh0ZW5kcyBCYXNlUnVzdFZlcmlmZXIge1xuICBjb25zdHJ1Y3Rvcihpbm5lciwgX3ZlcmlmaWNhdGlvblJlcXVlc3QsIG91dGdvaW5nUmVxdWVzdFByb2Nlc3Nvcikge1xuICAgIHN1cGVyKGlubmVyLCBvdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxiYWNrc1wiLCBudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUga2V5IHZlcmlmaWNhdGlvbiwgaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gc3RhcnRlZC5cbiAgICpcbiAgICogVGhpcyBtZWFucyBzZW5kaW5nIGEgYG0ua2V5LnZlcmlmaWNhdGlvbi5zdGFydGAgaWYgd2UgYXJlIHRoZSBmaXJzdCByZXNwb25kZXIsIG9yIGEgYG0ua2V5LnZlcmlmaWNhdGlvbi5hY2NlcHRgXG4gICAqIGlmIHRoZSBvdGhlciBzaWRlIGhhcyBhbHJlYWR5IHNlbnQgYSBzdGFydCBldmVudC5cbiAgICpcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSB2ZXJpZmljYXRpb24gaGFzIGNvbXBsZXRlZCwgb3IgcmVqZWN0cyBpZiB0aGUgdmVyaWZpY2F0aW9uIGlzIGNhbmNlbGxlZFxuICAgKiAgICBvciB0aW1lcyBvdXQuXG4gICAqL1xuICB2ZXJpZnkoKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfdGhpczkuc2VuZEFjY2VwdCgpO1xuICAgICAgeWllbGQgX3RoaXM5LmNvbXBsZXRpb25EZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCB0aGUgYWNjZXB0IG9yIHN0YXJ0IGV2ZW50LCBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHNlbnRcbiAgICovXG4gIHNlbmRBY2NlcHQoKSB7XG4gICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHJlcSA9IF90aGlzMTAuaW5uZXIuYWNjZXB0KCk7XG4gICAgICBpZiAocmVxKSB7XG4gICAgICAgIHlpZWxkIF90aGlzMTAub3V0Z29pbmdSZXF1ZXN0UHJvY2Vzc29yLm1ha2VPdXRnb2luZ1JlcXVlc3QocmVxKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG5cbiAgLyoqIGlmIHdlIGNhbiBub3cgc2hvdyB0aGUgY2FsbGJhY2tzLCBkbyBzbyAqL1xuICBvbkNoYW5nZSgpIHtcbiAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG4gICAgc3VwZXIub25DaGFuZ2UoKTtcbiAgICBpZiAodGhpcy5jYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICAgIHZhciBlbW9qaSA9IHRoaXMuaW5uZXIuZW1vamkoKTtcbiAgICAgIHZhciBkZWNpbWFsID0gdGhpcy5pbm5lci5kZWNpbWFscygpO1xuICAgICAgaWYgKGVtb2ppID09PSB1bmRlZmluZWQgJiYgZGVjaW1hbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzYXMgPSB7fTtcbiAgICAgIGlmIChlbW9qaSkge1xuICAgICAgICBzYXMuZW1vamkgPSBlbW9qaS5tYXAoZSA9PiBbZS5zeW1ib2wsIGUuZGVzY3JpcHRpb25dKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWNpbWFsKSB7XG4gICAgICAgIHNhcy5kZWNpbWFsID0gW2RlY2ltYWxbMF0sIGRlY2ltYWxbMV0sIGRlY2ltYWxbMl1dO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxsYmFja3MgPSB7XG4gICAgICAgIHNhcyxcbiAgICAgICAgY29uZmlybTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfY29uZmlybSA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdHMgPSB5aWVsZCBfdGhpczExLmlubmVyLmNvbmZpcm0oKTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gb2YgcmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgeWllbGQgX3RoaXMxMS5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IubWFrZU91dGdvaW5nUmVxdWVzdChtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmdW5jdGlvbiBjb25maXJtKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jb25maXJtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb25maXJtO1xuICAgICAgICB9KCksXG4gICAgICAgIG1pc21hdGNoOiAoKSA9PiB7XG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLmlubmVyLmNhbmNlbFdpdGhDb2RlKFwibS5taXNtYXRjaGVkX3Nhc1wiKTtcbiAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgdGhpcy5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IubWFrZU91dGdvaW5nUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5pbm5lci5jYW5jZWxXaXRoQ29kZShcIm0udXNlclwiKTtcbiAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgdGhpcy5vdXRnb2luZ1JlcXVlc3RQcm9jZXNzb3IubWFrZU91dGdvaW5nUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmVtaXQoVmVyaWZpZXJFdmVudC5TaG93U2FzLCB0aGlzLmNhbGxiYWNrcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBhbiBhcHByb3ByaWF0ZSBWZXJpZmljYXRpb25QaGFzZSBmb3IgYSBWZXJpZmljYXRpb25SZXF1ZXN0IHdoZXJlIHRoaXMgaXMgdGhlIHZlcmlmaWVyLlxuICAgKi9cbiAgZ2V0IHZlcmlmaWNhdGlvblBoYXNlKCkge1xuICAgIHJldHVybiBWZXJpZmljYXRpb25QaGFzZS5TdGFydGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGV0YWlscyBmb3IgYW4gU0FTIHZlcmlmaWNhdGlvbiwgaWYgb25lIGlzIGluIHByb2dyZXNzXG4gICAqXG4gICAqIFJldHVybnMgYG51bGxgLCB1bmxlc3MgdGhpcyB2ZXJpZmllciBpcyBmb3IgYSBTQVMtYmFzZWQgdmVyaWZpY2F0aW9uIGFuZCB3ZSBhcmUgd2FpdGluZyBmb3IgdGhlIHVzZXIgdG8gY29uZmlybVxuICAgKiB0aGUgU0FTIG1hdGNoZXMuXG4gICAqL1xuICBnZXRTaG93U2FzQ2FsbGJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBpbm5lciBSdXN0IHZlcmlmaWVyIHdpdGggYSBkaWZmZXJlbnQgb25lLlxuICAgKlxuICAgKiBAcGFyYW0gaW5uZXIgLSB0aGUgbmV3IFJ1c3QgdmVyaWZpZXJcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZXBsYWNlSW5uZXIoaW5uZXIpIHtcbiAgICBpZiAodGhpcy5pbm5lciAhPSBpbm5lcikge1xuICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuXG4gICAgICAvLyBBcyB3aXRoIFJ1c3RWZXJpZmljYXRpb25SZXF1ZXN0LCB3ZSBuZWVkIHRvIGF2b2lkIGEgcmVmZXJlbmNlIGN5Y2xlLlxuICAgICAgLy8gU2VlIHRoZSBjb21tZW50cyBpbiBSdXN0VmVyaWZpY2F0aW9uUmVxdWVzdC5cbiAgICAgIHZhciB3ZWFrVGhpcyA9IG5ldyBXZWFrUmVmKHRoaXMpO1xuICAgICAgaW5uZXIucmVnaXN0ZXJDaGFuZ2VzQ2FsbGJhY2soLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfd2Vha1RoaXMkZGVyZWYzO1xuICAgICAgICByZXR1cm4gKF93ZWFrVGhpcyRkZXJlZjMgPSB3ZWFrVGhpcy5kZXJlZigpKSA9PT0gbnVsbCB8fCBfd2Vha1RoaXMkZGVyZWYzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2Vha1RoaXMkZGVyZWYzLm9uQ2hhbmdlKCk7XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIHJlcGxhY2VJbm5lciB3aWxsIG9ubHkgZ2V0IGNhbGxlZCBpZiB3ZSBzdGFydGVkIHRoZSB2ZXJpZmljYXRpb24gYXQgdGhlIHNhbWUgdGltZSBhcyB0aGUgb3RoZXIgc2lkZSwgYW5kIHdlIGxvc3RcbiAgICAgIC8vIHRoZSB0aWUgYnJlYWtlci4gIFNvIHdlIG5lZWQgdG8gcmUtYWNjZXB0IHRoZWlyIHZlcmlmaWNhdGlvbi5cbiAgICAgIHRoaXMuc2VuZEFjY2VwdCgpO1xuICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKiogRm9yIGVhY2ggc3BlY2NlZCB2ZXJpZmljYXRpb24gbWV0aG9kLCB0aGUgcnVzdC1zaWRlIGBWZXJpZmljYXRpb25NZXRob2RgIGNvcnJlc3BvbmRpbmcgdG8gaXQgKi9cbnZhciB2ZXJpZmljYXRpb25NZXRob2RzQnlJZGVudGlmaWVyID0ge1xuICBbVmVyaWZpY2F0aW9uTWV0aG9kLlNhc106IFJ1c3RTZGtDcnlwdG9Kcy5WZXJpZmljYXRpb25NZXRob2QuU2FzVjEsXG4gIFtWZXJpZmljYXRpb25NZXRob2QuU2NhblFyQ29kZV06IFJ1c3RTZGtDcnlwdG9Kcy5WZXJpZmljYXRpb25NZXRob2QuUXJDb2RlU2NhblYxLFxuICBbVmVyaWZpY2F0aW9uTWV0aG9kLlNob3dRckNvZGVdOiBSdXN0U2RrQ3J5cHRvSnMuVmVyaWZpY2F0aW9uTWV0aG9kLlFyQ29kZVNob3dWMSxcbiAgW1ZlcmlmaWNhdGlvbk1ldGhvZC5SZWNpcHJvY2F0ZV06IFJ1c3RTZGtDcnlwdG9Kcy5WZXJpZmljYXRpb25NZXRob2QuUmVjaXByb2NhdGVWMVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgc3BlY2NlZCB2ZXJpZmljYXRpb24gbWV0aG9kIGlkZW50aWZpZXIgaW50byBhIHJ1c3Qtc2lkZSBgVmVyaWZpY2F0aW9uTWV0aG9kYC5cbiAqXG4gKiBAcGFyYW0gbWV0aG9kIC0gc3BlY2NlZCBtZXRob2QgaWRlbnRpZmllciwgZm9yIGV4YW1wbGUgYG0uc2FzLnYxYC5cbiAqIEByZXR1cm5zIFJ1c3Qtc2lkZSBgVmVyaWZpY2F0aW9uTWV0aG9kYCBjb3JyZXNwb25kaW5nIHRvIGBtZXRob2RgLlxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgbWV0aG9kIGlzIHVua25vd24uXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZmljYXRpb25NZXRob2RJZGVudGlmaWVyVG9NZXRob2QobWV0aG9kKSB7XG4gIHZhciBtZXRoID0gdmVyaWZpY2F0aW9uTWV0aG9kc0J5SWRlbnRpZmllclttZXRob2RdO1xuICBpZiAobWV0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB2ZXJpZmljYXRpb24gbWV0aG9kIFwiLmNvbmNhdChtZXRob2QpKTtcbiAgfVxuICByZXR1cm4gbWV0aDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZXZlbnQncyB0eXBlIG1hdGNoZXMgdGhhdCBvZiBhbiBpbi1yb29tIHZlcmlmaWNhdGlvbiBldmVudFxuICpcbiAqIEBwYXJhbSBldmVudCAtIE1hdHJpeEV2ZW50XG4gKiBAcmV0dXJuc1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWZXJpZmljYXRpb25FdmVudChldmVudCkge1xuICBzd2l0Y2ggKGV2ZW50LmdldFR5cGUoKSkge1xuICAgIGNhc2UgRXZlbnRUeXBlLktleVZlcmlmaWNhdGlvbkNhbmNlbDpcbiAgICBjYXNlIEV2ZW50VHlwZS5LZXlWZXJpZmljYXRpb25Eb25lOlxuICAgIGNhc2UgRXZlbnRUeXBlLktleVZlcmlmaWNhdGlvbk1hYzpcbiAgICBjYXNlIEV2ZW50VHlwZS5LZXlWZXJpZmljYXRpb25TdGFydDpcbiAgICBjYXNlIEV2ZW50VHlwZS5LZXlWZXJpZmljYXRpb25LZXk6XG4gICAgY2FzZSBFdmVudFR5cGUuS2V5VmVyaWZpY2F0aW9uUmVhZHk6XG4gICAgY2FzZSBFdmVudFR5cGUuS2V5VmVyaWZpY2F0aW9uQWNjZXB0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBFdmVudFR5cGUuUm9vbU1lc3NhZ2U6XG4gICAgICByZXR1cm4gZXZlbnQuZ2V0Q29udGVudCgpLm1zZ3R5cGUgPT09IE1zZ1R5cGUuS2V5VmVyaWZpY2F0aW9uUmVxdWVzdDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJpZmljYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/matrix-js-sdk/lib/rust-crypto/verification.js\n");

/***/ })

}]);