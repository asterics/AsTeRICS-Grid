/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkasterics_grid"] = self["webpackChunkasterics_grid"] || []).push([["node_modules_matrix-encrypt-attachment_lib_browser-encrypt-attachment_js"],{

/***/ "./node_modules/matrix-encrypt-attachment/lib/browser-encrypt-attachment.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/matrix-encrypt-attachment/lib/browser-encrypt-attachment.js ***!
  \**********************************************************************************/
/***/ ((module) => {

eval("(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\n/*\nCopyright 2021-2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeBase64 = exports.encodeBase64 = exports.decryptAttachment = exports.encryptAttachment = void 0;\nfunction encryptAttachment(plaintextBuffer) {\n    return __awaiter(this, void 0, void 0, function () {\n        var ivArray, cryptoKey, exportedKey, ciphertextBuffer, sha256Buffer;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    ivArray = new Uint8Array(16);\n                    window.crypto.getRandomValues(ivArray.subarray(0, 8));\n                    return [4 /*yield*/, window.crypto.subtle.generateKey({ 'name': 'AES-CTR', 'length': 256 }, true, ['encrypt', 'decrypt'])];\n                case 1:\n                    cryptoKey = _a.sent();\n                    return [4 /*yield*/, window.crypto.subtle.exportKey('jwk', cryptoKey)];\n                case 2:\n                    exportedKey = _a.sent();\n                    return [4 /*yield*/, window.crypto.subtle.encrypt({ name: 'AES-CTR', counter: ivArray, length: 64 }, cryptoKey, plaintextBuffer)];\n                case 3:\n                    ciphertextBuffer = _a.sent();\n                    return [4 /*yield*/, window.crypto.subtle.digest('SHA-256', ciphertextBuffer)];\n                case 4:\n                    sha256Buffer = _a.sent();\n                    return [2 /*return*/, {\n                            data: ciphertextBuffer,\n                            info: {\n                                v: 'v2',\n                                key: exportedKey,\n                                iv: encodeBase64(ivArray),\n                                hashes: {\n                                    sha256: encodeBase64(new Uint8Array(sha256Buffer)),\n                                },\n                            },\n                        }];\n            }\n        });\n    });\n}\nexports.encryptAttachment = encryptAttachment;\nfunction decryptAttachment(ciphertextBuffer, info) {\n    return __awaiter(this, void 0, void 0, function () {\n        var ivArray, expectedSha256base64, cryptoKey, digestResult, counterLength;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (info === undefined || info.key === undefined || info.iv === undefined\n                        || info.hashes === undefined || info.hashes.sha256 === undefined) {\n                        throw new Error('Invalid info. Missing info.key, info.iv or info.hashes.sha256 key');\n                    }\n                    if (info.v && !info.v.match(/^v[1-2]$/)) {\n                        throw new Error(\"Unsupported protocol version: \" + info.v);\n                    }\n                    ivArray = decodeBase64(info.iv);\n                    expectedSha256base64 = info.hashes.sha256;\n                    return [4 /*yield*/, window.crypto.subtle.importKey('jwk', info.key, { 'name': 'AES-CTR' }, false, ['encrypt', 'decrypt'])];\n                case 1:\n                    cryptoKey = _a.sent();\n                    return [4 /*yield*/, window.crypto.subtle.digest('SHA-256', ciphertextBuffer)];\n                case 2:\n                    digestResult = _a.sent();\n                    if (encodeBase64(new Uint8Array(digestResult)) != expectedSha256base64) {\n                        throw new Error('Mismatched SHA-256 digest');\n                    }\n                    if (info.v == 'v1' || info.v == 'v2') {\n                        // Version 1 and 2 use a 64 bit counter.\n                        counterLength = 64;\n                    }\n                    else {\n                        // Version 0 uses a 128 bit counter.\n                        counterLength = 128;\n                    }\n                    return [2 /*return*/, window.crypto.subtle.decrypt({ name: 'AES-CTR', counter: ivArray, length: counterLength }, cryptoKey, ciphertextBuffer)];\n            }\n        });\n    });\n}\nexports.decryptAttachment = decryptAttachment;\nfunction encodeBase64(uint8Array) {\n    // Misinterpt the Uint8Array as Latin-1.\n    // window.btoa expects a unicode string with codepoints in the range 0-255.\n    var latin1String = String.fromCharCode.apply(null, uint8Array);\n    // Use the builtin base64 encoder.\n    var paddedBase64 = window.btoa(latin1String);\n    // Calculate the unpadded length.\n    var inputLength = uint8Array.length;\n    var outputLength = 4 * Math.floor((inputLength + 2) / 3) + (inputLength + 2) % 3 - 2;\n    // Return the unpadded base64.\n    return paddedBase64.slice(0, outputLength);\n}\nexports.encodeBase64 = encodeBase64;\nfunction decodeBase64(base64) {\n    // Pad the base64 up to the next multiple of 4.\n    var paddedBase64 = base64 + '==='.slice(0, (4 - base64.length % 4) % 4);\n    // Decode the base64 as a misinterpreted Latin-1 string.\n    // window.atob returns a unicode string with codepoints in the range 0-255.\n    var latin1String = window.atob(paddedBase64);\n    // Encode the string as a Uint8Array as Latin-1.\n    var uint8Array = new Uint8Array(latin1String.length);\n    for (var i = 0; i < latin1String.length; i++) {\n        uint8Array[i] = latin1String.charCodeAt(i);\n    }\n    return uint8Array;\n}\nexports.decodeBase64 = decodeBase64;\nexports.default = {\n    encryptAttachment: encryptAttachment,\n    decryptAttachment: decryptAttachment,\n    encodeBase64: encodeBase64,\n    decodeBase64: decodeBase64,\n};\n\n},{}]},{},[1])(1)\n});\n//# sourceMappingURL=browser-encrypt-attachment.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0cml4LWVuY3J5cHQtYXR0YWNobWVudC9saWIvYnJvd3Nlci1lbmNyeXB0LWF0dGFjaG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxHQUFHLElBQXNELEVBQUUsbUJBQW1CLEtBQUssVUFBZ1AsQ0FBQyxhQUFhLDBCQUEwQixtQkFBbUIsa0JBQWtCLGdCQUFnQixVQUFVLFVBQVUsTUFBTSxTQUFtQyxDQUFDLGdCQUFnQixPQUFDLE9BQU8sb0JBQW9CLDhDQUE4QyxrQ0FBa0MsWUFBWSxZQUFZLG1DQUFtQyxpQkFBaUIsZUFBZSxzQkFBc0Isb0JBQW9CLFVBQVUsU0FBbUMsS0FBSyxXQUFXLFlBQVksU0FBUyxTQUFTLEtBQUs7QUFDNTBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxrQ0FBa0M7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSwrQ0FBK0M7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixtQkFBbUI7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsMERBQTBEO0FBQ25JO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRyxFQUFFLEdBQUc7QUFDVCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc3Rlcmljcy1ncmlkLy4vbm9kZV9tb2R1bGVzL21hdHJpeC1lbmNyeXB0LWF0dGFjaG1lbnQvbGliL2Jyb3dzZXItZW5jcnlwdC1hdHRhY2htZW50LmpzPzM0MzMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuTWF0cml4RW5jcnlwdEF0dGFjaG1lbnQgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuLypcbkNvcHlyaWdodCAyMDIxLTIwMjIgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlQmFzZTY0ID0gZXhwb3J0cy5lbmNvZGVCYXNlNjQgPSBleHBvcnRzLmRlY3J5cHRBdHRhY2htZW50ID0gZXhwb3J0cy5lbmNyeXB0QXR0YWNobWVudCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGVuY3J5cHRBdHRhY2htZW50KHBsYWludGV4dEJ1ZmZlcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl2QXJyYXksIGNyeXB0b0tleSwgZXhwb3J0ZWRLZXksIGNpcGhlcnRleHRCdWZmZXIsIHNoYTI1NkJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaXZBcnJheSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoaXZBcnJheS5zdWJhcnJheSgwLCA4KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdpbmRvdy5jcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHsgJ25hbWUnOiAnQUVTLUNUUicsICdsZW5ndGgnOiAyNTYgfSwgdHJ1ZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgY3J5cHRvS2V5ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ2p3aycsIGNyeXB0b0tleSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRLZXkgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdpbmRvdy5jcnlwdG8uc3VidGxlLmVuY3J5cHQoeyBuYW1lOiAnQUVTLUNUUicsIGNvdW50ZXI6IGl2QXJyYXksIGxlbmd0aDogNjQgfSwgY3J5cHRvS2V5LCBwbGFpbnRleHRCdWZmZXIpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGNpcGhlcnRleHRCdWZmZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdpbmRvdy5jcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGNpcGhlcnRleHRCdWZmZXIpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHNoYTI1NkJ1ZmZlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjaXBoZXJ0ZXh0QnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjogJ3YyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBleHBvcnRlZEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXY6IGVuY29kZUJhc2U2NChpdkFycmF5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGEyNTY6IGVuY29kZUJhc2U2NChuZXcgVWludDhBcnJheShzaGEyNTZCdWZmZXIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5lbmNyeXB0QXR0YWNobWVudCA9IGVuY3J5cHRBdHRhY2htZW50O1xuZnVuY3Rpb24gZGVjcnlwdEF0dGFjaG1lbnQoY2lwaGVydGV4dEJ1ZmZlciwgaW5mbykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl2QXJyYXksIGV4cGVjdGVkU2hhMjU2YmFzZTY0LCBjcnlwdG9LZXksIGRpZ2VzdFJlc3VsdCwgY291bnRlckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8gPT09IHVuZGVmaW5lZCB8fCBpbmZvLmtleSA9PT0gdW5kZWZpbmVkIHx8IGluZm8uaXYgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgaW5mby5oYXNoZXMgPT09IHVuZGVmaW5lZCB8fCBpbmZvLmhhc2hlcy5zaGEyNTYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZm8uIE1pc3NpbmcgaW5mby5rZXksIGluZm8uaXYgb3IgaW5mby5oYXNoZXMuc2hhMjU2IGtleScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLnYgJiYgIWluZm8udi5tYXRjaCgvXnZbMS0yXSQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogXCIgKyBpbmZvLnYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl2QXJyYXkgPSBkZWNvZGVCYXNlNjQoaW5mby5pdik7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkU2hhMjU2YmFzZTY0ID0gaW5mby5oYXNoZXMuc2hhMjU2O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ2p3aycsIGluZm8ua2V5LCB7ICduYW1lJzogJ0FFUy1DVFInIH0sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjcnlwdG9LZXkgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdpbmRvdy5jcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGNpcGhlcnRleHRCdWZmZXIpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGRpZ2VzdFJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuY29kZUJhc2U2NChuZXcgVWludDhBcnJheShkaWdlc3RSZXN1bHQpKSAhPSBleHBlY3RlZFNoYTI1NmJhc2U2NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGVkIFNIQS0yNTYgZGlnZXN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8udiA9PSAndjEnIHx8IGluZm8udiA9PSAndjInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJzaW9uIDEgYW5kIDIgdXNlIGEgNjQgYml0IGNvdW50ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyTGVuZ3RoID0gNjQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJzaW9uIDAgdXNlcyBhIDEyOCBiaXQgY291bnRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJMZW5ndGggPSAxMjg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHdpbmRvdy5jcnlwdG8uc3VidGxlLmRlY3J5cHQoeyBuYW1lOiAnQUVTLUNUUicsIGNvdW50ZXI6IGl2QXJyYXksIGxlbmd0aDogY291bnRlckxlbmd0aCB9LCBjcnlwdG9LZXksIGNpcGhlcnRleHRCdWZmZXIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlY3J5cHRBdHRhY2htZW50ID0gZGVjcnlwdEF0dGFjaG1lbnQ7XG5mdW5jdGlvbiBlbmNvZGVCYXNlNjQodWludDhBcnJheSkge1xuICAgIC8vIE1pc2ludGVycHQgdGhlIFVpbnQ4QXJyYXkgYXMgTGF0aW4tMS5cbiAgICAvLyB3aW5kb3cuYnRvYSBleHBlY3RzIGEgdW5pY29kZSBzdHJpbmcgd2l0aCBjb2RlcG9pbnRzIGluIHRoZSByYW5nZSAwLTI1NS5cbiAgICB2YXIgbGF0aW4xU3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1aW50OEFycmF5KTtcbiAgICAvLyBVc2UgdGhlIGJ1aWx0aW4gYmFzZTY0IGVuY29kZXIuXG4gICAgdmFyIHBhZGRlZEJhc2U2NCA9IHdpbmRvdy5idG9hKGxhdGluMVN0cmluZyk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB1bnBhZGRlZCBsZW5ndGguXG4gICAgdmFyIGlucHV0TGVuZ3RoID0gdWludDhBcnJheS5sZW5ndGg7XG4gICAgdmFyIG91dHB1dExlbmd0aCA9IDQgKiBNYXRoLmZsb29yKChpbnB1dExlbmd0aCArIDIpIC8gMykgKyAoaW5wdXRMZW5ndGggKyAyKSAlIDMgLSAyO1xuICAgIC8vIFJldHVybiB0aGUgdW5wYWRkZWQgYmFzZTY0LlxuICAgIHJldHVybiBwYWRkZWRCYXNlNjQuc2xpY2UoMCwgb3V0cHV0TGVuZ3RoKTtcbn1cbmV4cG9ydHMuZW5jb2RlQmFzZTY0ID0gZW5jb2RlQmFzZTY0O1xuZnVuY3Rpb24gZGVjb2RlQmFzZTY0KGJhc2U2NCkge1xuICAgIC8vIFBhZCB0aGUgYmFzZTY0IHVwIHRvIHRoZSBuZXh0IG11bHRpcGxlIG9mIDQuXG4gICAgdmFyIHBhZGRlZEJhc2U2NCA9IGJhc2U2NCArICc9PT0nLnNsaWNlKDAsICg0IC0gYmFzZTY0Lmxlbmd0aCAlIDQpICUgNCk7XG4gICAgLy8gRGVjb2RlIHRoZSBiYXNlNjQgYXMgYSBtaXNpbnRlcnByZXRlZCBMYXRpbi0xIHN0cmluZy5cbiAgICAvLyB3aW5kb3cuYXRvYiByZXR1cm5zIGEgdW5pY29kZSBzdHJpbmcgd2l0aCBjb2RlcG9pbnRzIGluIHRoZSByYW5nZSAwLTI1NS5cbiAgICB2YXIgbGF0aW4xU3RyaW5nID0gd2luZG93LmF0b2IocGFkZGVkQmFzZTY0KTtcbiAgICAvLyBFbmNvZGUgdGhlIHN0cmluZyBhcyBhIFVpbnQ4QXJyYXkgYXMgTGF0aW4tMS5cbiAgICB2YXIgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGxhdGluMVN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0aW4xU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlbaV0gPSBsYXRpbjFTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXk7XG59XG5leHBvcnRzLmRlY29kZUJhc2U2NCA9IGRlY29kZUJhc2U2NDtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBlbmNyeXB0QXR0YWNobWVudDogZW5jcnlwdEF0dGFjaG1lbnQsXG4gICAgZGVjcnlwdEF0dGFjaG1lbnQ6IGRlY3J5cHRBdHRhY2htZW50LFxuICAgIGVuY29kZUJhc2U2NDogZW5jb2RlQmFzZTY0LFxuICAgIGRlY29kZUJhc2U2NDogZGVjb2RlQmFzZTY0LFxufTtcblxufSx7fV19LHt9LFsxXSkoMSlcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci1lbmNyeXB0LWF0dGFjaG1lbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/matrix-encrypt-attachment/lib/browser-encrypt-attachment.js\n");

/***/ })

}]);